<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="foreword.html">まえがき</a></li><li class="affix"><a href="ch00-00-introduction.html">導入</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 事始め</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> インストール</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 数当てゲームをプログラムする</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 普遍的なプログラミング概念</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 変数と可変性</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> データ型</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 関数の動作法</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> コメント</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 制御フロー</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 所有権を理解する</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 所有権とは？</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 参照と借用</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> スライス</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 構造体を使用して関連のあるデータを構造化する</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 構造体を定義し、インスタンス化する</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 構造体を使用したプログラム例</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> メソッド記法</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumとパターンマッチング</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumを定義する</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match制御フロー演算子</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if letで簡潔な制御フロー</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> モジュール</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> modとファイルシステム</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pubで公開するか制御する</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> 異なるモジュールの名前を参照する</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 一般的なコレクション</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ベクタ型</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 文字列型</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ハッシュマップ</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> エラー処理</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!で回復不能なエラー</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Resultで回復可能なエラー</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!すべきかするまいか</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ジェネリックなデータ型</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> トレイト: 共通の振る舞いを定義する</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ライフタイムで参照を有効化する</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> テスト</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> テストを書く</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> テストを走らせる</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> テストの体系化</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 入出力プロジェクト: コマンドラインプログラムを構築する</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> コマンドライン引数を受け付ける</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ファイルを読み込む</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> リファクタリングしてモジュール性の向上とエラー処理</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> テスト駆動開発でライブラリの機能を開発する</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 環境変数を取り扱う</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 標準出力ではなく標準エラーにエラーメッセージを書き込む</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 関数型言語の機能: イテレータとクロージャ</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> クロージャ: 環境をキャプチャできる匿名関数</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 一連の要素をイテレータで処理する</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 入出力プロジェクトを改善する</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> パフォーマンス比較: ループVSイテレータ</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> CargoとCrates.ioについてより詳しく</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> リリースプロファイルでビルドをカスタマイズする</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.ioにクレートを公開する</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargoのワークスペース</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo installでCrates.ioからバイナリをインストールする</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 独自のコマンドでCargoで拡張する</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> スマートポインタ</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T>はヒープのデータを指し、既知のサイズである</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Derefトレイトにより、参照を通してデータにアクセスできる</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Dropトレイトにより、片付けの時にコードを実行する</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>は、参照カウント方式のスマートポインタ</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T>と内部可変性パターン</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 循環参照し、メモリをリークするのは安全である</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 恐れるな！並行性</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> スレッド</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> メッセージ受け渡し</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 状態共有</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 拡張可能な並行性: SyncとSend</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustのオブジェクト指向プログラミング機能</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> オブジェクト指向言語の特徴</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 異なる型の値を許容するトレイトオブジェクトを使用する</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> オブジェクト指向デザインパターンを実装する</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> パターンは値の構造に合致する</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> パターンが使用されるかもしれない箇所全部</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 論駁可能性: パターンが合致しないか</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> パターン記法全部</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 高度な機能</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 高度なライフタイム</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 高度なトレイト</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 高度な型</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 高度な関数とクロージャ</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最後のプロジェクト: マルチスレッドのWebサーバを構築する</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> シングルスレッドのWebサーバ</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> シングルスレッドのサーバをマルチスレッド化する</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 優美なシャットダウンとお片付け</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 付録</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - キーワード</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 演算子とシンボル</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 継承可能なトレイト</a></li><li><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - マクロ</a></li><li><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 翻訳</a></li><li><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 最新の機能</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rustが“Nightly Rust”になる方法</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- # Foreword -->
<a class="header" href="print.html#aまえがき" id="aまえがき"><h1>まえがき</h1></a>
<!-- It wasn’t always so clear, but the Rust programming language is fundamentally -->
<!-- about *empowerment*: no matter what kind of code you are writing now, Rust -->
<!-- empowers you to reach farther, to program with confidence in a wider variety of -->
<!-- domains than you did before. -->
<p>すぐにはわかりにくいかもしれませんが、Rustプログラミング言語は、エンパワーメント(empowerment)を根本原理としています:
どんな種類のコードを現在書いているにせよ、Rustは幅広い領域で以前よりも遠くへ到達し、
自信を持ってプログラムを組む力を与え(empower)ます。</p>
<!-- Take, for example, “systems-level” work that deals with low-level details of -->
<!-- memory management, data representation, and concurrency. Traditionally, this -->
<!-- realm of programming is seen as arcane, accessible only to a select few who -->
<!-- have devoted the necessary years learning to avoid its infamous pitfalls. And -->
<!-- even those who practice it do so with caution, lest their code be open to -->
<!-- exploits, crashes, or corruption. -->
<p>一例を挙げると、メモリ管理やデータ表現、並列性などの低レベルな詳細を扱う「システムレベル」のプログラミングがあります。
伝統的にこの分野は難解で、年月をかけてやっかいな落とし穴を回避する術を習得した選ばれし者にだけ可能と見なされています。
そのように鍛錬を積んだ者でさえ注意が必要で、さもないと書いたコードがクラッキングの糸口になったりクラッシュやデータ破損を引き起こしかねないのです。</p>
<!-- Rust breaks down these barriers by eliminating the old pitfalls and providing a -->
<!-- friendly, polished set of tools to help you along the way. Programmers who need -->
<!-- to “dip down” into lower-level control can do so with Rust, without taking on -->
<!-- the customary risk of crashes or security holes, and without having to learn -->
<!-- the fine points of a fickle toolchain. Better yet, the language is designed to -->
<!-- guide you naturally towards reliable code that is efficient in terms of speed -->
<!-- and memory usage. -->
<p>この難しさを取り除くために、Rustは、古い落とし穴を排除し、その過程で使いやすく役に立つ洗練された一連のツールを提供します。
低レベルな制御に「下がる」必要があるプログラマは、お決まりのクラッシュやセキュリティホールのリスクを負わず、
気まぐれなツールチェーンのデリケートな部分を学ぶ必要なくRustで同じことができます。さらにいいことに、
Rustは、スピードとメモリ使用の観点で効率的な信頼性の高いコードへと自然に導くよう設計されています。</p>
<!-- Programmers who are already working with low-level code can use Rust to raise -->
<!-- their ambitions. For example, introducing parallelism in Rust is a relatively -->
<!-- low-risk operation: the compiler will catch the classical mistakes for you. And -->
<!-- you can tackle more aggressive optimizations in your code with the confidence -->
<!-- that you won’t accidentally introduce crashes or exploits. -->
<p>既に低レベルコードに取り組んでいるプログラマは、Rustを使用してさらなる高みを目指せます。例えば、
Rustで並行性を導入することは、比較的低リスクです: コンパイラが伝統的なミスを捕捉してくれるのです。
そして、クラッシュやクラッキングの糸口を誤って導入しないという自信を持ってコードの大胆な最適化に取り組めるのです。</p>
<!-- But Rust isn’t limited to low-level systems programming. It’s expressive and -->
<!-- ergonomic enough to make CLI apps, web servers, and many other kinds of code -->
<!-- quite pleasant to write — you’ll find simple examples of both later in the -->
<!-- book. Working with Rust allows you to build skills that transfer from one -->
<!-- domain to another; you can learn Rust by writing a web app, then apply those -->
<!-- same skills to target your Raspberry Pi. -->
<p>ですが、Rustは低レベルなシステムプログラミングに限定されているわけではありません。十分に表現力豊かでエルゴノミックなので、
コマンドラインアプリやWebサーバ、その他様々な楽しいコードを書けます。この本の後半に両者の単純な例が見つかるでしょう。
Rustを使うことで1つの領域から他の領域へと使い回せる技術を身につけられます;
ウェブアプリを書いてRustを学び、それからその同じ技術をラズベリーパイを対象に適用できるのです。</p>
<!-- This book fully embraces the potential of Rust to empower its users. It’s a -->
<!-- friendly and approachable text intended to help you level up not just your -->
<!-- knowledge of Rust, but also your reach and confidence as a programmer in -->
<!-- general. So dive in, get ready to learn—and welcome to the Rust community! -->
<p>この本は、ユーザに力を与え(empower)るRustのポテンシャルを全て含んでいます。あなたのRustの知識のみをレベルアップさせるだけでなく、
プログラマとして全般的な能力や自信をもレベルアップさせる手助けを意図した親しみやすくわかりやすいテキストです。
さあ、飛び込んで学ぶ準備をしてください。Rustコミュニティへようこそ！</p>
<!-- — Nicholas Matsakis and Aaron Turon -->
<ul>
<li>ニコラス・マットサキス(Nicholas Matsakis)とアーロン・チューロン(Aaron Turon)</li>
</ul>
<!-- # Introduction -->
<a class="header" href="print.html#a導入" id="a導入"><h1>導入</h1></a>
<!-- > Note: This edition of the book is the same as [The Rust Programming -->
<!-- > Language][nsprust] available in print and ebook format from [No Starch -->
<!-- > Press][nsp]. -->
<blockquote>
<p>注釈: この本のこの版は、本として利用可能な<a href="https://nostarch.com/rust">The Rust Programming Language</a>と、
<a href="https://nostarch.com/">No Starch Press</a>のebook形式と同じです。</p>
</blockquote>
<!-- Welcome to *The Rust Programming Language*, an introductory book about Rust. -->
<p><em>The Rust Programming Language</em>へようこそ。Rustに関する入門書です。</p>
<!-- The Rust programming language helps you write faster, more reliable software. -->
<!-- High-level ergonomics and low-level control are often at odds in programming -->
<!-- language design; Rust challenges that conflict. Through balancing powerful -->
<!-- technical capacity and a great developer experience, Rust gives you the option -->
<!-- to control low-level details (such as memory usage) without all the hassle -->
<!-- traditionally associated with such control. -->
<p>Rustプログラミング言語は、高速で信頼できるソフトウェアを書く手助けをしてくれます。
高レベルのエルゴノミクス(<code>訳注</code>: ergonomicsとは、人間工学的という意味。砕いて言えば、人間に優しいということ)と低レベルの制御は、
しばしばプログラミング言語の設計においてトレードオフの関係になります;
Rustは、その衝突に挑戦しています。バランスのとれた強力な技術の許容量と素晴らしい開発者経験を通して、
Rustは伝統的にそれらの制御と紐付いていた困難全てなしに低レベルの詳細(メモリ使用など)を制御する選択肢を与えてくれます。</p>
<!-- ## Who Rust Is For -->
<a class="header" href="print.html#rustは誰のためのものなの" id="rustは誰のためのものなの"><h2>Rustは誰のためのものなの</h2></a>
<!-- Rust is ideal for many people for a variety of reasons. Let’s look at a few of -->
<!-- the most important groups. -->
<p>Rustは、様々な理由により多くの人にとって理想的です。いくつか最も重要なグループを見ていきましょう。</p>
<!-- ### Teams of Developers -->
<a class="header" href="print.html#a開発者チーム" id="a開発者チーム"><h3>開発者チーム</h3></a>
<!-- Rust is proving to be a productive tool for collaborating among large teams of -->
<!-- developers with varying levels of systems programming knowledge. Low-level code -->
<!-- is prone to a variety of subtle bugs, which in most other languages can be -->
<!-- caught only through extensive testing and careful code review by experienced -->
<!-- developers. In Rust, the compiler plays a gatekeeper role by refusing to -->
<!-- compile code with these elusive bugs, including concurrency bugs. By working -->
<!-- alongside the compiler, the team can spend their time focusing on the program’s -->
<!-- logic rather than chasing down bugs. -->
<p>Rustは、いろんなレベルのシステムプログラミングの知識を持つ開発者の巨大なチームとコラボレートするのに生産的なツールであると証明してきています。
低レベルコードは様々な種類の微細なバグを抱える傾向があり、そのようなバグは他の言語だと広範なテストと、
経験豊富な開発者による注意深いコードレビューによってのみ捕捉されるものです。Rustにおいては、
コンパイラが非同期のバグも含めたこのようなとらえどころのないバグのあるコードをコンパイルするのを拒むことで、
門番の役割を担います。コンパイラとともに取り組むことで、チームはバグを追いかけるよりもプログラムのロジックに集中することに、
時間を費やせるのです。</p>
<!-- Rust also brings contemporary developer tools to the systems programming world: -->
<p>Rustはまた、現代的な開発ツールをシステムプログラミング世界に導入します。</p>
<!-- * Cargo, the included dependency manager and build tool, makes adding, -->
<!--   compiling, and managing dependencies painless and consistent across the Rust -->
<!--   ecosystem. -->
<!-- * Rustfmt ensures a consistent coding style across developers. -->
<!-- * The Rust Language Server powers Integrated Development Environment (IDE) -->
<!--   integration for code completion and inline error messages. -->
<ul>
<li>Cargoは、付属の依存マネージャ兼ビルドツールで、依存を追加、コンパイル、管理することを楽かつ、
Rustエコシステムを通じて矛盾させません。</li>
<li>Rustfmtは開発者の間で矛盾のないコーディングスタイルを保証します。</li>
<li>Rust Language ServerはIDE(Intefrated Development Environment)にコード補完とインラインのエラーメッセージの統合の源となります。</li>
</ul>
<!-- By using these and other tools in the Rust ecosystem, developers can be -->
<!-- productive while writing systems-level code. -->
<p>これらや他のツールをRustのエコシステムで使用することで、開発者はシステムレベルのコードを記述しつつ、
生産的になれます。</p>
<!-- ### Students -->
<a class="header" href="print.html#a学生" id="a学生"><h3>学生</h3></a>
<!-- Rust is for students and those who are interested in learning about systems -->
<!-- concepts. Using Rust, many people have learned about topics like operating -->
<!-- systems development. The community is very welcoming and happy to answer -->
<!-- student questions. Through efforts such as this book, the Rust teams want to -->
<!-- make systems concepts more accessible to more people, especially those new to -->
<!-- programming. -->
<p>Rustは、学生やシステムの概念を学ぶことに興味のある方向けです。Rustを使用して、
多くの人がOS開発などの話題を学んできました。コミュニティはとても暖かく、喜んで学生の質問に答えてくれます。
この本のような努力を通じて、Rustチームはシステムの概念を多くの人、特にプログラミング初心者にとってアクセス可能にしたいと考えています。</p>
<!-- ### Companies -->
<a class="header" href="print.html#a企業" id="a企業"><h3>企業</h3></a>
<!-- Hundreds of companies, large and small, use Rust in production for a variety of -->
<!-- tasks. Those tasks include command line tools, web services, DevOps tooling, -->
<!-- embedded devices, audio and video analysis and transcoding, cryptocurrencies, -->
<!-- bioinformatics, search engines, Internet of Things applications, machine -->
<!-- learning, and even major parts of the Firefox web browser. -->
<p>数百の企業が、大企業、中小企業を問わず、様々なタスクにプロダクションでRustを使用しています。
そのタスクには、コマンドラインツール、Webサービス、DevOpsツール、組み込みデバイス、
オーディオとビデオの解析および変換、暗号通貨、生物情報学、サーチエンジン、IoTアプリケーション、
機械学習、Firefoxウェブブラウザの主要部分さえ含まれます。</p>
<!-- ### Open Source Developers -->
<a class="header" href="print.html#aオープンソース開発者" id="aオープンソース開発者"><h3>オープンソース開発者</h3></a>
<!-- Rust is for people who want to build the Rust programming language, community, -->
<!-- developer tools, and libraries. We’d love to have you contribute to the Rust -->
<!-- language. -->
<p>Rustは、Rustプログラミング言語やコミュニティ、開発者ツール、ライブラリを開発したい方向けです。
あなたがRust言語に貢献されることを心よりお待ちしております。</p>
<!-- ### People Who Value Speed and Stability -->
<a class="header" href="print.html#aスピードと安定性に価値を見出す方" id="aスピードと安定性に価値を見出す方"><h3>スピードと安定性に価値を見出す方</h3></a>
<!-- 最後から3行目、zero-cost abstractions, higher-level featuresの繋がりがよくわからない。byが両者にかかっているように訳した -->
<!-- Rust is for people who crave speed and stability in a language. By speed, we -->
<!-- mean the speed of the programs that you can create with Rust and the speed at -->
<!-- which Rust lets you write them. The Rust compiler’s checks ensure stability -->
<!-- through feature additions and refactoring. This is contrast to the brittle -->
<!-- legacy code in languages without these checks, which developers are often -->
<!-- afraid to modify. By striving for zero-cost abstractions, higher-level features -->
<!-- that compile to lower-level code as fast as code written manually, Rust -->
<!-- endeavors to make safe code be fast code as well. -->
<p>Rustは、スピードと安定性を言語に渇望する方向けです。ここでいうスピードとは、
Rustで作れるプログラムのスピードとソースコードを書くスピードのことです。Rustコンパイラのチェックにより、
機能の追加とリファクタリングを通して安定性を保証してくれます。これはこのようなチェックがない言語の脆いレガシーコードとは対照的で、
その場合開発者はしばしば、変更するのを恐れてしまいます。ゼロコスト抽象化を志向し、
手で書いたコードと同等の速度を誇る低レベルコードにコンパイルされる高レベル機能により、
Rustは安全なコードを高速なコードにもしようと努力しています。</p>
<!-- The Rust language hopes to support many other users as well; those mentioned -->
<!-- here are merely some of the biggest stakeholders. Overall, Rust’s greatest -->
<!-- ambition is to eliminate trade-offs that programmers have accepted for -->
<!-- decades: safety *and* productivity, speed *and* ergonomics. Give -->
<!-- Rust a try, and see if its choices work for you. -->
<p>Rust言語は他の多くのユーザのサポートも望んでいます; ここで名前を出した方は、
ただの最大の出資者の一部です。総合すると、Rustの最大の野望は、プログラマが数十年間受け入れてきた代償を排除することです:
つまり、安全性<em>と</em>生産性、スピード<em>と</em>エルゴノミクスです。Rustを試してみて、その選択が自分に合っているか確かめてください。</p>
<!-- ## Who This Book Is For -->
<a class="header" href="print.html#aこの本は誰のためのものなの" id="aこの本は誰のためのものなの"><h2>この本は誰のためのものなの</h2></a>
<!-- 最後から2行目、better servedをもっと上手く訳したい-->
<!-- This book assumes that you’ve written code in another programming language but -->
<!-- doesn’t make any assumptions about which one. We’ve tried to make the material -->
<!-- broadly accessible to those from a wide variety of programming backgrounds. We -->
<!-- don’t spend a lot of time talking about what programming *is* or how to think -->
<!-- about it. If you’re entirely new to programming, you would be better served by -->
<!-- reading a book that specifically provides an introduction to programming. -->
<p>この本は、あなたが他のプログラミング言語でコードを書いたことがあることを想定していますが、
具体的にどの言語かという想定はしません。幅広い分野のプログラミング背景からの人にとってこの資料を広くアクセスできるようにしようとしてきました。
プログラミングとはなん<em>なのか</em>やそれについて考える方法について多くを語るつもりはありません。
もし、完全なプログラミング初心者であれば、プログラミング入門を特に行う本を読むことでよりよく提供されるでしょう。</p>
<!-- ## How to Use This Book -->
<a class="header" href="print.html#aこの本の使い方" id="aこの本の使い方"><h2>この本の使い方</h2></a>
<!-- In general, this book assumes that you’re reading it in sequence from front to -->
<!-- back. Later chapters build on concepts in earlier chapters, and earlier -->
<!-- chapters might not delve into details on a topic; we typically revisit the -->
<!-- topic in a later chapter. -->
<p>一般的に、この本は、順番に読み進めていくことを前提にしています。後の章は、前の章の概念の上に成り立ち、
前の章では、ある話題にさほど深入りしない可能性があります; 典型的に後ほどの章で同じ話題を再度しています。</p>
<!-- You’ll find two kinds of chapters in this book: concept chapters and project -->
<!-- chapters. In concept chapters, you’ll learn about an aspect of Rust. In project -->
<!-- chapters, we’ll build small programs together, applying what you’ve learned so -->
<!-- far. Chapters 2, 12, and 20 are project chapters; the rest are concept chapters. -->
<p>この本には2種類の章があるとわかるでしょう: 概念の章とプロジェクトの章です。概念の章では、
Rustの一面を学ぶでしょう。プロジェクトの章では、それまでに学んだことを適用して一緒に小さなプログラムを構築します。
2、12、20章がプロジェクトの章です。つまり、残りは概念の章です。</p>
<!-- Chapter 1 explains how to install Rust, how to write a Hello, world! program, -->
<!-- and how to use Cargo, Rust’s package manager and build tool. Chapter 2 is a -->
<!-- hands-on introduction to the Rust language. We’ll cover concepts at a high -->
<!-- level, and later chapters will provide additional detail. If you want to get -->
<!--  your hands dirty right away, Chapter 2 is the one for that. At first, you -->
<!-- might even want to skip Chapter 3, which covers Rust features similar to those -->
<!-- of other programming language, and head straight to Chapter 4 to learn about -->
<!-- Rust’s ownership system. However, if you’re a particularly meticulous learner -->
<!-- who prefers to learn every detail before moving onto the next, you might want -->
<!-- to skip Chapter 2 and go straight to Chapter 3, returning to Chapter 2 when -->
<!-- you’d like to work on a project applying the details you’ve learned. -->
<p>第1章はRustのインストール方法、Hello, world!プログラムの書き方、Rustのパッケージマネージャ兼、
ビルドツールのCargoの使用方法を説明します。第2章は、Rust言語への実践的な導入です。概念を高度に講義し、後ほどの章で追加の詳細を提供します。
今すぐRustの世界に飛び込みたいなら、第2章こそがそのためのものです。第3章は他のプログラミング言語の機能に似たRustの機能を講義していますが、
最初その3章すら飛ばして、まっすぐに第4章に向かい、Rustの所有権システムについて学びたくなる可能性があります。
しかしながら、あなたが次に進む前に全ての詳細を学ぶことを好む特別に几帳面な学習者なら、
第2章を飛ばして真っ先に第3章に行き、学んだ詳細を適用するプロジェクトに取り組みたくなった時に第2章に戻りたくなる可能性があります。</p>
<!-- Chapter 5 discusses structs and methods, and Chapter 6 covers enums, `match` -->
<!-- expressions, and the `if let` control flow construct. You’ll use structs and -->
<!-- enums to make custom types in Rust. -->
<p>第5章は、構造体とメソッドについて議論し、第6章はenum、<code>match</code>式、<code>if let</code>フロー制御構文を講義します。
構造体とenumを使用してRustにおいて独自の型を作成します。</p>
<!-- In Chapter 7, you’ll learn about Rust’s module system and about privacy rules -->
<!-- for organizing your code and its public Application Programming Interface -->
<!-- (API). Chapter 8 discusses some common collection data structures that the -->
<!-- standard library provides, such as vectors, strings, and hash maps. Chapter 9 -->
<!-- explores Rust’s error-handling philosophy and techniques. -->
<p>第7章では、Rustのモジュールシステムと自分のコードとその公開されたAPI(Application Programming Interface)を体系化するプライバシー規則について学びます。
第8章では、ベクタ、文字列、ハッシュマップなどの標準ライブラリが提供する一般的なコレクションデータ構造の一部を議論します。
第9章では、Rustのエラー処理哲学とテクニックを探求します。</p>
<!-- Chapter 10 digs into generics, traits, and lifetimes, which give you the power -->
<!-- to define code that applies to multiple types. Chapter 11 is all about testing, -->
<!-- which even with Rust's safety guarantees is necessary to ensure your program's -->
<!-- logic is correct. In Chapter 12, we’ll build our own implementation of a subset -->
<!-- of functionality from the `grep` command line tool that searches for text -->
<!-- within files. For this, we’ll use many of the concepts we discussed in the -->
<!-- previous chapters. -->
<p>第10章ではジェネリクス、トレイト、ライフタイムについて深入りし、これらは複数の型に適用されるコードを定義する力をくれます。
第11章は、完全にテストに関してで、Rustのプログラムのロジックが正しいことを保証する安全性保証があってさえ、
必要になります。第12章では、ファイル内のテキストを検索する<code>grep</code>コマンドラインツールの一部の機能を自身で構築します。
このために、以前の章で議論した多くの概念を使用します。</p>
<!-- Chapter 13 explores closures and iterators: features of Rust that come from -->
<!-- functional programming languages. In Chapter 14, we’ll examine Cargo in more -->
<!-- depth and talk about best practices for sharing your libraries with others. -->
<!-- Chapter 15 discusses smart pointers that the standard library provides and the -->
<!-- traits that enable their functionality. -->
<p>第13章はクロージャとイテレータを探求します。これらは、関数型プログラミング言語由来のRustの機能です。
第14章では、Cargoをより詳しく調査し、他人と自分のライブラリを共有する最善の策について語ります。
第15章では、標準ライブラリが提供するスマートポインタとその機能を可能にするトレイトを議論します。</p>
<!-- In Chapter 16, we’ll walk through different models of concurrent programming -->
<!-- and talk about how Rust helps you to program in multiple threads fearlessly. -->
<!-- Chapter 17 looks at how Rust idioms compare to object-oriented programming -->
<!-- principles you might be familiar with. -->
<p>第16章では、非同期プログラミングの異なるモデルを見ていき、Rustが恐れなしに複数のスレッドでプログラムする手助けをする方法を語ります。
第17章では、馴染み深い可能性のあるオブジェクト指向プログラミングの原則とRustのイディオムがどう比較されるかに目を向けます。</p>
<!-- Chapter 18 is a reference on patterns and pattern matching, which are powerful -->
<!-- ways of expressing ideas throughout Rust programs. Chapter 19 contains a -->
<!-- smorgasbord of advanced topics of interest, including unsafe Rust and more -->
<!-- about lifetimes, traits, types, functions, and closures. -->
<p>第18章は、パターンとパターンマッチングのリファレンスであり、これらはRustプログラムを通して、
考えを表現する強力な方法になります。第19章は、unsafe Rustやライフタイム、トレイト、型、関数、クロージャの詳細を含む、
興味のある高度な話題のスモーガスボード(<code>訳注</code>: 日本でいうバイキングのこと)を含みます。</p>
<!-- In Chapter 20, we’ll complete a project in which we’ll implement a low-level -->
<!-- multithreaded web server! -->
<p>第20章では、低レベルなマルチスレッドのWebサーバを実装するプロジェクトを完成させます！</p>
<!-- Finally, some appendixes contain useful information about the language in a -->
<!-- more reference-like format. Appendix A covers Rust’s keywords, Appendix B -->
<!-- covers Rust’s operators and symbols, Appendix C covers derivable traits -->
<!-- provided by the standard library, Appendix D covers macros. -->
<p>最後に、言語についての有用な情報をよりリファレンスっぽい形式で含む付録があります。
付録AはRustのキーワードを講義し、付録Bは、Rustの演算子とシンボル、付録Cは、
標準ライブラリが提供する継承可能なトレイト、付録Dはマクロを講義します。</p>
<!-- There is no wrong way to read this book: if you want to skip ahead, go for it! -->
<!-- You might have to jump back to earlier chapters if you experience any -->
<!-- confusion. But do whatever works for you. -->
<p>この本を読む間違った方法なんてありません: 飛ばしたければ、どうぞご自由に！
混乱したら、前の章に戻らなければならない可能性もあります。ですが、自分に合った方法でどうぞ。</p>
<!-- An important part of the process of learning Rust is learning how to read the -->
<!-- error messages the compiler displays: these will guide you toward working code. -->
<!-- As such, we’ll provide many examples of code that doesn’t compile along with -->
<!-- the error message the compiler will show you in each situation. Know that if -->
<!-- you enter and run a random example, it may not compile! Make sure you read the -->
<!-- surrounding text to see whether the example you’re trying to run is meant to -->
<!-- error. In most situations, we’ll lead you to the correct version of any code -->
<!-- that doesn’t compile. -->
<p>Rustを学ぶ過程で重要な部分は、コンパイラが表示するエラーメッセージを読む方法を学ぶことです:
それは動くコードへと導いてくれます。そのため、各場面でコンパイラが表示するエラーメッセージとともに、
コンパイルできないコードの例を多く提供します。適当に例を選んで走らせたら、コンパイルできないかもしれないことを知ってください！
周りのテキストを読んで実行しようとしている例がエラーになることを意図しているのか確認することを確かめてください。
ほとんどの場合、コンパイルできないあらゆるコードの正しいバージョンへと導きます。</p>
<!-- ## Source code -->
<a class="header" href="print.html#aソースコード" id="aソースコード"><h2>ソースコード</h2></a>
<!-- The source files from which this book is generated can be found on -->
<!-- [GitHub][book]. -->
<p>この本が生成されるソースファイルは、<a href="https://github.com/rust-lang/book/tree/master/second-edition/src">GitHub</a>で見つかります。</p>
<p>この本はオープンソースです。間違いを見つけたら、<a href="https://github.com/rust-lang/book/tree/master/second-edition/src">GitHub</a>でissueを送ったり、
プルリクエストを送ったりするのを<ruby>躊躇<rp>(</rp><rt>ためら</rt><rp>)</rp></ruby>わないでください。
詳しくは、[CONTRIBUTING.md]をご参照ください</p>
<!-- # Getting Started -->
<a class="header" href="print.html#a事始め" id="a事始め"><h1>事始め</h1></a>
<!-- Let’s start your Rust journey! There’s a lot to learn, but every journey starts -->
<!-- somewhere. In this chapter, we’ll discuss: -->
<p>Rustの旅を始めましょう！学ぶべきことはたくさんありますが、いかなる旅もどこかから始まります。
この章では、以下のことを議論します:</p>
<!-- * Installing Rust on Linux, macOS, and Windows -->
<!-- * Writing a program that prints `Hello, world!` -->
<!-- * Using `cargo`, Rust’s package manager and build system -->
<ul>
<li>RustをLinux、macOS、Windowsにインストールする</li>
<li><code>Hello, world!</code>と出力するプログラムを書く</li>
<li><code>cargo</code>というRustのパッケージマネージャ兼ビルドシステムを使用する</li>
</ul>
<!-- ## Installation -->
<a class="header" href="print.html#aインストール" id="aインストール"><h2>インストール</h2></a>
<!-- The first step is to install Rust. We’ll download Rust through `rustup`, a -->
<!-- command line tool for managing Rust versions and associated tools. You’ll need -->
<!-- an internet connection for the download. -->
<p>最初の手順は、Rustをインストールすることです。Rustは、<code>rustup</code>というRustのバージョンと関連するツールを管理するコマンドラインツールを使用して、
ダウンロードします。ダウンロードするには、インターネット接続が必要でしょう。</p>
<!-- > Note: If you prefer not to use `rustup` for some reason, please see [the Rust -->
<!-- > installation page](https://www.rust-lang.org/install.html) for other options. -->
<blockquote>
<p>注釈: なんらかの理由で<code>rustup</code>を使用しないことを好むのなら、<a href="https://www.rust-lang.org/install.html">Rustインストールページ</a>で、
他の選択肢をご覧になってください。</p>
</blockquote>
<!-- The following steps install the latest stable version of the Rust compiler. All -->
<!-- the examples and output in this book use stable Rust 1.21.0. Rust’s stability -->
<!-- guarantees ensure that all the examples in the book that compile will continue -->
<!-- to compile with newer Rust versions. The output might differ slightly between -->
<!-- versions, because Rust often improves error messages and warnings. In other -->
<!-- words, any newer, stable version of Rust you install using these steps should -->
<!-- work as expected with the content of this book. -->
<p>以下の手順で最新の安定版のRustコンパイラをインストールします。この本の例と出力は全て、安定版のRust1.21.0を使用しています。
Rustの安定性保証により、現在この本の例でコンパイルできるものは、新しいバージョンになってもコンパイルでき続けることを保証します。
出力は、バージョンによって多少異なる可能性があります。Rustは頻繁にエラーメッセージと警告を改善しているからです。
言い換えると、どんな新しいバージョンでもこの手順に従ってインストールした安定版なら、
この本の内容で想定通りに動くはずです。</p>
<!-- > ### Command Line Notation -->
<!-- > -->
<!-- > In this chapter and throughout the book, we’ll show some commands used in the -->
<!-- > terminal. Lines that you should enter in a terminal all start with `$`. You -->
<!-- > don’t need to type in the `$` character; it indicates the start of each -->
<!-- > command. Lines that don't start with `$` typically show the output of the -->
<!-- > previous command. Additionally, PowerShell-specific examples will use `>` -->
<!-- > rather than `$`. -->
<blockquote>
<a class="header" href="print.html#aコマンドライン表記" id="aコマンドライン表記"><h3>コマンドライン表記</h3></a>
<p>この章及び、本を通して、端末で使用するなんらかのコマンドを示すことがあります。読者が入力するべき行は、
全て<code>$</code>で始まります。<code>$</code>文字を入れる必要はありません; 各コマンドの開始を示しているだけです。
<code>$</code>で始まらない行は、典型的には直前のコマンドの出力を示します。また、PowerShell限定の例は、
<code>$</code>ではなく、<code>&gt;</code>を使用します。</p>
</blockquote>
<!-- ### Installing `rustup` on Linux or macOS -->
<a class="header" href="print.html#linuxとmacosにrustupをインストールする" id="linuxとmacosにrustupをインストールする"><h3>LinuxとmacOSに<code>rustup</code>をインストールする</h3></a>
<!-- If you’re using Linux or macOS, open a terminal and enter the following command: -->
<p>LinuxかmacOSを使用しているなら、端末を開き、以下のコマンドを入力してください:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<!-- The command downloads a script and starts the installation of the `rustup` -->
<!-- tool, which installs the latest stable version of Rust. You might be prompted -->
<!-- for your password. If the install is successful, the following line will appear: -->
<p>このコマンドはスクリプトをダウンロードし、<code>rustup</code>ツールのインストールを開始し、Rustの最新の安定版をインストールします。
パスワードを求められる可能性があります。インストールがうまく行けば、以下の行が出現するでしょう:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<!-- If you prefer, feel free to download the script and inspect it before running -->
<!-- it. -->
<p>お好みでご自由にスクリプトをダウンロードし、実行前に調査することもできます。</p>
<!-- The installation script automatically adds Rust to your system PATH after your -->
<!-- next login. If you want to start using Rust right away instead of restarting -->
<!-- your terminal, run the following command in your shell to add Rust to your -->
<!-- system PATH manually: -->
<p>インストールスクリプトは、Rustを次回のログイン後にシステムのPATHに自動的に追加します。端末を再起動するのではなく、
いますぐにRustを使用し始めたいのなら、シェルで以下のコマンドを実行してRustをシステムのPATHに手動で追加します:</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<!-- Alternatively, you can add the following line to your *~/.bash_profile*: -->
<p>また、以下の行を <em>~/.bash_profile</em>に追加することもできます:</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<!-- Additionally, you’ll need a linker of some kind. It’s likely one is already -->
<!-- installed, but when you try to compile a Rust program and get errors indicating -->
<!-- that a linker could not execute, that means a linker isn’t installed on your -->
<!-- system and you’ll need to install one manually. C compilers usually come with -->
<!-- the correct linker. Check your platform’s documentation for how to install a C -->
<!-- compiler. Also, some common Rust packages depend on C code and will need a C -->
<!-- compiler. Therefore, it might be worth installing one now. -->
<p>さらに、なんらかの類のリンカーが必要になるでしょう。既にインストールされている可能性が高いものの、
Rustプログラムのコンパイルを試みて、リンカーが実行できないというエラーが出たら、
システムにリンカーがインストールされていないということなので、手動でインストールする必要があるでしょう。
Cコンパイラは通常正しいリンカーとセットになっています。
自分のプラットフォームのドキュメンテーションを見てCコンパイラのインストール方法を確認してください。
一般的なRustパッケージの中には、Cコードに依存し、Cコンパイラが必要になるものもあります。
故に今インストールする価値はあるかもしれません。</p>
<!-- ### Installing `rustup` on Windows -->
<a class="header" href="print.html#windowsでrustupをインストールする" id="windowsでrustupをインストールする"><h3>Windowsで<code>rustup</code>をインストールする</h3></a>
<!-- On Windows, go to [https://www.rust-lang.org/install.html][install] and follow -->
<!-- the instructions for installing Rust. At some point in the installation, you’ll -->
<!-- receive a message explaining that you’ll also need the C++ build tools for -->
<!-- Visual Studio 2013 or later. The easiest way to acquire the build tools is to -->
<!-- install [Build Tools for Visual Studio 2017][visualstudio]. The tools are in -->
<!-- the Other Tools and Frameworks section. -->
<p>Windowsでは、<a href="https://www.rust-lang.org/install.html">https://www.rust-lang.org/install.html</a>に行き、手順に従ってRustをインストールしてください。
インストールの途中で、Visual Studio2013以降用のC++ビルドツールも必要になるという旨のメッセージが出るでしょう。
ビルドツールを取得する最も簡単な方法は、<a href="https://www.visualstudio.com/downloads/">Visual Studio 2017用のビルドツール</a>をインストールすることです。
ツールは、他のツール及びフレームワークのセクションにあります。</p>
<!-- The rest of this book uses commands that work in both *cmd.exe* and PowerShell. -->
<!-- If there are specific differences, we’ll explain which to use. -->
<p>これ以降、<em>cmd.exe</em>とPowerShellの両方で動くコマンドを使用します。
特定の違いがあったら、どちらを使用すべきか説明します。</p>
<!-- ### Updating and Uninstalling -->
<a class="header" href="print.html#a更新及びアンインストール" id="a更新及びアンインストール"><h3>更新及びアンインストール</h3></a>
<!-- After you’ve installed Rust via `rustup`, updating to the latest version is -->
<!-- easy. From your shell, run the following update script: -->
<p><code>rustup</code>経由でRustをインストールしたら、最新版への更新は、簡単になります。シェルから、
以下の更新スクリプトを実行してください:</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<!-- To uninstall Rust and `rustup`, run the following uninstall script from your -->
<!-- shell: -->
<p>Rustと<code>rustup</code>をアンインストールするには、シェルから以下のアンインストールスクリプトを実行してください:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<!-- ### Troubleshooting -->
<a class="header" href="print.html#aトラブルシューティング" id="aトラブルシューティング"><h3>トラブルシューティング</h3></a>
<!-- To check whether you have Rust installed correctly, open a shell and enter this -->
<!-- line: -->
<p>Rustが正常にインストールされているか確かめるには、シェルを開いて以下の行を入力してください:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<!-- You should see the version number, commit hash, and commit date for the latest -->
<!-- stable version that has been released in the following format: -->
<p>バージョンナンバー、コミットハッシュ、最新の安定版がリリースされたコミット日時が以下のフォーマットで表示されるのを目撃するはずです。</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<!-- If you see this information, you have installed Rust successfully! If you don’t -->
<!-- see this information and you’re on Windows, check that Rust is in your `%PATH%` -->
<!-- system variable. If that’s all correct and Rust still isn’t working, there are -->
<!-- a number of places you can get help. The easiest is [the #rust IRC channel on -->
<!-- irc.mozilla.org][irc], which you can access through -->
<!-- [Mibbit][mibbit]. At that address you can chat with other Rustaceans (a silly -->
<!-- nickname we call ourselves) who can help you out. Other great resources include -->
<!-- [the Users forum][users] and [Stack Overflow][stackoverflow]. -->
<p>この情報が見れたら、Rustのインストールに成功しました！この情報が出ず、Windowsを使っているなら、
Rustが<code>%PATH%</code>システム環境変数にあることを確認してください。全て正常で、それでもRustが動かないなら、
助力を得られる場所はたくさんあります。最も簡単なのが<a href="irc://irc.mozilla.org/#rust">irc.mozilla.orgの#rust IRCチャンネル</a>で、
<a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>を通してアクセスできます。そのアドレスで、助けてくれる他のRustacean(自分たちを呼ぶバカなニックネーム)とチャットできます。
他の素晴らしいリソースには、<a href="https://users.rust-lang.org/">ユーザ・フォーラム</a>と<a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>が含まれます。</p>
<blockquote>
<p>Rustacean: いらないかもしれない補足です。Rustaceanは公式にcrustaceans(甲殻類)から<a href="https://mobile.twitter.com/rustlang/status/916284650674323457">来て</a>いるそうです。
そのため、Rustのマスコットは非公式らしいですが、<a href="https://www.slideshare.net/wolf-dog/ss-64026540">カニ</a>。上の会話でCの欠点を削ぎ落としているからcを省いてるの？みたいなことを聞いてますが、
違うそうです。検索したら、堅牢性が高いから甲殻類という意見もありますが、真偽は不明です。
明日使えるかもしれないトリビアでした。</p>
</blockquote>
<!-- ### Local Documentation -->
<a class="header" href="print.html#aローカルのドキュメンテーション" id="aローカルのドキュメンテーション"><h3>ローカルのドキュメンテーション</h3></a>
<!-- The installer also includes a copy of the documentation locally, so you can -->
<!-- read it offline. Run `rustup doc` to open the local documentation in your -->
<!-- browser. -->
<p>インストーラは、ドキュメンテーションの複製もローカルに含んでいるので、オフラインで閲覧することができます。
ブラウザでローカルのドキュメンテーションを開くには、<code>rustup doc</code>を実行してください。</p>
<!-- Any time a type or function is provided by the standard library and you’re not -->
<!-- sure what it does or how to use it, use the application programming interface -->
<!-- (API) documentation to find out! -->
<p>標準ライブラリにより型や関数が提供され、それがなんなのかや使用方法に確信が持てない度に、APIドキュメンテーションを使用して探してください！</p>
<!-- ## Hello, World! -->
<a class="header" href="print.html#hello-world" id="hello-world"><h2>Hello, World!</h2></a>
<!-- Now that you’ve installed Rust, let’s write your first Rust program. It’s -->
<!-- traditional when learning a new language to write a little program that prints -->
<!-- the text `Hello, world!` to the screen, so we’ll do the same here! -->
<p>Rustをインストールしたので、最初のRustプログラムを書きましょう。新しい言語を学ぶ際に、
<code>Hello, world!</code>というテキストを画面に出力する小さなプログラムを書くことは伝統的なことなので、
ここでも同じようにしましょう！</p>
<!-- > Note: This book assumes basic familiarity with the command line. Rust makes -->
<!-- > no specific demands about your editing or tooling or where your code lives, so -->
<!-- > if you prefer to use an integrated development environment (IDE) instead of -->
<!-- > the command line, feel free to use your favorite IDE. Many IDEs now have some -->
<!-- > degree of Rust support; check the IDE’s documentation for details. Recently, -->
<!-- > the Rust team has been focusing on enabling great IDE support, and progress -->
<!-- > has been made rapidly on that front! -->
<blockquote>
<p>注釈: この本は、コマンドラインに基本的な馴染みがあることを前提にしています。Rustは、編集やツール、
どこにコードがあるかについて特定の要求をしないので、コマンドラインではなくIDEを使用することを好むのなら、
どうぞご自由にお気に入りのIDEを使用してください。今では、多くのIDEがなんらかの形でRustをサポートしています;
詳しくは、IDEのドキュメンテーションをご覧ください。最近、Rustチームは優れたIDEサポートを有効にすることに注力し、
その前線で急激に成果があがっています！</p>
</blockquote>
<!-- ### Creating a Project Directory -->
<a class="header" href="print.html#aプロジェクトのディレクトリを作成する" id="aプロジェクトのディレクトリを作成する"><h3>プロジェクトのディレクトリを作成する</h3></a>
<!-- You’ll start by making a directory to store your Rust code. It doesn’t matter -->
<!-- to Rust where your code lives, but for the exercises and projects in this book, -->
<!-- we suggest making a *projects* directory in your home directory and keeping all -->
<!-- your projects there. -->
<p>Rustコードを格納するディレクトリを作ることから始めましょう。Rustにとって、コードがどこにあるかは問題ではありませんが、
この本の練習とプロジェクトのために、ホームディレクトリに<em>projects</em>ディレクトリを作成してプロジェクトを全てそこに保管することを推奨します。</p>
<!-- Open a terminal and enter the following commands to make a *projects* directory -->
<!-- and a directory for the Hello, world! project within the *projects* directory. -->
<p>端末を開いて以下のコマンドを入力し、<em>projects</em>ディレクトリと<em>projects</em>ディレクトリ内に、
Hello, world!プロジェクトのディレクトリを作成してください。</p>
<!-- For Linux and macOS, enter this: -->
<p>LinuxとmacOSなら、こう入力してください:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<!-- For Windows CMD, enter this: -->
<p>Windowsのcmdなら、こう:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!-- For Windows PowerShell, enter this: -->
<p>WindowsのPowerShellなら、こう:</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projects
&gt; cd $env:USERPROFILE\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!-- ### Writing and Running a Rust Program -->
<a class="header" href="print.html#rustプログラムを書いて走らせる" id="rustプログラムを書いて走らせる"><h3>Rustプログラムを書いて走らせる</h3></a>
<!-- Next, make a new source file and call it *main.rs*. Rust files always end with -->
<!-- the *.rs* extension. If you’re using more than one word in your filename, use -->
<!-- an underscore to separate them. For example, use *hello_world.rs* rather than -->
<!-- *helloworld.rs*. -->
<p>次にソースファイルを作り、<em>main.rs</em>と呼んでください。Rustのファイルは常に <em>.rs</em>という拡張子で終わります。
ファイル名に2単語以上使っているなら、アンダースコアで区切ってください。例えば、<em>helloworld.rs</em>ではなく、
<em>hello_world.rs</em>を使用してください。</p>
<!-- Now open the *main.rs* file you just created and enter the code in Listing 1-1. -->
<p>さて、作ったばかりの<em>main.rs</em>ファイルを開き、リスト1-1のコードを入力してください。</p>
<!-- <span class="filename">Filename: main.rs</span> -->
<p><span class="filename">ファイル名: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!-- <span class="caption">Listing 1-1: A program that prints `Hello, world!`</span> -->
<p><span class="caption">リスト1-1: <code>Hello, world!</code>と出力するプログラム</span></p>
<!-- Save the file and go back to your terminal window. On Linux or macOS, enter -->
<!-- the following commands to compile and run the file: -->
<p>ファイルを保存し、端末ウィンドウに戻ってください。LinuxかmacOSなら、以下のコマンドを打ってファイルをコンパイルし、
実行してください:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<!-- On Windows, enter the command `.\main.exe` instead of `./main`: -->
<p>Windowsなら、<code>./main</code>の代わりに<code>.\main.exe</code>と打ちます:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<!-- Regardless of your operating system, the string `Hello, world!` should print to -->
<!-- the terminal. If you don’t see this output, refer back to the “Troubleshooting” -->
<!-- section for ways to get help. -->
<p>OSに関わらず、<code>Hello, world!</code>という文字列が端末に出力されるはずです。この出力が見れないなら、
「トラブルシューティング」節に立ち戻って、助けを得る方法を参照してください。</p>
<!-- If `Hello, world!` did print, congratulations! You’ve officially written a Rust -->
<!-- program. That makes you a Rust programmer-welcome! -->
<p><code>Hello, world!</code>が確かに出力されたら、おめでとうございます！正式にRustプログラムを書きました。
Rustプログラマになったのです！ようこそ！</p>
<!-- ### Anatomy of a Rust Program -->
<a class="header" href="print.html#rustプログラムの解剖" id="rustプログラムの解剖"><h3>Rustプログラムの解剖</h3></a>
<!-- Let’s review in detail what just happened in your Hello, world! program. -->
<!-- Here’s the first piece of the puzzle: -->
<p>Hello, world!プログラムでちょうど何が起こったのか詳しく確認しましょう。
こちらがパズルの最初のピースです:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<!-- These lines define a function in Rust. The `main` function is special: it is -->
<!-- always the first code that runs in every executable Rust program. The first -->
<!-- line declares a function named `main` that has no parameters and returns -->
<!-- nothing. If there were parameters, they would go inside the parentheses, `()`. -->
<!-- and `)`. -->
<p>これらの行でRustで関数を定義しています。<code>main</code>関数は特別です: 常に全ての実行可能なRustプログラムで走る最初のコードになります。
1行目は、引数がなく、何も返さない<code>main</code>という関数を宣言しています。引数があるなら、かっこ(<code>()</code>)の内部に入ります。</p>
<!-- Also, note that the function body is wrapped in curly brackets, `{}`. Rust -->
<!-- requires these around all function bodies. It’s good style to place the opening -->
<!-- curly bracket on the same line as the function declaration, adding one space in -->
<!-- between. -->
<p>また、関数の本体が波括弧(<code>{</code>と<code>}</code>)に包まれていることにも注目してください。Rustでは、全ての関数本体の周りにこれらが必要になります。
スペースを1つあけて、開き波括弧を関数宣言と同じ行に配置するのがいいスタイルです。</p>
<!-- At the time of this writing, an automatic formatter tool called `rustfmt` is -->
<!-- under development. If you want to stick to a standard style across Rust -->
<!-- projects, `rustfmt` will format your code in a particular style. The Rust team -->
<!-- plans to eventually include this tool with the standard Rust distribution, like -->
<!-- `rustc`. So depending on when you read this book, it might already be installed -->
<!-- on your computer! Check the online documentation for more details. -->
<p>これを執筆している時点では、<code>rustfmt</code>と呼ばれる自動整形ツールは開発中です。複数のRustプロジェクトに渡って、
標準的なスタイルに固執したいなら、<code>rustfmt</code>は特定のスタイルにコードを整形してくれます。Rustチームは、
最終的に<code>rustc</code>のように標準的なRustの配布にこのツールを含むことを計画しています。従って、この本を読んだ時期によっては、
既にコンピュータにインストールされている可能性もあります！詳細は、オンラインのドキュメンテーションを確認してください。</p>
<!-- Inside the `main` function is the following code: -->
<p><code>main</code>関数内には、こんなコードがあります:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, world!&quot;);
#}</code></pre></pre>
<!-- This line does all the work in this little program: it prints text to the -->
<!-- screen. There are four important details to notice here. First, Rust style is -->
<!-- to indent with four spaces, not a tab. -->
<p>この行が、この小さなプログラムの全作業をしています: テキストを画面に出力するのです。
ここで気付くべき重要な詳細が4つあります。まず、Rustのスタイルは、タブではなく、4スペースでインデントするということです。</p>
<!-- Second, `println!` calls a Rust macro. If it called a function instead, it -->
<!-- would be entered as `println` (without the `!`). We’ll discuss Rust macros in -->
<!-- more detail in Appendix D. For now, you just need to know that using a `!` -->
<!-- means that you’re calling a macro instead of a normal function. -->
<p>2番目に<code>println!</code>はRustのマクロを呼び出すということです。代わりに関数を呼んでいたら、
<code>println</code>(<code>!</code>なし)と入力されているでしょう。Rustのマクロについて詳しくは、付録Dで議論します。
とりあえず、<code>!</code>を使用すると、普通の関数ではなくマクロを呼んでいるのだということを知っておくだけでいいでしょう。</p>
<!-- Third, you see the `"Hello, world!"` string. We pass this string as an argument -->
<!-- to `println!`, and the string is printed to the screen. -->
<p>3番目に、<code>&quot;Hello, world!&quot;</code>文字列が見えます。この文字列を引数として<code>println!</code>に渡し、
この文字列が画面に表示されているのです。</p>
<!-- Fourth, we end the line with a semicolon (`;`), which indicates that this -->
<!-- expression is over and the next one is ready to begin. Most lines of Rust code -->
<!-- end with a semicolon. -->
<p>4番目にこの行をセミコロン(<code>;</code>)で終え、この式が終わり、次の式の準備ができていると示唆していることです。
Rustコードのほとんどの行は、セミコロンで終わります。</p>
<!-- ### Compiling and Running Are Separate Steps -->
<a class="header" href="print.html#aコンパイルと実行は個別のステップ" id="aコンパイルと実行は個別のステップ"><h3>コンパイルと実行は個別のステップ</h3></a>
<!-- You’ve just run a newly created program, so let’s examine each step in the -->
<!-- process. -->
<p>新しく作成したプログラムをちょうど実行したので、その途中の手順を調査しましょう。</p>
<!-- Before running a Rust program, you must compile it using the Rust compiler by -->
<!-- entering the `rustc` command and passing it the name of your source file, like -->
<!-- this: -->
<p>Rustプログラムを実行する前に、以下のように、<code>rustc</code>コマンドを入力し、ソースファイルの名前を渡すことで、
Rustコンパイラを使用してコンパイルしなければなりません。</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<!-- If you have a C or C++ background, you’ll notice that this is similar to `gcc` -->
<!-- or `clang`. After compiling successfully, Rust outputs a binary executable. -->
<p>あなたにCやC++の背景があるなら、これは<code>gcc</code>や<code>clang</code>と似ていると気付くでしょう。コンパイルに成功後、
Rustはバイナリの実行可能ファイルを出力します。</p>
<!-- On Linux, macOS, and PowerShell on Windows, you can see the executable by -->
<!-- entering the `ls` command in your shell as follows: -->
<p>Linux、macOS、WindowsのPowerShellなら、シェルで以下のように<code>ls</code>コマンドを入力することで実行可能ファイルを見られます:</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<!-- With CMD on Windows, you would enter the following: -->
<p>WindowsのCMDなら、以下のように入力するでしょう:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
         %= /Bオプションは、ファイル名だけを表示することを宣言する =%
main.exe
main.pdb
main.rs
</code></pre>
<!-- This shows the source code file with the *.rs* extension, the executable file -->
<!-- (*main.exe* on Windows, but *main* on all other platforms), and, when using -->
<!-- CMD, a file containing debugging information with the *.pdb* extension. From -->
<!-- here, you run the *main* or *main.exe* file, like this: -->
<p>これは、<em>.rs</em>拡張子のソースコードファイル、実行可能ファイル(Windowsなら<em>main.exe</em>、他のプラットフォームでは、<em>main</em>)、
そして、CMDを使用しているなら、<em>.pdb</em>拡張子のデバッグ情報を含むファイルを表示します。ここから、
<em>main</em>か<em>main.exe</em>を走らせます。このように:</p>
<pre><code class="language-text">$ ./main # or .\main.exe on Windows
         # または、Widnowsなら.\main.exe
</code></pre>
<!-- If *main.rs* was your Hello, world! program, this line would print `Hello, -->
<!-- world!` to your terminal. -->
<p><em>main.rs</em>がHello, world!プログラムなら、この行は<code>Hello, world!</code>と端末に出力するでしょう。</p>
<!-- *.rb*がなぜかイタリックにならない -->
<!-- If you’re more familiar with a dynamic language, such as Ruby, Python, or -->
<!-- JavaScript, you might not be used to compiling and running a program as -->
<!-- separate steps. Rust is an *ahead-of-time compiled* language, meaning you can -->
<!-- compile a program and give the executable to someone else, and they can run it -->
<!-- even without having Rust installed. If you give someone a *.rb*, *.py*, or -->
<!-- *.js* file, they need to have a Ruby, Python, or JavaScript implementation -->
<!-- installed (respectively). But in those languages, you only need one command to -->
<!-- compile and run your program. Everything is a trade-off in language design. -->
<p>RubyやPython、JavaScriptなどの動的言語により造詣が深いなら、プログラムのコンパイルと実行を個別の手順で行うことに慣れていない可能性があります。
Rustは<em>AOTコンパイル</em>(ahead-of-time; <code>訳注</code>: 予め)言語です。つまり、プログラムをコンパイルし、
実行可能ファイルを誰かにあげ、あげた人がRustをインストールしなくても実行できるわけです。
誰かに <em>.rb</em>、<em>.py</em>、<em>.js</em>ファイルをあげたら、それぞれRuby、Python、JavaScriptの実装がインストールされている必要があります。
ですが、そのような言語では、プログラムをコンパイルし実行するには、1コマンドしか必要ないのです。
全ては言語設計においてトレードオフなのです。</p>
<!-- Just compiling with `rustc` is fine for simple programs, but as your project -->
<!-- grows, you’ll want to manage all the options and make it easy to share your -->
<!-- code. Next, we’ll introduce you to the Cargo tool, which will help you write -->
<!-- real-world Rust programs. -->
<p>簡単なプログラムなら<code>rustc</code>でコンパイルするだけでも十分ですが、プロジェクトが肥大化してくると、
オプションを全て管理し、自分のコードを簡単に共有したくなるでしょう。次は、Cargoツールを紹介します。
これは、現実世界のRustプログラムを書く手助けをしてくれるでしょう。</p>
<!-- ## Hello, Cargo! -->
<a class="header" href="print.html#hello-cargo" id="hello-cargo"><h2>Hello, Cargo!</h2></a>
<!-- Cargo is Rust’s build system and package manager. Most Rustaceans use this tool -->
<!-- to manage their Rust projects because Cargo handles a lot of tasks for you, -->
<!-- such as building your code, downloading the libraries your code depends on, and -->
<!-- building those libraries. (We call libraries your code needs *dependencies*.) -->
<p>Cargoは、Rustのビルドシステム兼、パッケージマネージャです。ほとんどのRustaceanはこのツールを使用して、
Rustプロジェクトの管理をしています。Cargoは、コードのビルドやコードが依存しているライブラリのダウンロード、
それらのライブラリのビルド(コードが必要とするライブラリを我々は、<em>依存</em>と呼んでいます)などの多くの仕事を扱ってくれるからです。</p>
<!-- The simplest Rust programs, like the one we’ve written so far, don’t have any -->
<!-- dependencies. So if we had built the Hello, world! project with Cargo, it would -->
<!-- only use the part of Cargo that handles building your code. As you write more -->
<!-- complex Rust programs, you’ll add dependencies, and if you start a project -->
<!-- using Cargo, adding dependencies will be much easier to do. -->
<p>今までに書いたような最も単純なRustプログラムは、依存がありません。従って、Hello, world!プロジェクトをCargoを使ってビルドしても、
Cargoのコードをビルドする部分しか使用しないでしょう。より複雑なRustプログラムを書くにつれて、
依存を追加し、Cargoでプロジェクトを開始したら、依存の追加は、遥かに簡単になるのです。</p>
<!-- Because the vast majority of Rust projects use Cargo, the rest of this book -->
<!-- assumes that you’re using Cargo too. Cargo comes installed with Rust if you -->
<!-- used the official installers discussed in the “Installation” section. If you -->
<!-- installed Rust through some other means, check whether Cargo is installed by -->
<!-- entering the following into your terminal: -->
<p>Rustプロジェクトの大多数がCargoを使用しているので、これ以降この本では、あなたもCargoを使用していることを想定します。
Cargoは、「インストール」節で議論した公式のインストーラを使用していれば、勝手にインストールされます。
Rustを他の何らかの手段でインストールした場合、以下のコマンドを端末に入れてCargoがインストールされているか確かめてください:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<!-- If you see a version number, you have it! If you see an error, such as `command -->
<!-- not found`, look at the documentation for your method of installation to -->
<!-- determine how to install Cargo separately. -->
<p>バージョンナンバーが見えたら、インストールされています！<code>command not found</code>などのエラーが見えたら、
自分のインストール方法を求めてドキュメンテーションを見、Cargoを個別にインストールする方法を決定してください。</p>
<!-- ### Creating a Project with Cargo -->
<a class="header" href="print.html#cargoでプロジェクトを作成する" id="cargoでプロジェクトを作成する"><h3>Cargoでプロジェクトを作成する</h3></a>
<!-- Let’s create a new project using Cargo and look at how it differs from our -->
<!-- original Hello, world! project. Navigate back to your *projects* directory (or -->
<!-- wherever you decided to store your code). Then, on any operating system, run -->
<!-- the following: -->
<p>Cargoを使用して新しいプロジェクトを作成し、元のHello, world!プロジェクトとどう違うかを見ましょう。
<em>projects</em>ディレクトリ(あるいはコードを格納すると決めた場所)に戻ってください。それから、
OSに関わらず、以下を実行してください:</p>
<pre><code class="language-text">$ cargo new hello_cargo --bin
$ cd hello_cargo
</code></pre>
<!-- The first command creates a new binary executable called *hello_cargo*. The -->
<!-- `--bin` argument passed to `cargo new` makes an executable application (often -->
<!-- just called a *binary*) as opposed to a library. We’ve named our project -->
<!-- *hello_cargo*, and Cargo creates its files in a directory of the same name. -->
<p>最初のコマンドは、<em>hello_cargo</em>という新しいバイナリの実行可能ファイルを作成します。<code>cargo new</code>に渡した<code>--bin</code>引数が、
ライブラリとは対照的に実行可能なアプリケーション(よく単に<em>バイナリ</em>と呼ばれる)を作成します。プロジェクトを<em>hello_cargo</em>と名付け、
Cargoは、そのファイルを同名のディレクトリに作成します。</p>
<!-- Go into the *hello_cargo* directory and list the files. You’ll see that Cargo -->
<!-- has generated two files and one directory for us: a *Cargo.toml* file and a -->
<!-- *src* directory with a *main.rs* file inside. It has also initialized a new Git -->
<!-- repository along with a *.gitignore* file. -->
<p><em>hello_cargo</em>ディレクトリに行き、ファイルを列挙してください。Cargoが2つのファイルと1つのディレクトリを生成してくれたことがわかるでしょう:
<em>Cargo.toml</em>ファイルと、中に<em>main.rs</em>ファイルがある<em>src</em>ディレクトリです。また、
<em>.gitignore</em>ファイルと共に、新しいGitリポジトリも初期化しています。</p>
<!-- > Note: Git is a common version control system. You can change `cargo new` to -->
<!-- > use a different version control system or no version control system by using -->
<!-- > the `--vcs` flag. Run `cargo new --help` to see the available options. -->
<blockquote>
<p>注釈: Gitは一般的なバージョンコントロールシステムです。<code>cargo new</code>を変更して、異なるバージョンコントロールシステムを使用したり、
<code>--vcs</code>フラグを使用して何もバージョンコントロールシステムを使用しないようにもできます。
<code>cargo new --help</code>を走らせて、利用可能なオプションを確認してください。</p>
</blockquote>
<!-- Open *Cargo.toml* in your text editor of choice. It should look similar to the -->
<!-- code in Listing 1-2. -->
<p>お好きなテキストエディタで<em>Cargo.toml</em>を開いてください。リスト1-2のコードのような見た目のはずです。</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<!-- <span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo -->
<!-- new`</span> -->
<p><span class="caption">リスト1-2: <code>cargo new</code>で生成される<em>Cargo.toml</em>の中身</span></p>
<!-- This file is in the [*TOML*][toml] (*Tom’s Obvious, Minimal -->
<!-- Language*) format, which is Cargo’s configuration format. -->
<p>このファイルは<a href="https://github.com/toml-lang/toml">TOML</a>(<em>Tom's Obvious, Minimal Language</em>; <code>直訳</code>: トムの明確な最小限の言語)フォーマットで、
Cargoの設定フォーマットです。</p>
<!-- The first line, `[package]`, is a section heading that indicates that the -->
<!-- following statements are configuring a package. As we add more information to -->
<!-- this file, we’ll add other sections. -->
<p>最初の行の<code>[package]</code>は、後の文がパッケージを設定していることを示すセクションヘッダーです。もっと情報を追加すれば、
別のセクションも追加するでしょう。</p>
<!-- The next three lines set the configuration information Cargo needs to compile -->
<!-- your program: the name, the version, and who wrote it. Cargo gets your name and -->
<!-- email information from your environment, so if that information is not correct, -->
<!-- fix the information now and then save the file. -->
<p>その後の3行が、Cargoがプログラムをコンパイルするのに必要な設定情報をセットします: 名前、バージョン、誰が書いたかです。
Cargoは名前とEメールの情報を環境から取得するので、その情報が正しくなければ、
今修正してそれから保存してください。</p>
<!-- The last line, `[dependencies]`, is the start of a section for you to list any -->
<!-- of your project’s dependencies. In Rust, packages of code are referred to as -->
<!-- *crates*. We won’t need any other crates for this project, but we will in the -->
<!-- first project in Chapter 2, so we’ll use this dependencies section then. -->
<p>最後の行の<code>[dependencies]</code>は、プロジェクトの依存を列挙するためのセクションの始まりです。
Rustでは、パッケージのコードは<em>クレート</em>として参照されます。このプロジェクトでは何も他のクレートは必要ありませんが、
第2章の最初のプロジェクトでは必要なので、その時にはこの依存セクションを使用するでしょう。</p>
<!-- Now open *src/main.rs* and take a look: -->
<p>では、<em>src/main.rs</em>を開いて覗いてみてください:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!-- Cargo has generated a Hello, world! program for you, just like the one we wrote -->
<!-- in Listing 1-1! So far, the differences between our previous project and the -->
<!-- project Cargo generates are that Cargo placed the code in the *src* directory, -->
<!-- and we have a *Cargo.toml* configuration file in the top directory. -->
<p>ちょうどリスト1-1で書いたように、CargoはHello, world!プログラムを生成してくれています。ここまでで、
前のプロジェクトとCargoが生成したプロジェクトの違いは、Cargoが<em>src</em>ディレクトリにコードを配置し、
最上位のディレクトリに<em>Cargo.toml</em>設定ファイルがあることです。</p>
<!-- Cargo expects your source files to live inside the *src* directory. The -->
<!-- top-level project directory is just for README files, license information, -->
<!-- configuration files, and anything else not related to your code. Using Cargo -->
<!-- helps you organize your projects. There’s a place for everything, and -->
<!-- everything is in its place. -->
<p>Cargoは、ソースファイルが<em>src</em>ディレクトリにあることを期待します。プロジェクトの最上位のディレクトリは、
READMEファイル、ライセンス情報、設定ファイル、あるいは、他のコードに関連しないもののためのものです。
Cargoを使用すると、プロジェクトを体系化する手助けをしてくれます。適材適所であり、
全てがその場所にあるのです。</p>
<!-- If you started a project that doesn’t use Cargo, as we did with the Hello, -->
<!-- world! project, you can convert it to a project that does use Cargo. Move the -->
<!-- project code into the *src* directory and create an appropriate *Cargo.toml* -->
<!-- file. -->
<p>Hello, world!プロジェクトのように、Cargoを使用しないプロジェクトを開始したら、
実際にCargoを使用するプロジェクトに変換することができます。プロジェクトのコードを<em>src</em>ディレクトリに移動し、
適切な<em>Cargo.toml</em>ファイルを作成してください。</p>
<!-- ### Building and Running a Cargo Project -->
<a class="header" href="print.html#cargoプロジェクトをビルドし実行する" id="cargoプロジェクトをビルドし実行する"><h3>Cargoプロジェクトをビルドし、実行する</h3></a>
<!-- Now let’s look what's different when we build and run the Hello, world! -->
<!-- program with Cargo! From your *hello_cargo* directory, build your project by -->
<!-- entering the following command: -->
<p>さて、CargoでHello, world!プログラムをビルドし、実行する時の違いに目を向けましょう！<em>hello_cargo</em>ディレクトリから、
以下のコマンドを入力してプロジェクトをビルドしてください:</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<!-- This command creates an executable file in *target/debug/hello_cargo* (or -->
<!-- *target\debug\hello_cargo.exe* on Windows) rather than in your current -->
<!-- directory. You can run the executable with this command: -->
<p>このコマンドは、カレントディレクトリではなく、<em>target/debug/hello_cargo</em>(あるいはWindowsなら、
<em>target/debug/hello_cargo.exe</em>)の実行可能ファイルを作成します。以下のコマンドで実行可能ファイルを実行できます:</p>
<pre><code class="language-text">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
                             # あるいは、Windowsなら、.\target\debug\hello_cargo.exe
Hello, world!
</code></pre>
<!-- If all goes well, `Hello, world!` should print to the terminal. Running `cargo -->
<!-- build` for the first time also causes Cargo to create a new file at the top -->
<!-- level: *Cargo.lock*. This file keeps track of the exact versions of -->
<!-- dependencies in your project. This project doesn’t have dependencies, so the -->
<!-- file is a bit sparse. You won’t ever need to change this file manually; Cargo -->
<!-- manages its contents for you. -->
<p>全てがうまくいけば、<code>Hello, world!</code>が端末に出力されるはずです。初めて<code>cargo build</code>を実行すると、
Cargoが最上位に新しいファイルも作成します: <em>Cargo.lock</em>です。このファイルは、自分のプロジェクトの依存の正確なバージョンを追いかけます。
このプロジェクトには依存がないので、ファイルはやや空っぽです。絶対にこのファイルを手動で変更する必要はないでしょう;
Cargoが中身を管理してくれるのです。</p>
<!-- We just built a project with `cargo build` and ran it with -->
<!-- `./target/debug/hello_cargo`, but we can also use `cargo run` to compile the -->
<!-- code and then run the resulting executable all in one command: -->
<p><code>cargo build</code>でプロジェクトをビルドし、<code>./target/debug/hello_cargo</code>で実行したばかりですが、
<code>cargo run</code>を使用して、コードをコンパイルし、それから吐かれた実行可能ファイルを全部1コマンドで実行することもできます:</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!-- Notice that this time we didn’t see output indicating that Cargo was compiling -->
<!-- `hello_cargo`. Cargo figured out that the files hadn’t changed, so it just ran -->
<!-- the binary. If you had modified your source code, Cargo would have rebuilt the -->
<!-- project before running it, and you would have seen this output: -->
<p>今回は、Cargoが<code>hello_cargo</code>をコンパイルしていることを示唆する出力がないことに気付いてください。
Cargoはファイルが変更されていないことを推論したので、単純にバイナリを実行したのです。
ソースコードを変更していたら、Cargoは実行前にプロジェクトを再ビルドし、こんな出力を目の当たりにしたでしょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!-- Cargo also provides a command called `cargo check`. This command quickly checks -->
<!-- your code to make sure it compiles but doesn’t produce an executable: -->
<p>Cargoは<code>cargo check</code>というコマンドも提供しています。このコマンドは、迅速にコードを確認し、
コンパイルできることを確かめますが、実行可能ファイルは生成しません:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<!-- Why would you not want an executable? Often, `cargo check` is much faster than -->
<!-- `cargo build`, because it skips the step of producing an executable. If you’re -->
<!-- continually checking your work while writing the code, using `cargo check` will -->
<!-- speed up the process! As such, many Rustaceans run `cargo check` periodically -->
<!-- as they write their program to make sure it compiles. Then they run `cargo -->
<!-- build` when they’re ready to use the executable. -->
<p>何故、実行可能ファイルが欲しくないのでしょうか？しばしば、<code>cargo check</code>は、<code>cargo build</code>よりも遥かに速くなります。
実行可能ファイルを生成する手順を飛ばすからです。コードを書いている際に継続的に自分の作業を確認するのなら、
<code>cargo check</code>を使用すると、その過程が高速化されます！そのため、多くのRustaceanは、
プログラムを書く際にコンパイルできるか確かめるために定期的に<code>cargo check</code>を実行します。
そして、実行可能ファイルを使用できる状態になったら、<code>cargo build</code>を走らせるのです。</p>
<!-- Let’s recap what we’ve learned so far about Cargo: -->
<p>ここまでにCargoについて学んだことをおさらいしましょう:</p>
<!-- * We can build a project using `cargo build` or `cargo check`. -->
<!-- * We can build and run a project in one step using `cargo run`. -->
<!-- * Instead of saving the result of the build in the same directory as our code, -->
<!--   Cargo stores it in the *target/debug* directory. -->
<ul>
<li><code>cargo build</code>か<code>cargo check</code>でプロジェクトをビルドできる。</li>
<li>プロジェクトのビルドと実行を1ステップで<code>cargo run</code>でできる。</li>
<li>ビルドの結果をコードと同じディレクトリに保存するのではなく、Cargoは<em>target/debug</em>ディレクトリに格納する。</li>
</ul>
<!-- An additional advantage of using Cargo is that the commands are the same no -->
<!-- matter which operating system you’re working on. So, at this point, we’ll no -->
<!-- longer provide specific instructions for Linux and macOS versus Windows. -->
<p>Cargoを使用する追加の利点は、使用しているOSに関わらず、同じコマンドが使用できることです。
故にこの時点で、WindowsとLinux及びmacOSで特定の手順を提供することは最早なくなります。</p>
<!-- ### Building for Release -->
<a class="header" href="print.html#aリリースビルドを行う" id="aリリースビルドを行う"><h3>リリースビルドを行う</h3></a>
<!-- When your project is finally ready for release, you can use `cargo build -->
<!-- --release` to compile it with optimizations. This command will create an -->
<!-- executable in *target/release* instead of *target/debug*. The optimizations -->
<!-- make your Rust code run faster, but turning them on lengthens the time it takes -->
<!-- for your program to compile. This is why there are two different profiles: one -->
<!-- for development, when you want to rebuild quickly and often, and another for -->
<!-- building the final program you’ll give to a user that won’t be rebuilt -->
<!-- repeatedly and that will run as fast as possible. If you’re benchmarking your -->
<!-- code’s running time, be sure to run `cargo build --release` and benchmark with -->
<!-- the executable in *target/release*. -->
<p>プロジェクトを最終的にリリースする準備ができたら、<code>cargo build --release</code>を使用して、
最適化を行なってコンパイルすることができます。このコマンドは、<em>target/debug</em>ではなく、
<em>target/release</em>に実行可能ファイルを作成します。最適化は、Rustコードの実行を速くしてくれますが、
オンにするとプログラムをコンパイルする時間が延びます。このため、2つの異なるプロファイルがあるのです:
頻繁に再ビルドをかけたい開発用と、繰り返し再ビルドすることはなく、できるだけ高速に動いてユーザにあげる最終的なプログラムをビルドする用のです。
コードの実行時間をベンチマークするなら、<code>cargo build --release</code>を確実に実行し、<em>target/release</em>の実行可能ファイルでベンチマークしてください。</p>
<!-- ### Cargo as Convention -->
<a class="header" href="print.html#a習慣としてのcargo" id="a習慣としてのcargo"><h3>習慣としてのCargo</h3></a>
<!-- With simple projects, Cargo doesn’t provide a lot of value over just using -->
<!-- `rustc`, but it will prove its worth as your programs become more intricate. -->
<!-- With complex projects composed of multiple crates, it’s much easier to let -->
<!-- Cargo coordinate the build. -->
<p>単純なプロジェクトでは、Cargoは単に<code>rustc</code>を使用する以上の価値を生みませんが、プログラムが複雑になるにつれて、
その価値を証明するでしょう。複数のクレートからなる複雑なプロジェクトでは、Cargoにビルドを調整してもらうのが遥かに簡単です。</p>
<!-- Even though the `hello_cargo` project is simple, it now uses much of the real -->
<!-- tooling you’ll use in the rest of your Rust career. In fact, to work on any -->
<!-- existing projects, you can use the following commands to check out the code -->
<!-- using Git, change to that project’s directory, and build: -->
<p><code>hello_cargo</code>プロジェクトは単純ではありますが、今では、Rustのキャリアを通じて使用するであろう本物のツールを多く使用するようになりました。
事実、既存のどんなプロジェクトに取り組むにも、以下のコマンドを使用して、Gitでコードをチェックアウトし、
そのプロジェクトのディレクトリに移動し、ビルドできます:</p>
<pre><code class="language-text">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<!-- For more information about Cargo, check out [its documentation]. -->
<p>Cargoについてより詳しく知るには、<a href="https://doc.rust-lang.org/cargo/">ドキュメンテーション</a>を確認してください。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ" id="aまとめ"><h2>まとめ</h2></a>
<!-- You’re already off to a great start on your Rust journey! In this chapter, -->
<!-- you’ve learned how to: -->
<p>既にRustの旅の素晴らしいスタートを切っています！この章では、以下の方法を学びました:</p>
<!-- * Install the latest stable version of Rust using `rustup` -->
<!-- * Update to a newer Rust version -->
<!-- * Open locally installed documentation -->
<!-- * Write and run a Hello, world! program using `rustc` directly -->
<!-- * Create and run a new project using the conventions of Cargo -->
<ul>
<li><code>rustup</code>で最新の安定版のRustをインストールする方法</li>
<li>新しいRustのバージョンに更新する方法</li>
<li>ローカルにインストールされたドキュメンテーションを開く方法</li>
<li>直接<code>rustc</code>を使用してHello, world!プログラムを書き、実行する方法</li>
<li>Cargoの慣習を使用して新しいプロジェクトを作成し、実行する方法</li>
</ul>
<!-- This is a great time to build a more substantial program to get used to reading -->
<!-- and writing Rust code. So, in Chapter 2, we’ll build a guessing game program. -->
<!-- If you would rather start by learning how common programming concepts work in -->
<!-- Rust, see Chapter 3 and then return to Chapter 2. -->
<p>より中身のあるプログラムをビルドし、Rustコードの読み書きに慣れるいいタイミングです。故に、第2章では、
数当てゲームを構築します。むしろ一般的なプログラミングの概念がRustでどう動くのか学ぶことから始めたいのであれば、
第3章を見て、それから第2章に戻ってください。</p>
<!-- # Programming a Guessing Game -->
<a class="header" href="print.html#a数当てゲームをプログラムする" id="a数当てゲームをプログラムする"><h1>数当てゲームをプログラムする</h1></a>
<!-- Let’s jump into Rust by working through a hands-on project together! This -->
<!-- chapter introduces you to a few common Rust concepts by showing you how to use -->
<!-- them in a real program. You’ll learn about `let`, `match`, methods, associated -->
<!-- functions, external crates, and more! The following chapters will explore these -->
<!-- ideas in more detail. In this chapter, you’ll practice the fundamentals. -->
<p>実物のプロジェクトに一緒に取り組むことで、Rustの世界へ飛び込みましょう！
この章では、実際のプログラム内で使用しながらいくつかの一般的なRustの概念に触れます。
let文、match式、メソッド、関連関数、外部クレートの使用などについて学ぶでしょう！
後ほどの章でこれらの概念について深く知ることになります。この章では、基礎部分だけにしましょう。</p>
<!-- We’ll implement a classic beginner programming problem: a guessing game. Here’s -->
<!-- how it works: the program will generate a random integer between 1 and 100. It -->
<!-- will then prompt the player to enter a guess. After a guess is entered, the -->
<!-- program will indicate whether the guess is too low or too high. If the guess is -->
<!-- correct, the game will print a congratulatory message and exit. -->
<p>古典的な初心者向けのプログラミング問題を実装してみましょう: 数当てゲームです。
これは以下のように動作します: プログラムは1から100までの乱数整数を生成します。
そしてプレーヤーに予想を入力するよう促します。予想を入力したら、プログラムは、
その予想が少なすぎたか多すぎたかを出力します。予想が当たっていれば、ゲームは祝福メッセージを表示し、
終了します。</p>
<!-- ## Setting Up a New Project -->
<a class="header" href="print.html#a新規プロジェクトの立ち上げ" id="a新規プロジェクトの立ち上げ"><h2>新規プロジェクトの立ち上げ</h2></a>
<!-- To set up a new project, go to the *projects* directory that you created in -->
<!-- Chapter 1 and make a new project using Cargo, like so: -->
<p>新規プロジェクトを立ち上げるには、第1章で作成した<em>projects</em>ディレクトリに行き、
Cargoを使って以下のように新規プロジェクトを作成します。</p>
<pre><code class="language-text">$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<!-- The first command, `cargo new`, takes the name of the project (`guessing_game`) -->
<!-- as the first argument. The `--bin` flag tells Cargo to make a binary project, -->
<!-- like to the one in Chapter 1. The second command changes to the new -->
<!-- project’s directory. -->
<p>最初のコマンド<code>cargo new</code>は、プロジェクト名を第1引数に取ります(<code>guessing_game</code>ですね)。
<code>--bin</code>というフラグは、Cargoにバイナリ生成プロジェクトを作成させます。第1章のものと似ていますね。
2番目のコマンドで新規プロジェクトのディレクトリに移動します。</p>
<!-- Look at the generated *Cargo.toml* file: -->
<p>生成された<em>Cargo.toml</em>ファイルを見てください:</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;名前 &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<!-- If the author information that Cargo obtained from your environment is not -->
<!-- correct, fix that in the file and save it again. -->
<p>もし、Cargoがあなたの環境から取得した作者情報が間違っていたら、
ファイルを編集して保存し直してください。</p>
<!-- As you saw in Chapter 1, `cargo new` generates a “Hello, world!” program for -->
<!-- you. Check out the *src/main.rs* file: -->
<p>第1章でも見かけたように、<code>cargo new</code>コマンドは、&quot;Hello, world!&quot;プログラムを生成してくれます。
<em>src/main.rs</em>ファイルをチェックしてみましょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!-- Now let’s compile this “Hello, world!” program and run it in the same step -->
<!-- using the `cargo run` command: -->
<p>さて、この&quot;Hello, world!&quot;プログラムをコンパイルし、<code>cargo run</code>コマンドを使用して、
以前と同じように動かしてみましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<!-- The `run` command comes in handy when you need to rapidly iterate on a project, -->
<!-- as we'll do in this game, quickly testing each iteration before moving on to -->
<!-- the next one. -->
<p><code>run</code>コマンドは、プロジェクトに迅速に段階を踏んで取り掛かる必要がある場合に有用であり、
次のステップに進む前に各段階を急速にテストして、このゲームではそれを行います。</p>
<!-- Reopen the *src/main.rs* file. You’ll be writing all the code in this file. -->
<p>再度<em>src/main.rs</em>ファイルを開きましょう。ここにすべてのコードを書いていきます。</p>
<!-- ## Processing a Guess -->
<a class="header" href="print.html#a予想を処理する" id="a予想を処理する"><h2>予想を処理する</h2></a>
<!-- The first part of the guessing game program will ask for user input, process -->
<!-- that input, and check that the input is in the expected form. To start, we’ll -->
<!-- allow the player to input a guess. Enter the code in Listing 2-1 into -->
<!-- *src/main.rs* -->
<p>数当てプログラムの最初の部分は、ユーザに入力を求め、その入力を処理し、予期した形式になっていることを確認します。
手始めにプレーヤーが予想を入力できるようにしましょう。
リスト2-1のコードを<em>src/main.rs</em>に入力してください。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);          // 数を当ててごらん

    println!(&quot;Please input your guess.&quot;);   // ほら、予想を入力してね

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);     // 行の読み込みに失敗しました

    println!(&quot;You guessed: {}&quot;, guess);     // 次のように予想しました: {}
}
</code></pre>
<!-- <span class="caption">Listing 2-1: Code that gets a guess from the user and prints -->
<!-- it</span> -->
<p><span class="caption">リスト2-1: ユーザに予想を入力してもらい、それを出力するコード</span></p>
<blockquote>
<p>注釈: The programming language Rust第1版の翻訳者によると、
ソースコードのコメント中以外に日本語文字があるとコンパイルに失敗することがあるそうなので、文字列の英語は、コメントに和訳を載せます。
また、重複する内容の場合には、最初の1回だけ掲載するようにします。</p>
</blockquote>
<!-- This code contains a lot of information, so let’s go over it line by line. To -->
<!-- obtain user input and then print the result as output, we need to bring the -->
<!-- `io` (input/output) library into scope. The `io` library comes from the -->
<!-- standard library (which is known as `std`): -->
<p>このコードには、たくさんの情報が詰め込まれてますね。なので、行ごとに見ていきましょう。
ユーザ入力を受け付け、結果を出力するためには、<code>io</code>(入/出力)ライブラリをスコープに導入する必要があります。
<code>io</code>ライブラリは、標準ライブラリ(<code>std</code>として知られています)に存在します:</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<!-- By default, Rust brings only a few types into the scope of every program in -->
<!-- [the *prelude*][prelude]. If a type you want to use isn’t in the -->
<!-- prelude, you have to bring that type into scope explicitly with a `use` -->
<!-- statement. Using the `std::io` library provides you with a number of useful -->
<!-- features, including the ability to accept user input. -->
<p>デフォルトでは、<a href="../../std/prelude/index.html"><em>prelude</em></a><!-- ignored -->に存在するいくつかの型のみ使えます。
もし、使用したい型がpreludeにない場合は、<code>use</code>文で明示的にその型をスコープに導入する必要があります。
<code>std::io</code>ライブラリを使用することで、ユーザ入力を受け付ける能力などの実用的な機能の多くを使用することができます。</p>
<!-- As you saw in Chapter 1, the `main` function is the entry point into the -->
<!-- program: -->
<p>第1章で見た通り、<code>main</code>関数がプログラムへのエントリーポイント(スタート地点)になります:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<!-- The `fn` syntax declares a new function, the parentheses, `()`,  indicate there -->
<!-- are no parameters, and the curly bracket, `{`, starts the body of the function. -->
<p><code>fn</code>構文が関数を新しく宣言し、かっこの<code>()</code>は引数がないことを示し、波括弧の<code>{</code>が関数本体のスタート地点になります。</p>
<!-- As you also learned in Chapter 1, `println!` is a macro that prints a string to -->
<!-- the screen: -->
<p>また、第1章で学んだように、<code>println!</code>は、文字列を画面に表示するマクロになります:</p>
<pre><code class="language-rust ignore">println!(&quot;Guess the number!&quot;);

println!(&quot;Please input your guess.&quot;);
</code></pre>
<!-- This code is printing a prompt stating what the game is and requesting -->
<!-- input from the user. -->
<p>このコードは、このゲームが何かを出力し、ユーザに入力を求めています。</p>
<!-- ### Storing Values with Variables -->
<a class="header" href="print.html#a値を変数に保持する" id="a値を変数に保持する"><h3>値を変数に保持する</h3></a>
<!-- Next, we’ll create a place to store the user input, like this: -->
<p>次に、ユーザ入力を保持する場所を作りましょう。こんな感じに:</p>
<pre><code class="language-rust ignore">let mut guess = String::new();
</code></pre>
<!-- Now the program is getting interesting! There’s a lot going on in this little -->
<!-- line. Notice that this is a `let` statement, which is used to create a -->
<!-- *variable*. Here’s another example: -->
<p>さあ、プログラムが面白くなってきましたね。このたった1行でいろんなことが起きています。
これが<code>let</code>文であることに注目してください。これを使用して<em>変数</em>を生成しています。
こちらは、別の例です:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<!-- This line will create a new variable named `foo` and binds it to the value `bar`. -->
<!-- In Rust, variables are immutable by default. We'll discuss this concept in -->
<!-- detail in the "Variables and Mutability" section in Chapter 3. The following -->
<!-- example shows how to use `mut` before the variable name to make a variable -->
<!-- mutable: -->
<p>この行では、<code>foo</code>という名前の新しい変数を作成し、<code>bar</code>の値に束縛しています。
Rustでは、変数は標準で不変(immutable)です。この概念について詳しくは、
第3章の「変数と可変性」節で議論します。以下の例には、
変数名の前に<code>mut</code>修飾子をつけて変数を可変にする方法が示されています:</p>
<pre><code class="language-rust ignore">let foo = 5; // immutable
let mut bar = 5; // mutable
</code></pre>
<!-- コメント中にコメント終了記号があると、パースに失敗するので、省いています。 -->
<!--  Note: The `//` syntax starts a comment that continues until the end of the -->
<!--  line. Rust ignores everything in comments, which are discussed in more detail -->
<!--  in Chapter 3 -->
<blockquote>
<p>注釈: <code>//</code>という記法は、行末まで続くコメントを記述します。
コンパイラは、コメントを一切無視し、これについても第3章で詳しく議論します。</p>
</blockquote>
<!-- Let’s return to the guessing game program. You now know that `let mut guess` -->
<!-- will introduce a mutable variable named `guess`. On the other side of the equal -->
<!-- sign (`=`) is the value that `guess` is bound to, which is the result of -->
<!-- calling `String::new`, a function that returns a new instance of a `String`. -->
<!-- [`String`][string] is a string type provided by the standard -->
<!-- library that is a growable, UTF-8 encoded bit of text. -->
<p>さあ、<code>let mut guess</code>が<code>guess</code>という名前の可変変数を導入するとわかりましたね。
イコール記号(<code>=</code>)の逆側には、変数<code>guess</code>が束縛される値があります。この値は、
<code>String::new</code>関数の呼び出し結果であり、この関数は、<code>String</code>型のオブジェクトを返します。
<a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore -->型は、標準ライブラリによって提供される文字列型で、
サイズ可変、UTF-8エンコードされたテキスト破片になります。</p>
<!-- The `::` syntax in the `::new` line indicates that `new` is an *associated -->
<!-- function* of the `String` type. An associated function is implemented on a type, -->
<!-- in this case `String`, rather than on a particular instance of a `String`. Some -->
<!-- languages call this a *static method*. -->
<p><code>::new</code>行にある<code>::</code>という記法は、<code>new</code>が<code>String</code>型の<em>関連関数</em>であることを表しています。
関連関数とは、<code>String</code>型の特定のオブジェクトよりも型(この場合は<code>String</code>)に対して
実装された関数のことであり、<em>静的メソッド</em>と呼ばれる言語もあります。</p>
<!-- This `new` function creates a new, empty string. You’ll find a `new` function -->
<!-- on many types, because it’s a common name for a function that makes a new value -->
<!-- of some kind. -->
<p>この<code>new</code>関数は、新しく空の文字列を生成します。<code>new</code>関数は、いろんな型に見られます。
なぜなら、何らかの新規値を生成する関数にとってありふれた名前だからです。</p>
<!-- To summarize, the `let mut guess = String::new();` line has created a mutable -->
<!-- variable that is currently bound to a new, empty instance of a `String`. Whew! -->
<p>まとめると、<code>let mut guess = String::new();</code>という行は、現在、新たに空の<code>String</code>オブジェクトに束縛されている
可変変数を作っているわけです。ふう！</p>
<!-- Recall that we included the input/output functionality from the standard -->
<!-- library with `use std::io;` on the first line of the program. Now we’ll call an -->
<!-- associated function, `stdin`, on `io`: -->
<p>プログラムの1行目で、<code>use std::io</code>として、標準ライブラリから入/出力機能を取り込んだことを思い出してください。
今度は、<code>io</code>型の<code>stdin</code>関連関数を呼び出しましょう:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);
</code></pre>
<!-- If we hadn't the `use std::io` line at the beginning of the program, we -->
<!-- could have written this function call as `std::io::stdin`. The `stdin` function -->
<!-- returns an instance of [`std::io::Stdin`][iostdin], which is a -->
<!-- type that represents a handle to the standard input for your terminal. -->
<p>仮に、プログラムの冒頭で<code>use std::io</code>としていなければ、この関数呼び出しは、<code>std::io::stdin</code>と記述していたでしょう。
この<code>stdin</code>関数は、 <a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->オブジェクトを返し、この型は、
ターミナルの標準入力へのハンドルを表す型になります。</p>
<!-- The next part of the code, `.read_line(&mut guess)`, calls the -->
<!-- [`read_line`][read_line] method on the standard input handle to -->
<!-- get input from the user. We’re also passing one argument to `read_line`: `&mut -->
<!-- guess`. -->
<p>その次のコード破片、<code>.read_line(&amp;mut guess)</code>は、標準入力ハンドルの<a href="../../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore -->
メソッドを呼び出して、ユーザから入力を受け付けます。また、<code>read_line</code>メソッドに対して、<code>&amp;mut guess</code>という引数を一つ渡していますね.</p>
<!-- The job of `read_line` is to take whatever the user types into standard input -->
<!-- and place that into a string, so it takes that string as an argument. The -->
<!-- string argument needs to be mutable so the method can change the string’s -->
<!-- content by adding the user input. -->
<p><code>read_line</code>メソッドの仕事は、ユーザが標準入力したものすべてを取り出し、文字列に格納することなので、
格納する文字列を引数として取ります。この文字列引数は、可変である必要があります。
メソッドがユーザ入力を追記して、文字列の中身を変えられるようにってことですね。</p>
<!-- The `&` indicates that this argument is a *reference*, which gives you a way to -->
<!-- let multiple parts of your code access one piece of data without needing to -->
<!-- copy that data into memory multiple times. References are a complex feature, -->
<!-- and one of Rust’s major advantages is how safe and easy it is to use -->
<!-- references. You don’t need to know a lot of those details to finish this -->
<!-- program. For now, all you need to know is that like variables, references are -->
<!-- immutable by default. Hence, you need to write `&mut guess` rather than -->
<!-- `&guess` to make it mutable. (Chapter 4 will explain references more -->
<!-- thoroughly.) -->
<p><code>&amp;</code>という記号は、この引数が<em>参照</em>であることを表し、これのおかげで、データを複数回メモリにコピーせずとも、
コードの複数箇所で同じデータにアクセスできるようになるわけです。参照は複雑な機能であり、
とても安全かつ簡単に参照を使うことができることは、Rustの主要な利点の一つでもあります。
そのような詳細を知らなくても、このプログラムを完成させることはできます:
現時点では、変数のように、参照も標準で不変であることを知っておけばいいでしょう。
故に、<code>&amp;guess</code>と書くのではなく、<code>&amp;mut guess</code>と書いて、可変にする必要があるのです。
(第4章で参照について詳しく説明します)</p>
<!-- ### Handling Potential Failure with the `Result` Type -->
<a class="header" href="print.html#result型で失敗の可能性を扱う" id="result型で失敗の可能性を扱う"><h3><code>Result</code>型で失敗の可能性を扱う</h3></a>
<!-- We’re not quite done with this line of code. Although what we've discussed so -->
<!-- far is a single line of text, it’s only the first part of the single logical -->
<!-- line of code. The second part is this method: -->
<p>まだ、この行は終わりではありませんよ。ここまでに議論したのはテキストでは1行ですが、コードとしての論理行としては、
まだ所詮最初の部分でしかないのです。2番目の部分はこのメソッドです:</p>
<pre><code class="language-rust ignore">.expect(&quot;Failed to read line&quot;);
</code></pre>
<!-- When you call a method with the `.foo()` syntax, it’s often wise to introduce a -->
<!-- newline and other whitespace to help break up long lines. We could have -->
<!-- written this code as: -->
<p><code>.foo()</code>という記法で、メソッドを呼び出す時、改行と空白で長い行を分割するのがしばしば賢明です。
今回の場合、こう書くこともできますよね:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<!-- However, one long line is difficult to read, so it’s best to divide it: two -->
<!-- lines for two method calls. Now let’s discuss what this line does. -->
<p>しかし、長い行は読みづらいものです。なので、分割しましょう: 2回のメソッド呼び出しに、2行です。
さて、この行が何をしているのかについて議論しましょうか。</p>
<!-- As mentioned earlier, `read_line` puts what the user types into the string -->
<!-- we're passing it, but it also returns a value—in this case, an -->
<!-- [`io::Result`][ioresult]. Rust has a number of types named -->
<!-- `Result` in its standard library: a generic [`Result`][result] as -->
<!-- well as specific versions for submodules, such as `io::Result`. -->
<p>以前にも述べたように、<code>read_line</code>メソッドは、渡された文字列にユーザが入力したものを入れ込むだけでなく、
値も返します(今回は<a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->です)。 Rustには<code>Result</code>と名のついた型が
標準ライブラリにたくさんあります: 汎用の<a href="../../std/result/enum.Result.html"><code>Result</code></a><!-- ignore -->の他、
<code>io::Result</code>などのサブモジュール用に特化したものまで。</p>
<!-- The `Result` types are [*enumerations*][enums], often referred -->
<!-- to as *enums*. An enumeration is a type that can have a fixed set of values, -->
<!-- and those values are called the enum’s *variants*. Chapter 6 will cover enums -->
<!-- in more detail. -->
<p>この<code>Result</code>型は、<a href="ch06-00-enums.html"><em>列挙型</em></a><!-- ignore -->であり、普通、<em>enum</em>(イーナム)と呼ばれます。
列挙型とは、固定された種類の値を持つ型のことであり、それらの値は、enumの<em>バリアント</em>(variant)と呼ばれます。
enumについては、第6章で詳しく解説します。</p>
<!-- For `Result`, the variants are `Ok` or `Err`. The `Ok` variant indicates the -->
<!-- the operation was successful, and inside `Ok` is the successfully generated value. -->
<!-- The `Err` variant means the operation failed, and `Err` contains information -->
<!-- about how and why the operation failed. -->
<p><code>Result</code>型に関しては、取りうる型の値(バリアント)は<code>Ok</code>か<code>Err</code>です。<code>Ok</code>列挙子は、処理が成功したことを表し、
中に生成された値を保持します。<code>Err</code>列挙子は、処理が失敗したことを意味し、<code>Err</code>は、処理が失敗した過程や、
理由などの情報を保有します。</p>
<!-- The purpose of these `Result` types is to encode error handling information. -->
<!-- Values of the `Result` type, like values of any type, have methods defined on them. An -->
<!-- instance of `io::Result` has an [`expect` method][expect] that -->
<!-- you can call. If this instance of `io::Result` is an `Err` value, `expect` will -->
<!-- cause the program to crash and display the message that you passed as an -->
<!-- argument to `expect`. If the `read_line` method returns an `Err`, it would -->
<!-- likely be the result of an error coming from the underlying operating system. -->
<!-- If this instance of `io::Result` is an `Ok` value, `expect` will take the -->
<!-- return value that `Ok` is holding and return just that value to you so you -->
<!-- could use it. In this case, that value is the number of bytes in what the user -->
<!-- entered into standard input. -->
<p>これら<code>Result</code>型の目的は、エラー処理の情報をコード化することです。<code>Result</code>型の値も、他の型同様、
メソッドが定義されています。<code>io::Result</code>オブジェクトには、呼び出し可能な<a href="../../std/result/enum.Result.html#method.expect"><code>expect</code>メソッド</a><!-- ignore -->があります。
この<code>io::Result</code>オブジェクトが<code>Err</code>値の場合、<code>expect</code>メソッドはプログラムをクラッシュさせ、
引数として渡されたメッセージを表示します。<code>read_line</code>メソッドが<code>Err</code>を返したら、
恐らく根底にあるOSによるエラーに起因するのでしょう。
この<code>io::Result</code>オブジェクトが<code>Ok</code>値の場合、<code>expect</code>メソッドは、<code>Ok</code>バリアントが保持する
返り値を取り出して、ただその値を返すので、これを使用することができるでしょう。
今回の場合、その返り値とは、ユーザが標準入力に入力したデータのバイト数になります。</p>
<!-- If you don’t call `expect`, the program will compile, but we’ll get a warning: -->
<p>もし、<code>expect</code>メソッドを呼び出さなかったら、コンパイルは通るものの、警告が出るでしょう:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
(警告: 使用されなければならない結果が使用されていません)
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<!-- Rust warns that we haven’t used the `Result` value returned from `read_line`, -->
<!-- indicating that the program hasn’t handled a possible error. -->
<p>コンパイラは、私たちが<code>read_line</code>メソッドから返ってきた<code>Result</code>値を使用していないと警告してきており、
これは、プログラムがエラーの可能性に対処していないことを示します。</p>
<!-- The right way to suppress the warning is to actually write error handling, but -->
<!-- because you just want to crash this program when a problem occurs, you can use -->
<!-- `expect`. You'll learn about recovering from errors in Chapter 9. -->
<p>警告を抑制する正しい手段は、実際にエラー対処コードを書くことですが、今は、
問題が起きた時にプロラグムをクラッシュさせたいので、<code>expect</code>を使用できるわけです。
エラーから復旧する方法については、第9章で学ぶでしょう。</p>
<!-- ### Printing Values with `println!` Placeholders -->
<a class="header" href="print.html#printlnマクロのプレースホルダーで値を出力する" id="printlnマクロのプレースホルダーで値を出力する"><h3><code>println!</code>マクロのプレースホルダーで値を出力する</h3></a>
<!-- Aside from the closing curly brackets, there’s only one more line to discuss in -->
<!-- the code added so far, which is the following: -->
<p>閉じ波かっこを除けば、ここまでに追加されたコードのうち議論すべきものは、残り1行であり、それは以下の通りです:</p>
<pre><code class="language-rust ignore">println!(&quot;You guessed: {}&quot;, guess);
</code></pre>
<!-- 2行目、crab princerがわからない。pincerがハサミらしいので、typo？ -->
<!-- This line prints the string we saved the user’s input in. The set of curly  -->
<!-- brackets, `{}`, is a placeholder: think of `{}` as little crab princers that -->
<!-- hold a value in place. You can print more than one value using curly brackets: -->
<!-- the first set of curly brackets holds the first value listed after the format -->
<!-- string, the second set holds the second value, and so on. Printing multiple -->
<!-- values in one call to `println!` would look like this: -->
<p>この行は、ユーザ入力を保存した文字列の中身を出力します。1組の波括弧の<code>{}</code>は、プレースホルダーの役目を果たします:
<code>{}</code>は値を所定の場所に保持する小さなカニのはさみと考えてください。波括弧を使って一つ以上の値を出力できます:
最初の波括弧の組は、フォーマット文字列の後に列挙された最初の値に対応し、
2組目は、2つ目の値、とそんな感じで続いていきます。1回の<code>println!</code>の呼び出しで複数値を出力するコードは、
以下のような感じになります:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
#}</code></pre></pre>
<!-- This code would print `x = 5 and y = 10`. -->
<p>このコードは、<code>x = 5 and y = 10</code>と出力するでしょう.</p>
<!-- ### Testing the First Part -->
<a class="header" href="print.html#a最初の部分をテストする" id="a最初の部分をテストする"><h3>最初の部分をテストする</h3></a>
<!-- Let’s test the first part of the guessing game. Run it using `cargo run`: -->
<p>数当てゲームの最初の部分をテストしてみましょう。<code>cargo run</code>でプログラムを走らせてください:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!           (数を当ててごらん)
Please input your guess.    (ほら、予想を入力して)
6
You guessed(次のように予想したよ): 6
</code></pre>
<!-- At this point, the first part of the game is done: we’re getting input from the -->
<!-- keyboard and then printing it. -->
<p>ここまでで、ゲームの最初の部分は完成になります: キーボードからの入力を受け付け、出力できるようになりました。</p>
<!-- ## Generating a Secret Number -->
<a class="header" href="print.html#a秘密の数字を生成する" id="a秘密の数字を生成する"><h2>秘密の数字を生成する</h2></a>
<!-- Next, we need to generate a secret number that the user will try to guess. The -->
<!-- secret number should be different every time so the game is fun to play more -->
<!-- than once. Let’s use a random number between 1 and 100 so the game isn’t too -->
<!-- difficult. Rust doesn’t yet include random number functionality in its standard -->
<!-- library. However, the Rust team does provide a [`rand` crate][randcrate]. -->
<p>次に、ユーザが数当てに挑戦する秘密の数字を生成する必要があります。毎回この秘密の数字は、変わるべきです。
ゲームが何回も楽しめるようにですね。ゲームが難しくなりすぎないように、1から100までの乱数を使用しましょう。
Rustの標準ライブラリには、乱数機能はまだ含まれていません。ですが、実は、Rustの開発チームが<a href="https://crates.io/crates/rand"><code>rand</code>クレート</a>を
用意してくれています。</p>
<!-- ### Using a Crate to Get More Functionality -->
<a class="header" href="print.html#aクレートを使用して機能を追加する" id="aクレートを使用して機能を追加する"><h3>クレートを使用して機能を追加する</h3></a>
<!-- Remember that a crate is a package of Rust code. The project we’ve been -->
<!-- building is a *binary crate*, which is an executable. The `rand` crate is a -->
<!-- *library crate*, which contains code intended to be used in other programs. -->
<p>クレートはRustコードのパッケージであることを思い出してください。私たちがここまで作ってきたプロジェクトは、
<em>バイナリークレート</em>であり、これは実行可能形式になります。<code>rand</code>クレートは<em>ライブラリクレート</em>であり、
他のプログラムで使用するためのコードが含まれています。</p>
<!-- Cargo’s use of external crates is where it really shines. Before we can write -->
<!-- code that uses `rand`, we need to modify the *Cargo.toml* file to include the -->
<!-- `rand` crate as a dependency. Open that file now and add the following line to -->
<!-- the bottom beneath the `[dependencies]` section header that Cargo created for -->
<!-- you: -->
<p>外部クレートを使用する部分は、Cargoがとても輝くところです。<code>rand</code>を使ったコードを書ける前に、
<em>Cargo.toml</em>ファイルを編集して、<code>rand</code>クレートを依存ファイルとして取り込む必要があります。
今このファイルを開いて、以下の行をCargoが自動生成した<code>[dependencies]</code>セクションヘッダーの一番下に追記しましょう:</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<!-- In the *Cargo.toml* file, everything that follows a header is part of a section -->
<!-- that continues until another section starts. The `[dependencies]` section is -->
<!-- where you tell Cargo which external crates your project depends on and which -->
<!-- versions of those crates you require. In this case, we’ll specify the `rand` -->
<!-- crate with the semantic version specifier `0.3.14`. Cargo understands [Semantic -->
<!-- Versioning][semver] (sometimes called *SemVer*), which is a -->
<!-- standard for writing version numbers. The number `0.3.14` is actually shorthand -->
<!-- for `^0.3.14`, which means “any version that has a public API compatible with -->
<!-- version 0.3.14.” -->
<p><em>Cargo.toml</em>ファイルにおいて、ヘッダーに続くものは全て、他のセクションが始まるまで続くセクションの一部になります。
<code>[dependecies]</code>セクションは、プロジェクトが依存する外部クレートと必要とするバージョンを記述するところです。
今は、<code>rand</code>クレートで、セマンティックバージョンには<code>0.3.14</code>を指定します。Cargoはバージョンナンバー記述の
標準規格である<a href="http://semver.org">セマンティックバージョニング</a><!-- ignore --> (時に<em>SemVer</em>と呼ばれる)を理解します。
<code>0.3.14</code>という数字は、実際には<code>^0.3.14</code>の省略記法で、これは、「バージョン0.3.14と互換性のある公開APIを持つ
任意のバージョン」を意味します。</p>
<!-- Now, without changing any of the code, let’s build the project, as shown in -->
<!-- Listing 2-2. -->
<p>さて、コードは一切変えずに、リスト2-2のようにプロジェクトをビルドしましょう。</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index` (レジストリを更新しています)
 Downloading rand v0.3.14                                            (rand v0.3.14をダウンロードしています)
 Downloading libc v0.2.14                                            (libc v0.2.14をダウンロードしています)
   Compiling libc v0.2.14                                            (libc v0.2.14をコンパイルしています)
   Compiling rand v0.3.14                                            (rand v0.3.14をコンパイルしています)
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)   (guessing_game v0.1.0をコンパイルしています)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs    
</code></pre>
<!-- <span class="caption">Listing 2-2: The output from running `cargo build` after -->
<!-- adding the rand crate as a dependency</span> -->
<p><span class="caption">リスト2-2: randクレートを依存として追加した後の<code>cargo build</code>コマンドの出力</span></p>
<!-- You may see different version numbers (but they will all be compatible with -->
<!-- the code, thanks to SemVer!), and the lines may be in a different order. -->
<p>もしかしたら、バージョンナンバーは違うかもしれません(でも、互換性はあります、SemVerのおかげでね！)。
そして、行の出力順序も違うかもしれません。</p>
<!-- Now that we have an external dependency, Cargo fetches the latest versions of -->
<!-- everything from the *registry*, which is a copy of data from -->
<!-- [Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem post -->
<!-- their open source Rust projects for others to use. -->
<p>今や、外部依存を持つようになったので、Cargoは<em>レジストリ</em>(registry、登録所)から最新バージョンを拾ってきます。
<em>レジストリ</em>とは、<a href="https://crates.io">Crates.io</a>のデータのコピーです. Crates.ioとは、Rustのエコシステムにいる人間が、
他の人も使えるように自分のオープンソースのRustプロジェクトを投稿する場所です。</p>
<!-- After updating the registry, Cargo checks the `[dependencies]` section and -->
<!-- downloads any crates you don’t have yet. In this case, although we only listed -->
<!-- `rand` as a dependency, Cargo also grabbed a copy of `libc`, because `rand` -->
<!-- depends on `libc` to work. After downloading the crates, Rust compiles them and -->
<!-- then compiles the project with the dependencies available. -->
<p>レジストリの更新後、Cargoは<code>[dependencies]</code>セクションをチェックし、まだ取得していないクレートを全部ダウンロードします。
今回の場合、<code>rand</code>しか依存ファイルには列挙していませんが、Cargoは<code>libc</code>のコピーも拾ってきます。
<code>rand</code>クレートが<code>libc</code>に依存しているからですね。クレートのダウンロード完了後、コンパイラは依存ファイル、
そして、依存が利用可能な状態でプロジェクトをコンパイルします。</p>
<!-- If you immediately run `cargo build` again without making any changes, you -->
<!-- won't get any output aside from the `Finished` line. Cargo knows it has already -->
<!-- downloaded and compiled the dependencies, and you haven't changed anything -->
<!-- about them in your *Cargo.toml* file. Cargo also knows that you haven't changed -->
<!-- anything about your code, so it doesn't recompile that either. With nothing to -->
<!-- do, it simply exits -->
<p>何も変更せず即座に<code>cargo build</code>コマンドを走らせたら、<code>Finished</code>行を除いて何も出力されないでしょう。
Cargoは、すでに全ての依存をダウンロードしてコンパイル済みであることも、
あなたが<em>Cargo.toml</em>ファイルを弄ってないことも知っているからです。さらに、Cargoはプログラマがコードを変更していないことも検知するので、
再度コンパイルすることもありません。することがないので、ただ単に終了します。</p>
<!-- If you open up the *src/main.rs* file, make a trivial change, and then save it -->
<!-- and build again, you’ll only see two line of output: -->
<p><em>src/main.rs</em>ファイルを開き、些細な変更をし、保存して再度ビルドを行えば、2行だけ出力があるでしょう:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<!-- These lines show Cargo only updates the build with your tiny change to the -->
<!-- *src/main.rs* file. Your dependencies haven't changed, so Cargo knows it can -->
<!-- reuse what it has already downloaded and compiled for those. It just rebuilds -->
<!-- your part of the code. -->
<p>この行は、Cargoが<em>src/main.rs</em>ファイルへの取るに足らない変更に対してビルドを更新していることを示しています。
依存は変更していないので、Cargoは、すでにダウンロードしてコンパイルまで済ませてある依存を使用できると検知します。
自分で書いたコードのみ再ビルドをかけるわけです。</p>
<!-- #### The *Cargo.lock* File Ensures Reproducible Builds -->
<a class="header" href="print.html#cargolockファイルで再現可能なビルドを保証する" id="cargolockファイルで再現可能なビルドを保証する"><h4><em>Cargo.lock</em>ファイルで再現可能なビルドを保証する</h4></a>
<!-- Cargo has a mechanism that ensures you can rebuild the same artifact every time -->
<!-- you or anyone else builds your code: Cargo will use only the versions of the -->
<!-- dependencies you specified until you indicate otherwise. For example, what -->
<!-- happens if next week version 0.3.15 of the `rand` crate comes out and contains -->
<!-- an important bug fix but also contains a regression that will break your code? -->
<p>Cargoは、プログラマが自分のコードを更新するたびに同じ生成物を再構成することを保証してくれるメカニズムを
備えています: Cargoは、プログラマが明示するまで、指定したバージョンの依存のみを使用します。
例として、<code>rand</code>クレートの次週のバージョン0.3.15が登場し、重要なバグ修正がなされているけれども、
自分のコードを破壊してしまう互換性破壊があった場合はどうなるでしょう？</p>
<!-- The answer to this problem is the *Cargo.lock* file, which was created the -->
<!-- first time you ran `cargo build` and is now in your *guessing_game* directory. -->
<!-- When you build a project for the first time, Cargo figures out all the -->
<!-- versions of the dependencies that fit the criteria and then writes them to -->
<!-- the *Cargo.lock* file. When you build your project in the future, Cargo will -->
<!-- see that the *Cargo.lock* file exists and use the versions specified there -->
<!-- rather than doing all the work of figuring out versions again. This lets you -->
<!-- have a reproducible build automatically. In other words, your project will -->
<!-- remain at `0.3.14` until you explicitly upgrade, thanks to the *Cargo.lock* -->
<!-- file. -->
<p>この問題に対する回答は、<em>Cargo.lock</em>ファイルであり、このファイルは、初めて<code>cargo build</code>コマンドを
走らせた時に生成され、<em>guessing_game</em>ディレクトリに存在しています。プロジェクトを初めてビルドする際に、
Cargoは判断基準(criteria)に合致するよう全ての依存のバージョンを計算し、<em>Cargo.lock</em>ファイルに記述します。
次にプロジェクトをビルドする際には、Cargoは<em>Cargo.lock</em>ファイルが存在することを確かめ、
再度バージョンの計算の作業を行うのではなく、そこに指定されているバージョンを使用します。
このことにより、自動的に再現可能なビルドを構成できるのです。つまり、明示的にアップグレードしない限り、
プロジェクトが使用するバージョンは<code>0.3.14</code>に保たれるのです。<em>Cargo.lock</em>ファイルのおかげでね。</p>
<!-- #### Ensuring Reproducible Builds with the *Cargo.lock* File -->
<a class="header" href="print.html#cargolockファイルで再現可能なビルドを保証する-1" id="cargolockファイルで再現可能なビルドを保証する-1"><h4><em>Cargo.lock</em>ファイルで再現可能なビルドを保証する</h4></a>
<!-- When you *do* want to update a crate, Cargo provides another command, `update`, -->
<!-- which will ignore the *Cargo.lock* file and figure out all the latest versions -->
<!-- that fit your specifications in *Cargo.toml*. If that works, Cargo will write -->
<!-- those versions to the *Cargo.lock* file-->
<p>クレートを<em>本当に</em>アップグレードする必要が出てきたら、Cargoの別のコマンド(<code>update</code>)を使用しましょう。
これは、<em>Cargo.lock</em>ファイルを無視して<em>Cargo.toml</em>ファイル内の全ての指定に合致する最新バージョンを計算します。
それがうまくいったら、Cargoはそれらのバージョンを<em>Cargo.lock</em>ファイルに記述します。</p>
<!-- But by default, Cargo will only look for versions larger than `0.3.0` and -->
<!-- smaller than `0.4.0`. If the `rand` crate has released two new versions, -->
<!-- `0.3.15` and `0.4.0`, you would see the following if you ran `cargo update`: -->
<p>しかし標準でCargoは、<code>0.3.0</code>以上、<code>0.4.0</code>未満のバージョンのみを検索します。<code>rand</code>クレートの新バージョンが
2つリリースされていたら(<code>0.3.15</code>と<code>0.4.0</code>だとします)、<code>cargo update</code>コマンドを走らせた時に以下のような
メッセージを目の当たりにするでしょう:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    (レジストリ`https://github.com/rust-lang/crates-io-index`を更新しています)
    Updating rand v0.3.14 -&gt; v0.3.15
    (randクレートをv0.3.14 -&gt; v0.3.15に更新しています)
</code></pre>
<!-- At this point, you would also notice a change in your *Cargo.lock* file noting -->
<!-- that the version of the `rand` crate you are now using is `0.3.15`. -->
<!-- ちょっとこなれた日本語にしづらい英文 -->
<p>この時点で、<em>Cargo.lock</em>ファイルに書かれている現在使用している<code>rand</code>クレートのバージョンが、
<code>0.3.15</code>になっていることにも気付くでしょう。</p>
<!-- If you wanted to use `rand` version `0.4.0` or any version in the `0.4.x` -->
<!-- series, you’d have to update the *Cargo.toml* file to look like this instead: -->
<p><code>rand</code>のバージョン<code>0.4.0</code>または、<code>0.4.x</code>シリーズのどれかを使用したかったら、
代わりに<em>Cargo.toml</em>ファイルを以下のように更新しなければならないでしょう:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<!-- The next time you run `cargo build`, Cargo will update the registry of crates -->
<!-- available and reevaluate your `rand` requirements according to the new version -->
<!-- you have specified. -->
<p>次回、<code>cargo build</code>コマンドを走らせたら、Cargoは利用可能なクレートのレジストリを更新し、
<code>rand</code>クレートの必要条件を指定した新しいバージョンに再評価します。</p>
<!-- There’s a lot more to say about [Cargo][doccargo] and [its -->
<!-- ecosystem][doccratesio] which we'll discuss in Chapter 14, but -->
<!-- for now, that’s all you need to know. Cargo makes it very easy to reuse -->
<!-- libraries, so Rustaceans are able to write smaller projects that are assembled -->
<!-- from a number of packages. -->
<p>まだ第14章で議論する<a href="http://doc.crates.io">Cargo</a><!-- ignore -->と<a href="http://doc.crates.io/crates-io.html">そのエコシステム</a><!-- ignore -->
については述べたいことが山ほどありますが、とりあえずは、これで知っておくべきことは全てです。
Cargoのおかげでライブラリはとても簡単に再利用ができるので、Rustacean（Rustユーザのこと）は数多くのパッケージから
構成された小規模のプロジェクトを書くことができるのです。</p>
<!-- ### Generating a Random Number -->
<a class="header" href="print.html#a乱数を生成する" id="a乱数を生成する"><h3>乱数を生成する</h3></a>
<!-- Now that you've added the `rand` crate to *Cargo.toml*, let's start using -->
<!-- `rand`. The next step is to update *src/main.rs*, as shown in Listing 2-3. -->
<p><em>Cargo.toml</em>に<code>rand</code>クレートを追加したので、<code>rand</code>クレートを<em>使用</em>開始しましょう。
次のステップは、リスト2-3のように<em>src/main.rs</em>ファイルを更新することです。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);    //秘密の数字は次の通り: {}

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);                     //行の読み込みに失敗しました

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<!-- <span class="caption">Listing 2-3: Adding code to generate a -->
<!-- random number</span> -->
<p><span class="caption">リスト2-3: 乱数を生成するコードの追加</span></p>
<!-- First, we add a line that lets Rust know we’ll be using the `rand` crate as an -->
<!-- external dependency. This also does the equivalent of calling `use rand`, so -->
<!-- now we can call anything in the `rand` crate by placing `rand::` before it. -->
<p>まず、コンパイラに<code>rand</code>クレートを外部依存として使用することを知らせる行を追加しています。
これにより、<code>use rand</code>を呼ぶのと同じ効果が得られるので、<code>rand</code>クレートのものを<code>rand::</code>
という接頭辞をつけて呼び出せるようになりました。</p>
<!-- Next, we add another `use` line: `use rand::Rng`. The `Rng` trait defines -->
<!-- methods that random number generators implement, and this trait must be in -->
<!-- scope for us to use those methods. Chapter 10 will cover traits in detail. -->
<p>次に、別の<code>use</code>行を追加しています: <code>use rand::Rng</code>ですね。<code>Rng</code>トレイトは乱数生成器が実装するメソッドを定義していて、
このトレイトがスコープにないと、メソッドを使用できないのです。トレイトについて詳しくは、
第10章で解説します。</p>
<!-- Also, we’re adding two more lines in the middle. The `rand::thread_rng` function -->
<!-- will give us the particular random number generator that we’re going to use: -->
<!-- one that is local to the current thread of execution and seeded by the -->
<!-- operating system. Next, we call the `gen_range` method on the random number -->
<!-- generator. This method is defined by the `Rng` trait that we brought into -->
<!-- scope with the `use rand::Rng` statement. The `gen_range` method takes two -->
<!-- numbers as arguments and generates a random number between them. It’s inclusive -->
<!-- on the lower bound but exclusive on the upper bound, so we need to specify `1` -->
<!-- and `101` to request a number between 1 and 100. -->
<p>また、途中に2行追加もしています。<code>rand::thread_rng</code>関数は、これから使う特定の乱数生成器を
返してくれます: この乱数生成器は、実行スレッドに固有で、OSにより、シード値を与えられています。
次に、この乱数生成器の<code>gen_range</code>メソッドを呼び出しています。このメソッドは、<code>use rand::Rng</code>文で
スコープに導入した<code>Rng</code>トレイトで定義されています。<code>gen_range</code>メソッドは二つの数字を引数に取り、
それらの間の乱数を生成してくれます。範囲は下限値を含み、上限値を含まないため、<code>1</code>と<code>101</code>と指定しないと
1から100の範囲の数字は得られません。</p>
<!-- Note: You won’t just know which traits to use and which methods and functions -->
<!-- to call from a crate. Instructions for using a crate are in each crate’s -->
<!-- documentation. Another neat feature of Cargo is that you can run the `cargo -->
<!-- doc --open` command, which will build documentation provided by all of your -->
<!-- dependencies locally and open it in your browser. If you’re interested in -->
<!-- other functionality in the `rand` crate, for example, run `cargo doc --open` -->
<!-- and click `rand` in the sidebar on the left. -->
<blockquote>
<p>単純に使用すべきトレイトとクレートからどの関数とメソッドを呼び出すか知っているわけではないでしょう。
クレートの使用方法は、各クレートのドキュメントにあります。Cargoの別の素晴しい機能は、<code>cargo doc --open</code>コマンドを
走らせてローカルに存在する依存すべてのドキュメントをビルドし、ブラウザで閲覧できる機能です。例えば、
<code>rand</code>クレートの他の機能に興味があるなら、<code>cargo doc --open</code>コマンドを走らせて、左側のサイドバーから
<code>rand</code>をクリックしてください。</p>
</blockquote>
<!-- The second line that we added to the code prints the secret number. This is -->
<!-- useful while we’re developing the program to be able to test it, but we’ll -->
<!-- delete it from the final version. It’s not much of a game if the program prints -->
<!-- the answer as soon as it starts! -->
<p>コードに追加した2行目は、秘密の数字を出力してくれます。これは、プログラムを開発中にはテストするのに役立ちますが、
最終版からは削除する予定です。プログラムがスタートと同時に答えを出力しちゃったら、ゲームになりませんからね！</p>
<!-- Try running the program a few times: -->
<p>試しに何回かプログラムを走らせてみてください:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!                         (何回も出ているので、ここでは和訳は省略します)
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<!-- You should get different random numbers, and they should all be numbers between -->
<!-- 1 and 100. Great job! -->
<p>毎回異なる乱数が出て、その数字はすべて1から100の範囲になるはずです。よくやりました！</p>
<!-- ## Comparing the Guess to the Secret Number -->
<a class="header" href="print.html#a予想と秘密の数字を比較する" id="a予想と秘密の数字を比較する"><h2>予想と秘密の数字を比較する</h2></a>
<!-- Now that we have user input and a random number, we can compare them. That step-->
<!-- is shown in Listing 2-4. Note that this code won't compile quite yet, as we -->
<!-- will explain. -->
<p>今や、ユーザ入力と乱数生成ができるようになったので、比較することができますね。
このステップはリスト2-4に示されています。このコードは現状ではコンパイルできないので、
説明することに注意してください。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // ---snip---

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),       //小さすぎ！
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),      //大きすぎ！
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),        //やったね！
    }
}
</code></pre>
<!-- <span class="caption">Listing 2-4: Handling the possible return values of -->
<!-- comparing two numbers</span> -->
<p><span class="caption">リスト2-4: 2値比較の可能性のある返り値を処理する</span></p>
<!-- The first new bit here is another `use` statement, bringing a type called -->
<!-- `std::cmp::Ordering` into scope from the standard library. Like `Result`, -->
<!-- `Ordering` is another enum, but the variants for `Ordering` are `Less`, -->
<!-- `Greater`, and `Equal`. These are the three outcomes that are possible when you -->
<!-- compare two values. -->
<p>最初の新しい点は、別の<code>use</code>文です。これで、<code>std::cmp::Ordering</code>という型を標準ライブラリから
スコープに導入しています。<code>Result</code>と同じく<code>Ordering</code>もenumです。ただ、<code>Ordering</code>の列挙子は、
<code>Less</code>、<code>Greater</code>そして、<code>Equal</code>です。これらは、2値比較した時に発生しうる3種類の結果です。</p>
<pre><code class="language-rust ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<!-- Then we add five new lines at the bottom that use the `Ordering` type. The -->
<!-- `cmp` method compares two values and can be called on anything that can be -->
<!-- compared. It takes a reference to whatever you want to compare with: here it’s -->
<!-- comparing the `guess` to the `secret_number`. Then it returns a variant of the -->
<!-- `Ordering` enum we brought into scope with the `use` statement. We use a -->
<!-- [`match`][match] expression to decide what to do next based on -->
<!-- which variant of `Ordering` was returned from the call to `cmp` with the values -->
<!-- in `guess` and `secret_number`. -->
<p>それから、一番下に新しく5行追加して<code>Ordering</code>型を使用しています。<code>cmp</code>メソッドは、
2値を比較し、比較できるものに対してならなんに対しても呼び出せます。このメソッドは、
比較したいものへの参照を取ります: ここでは、<code>guess</code>変数と<code>secret_number</code>変数を比較しています。
それからこのメソッドは<code>use</code>文でスコープに導入した<code>Ordering</code>列挙型の値を返します。
<a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->式を使用して、<code>guess</code>変数と<code>secret_number</code>を<code>cmp</code>に渡して返ってきた<code>Ordering</code>の列挙子に基づき、
次の動作を決定しています。</p>
<!-- A `match` expression is made up of *arms*. An arm consists of a *pattern* and -->
<!-- the code that should be run if the value given to the beginning of the `match` -->
<!-- expression fits that arm’s pattern. Rust takes the value given to `match` and -->
<!-- looks through each arm’s pattern in turn. The `match` construct and patterns -->
<!-- are powerful features in Rust that let you express a variety of situations your -->
<!-- code might encounter and helps ensure that you handle them all. These features -->
<!-- will be covered in detail in Chapter 6 and Chapter 18, respectively. -->
<p><code>match</code>式は、複数の<em>アーム</em>(腕)からできています。一つのアームは、パターンとそのパターンに
<code>match</code>式の冒頭で与えた値がマッチした時に走るコードから構成されています。Rustは、<code>match</code>に与えられた
値を取り、各アームのパターンを順番に照合していきます。<code>match</code>式とパターンは、コードを書く際に
<ruby>出<rp>(</rp><rt>で</rt><rp>)</rp>会<rp>(</rp><rt>くわ</rt><rp>)</rp></ruby>す様々なシチュエーションを表現させてくれ、
すべてのシチュエーションに対処していることを保証するのを手助けしてくれるRustの強力な機能です。
これらの機能は、それぞれ、第6章と第18章で詳しく解説することにします。</p>
<!-- Let’s walk through an example of what would happen with the `match` expression -->
<!-- used here. Say that the user has guessed 50 and the randomly generated secret -->
<!-- number this time is 38. When the code compares 50 to 38, the `cmp` method will -->
<!-- return `Ordering::Greater`, because 50 is greater than 38. The `match` -->
<!-- expression gets the `Ordering::Greater value and starts checking each arm's -->
<!-- pattern. It looks at the first arm's pattern, `Ordering::Less`, and sees that -->
<!-- the value `Ordering::Greater` does not match `Ordering::Less`, so it ignores -->
<!-- the code in that arm and moves to the next arm. The next arm’s pattern, -->
<!-- `Ordering::Greater`, *does* match `Ordering::Greater`! The associated code in -->
<!-- that arm will execute and print `Too big!` to the screen. The `match` -->
<!-- expression ends because it has no need to look at the last arm in this scenario. -->
<p>ここで使われている<code>match</code>式でどんなことが起こるかの例をじっくり観察してみましょう！例えば、
ユーザは50と予想し、ランダム生成された秘密の数字は今回、38だったとしましょう。コードが50と38を比較すると、
<code>cmp</code>メソッドは<code>Ordering::Greater</code>を返します。50は38よりも大きいからですね。<code>match</code>式に、
<code>Ordering::Greater</code>が与えられ、各アームのパターンを吟味し始めます。まず、
最初のアームのパターンと照合します(<code>Ordering::Less</code>ですね)。しかし、
値の<code>Ordering::Greater</code>と<code>Ordering::Less</code>はマッチしないため、このアームのコードは無視され、
次のアームに移ります。次のアームのパターン、<code>Ordering::Greater</code>は<em>見事に</em><code>Ordering::Greater</code>とマッチします！
このアームに紐づけられたコードが実行され、画面に<code>Too big!</code>が表示されます。
これで<code>match</code>式の実行は終わりになります。この筋書きでは、最後のアームと照合する必要はもうないからですね。</p>
<!-- However, the code in Listing 2-4 won’t compile yet. Let’s try it: -->
<p>ところが、リスト2-4のコードは、まだコンパイルが通りません。試してみましょう:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types          (型が合いません)
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |                                    (構造体`std::string::String`を予期したけど、整数型変数が見つかりました)
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error   (先のエラーのため、処理を中断します)
Could not compile `guessing_game`.      (`guessing_game`をコンパイルできませんでした)
</code></pre>
<!-- The core of the error states that there are *mismatched types*. Rust has a -->
<!-- strong, static type system. However, it also has type inference. When we wrote -->
<!-- `let guess = String::new()`, Rust was able to infer that `guess` should be a -->
<!-- `String` and didn’t make us write the type. The `secret_number`, on the other -->
<!-- hand, is a number type. A few number types can have a value between 1 and 100: -->
<!-- `i32`, a 32-bit number; `u32`, an unsigned 32-bit number; `i64`, a 64-bit -->
<!-- number; as well as others. Rust defaults to an `i32`, which is the type of -->
<!-- `secret_number` unless we add type information elsewhere that would cause Rust -->
<!-- to infer a different numerical type. The reason for the error is that Rust -->
<!-- cannot compare a string and a number type. -->
<p>このエラーの核は、<em>型の不一致</em>があると言っています。Rustは、強い静的型システムを持っています。
しかし、型推論にも対応しています。<code>let guess = String::new()</code>と書いた時、コンパイラは、
<code>guess</code>が<code>String</code>型であるはずと推論してくれ、その型を明示させられることはありませんでした。
一方で、<code>secret_number</code>変数は、数値型です。1から100を表すことができる数値型はいくつかあります:
<code>i32</code>は32ビットの数字; <code>u32</code>は32ビットの非負数字; <code>i64</code>は64ビットの数字;などです。
Rustでの標準は、<code>i32</code>型であり、型情報をどこかに追加して、コンパイラに異なる数値型だと推論させない限り、
<code>secret_number</code>の型はこれになります。エラーの原因は、Rustでは、文字列と数値型を比較できないことです。</p>
<!-- Ultimately, we want to convert the `String` the program reads as input into a -->
<!-- real number type so we can compare it numerically to the guess. We can do that -->
<!-- by adding the following two lines to the `main` function body: -->
<p>究極的には、プログラムが入力として読み込む<code>String</code>型を現実の数値型に変換し、
予想と数値として比較できるようにしたいわけです。これは、以下の2行を<code>main</code>関数の本体に追記することでできます:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);                 //数値を入力してください！

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<!-- The two new lines are: -->
<p>その2行とは:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse()
    .expect(&quot;Please type a number!&quot;);
</code></pre>
<!-- We create a variable named `guess`. But wait, doesn’t the program already have -->
<!-- a variable named `guess`? It does, but Rust allows us to *shadow* the previous -->
<!-- value of `guess` with a new one. This feature is often used in sutuations in -->
<!-- in which you want to convert a value from one type to another type. Shadowing lets -->
<!-- us reuse the `guess` variable name rather than forcing us to create two unique -->
<!-- variables, such as `guess_str` and `guess` for example. (Chapter 3 covers -->
<!-- shadowing in more detail.) -->
<p><code>guess</code>という名前の変数を生成しています。あれ、でも待って。もうプログラムには<code>guess</code>という名前の変数が
ありませんでしたっけ？確かにありますが、Rustでは、新しい値で<code>guess</code>の値を<em>覆い隠す</em>(shadow)ことが
許されているのです。この機能は、今回のような、値を別の型に変換したいシチュエーションでよく使われます。
シャドーイング(shadowing)のおかげで別々の変数を2つ作らされることなく、<code>guess</code>という変数名を再利用することができるのです。
<code>guess_str</code>と<code>guess</code>みたいなね(シャドーイングについては、第3章でもっと掘り下げます)。</p>
<!-- We bind `guess` to the expression `guess.trim().parse()`. The `guess` in the -->
<!-- expression refers to the original `guess` that was a `String` with the input in -->
<!-- it. The `trim` method on a `String` instance will eliminate any whitespace at -->
<!-- the beginning and end. Although `u32` can contain only numerical characters, -->
<!-- the user must press the <span class="keystroke">enter</span> to satisfy -->
<!-- `read_line`. When the user presses <span class="keystroke">enter</span>, a -->
<!-- newline character is added to the string. For example, if the user types <span -->
<!-- class="keystroke">5</span> and presses <span class="keystroke">enter</span>, -->
<!-- `guess` looks like this: `5\n`. The `\n` represents “newline,” the result of -->
<!-- pressing <span class="keystroke">enter</span>. The `trim` method eliminates -->
<!-- `\n`, resulting in just `5`. -->
<p><code>guess</code>を<code>guess.trim().parse()</code>という式に束縛しています。この式中の<code>guess</code>は、
入力が入った<code>String</code>型の元々の<code>guess</code>を指しています。<code>String</code>オブジェクトの<code>trim</code>メソッドは、
両端の空白をすべて除去します。<code>u32</code>型は、数字しか含むことができませんが、ユーザは、
<code>read_line</code>の処理を終えるために<span class="keystroke">エンター</span>を押さなければなりません。
ユーザが<span class="keystroke">エンター</span>を押したら、改行文字が文字列に追加されます。
具体例として、ユーザが<span class="keystroke">5</span>を入力して、
<span class="keystroke">エンター</span>を押せば、<code>guess</code>は次のようになります: <code>5\n</code>。
この<code>\n</code>が「改行」、つまりエンターキーを押した結果を表しているわけです。
<code>trim</code>メソッドは、<code>\n</code>を削除するので、ただの<code>5</code>になります。</p>
<!-- The [`parse` method on strings][parse] parses a string into some -->
<!-- kind of number. Because this method can parse a variety of number types, we -->
<!-- need to tell Rust the exact number type we want by using `let guess: u32`. The -->
<!-- colon (`:`) after `guess` tells Rust we’ll annotate the variable’s type. Rust -->
<!-- has a few built-in number types; the `u32` seen here is an unsigned, 32-bit -->
<!-- integer. It’s a good default choice for a small positive number. You’ll learn -->
<!-- about other number types in Chapter 3. Additionally, the `u32` annotation in -->
<!-- this example program and the comparison with `secret_number` means that Rust -->
<!-- will infer that `secret_number` should be a `u32` as well. So now the -->
<!-- comparison will be between two values of the same type! -->
<p><a href="../../std/primitive.str.html#method.parse">文字列の<code>parse</code>メソッド</a><!-- ignore -->は、文字列をパースして何らかの数値にします。
このメソッドは、いろんな数値型をパースできるので、<code>let guess: u32</code>としてコンパイラに私たちが求めている型をズバリ示唆する必要があるのです。
<code>guess</code>の後のコロン(<code>:</code>)がコンパイラに変数の型を注釈する合図になります。
Rustには、組み込みの数値型がいくつかあります; ここの<code>u32</code>型は、32ビットの非負整数です。
<code>u32</code>型は小さな非負整数のデフォルトの選択肢として丁度良いです。他の数値型については、第3章で学ぶでしょう。
付け加えると、このサンプルプログラムの<code>u32</code>という注釈と<code>secret_number</code>変数との比較は、
<code>secret_number</code>変数も<code>u32</code>型であるとコンパイラが推論することを意味します。
従って、今では比較が同じ型の2つの値で行われることになるわけです！</p>
<!-- The call to `parse` could easily cause an error. If, for example, the string -->
<!-- contained `A👍%`, there would be no way to convert that to a number. Because it -->
<!-- might fail, the `parse` method returns a `Result` type, much as the `read_line` -->
<!-- method does (discussed earlier in “Handling Potential Failure with the Result -->
<!-- Type”). We’ll treat this `Result` the same way by using the `expect` method -->
<!-- again. If `parse` returns an `Err` `Result` variant because it couldn’t create -->
<!-- a number from the string, the `expect` call will crash the game and print the -->
<!-- message we give it. If `parse` can successfully convert the string to a number, -->
<!-- it will return the `Ok` variant of `Result`, and `expect` will return the -->
<!-- number that we want from the `Ok` value. -->
<p><code>parse</code>メソッドの呼び出しは、エラーになりやすいです。例としては、文字列が<code>A👍%</code>を含んでいたら、
数値に変換できるわけがありません。失敗する可能性があるので、<code>parse</code>メソッドは、
<code>Result</code>型を返すわけです。ちょうど、(「Result型で失敗する可能性に対処する」節で先ほど議論した)<code>read_line</code>メソッドのようにというわけですね。
今回も、<code>expect</code>メソッドを使用して<code>Result</code>型を同じように扱います。この<code>Result</code>を<code>expect</code>メソッドを再度使用して、
同じように扱います。もし、文字列から数値を生成できなかったために、<code>parse</code>メソッドが<code>Result</code>型の<code>Err</code>値を返したら、
<code>expect</code>メソッドの呼び出しは、ゲームをクラッシュさせ、与えたメッセージを表示します。
もし、<code>parse</code>メソッドが文字列の数値への変換に成功したら、<code>Result</code>型の<code>Ok</code>値を返し、
<code>expect</code>メソッドは、<code>Ok</code>値から必要な数値を返してくれます。</p>
<!-- Let’s run the program now! -->
<p>さあ、プログラムを走らせましょう！</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<!-- Nice! Even though spaces were added before the guess, the program still figured -->
<!-- out that the user guessed 76. Run the program a few times to verify the -->
<!-- different behavior with different kinds of input: guess the number correctly, -->
<!-- guess a number that is too high, and guess a number that is too low. -->
<p>いいですね！予想の前にスペースを追加したにもかかわらず、プログラムはちゃんとユーザが76と予想したことを導き出しました。
プログラムを何回か走らせて、異なる入力の色々な振る舞いを確認してください: つまり、
数字を正しく言い当てたり、大きすぎる値を予想したり、低すぎる数字を入力したりということです。</p>
<!-- We have most of the game working now, but the user can make only one guess. -->
<!-- Let’s change that by adding a loop! -->
<p>ここまでで大方ゲームはうまく動くようになりましたが、まだユーザは1回しか予想できません。
ループを追加して、その部分を変更しましょう！</p>
<!-- ## Allowing Multiple Guesses with Looping -->
<a class="header" href="print.html#aループで複数回の予想を可能にする" id="aループで複数回の予想を可能にする"><h2>ループで複数回の予想を可能にする</h2></a>
<!-- The `loop` keyword creates an infinite loop. We'll add that now to give users -->
<!-- more chances at guessing the number: -->
<p><code>loop</code>キーワードは、無限ループを作り出します。これを追加して、ユーザが何回も予想できるようにしましょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<!-- As you can see, we’ve moved everything into a loop from the guess input prompt -->
<!-- onward. Be sure to indent the lines inside the loop another four spaces each  -->
<!-- and run the program again. Notice that there is a new problem because the -->
<!-- program is doing exactly what we told it to do: ask for another guess forever! -->
<!-- It doesn't seem like the user can quit! -->
<p>見てわかる通り、予想入力部分以降をループに入れ込みました。ループ内の行にインデントを追加するのを忘れないようにして、
またプログラムを走らせてみましょう。新たな問題が発生したことに気付いてください。
プログラムが教えた通りに動作しているからですね: 永遠に予想入力を求めるわけです！
これでは、ユーザが終了できないようです！</p>
<!-- The user could always halt the program by using the keyboard shortcut <span -->
<!-- class="keystroke">ctrl-c</span>. But there’s another way to escape this -->
<!-- insatiable monster as mentioned in the `parse` discussion in “Comparing the -->
<!-- Guess to the Secret Number”: if the user enters a non-number answer, the -->
<!-- program will crash. The user can take advantage of that in order to quit, as -->
<!-- shown here: -->
<p>ユーザは、<span class="keystroke">ctrl-c</span>というキーボードショートカットを使って、いつでもプログラムを強制終了させられます。
しかし、「予想を秘密の数字と比較する」節の<code>parse</code>メソッドに関する議論で触れたように、
この貪欲なモンスターを回避する別の方法があります: ユーザが数字以外の答えを入力すれば、プログラムはクラッシュするのです。
ユーザは、その利点を活かして、終了することができます。以下のようにですね:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
(スレッド'main'は'数字を入力してください！: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
(注釈: `RUST_BACKTRACE=1`で走らせるとバックトレースを見れます)
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
(エラー: プロセスは予期なく終了しました)
</code></pre>
<!-- Typing `quit` actually quits the game, but so will any other non-number input. -->
<!-- However, this is suboptimal to say the least. We want the game to automatically -->
<!-- stop when the correct number is guessed. -->
<p><code>quit</code>と入力すれば、実際にゲームを終了できるわけですが、別に他の数字以外の入力でもそうなります。
しかしながら、これは最低限度と言えるでしょう。正しい数字が予想されたら、自動的にゲームが停止してほしいわけです。</p>
<!-- ### Quitting After a Correct Guess -->
<a class="header" href="print.html#a正しい予想をした後に終了する" id="a正しい予想をした後に終了する"><h3>正しい予想をした後に終了する</h3></a>
<!-- Let’s program the game to quit when the user wins by adding a `break` statement: -->
<p><code>break</code>文を追加して、ユーザが勝った時にゲームが終了するようにプログラムしましょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!-- Adding the `break` line after `You win!` makes the program exit the loop when -->
<!-- the user guesses the secret number correctly. Exiting the loop also means -->
<!-- exiting the program, because the loop is the last part of `main`. -->
<p><code>break</code>文の1行を<code>You win!</code>の後に追記することで、ユーザが秘密の数字を正確に予想した時に、
プログラムはループを抜けるようになりました。ついでに、ループを抜けることは、プログラムを終了することを意味します。
ループが<code>main</code>関数の最後の部分だからですね。</p>
<!-- ### Handling Invalid Input -->
<a class="header" href="print.html#a不正な入力を処理する" id="a不正な入力を処理する"><h3>不正な入力を処理する</h3></a>
<!-- To further refine the game’s behavior, rather than crashing the program when -->
<!-- the user inputs a non-number, let’s make the game ignore a non-number so the -->
<!-- user can continue guessing. We can do that by altering the line where `guess` -->
<!-- is converted from a `String` to a `u32`, as showin in Listing 2-5. -->
<p>さらにゲームの振る舞いを改善するために、ユーザが数値以外を入力した時にプログラムをクラッシュさせるのではなく、
非数値を無視してユーザが数当てを続けられるようにしましょう！これは、
<code>guess</code>が<code>String</code>型から<code>u32</code>型に変換される行を改変することで達成できます。リスト2-5のようにですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);

let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};

println!(&quot;You guessed: {}&quot;, guess);

// --snip--
</code></pre>
<!-- <span class="caption">Listing 2-5: Ignoring a non-number guess and asking for -->
<!-- another guess instead of crashing the program</span> -->
<p><span class="caption">リスト2-5: 非数値の予想を無視し、プログラムをクラッシュさせるのではなく、もう1回予想してもらう</span></p>
<!-- Switching from an `expect` call to a `match` expression is how you generally -->
<!-- move from crash on an error to handling the error. Remember that `parse` -->
<!-- returns a `Result` type and `Result` is an enum that has the variants `Ok` or -->
<!-- `Err`. We’re using a `match` expression here, as we did with the `Ordering` -->
<!-- result of the `cmp` method. -->
<p><code>expect</code>メソッドの呼び出しから<code>match</code>式に切り替えることは、
エラーでクラッシュする動作からエラー処理を行う処理へ変更する一般的な手段になります。<code>parse</code>メソッドは、
<code>Result</code>型を返し、<code>Result</code>は<code>Ok</code>か<code>Err</code>の値を取りうるenumであることを思い出してください。
ここでは<code>match</code>式を使っています。<code>cmp</code>メソッドの<code>Ordering</code>という結果のような感じですね。</p>
<!-- If `parse` is able to successfully turn the string into a number, it will -->
<!-- return an `Ok` value that contains the resulting number. That `Ok` value will -->
<!-- match the first arm’s pattern, and the `match` expression will just return the -->
<!-- `num` value that `parse` produced and put inside the `Ok` value. That number -->
<!-- will end up right where we want it in the new `guess` variable we’re creating. -->
<p><code>parse</code>メソッドは、文字列から数値への変換に成功したら、結果の数値を保持する<code>Ok</code>値を返します。
この<code>Ok</code>値は、最初のアームのパターンにマッチし、この<code>match</code>式は<code>parse</code>メソッドが生成し、
<code>Ok</code>値に格納した<code>num</code>の値を返すだけです。その数値が最終的に生成した新しい<code>guess</code>変数の欲しい場所に含まれます。</p>
<!-- If `parse` is *not* able to turn the string into a number, it will return an -->
<!-- `Err` value that contains more information about the error. The `Err` value -->
<!-- does not match the `Ok(num)` pattern in the first `match` arm, but it does match -->
<!-- the `Err(_)` pattern in the second arm. The underscore, `_`, is a -->
<!-- catchall value; in this example, we’re saying we want to match all `Err` -->
<!-- values, no matter what information they have inside them. So the program will -->
<!-- execute the second arm's code, `continue`, which tells the program to go to the -->
<!-- next iteration of the `loop` and ask for another guess. So effectively, the -->
<!-- program ignores all errors that `parse` might encounter! -->
<p><code>parse</code>メソッドは、文字列から数値への変換に<em>失敗</em>したら、エラーに関する情報を多く含む<code>Err</code>値を返します。
この<code>Err</code>値は、最初の<code>match</code>アームの<code>Ok(num)</code>というパターンにはマッチしないものの、
2番目のアームの<code>Err(_)</code>というパターンにはマッチするわけです。この<code>_</code>は、包括値です; この例では、
保持している情報がどんなものでもいいから全ての<code>Err</code>値にマッチさせたいと宣言しています。
従って、プログラムは2番目のアームのコードを実行し(<code>continue</code>ですね)、これは、<code>loop</code>の
次の段階に移り、再度予想入力を求めるようプログラムに指示します。故に実質的には、プログラムは<code>parse</code>メソッドが
遭遇しうる全てのエラーを無視するようになります！</p>
<!-- Now everything in the program should work as expected. Let’s try it: -->
<p>さて、プログラムの全てがうまく予想通りに動くはずです。試しましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<!-- Awesome! With one tiny final tweak, we will finish the guessing game. Recall -->
<!-- that the program is still printing the secret number. That worked well for -->
<!-- testing, but it ruins the game. Let’s delete the `println!` that outputs the -->
<!-- secret number. Listing 2-6 shows the final code: -->
<p>素晴らしい！最後にひとつまみ変更を加えて、数当てゲームを完了にしましょう。
プログラムが未だに秘密の数字を出力していることを思い出してください。テスト中はうまく動くけど、
ゲームを台無しにしてしまいます。秘密の数字を出力する<code>println!</code>を削除しましょう。
リスト2-5が成果物のコードです:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!-- <span class="caption">Listing 2-6: Complete guessing game code</span> -->
<p><span class="caption">リスト2-6: 数当てゲームの完全なコード</span></p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-1" id="aまとめ-1"><h2>まとめ</h2></a>
<!-- At this point, you’ve successfully built the guessing game. Congratulations! -->
<p>ここまでで、数当てゲームの作成に成功しました。おめでとうございます！</p>
<!-- This project was a hands-on way to introduce you to many new Rust concepts: -->
<!-- `let`, `match`, methods, associated functions, external crates, and more. In-->
<!-- the next few chapters, you’ll learn about these concepts in more detail. -->
<!-- Chapter 3 covers concepts that most programming languages have, such as -->
<!-- variables, data types, and functions, and shows how to use them in Rust. -->
<!-- Chapter 4 explores ownership, a feature that makes Rust different from other -->
<!-- languages. Chapter 5 discusses structs and method syntax, and Chapter 6 -->
<!-- explains how enums work. -->
<p>このプロジェクトは、たくさんの新しいRustの概念に触れる実践的な方法でした:
<code>let</code>文、<code>match</code>式、メソッド、関連関数、外部クレートの使用などなど。
以降の数章で、これらの概念についてより深く学ぶことになるでしょう。
第3章では、ほとんどのプログラミング言語が持っている、変数、データ型、関数などの概念について解説し、
それらのRustでの使用方法について示します。
第4章では、所有権について見ます。これにより、Rustは他の言語とかけ離れた存在になっています。
第5章では、構造体とメソッド記法について議論し、第6章ではenumの動作法を説明します。</p>
<!-- # Common Programming Concepts -->
<a class="header" href="print.html#a一般的なプログラミングの概念" id="a一般的なプログラミングの概念"><h1>一般的なプログラミングの概念</h1></a>
<!-- This chapter covers concepts that appear in almost every programming language -->
<!-- and how they work in Rust. Many programming languages have much in common at -->
<!-- their core. None of the concepts presented in this chapter are unique to Rust, -->
<!-- but we’ll discuss them in the context of Rust and explain the conventions -->
<!-- around using these concepts. -->
<p>この章では、ほとんど全てのプログラミング言語で見られる概念を解説し、それらがRustにおいて、
どう動作するかを見ていきます。多くのプログラミング言語は、その核心において、いろいろなものを共有しています。
この章で提示する概念は、全てRustに固有のものではありませんが、Rustの文脈で議論し、
これらの概念を使用することにまつわる仕様を説明します。</p>
<!-- Specifically, you’ll learn about variables, basic types, functions, comments, -->
<!-- and control flow. These foundations will be in every Rust program, and learning -->
<!-- them early will give you a strong core to start from. -->
<p>具体的には、変数、基本的な型、関数、コメント、そしてフロー制御について学びます。
これらの基礎は全てのRustプログラムに存在するものであり、それらを早期に学ぶことは
強力な基礎を築くことになるでしょう。</p>
<!--  ### Keywords -->
<!--  -->
<!--  The Rust language has a set of *keywords* that have been reserved for use by -->
<!--  the language only, much as in other languages. Keep in mind that you cannot -->
<!--  use these words as names of variables or functions. Most of the keywords have -->
<!--  special meanings, and you’ll be using them to do various tasks in your Rust -->
<!--  programs; a few have no current functionality associated with them but have -->
<!--  been reserved for functionality that might be added to Rust in the future. You -->
<!--  can find a list of the keywords in Appendix A. -->
<blockquote>
<a class="header" href="print.html#aキーワード" id="aキーワード"><h3>キーワード</h3></a>
<p>Rust言語にも他の言語同様、キーワードが存在し、これらは言語だけが使用できるようになっています。
これらの単語は、変数や関数名には使えないことを弁えておいてください。ほとんどのキーワードは、特別な意味を持っており、
自らのRustプログラムにおいて、様々な作業をこなすために使用することができます;
いくつかは、紐付けられた機能がないものの、将来Rustに追加されるかもしれない機能用に予約されています。
キーワードの一覧は、付録Aで確認できます。</p>
</blockquote>
<!-- ## Variables and Mutability -->
<a class="header" href="print.html#a変数と可変性" id="a変数と可変性"><h2>変数と可変性</h2></a>
<!-- As mentioned in Chapter 2, by default variables are immutable. This is one of -->
<!-- many nudges Rust gives you to write your code in a way that takes advantage of -->
<!-- the safety and easy concurrency that Rust offers. However, you still have the -->
<!-- option to make your variables mutable. Let’s explore how and why Rust -->
<!-- encourages you to favor immutability and why sometimes you might want to opt -->
<!-- out. -->
<p>第2章で触れた通り、変数は標準で不変になります。これは、
Rustが提供する安全性や簡潔な並列プログラミングの利点を享受する形でコードを書くための選択の1つです。
ところが、まだ変数を可変にするという選択肢も残されています。
どのように、そしてなぜRustは不変性を推奨するのか、そしてなぜそれとは違う道を選びたくなることがあるのか見ていきましょう。</p>
<!-- When a variable is immutable, once a value is bound to a name, you can't change-->
<!-- that value. To illustrate this, let’s generate a new project called *variables* -->
<!-- in your *projects* directory by using `cargo new --bin variables`. -->
<p>変数が不変であると、値が一旦名前に束縛されたら、その値を変えることができません。
これを具体的に説明するために、<em>projects</em>ディレクトリに<code>cargo new --bin variables</code>コマンドを使って、
<em>variables</em>という名前のプロジェクトを生成しましょう。</p>
<!-- Then, in your new *variables* directory, open *src/main.rs* and replace its -->
<!-- code with the following code that won't compile just yet: -->
<p>それから、新規作成した<em>variables</em>ディレクトリで、<em>src/main.rs</em>ファイルを開き、
その中身を以下のコードに置き換えましょう。このコードはコンパイルできません:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);     // xの値は{}です
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<!-- Save and run the program using `cargo run`. You should receive an error -->
<!-- message, as shown in this output: -->
<p>これを保存し、<code>cargo run</code>コマンドでプログラムを走らせてください。次の出力に示されているようなエラーメッセージを受け取るはずです:</p>
<pre><code class="language-text">error[E0384]: cannot assgin twice immutable variable `x`
              (不変変数`x`に2回代入できません)
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
  |         (`x`への最初の代入)
3 |     println!(&quot;The value of x is: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<!-- This example shows how the compiler helps you find errors in your programs. -->
<!-- Even though compiler errors can be frustrating, they only mean your program -->
<!-- isn’t safely doing what you want it to do yet; they do *not* mean that you’re -->
<!-- not a good programmer! Experienced Rustaceans still get compiler errors. -->
<p>この例では、コンパイラがプログラムに潜むエラーを見つけ出す手助けをしてくれることが示されています。
コンパイルエラーは、イライラすることもあるものですが、まだプログラムにしてほしいことを安全に行えていないだけということなのです;
エラーが出るからといって、あなたがいいプログラマではないという意味では<em>ありません</em>！
経験豊富なRustaceanでも、コンパイルエラーを出すことはあります。</p>
<!-- The error message indicates that the cause of the error is that you `cannot -->
<!-- assign twice to immutable variable x`, because you tried to assign a second -->
<!-- value to the immutable `x` variable. -->
<p>このエラーは、エラーの原因が<code>不変変数xに2回代入できない</code>であると示しています。不変な<code>x</code>という変数に第2段階の値を代入しようとしたからです。</p>
<!-- It’s important that we get compile-time errors when we attempt to change a -->
<!-- value that we previously designated as immutable because this very situation -->
<!-- can lead to bugs. If one part of our code operates on the assumption that a -->
<!-- value will never change and another part of our code changes that value, it’s -->
<!-- possible that the first part of the code won’t do what it was designed to do. -->
<!-- This cause of bugs can be difficult to track down after the fact, -->
<!-- especially when the second piece of code changes the value only *sometimes*. -->
<p>以前に不変と指定された値を変えようとした時に、コンパイルエラーが出るのは重要なことです。
なぜなら、この状況はまさしく、バグに繋がるからです。コードのある部分は、
値が変わることはないという前提のもとに処理を行い、別の部分がその値を変更していたら、
最初の部分が目論見通りに動いていない可能性があるのです。このようなバグの発生は、
事実(<code>訳注</code>:実際にプログラムを走らせた結果のことと思われる)の後には追いかけづらいものです。
特に第2のコード片が、値を<em>時々</em>しか変えない場合尚更です。</p>
<!-- In Rust the compiler guarantees that when you state that a value won’t change, -->
<!-- it really won’t change. That means that when you’re reading and writing code, -->
<!-- you don’t have to keep track of how and where a value might change. Your code -->
<!-- is thus easier to reason through. -->
<p>Rustでは、値が不変であると宣言したら、本当に変わらないことをコンパイラが担保してくれます。
つまり、コードを読み書きする際に、どこでどうやって値が変化しているかを追いかける必要がなくなります。
故にコードを通して正しいことを確認するのが簡単になるのです。</p>
<!-- But mutability can be very useful. Variables are immutable only by default; as -->
<!-- you did in Chapter 2, you can make them mutable by adding `mut` in front of the -->
<!-- variable name. In addition to allowing this value to change, `mut` conveys -->
<!-- intent to future readers of the code by indicating that other parts of the code -->
<!-- will be changing this variable value. -->
<p>しかし、可変性は時として非常に有益なこともあります。変数は、標準でのみ、不変です。つまり、
第2章のように変数名の前に<code>mut</code>キーワードを付けることで、可変にできるわけです。この値が変化できるようにするとともに、
<code>mut</code>により、未来の読者に対してコードの別の部分がこの変数の値を変える可能性を示すことで、その意図を汲ませることができるのです。</p>
<!-- For example, change *src/main.rs* to the following: -->
<p>例として、<em>src/main.rs</em>ファイルを以下のように書き換えてください:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<!-- When we run the program now, we get this: -->
<p>今、このプログラムを走らせると、以下のような出力が得られます:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5   (xの値は5です)
The value of x is: 6
</code></pre>
<!-- We’re allowed to change the value that `x` binds to from `5` to `6` when `mut` -->
<!-- is used. In some cases, you’ll want to make a variable mutable because it makes -->
<!-- the code more convenient to write than if it had only immutable variables. -->
<p><code>mut</code>キーワードを使われると、<code>x</code>が束縛している値を<code>5</code>から<code>6</code>に変更できます。
変数を可変にする方が、不変変数だけがあるよりも書きやすくなるので、変数を可変にしたくなることもあるでしょう。</p>
<!-- There are multiple trade-offs to consider, in addition to the prevention of -->
<!-- bugs. For example, in cases where you’re using large data structures, mutating -->
<!-- an instance in place may be faster than copying and returning newly allocated -->
<!-- instances. With smaller data structures, creating new instances and writing in -->
<!-- a more functional programming style may be easier to think through, so lower -->
<!-- performance might be a worthwhile penalty for gaining that clarity. -->
<p>考えるべきトレードオフはバグの予防以外にも、いくつかあります。例えば、大きなデータ構造を使う場合などです。
インスタンスを可変にして変更できるようにする方が、いちいちインスタンスをコピーして新しくメモリ割り当てされたインスタンスを返すよりも速くなります。
小規模なデータ構造なら、新規インスタンスを生成して、もっと関数型っぽいコードを書く方が通して考えやすくなるため、
低パフォーマンスは、その簡潔性を得るのに足りうるペナルティになるかもしれません。</p>
<!-- ### Differences Between Variables and Constants -->
<a class="header" href="print.html#a変数と定数constantsの違い" id="a変数と定数constantsの違い"><h3>変数と定数(constants)の違い</h3></a>
<!-- Being unable to change the value of a variable might have reminded you of -->
<!-- another programming concept that most other languages have: *constants*. Like -->
<!-- immutable variables, constants are values that are bound to a name and are not-->
<!-- allowed to change, but there are a few differences between constants and -->
<!-- variables. -->
<p>変数の値を変更できないようにするといえば、他の多くの言語も持っている別のプログラミング概念を思い浮かべるかもしれません:
<em>定数</em>です。不変変数のように、定数は名前に束縛され、変更することが叶わない値のことですが、
定数と変数の間にはいくつかの違いがあります。</p>
<!-- First, we aren’t allowed to use `mut` with constants. Constants aren't just -->
<!-- immutable by default-they're always immutable. -->
<p>まず、定数には<code>mut</code>キーワードは使えません: 定数は標準で不変であるだけでなく、常に不変なのです。</p>
<!-- You declare constants using the `const` keyword instead of the `let` keyword, -->
<!-- and the type of the value *must* be annotated. We're about to cover types and -->
<!-- type annotations in the next section, “Data Types,” so don't worry about the -->
<!-- details right now. Just know that we must always annotate the type. -->
<p>定数は<code>let</code>キーワードの代わりに、<code>const</code>キーワードで宣言し、値の型は<em>必ず</em>注釈しなければなりません。
型と型注釈については次のセクション、「データ型」で解説する予定なので、その詳細については気にする必要はありません。
ただ単に型は常に注釈しなければならないのだと思っていてください。</p>
<!-- Constants can be declared in any scope, including the global scope, which makes -->
<!-- them useful for values that many parts of code need to know about. -->
<p>定数はどんなスコープでも定義できます。グローバルスコープも含めてです。なので、
いろんなところで使用される可能性のある値を定義するのに役に立ちます。</p>
<!-- The last difference is that constants may be set only to a constant expression, -->
<!-- not the result of a function call or any other value that could only be -->
<!-- computed at runtime. -->
<p>最後の違いは、定数は定数式にしかセットできないことです。関数呼び出し結果や、実行時に評価される値にはセットできません。</p>
<!-- Here's an example of a constant declaration where the constant's name is -->
<!-- `MAX_POINTS` and its value is set to 100,000. (Rust naming convention for -->
<!-- constants is to use all upper case with underscores between words): -->
<p>定数の名前が<code>MAX_POINTS</code>で、値が100,000にセットされた定数定義の例をご覧ください。(Rustの定数の命名規則は、
全て大文字でアンダースコアで単語区切りすることです):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const MAX_POINTS: u32 = 100_000;
#}</code></pre></pre>
<!-- Constants are valid for the entire time a program runs, within the scope they -->
<!-- were declared in, making them a useful choice for values in your application -->
<!-- domain that multiple parts of the program might need to know about, such as the -->
<!-- maximum number of points any player of a game is allowed to earn or the speed -->
<!-- of light. -->
<p>定数は、プログラムが走る期間、定義されたスコープ内でずっと有効です。従って、
プログラムのいろんなところで使用される可能性のあるアプリケーション空間の値を定義するのに有益な選択肢になります。
例えば、ゲームでプレイヤーが取得可能なポイントの最高値や、光速度などですね。</p>
<!-- Naming hardcoded values used throughout your program as constants is useful in -->
<!-- conveying the meaning of that value to future maintainers of the code. It also -->
<!-- helps to have only one place in your code you would need to change if the -->
<!-- hardcoded value needed to be updated in the future. -->
<p>プログラム中で使用されるハードコードされた値に対して、定数として名前付けすることは、
コードの将来的な管理者にとって値の意味を汲むのに役に立ちます。将来、ハードコードされた値を変える必要が出た時に、
たった1箇所を変更するだけで済むようにもしてくれます。</p>
<!-- ### Shadowing -->
<a class="header" href="print.html#aシャドーイング" id="aシャドーイング"><h3>シャドーイング</h3></a>
<!-- As you saw in the guessing game tutorial in the “Comparing the Guess to the -->
<!-- Secret Number” section in Chapter 2, you can declare a new variable with the -->
<!-- same name as a previous variable, and the new variable shadows the previous -->
<!-- variable. Rustaceans say that the first variable is *shadowed* by the second, -->
<!-- which means that the second variable’s value is what appears when the variable -->
<!-- is used. We can shadow a variable by using the same variable’s name and -->
<!-- repeating the use of the `let` keyword as follows: -->
<p>第2章の数当てゲームのチュートリアル、「秘密の数字と予想を比較する」節で見たように、前に定義した変数と同じ名前の変数を新しく宣言でき、
新しい変数は、前の変数を覆い隠し(shadow)ます。Rustaceanはこれを最初の変数は、
2番目の変数に<em>シャドー</em>されたと言い、この変数を使用した際に、2番目の変数の値が現れるということです。
以下のようにして、同じ変数名を用いて変数を覆い隠し、<code>let</code>キーワードの使用を繰り返します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<!-- This program first binds `x` to a value of `5`. Then it shadows `x` by -->
<!-- repeating `let x =`, taking the original value and adding `1` so the value of -->
<!-- `x` is then `6`. The third `let` statement also shadows `x`, multiplying the -->
<!-- previous value by `2` to give `x` a final value of `12`. Wehn we run this -->
<!-- program, it will output the following: -->
<p>このプログラムはまず、<code>x</code>を<code>5</code>という値に束縛します。それから<code>let x =</code>を繰り返すことで<code>x</code>を覆い隠し、
元の値に<code>1</code>を加えることになるので、<code>x</code>の値は、<code>6</code>になります。
3番目の<code>let</code>文も<code>x</code>を覆い隠し、以前の値に<code>2</code>をかけることになるので、<code>x</code>の最終的な値は<code>12</code>になります。
このプログラムを走らせたら、以下のように出力するでしょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
</code></pre>
<!-- Shadowing is different than marking a variable as `mut`, because we’ll get a -->
<!-- compile-time error if we accidentally try to reassign to this variable without -->
<!-- using the `let` keyword. By using `let`, we can perform a few transformations -->
<!-- on a value but have the variable be immutable after those transformations have -->
<!-- been completed. -->
<p>シャドーイングは、変数を<code>mut</code>にするのとは違います。なぜなら、<code>let</code>キーワードを使わずに、
誤ってこの変数に再代入を試みようものなら、コンパイルエラーが出るからです。<code>let</code>を使うことで、
値にちょっとした加工は加えられますが、その加工が終わったら、変数は不変になるわけです。</p>
<!-- The other difference between `mut` and shadowing is that because we’re -->
<!-- effectively creating a new variable when we use the `let` keyword again, we can -->
<!-- change the type of the value but reuse the same name. For example, say our -->
<!-- program asks a user to show how many spaces they want between some text by -->
<!-- inputting space characters, but we really want to store that input as a number: -->
<p><code>mut</code>と上書きのもう一つの違いは、再度<code>let</code>キーワードを使用したら、実効的には新しい変数を生成していることになるので、
値の型を変えつつ、同じ変数名を使いまわせることです。例えば、
プログラムがユーザに何らかのテキストに対して空白文字を入力することで何個分のスペースを表示したいかを尋ねるとします。
ただ、実際にはこの入力を数値として保持したいとしましょう:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let spaces = &quot;   &quot;;
let spaces = spaces.len();
#}</code></pre></pre>
<!-- This construct is allowed because the first `spaces` variable is a string type -->
<!-- and the second `spaces` variable, which is a brand-new variable that happens to -->
<!-- have the same name as the first one, is a number type. Shadowing thus spares us -->
<!-- from having to come up with different names, like `spaces_str` and -->
<!-- `spaces_num`; instead, we can reuse the simpler `spaces` name. However, if we -->
<!-- try to use `mut` for this, as shown here, we'll get a compile-time error: -->
<p>この文法要素は、容認されます。というのも、最初の<code>spaces</code>変数は文字列型であり、2番目の<code>spaces</code>変数は、
たまたま最初の変数と同じ名前になったまっさらな変数のわけですが、数値型になるからです。故に、シャドーイングのおかげで、
異なる名前を思いつく必要がなくなるわけです。<code>spaces_str</code>と<code>spaces_num</code>などですね; 代わりに、
よりシンプルな<code>spaces</code>という名前を再利用できるわけです。一方で、この場合に<code>mut</code>を使おうとすると、
以下に示した通りですが、コンパイルエラーになるわけです:</p>
<pre><code class="language-rust ignore">let mut spaces = &quot;   &quot;;
spaces = spaces.len();
</code></pre>
<!-- The error says we’re not allowed to mutate a variable’s -->
<!-- type: -->
<p>変数の型を可変にすることは許されていないと言われているわけです:</p>
<pre><code class="language-text">error[E0308]: mismatched types          (型が合いません)
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |                           (&amp;str型を予期しましたが、usizeが見つかりました)
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre>
<!-- Now that we’ve explored how variables work, let’s look at more data types they -->
<!-- can have. -->
<p>さあ、変数が動作する方法を見てきたので、今度は変数が取りうるデータ型について見ていきましょう。</p>
<!-- ## Data Types -->
<a class="header" href="print.html#aデータ型" id="aデータ型"><h2>データ型</h2></a>
<!-- Every value in Rust is of a certain *data type*, which tells Rust what kind of -->
<!-- data is being specified so it knows how to work with that data. We'll look at -->
<!-- two data type subsets: scalar and compound. -->
<p>Rustにおける値は全て、何らかの<em>データ型</em>になり、コンパイラがどんなデータが指定されているか知れるので、
そのデータの取り扱い方も把握できるというわけです。2種のデータ型のサブセットを見ましょう: スカラー型と複合型です。</p>
<!-- Keep in mind that Rust is a *statically typed* language, which means that it -->
<!-- must know the types of all variables at compile time. The compiler can usually -->
<!-- infer what type we want to use based on the value and how we use it. In cases -->
<!-- when many types are possible, such as when we converted a `String` to a numeric -->
<!-- type using `parse` in the “Comparing the Guess to the Secret Number” section in -->
<!-- Chapter 2, we must add a type annotation, like this: -->
<p>Rustは<em>静的型付き</em>言語であることを弁えておいてください。つまり、
コンパイル時に全ての変数の型が判明している必要があるということです。コンパイラは通常、値と使用方法に基づいて、
使用したい型を推論してくれます。複数の型が推論される可能性がある場合、例えば、
第2章の「秘密の数字と予想を比較する」節で<code>parse</code>メソッドを使って<code>String</code>型を数値型に変換した時のような場合には、
型注釈をつけなければいけません。以下のようにですね:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);    // 数字ではありません！
#}</code></pre></pre>
<!-- If we don’t add the type annotation here, Rust will display the following -->
<!-- error, which means the compiler needs more information from us to know which -->
<!-- type we want to use: -->
<p>ここで型注釈を付けなければ、コンパイラは以下のエラーを表示し、これは可能性のある型のうち、
どの型を使用したいのかを知るのに、コンパイラがプログラマからもっと情報を得る必要があることを意味します:</p>
<pre><code class="language-text">error[E0282]: type annotations needed
              (型注釈が必要です)
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ cannot infer type for `_`
  |               (`_`の型が推論できません)
  |
  = note: type annotations or generic parameter binding required
    (注釈: 型注釈、またはジェネリクス引数束縛が必要です)
</code></pre>
<!-- You’ll see different type annotations for other data types. -->
<p>他のデータ型についても、様々な型注釈を目にすることになるでしょう。</p>
<!-- ### Scalar Types -->
<a class="header" href="print.html#aスカラー型" id="aスカラー型"><h3>スカラー型</h3></a>
<!-- A *scalar* type represents a single value. Rust has four primary scalar types: -->
<!-- integers, floating-point numbers, Booleans, and characters. You may recognize -->
<!-- these from other programming languages. Let’s jump into how they work in Rust. -->
<p>スカラー型は、単独の値を表します。Rustには主に4つのスカラー型があります:
整数、浮動小数点数、論理値、最後に文字です。他のプログラミング言語でも、これらの型を見かけたことはあるでしょう。
Rustでの動作方法に飛び込みましょう。</p>
<!-- #### Integer Types -->
<a class="header" href="print.html#a整数型" id="a整数型"><h4>整数型</h4></a>
<!-- An *integer* is a number without a fractional component. We used one integer -->
<!-- type in Chapter 2, the `u32` type. This type declaration indicates that the -->
<!-- value it’s associated with should be an unsigned integer (signed integer types -->
<!-- start with `i` instead of `u`) that takes up 32 bits of space. Table 3-1 shows-->
<!-- the built-in integer types in Rust. Each variant in the Signed and Unsigned -->
<!-- columns (for example, `i16`) can be used to declare the type of an integer -->
<!-- value. -->
<p>整数とは、小数部分のない数値のことです。第2章で一つの整数型を使用しました。<code>u32</code>型です。
この型定義は、紐付けられる値が、符号なし整数(符号付き整数は<code>u</code>ではなく、<code>i</code>で始まります)になり、
これは、32ビット分のサイズを取ります。表3-1は、Rustの組み込み整数型を表示しています。
符号付きと符号なし欄の各バリアント(例: <code>i16</code>)を使用して、整数値の型を宣言することができます。</p>
<!-- <span class="caption">Table 3-1: Integer Types in Rust</span> -->
<p><span class="caption">表3-1: Rustの整数型</span></p>
<!-- | Length | Signed  | Unsigned | -->
<!-- |--------|---------|----------| -->
<!-- | 8-bit  | `i8`    | `u8`     | -->
<!-- | 16-bit | `i16`   | `u16`    | -->
<!-- | 32-bit | `i32`   | `u32`    | -->
<!-- | 64-bit | `i64`   | `u64`    | -->
<!-- | arch   | `isize` | `usize`  | -->
<table><thead><tr><th> 大きさ  </th><th> 符号付き </th><th> 符号なし </th></tr></thead><tbody>
<tr><td> 8-bit  </td><td> <code>i8</code>    </td><td> <code>u8</code>    </td></tr>
<tr><td> 16-bit </td><td> <code>i16</code>   </td><td> <code>u16</code>   </td></tr>
<tr><td> 32-bit </td><td> <code>i32</code>   </td><td> <code>u32</code>   </td></tr>
<tr><td> 64-bit </td><td> <code>i64</code>   </td><td> <code>u64</code>   </td></tr>
<tr><td> arch   </td><td> <code>isize</code> </td><td> <code>usize</code> </td></tr>
</tbody></table>
<!-- Each variant can be either signed or unsigned and has an explicit size. -->
<!-- *Signed* and *unsigned* refers to whether it’s possible for the number to be -->
<!-- negative or positive-in other words, whether the number needs to have a sign -->
<!-- with it (signed) or whether it will only ever be positive and can therefore be -->
<!-- represented without a sign (unsigned). It’s like writing numbers on paper: when -->
<!-- the sign matters, a number is shown with a plus sign or a minus sign; however, -->
<!-- when it’s safe to assume the number is positive, it’s shown with no sign. -->
<!-- Signed numbers are stored using two’s complement representation (if you’re -->
<!-- unsure what this is, you can search for it online; an explanation is outside -->
<!-- the scope of this book). -->
<p>各バリアントは、符号付きか符号なしかを選べ、明示的なサイズを持ちます。<em>符号付き</em>と<em>符号なし</em>は、
数値が正負を持つかどうかを示します。つまり、数値が符号を持つ必要があるかどうか(符号付き)、または、
絶対に正数にしかならず符号なしで表現できるかどうか(符号なし)です。これは、数値を紙に書き下すのと似ています:
符号が問題になるなら、数値はプラス記号、またはマイナス記号とともに表示されます; しかしながら、
その数値が正数であると仮定することが安全なら、符号なしで表示できるわけです。符号付き数値は、
2の補数表現で保持されます(これが何なのか確信を持てないのであれば、ネットで検索することができます。
まあ要するに、この解説は、この本の範疇外というわけです)。</p>
<!-- Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n - -->
<!-- 1</sup> - 1 inclusive, where *n* is the number of bits that variant uses. So an -->
<!-- `i8` can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which equals -->
<!-- -128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - 1, -->
<!-- so a `u8` can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to 255. -->
<p>各符号付きバリアントは、-(2<sup>n - 1</sup>)以上2<sup>n - 1</sup> - 1以下の数値を保持でき、
ここで<em>n</em>はこのバリアントが使用するビット数です。以上から、<code>i8</code>型は-(2<sup>7</sup>)から2<sup>7</sup> - 1まで、
つまり、-128から127までを保持できます。符号なしバリアントは、0以上2<sup>n</sup> - 1以下を保持できるので、
<code>u8</code>型は、0から2<sup>8</sup> - 1までの値、つまり、0から255までを保持できることになります。</p>
<!-- Additionally, the `isize` and `usize` types depend on the kind of computer your -->
<!-- program is running on: 64-bits if you’re on a 64-bit architecture and 32-bits -->
<!-- if you’re on a 32-bit architecture. -->
<p>加えて、<code>isize</code>と<code>usize</code>型は、プログラムが動作しているコンピュータの種類に依存します:
64ビットアーキテクチャなら、64ビットですし、32ビットアーキテクチャなら、32ビットになります。</p>
<!-- You can write integer literals in any of the forms shown in Table 3-2. Note -->
<!-- that all number literals except the byte literal allow a type suffix, such as -->
<!-- `57u8`, and `_` as a visual separator, such as `1_000`. -->
<p>整数リテラル(<code>訳注</code>: リテラルとは、見たままの値ということ)は、表3-2に示すどの形式でも記述することができます。
バイトリテラルを除く数値リテラルは全て、
型接尾辞(例えば、<code>57u8</code>)と<code>_</code>を見た目の区切り記号(例えば、<code>1_000</code>)を付加することができます。</p>
<!-- <span class="caption">Table 3-2: Integer Literals in Rust</span> -->
<p><span class="caption">表3-2: Rustの整数リテラル</span></p>
<!-- | Number literals  | Example       | -->
<!-- |------------------|---------------| -->
<!-- | Decimal          | `98_222`      | -->
<!-- | Hex              | `0xff`        | -->
<!-- | Octal            | `0o77`        | -->
<!-- | Binary           | `0b1111_0000` | -->
<!-- | Byte (`u8` only) | `b'A'`        | -->
<table><thead><tr><th> 数値リテラル       </th><th> 例            </th></tr></thead><tbody>
<tr><td> 10進数            </td><td> <code>98_222</code>      </td></tr>
<tr><td> 16進数            </td><td> <code>0xff</code>        </td></tr>
<tr><td> 8進数             </td><td> <code>0o77</code>        </td></tr>
<tr><td> 2進数             </td><td> <code>0b1111_0000</code> </td></tr>
<tr><td> バイト (<code>u8</code>だけ)  </td><td> <code>b'A'</code>        </td></tr>
</tbody></table>
<!-- So how do you know which type of integer to use? If you’re unsure, Rust’s -->
<!-- defaults are generally good choices, and integer types default to `i32`: this -->
<!-- type is generally the fastest, even on 64-bit systems. The primary situation in -->
<!-- which you’d use `isize` or `usize` is when indexing some sort of collection. -->
<p>では、どの整数型を使うべきかはどう把握すればいいのでしょうか？もし確信が持てないのならば、
Rustの基準型は一般的にいい選択肢になります。整数型の基準は<code>i32</code>型です: 64ビットシステム上でも、
この型が普通最速になります。<code>isize</code>と<code>usize</code>を使う主な状況は、何らかのコレクションにアクセスすることです。</p>
<!-- #### Floating-Point Types -->
<a class="header" href="print.html#a浮動小数点型" id="a浮動小数点型"><h4>浮動小数点型</h4></a>
<!-- Rust also has two primitive types for *floating-point numbers*, which are -->
<!-- numbers with decimal points. Rust’s floating-point types are `f32` and `f64`, -->
<!-- which are 32 bits and 64 bits in size, respectively. The default type is `f64` -->
<!-- because on modern CPUs it’s roughly the same speed as `f32` but is capable of -->
<!-- more precision. -->
<p>Rustにはさらに、<em>浮動小数点数</em>に対しても、2種類の基本型があり、浮動小数点数とは数値に小数点がついたもののことです。
Rustの浮動小数点型は、<code>f32</code>と<code>f64</code>で、それぞれ32ビットと64ビットサイズです。基準型は<code>f64</code>です。
なぜなら、現代のCPUでは、<code>f32</code>とほぼ同スピードにもかかわらず、より精度が高くなるからです。</p>
<!-- Here’s an example that shows floating-point numbers in action: -->
<p>実際に動作している浮動小数点数の例をご覧ください:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<!-- Floating-point numbers are represented according to the IEEE-754 standard. The -->
<!-- `f32` type is a single-precision float, and `f64` has double precision. -->
<p>浮動小数点数は、IEEE-754規格に従って表現されています。<code>f32</code>が単精度浮動小数点数、
<code>f64</code>が倍精度浮動小数点数です。</p>
<!-- #### Numeric Operations -->
<a class="header" href="print.html#a数値演算" id="a数値演算"><h4>数値演算</h4></a>
<!-- Rust supports the usual basic mathematical operations you’d expect for all of the -->
<!-- number types: addition, subtraction, multiplication, division, and remainder. -->
<!-- The following code shows how you’d use each one in a `let` statement: -->
<p>Rustにも全数値型に期待されうる標準的な数学演算が用意されています: 足し算、引き算、掛け算、割り算、余りです。
以下の例では、<code>let</code>文での各演算の使用方法をご覧になれます:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- ```rust -->
<!-- fn main() { -->
<!--     // addition -->
<!--     let sum = 5 + 10; -->
<!-- -->
<!--     // subtraction -->
<!--     let difference = 95.5 - 4.3; -->
<!-- -->
<!--     // multiplication -->
<!--     let product = 4 * 30; -->
<!-- -->
<!--     // division -->
<!--     let quotient = 56.7 / 32.2; -->
<!-- -->
<!--     // remainder -->
<!--     let remainder = 43 % 5; -->
<!-- } -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // 足し算
    let sum = 5 + 10;

    // 引き算
    let difference = 95.5 - 4.3;

    // 掛け算
    let product = 4 * 30;

    // 割り算
    let quotient = 56.7 / 32.2;

    // 余り
    let remainder = 43 % 5;
}
</code></pre></pre>
<!-- Each expression in these statements uses a mathematical operator and evaluates -->
<!-- to a single value, which is then bound to a variable. Appendix B contains a -->
<!-- list of all operators that Rust provides. -->
<p>これらの文の各式は、数学演算子を使用しており、一つの値に評価され、変数に束縛されます。
付録BにRustで使える演算子の一覧が載っています。</p>
<!-- #### The Boolean Type -->
<a class="header" href="print.html#a論理値型" id="a論理値型"><h4>論理値型</h4></a>
<!-- As in most other programming languages, a boolean type in Rust has two possible -->
<!-- values: `true` and `false`. The boolean type in Rust is specified using `bool`. -->
<!-- For example: -->
<p>他の多くの言語同様、Rustの論理値型も取りうる値は二つしかありません: <code>true</code>と<code>false</code>です。
Rustの論理値型は、<code>bool</code>と指定されます。
例です:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- ```rust -->
<!-- fn main() { -->
<!--     let t = true; -->
<!--     let f: bool = false; // with explicit type annotation -->
<!-- } -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // 明示的型注釈付きで
}
</code></pre></pre>
<!-- The main way to use Boolean values is through conditionals, such as an `if` -->
<!-- expression. We’ll cover how `if` expressions work in Rust in the “Control Flow” -->
<!-- section. -->
<p>論理値を使う主な手段は、条件式です。例えば、<code>if</code>式などですね。<code>if</code>式のRustでの動作方法については、
「制御フロー」節で解説します。</p>
<!-- #### The Character Type -->
<a class="header" href="print.html#a文字型" id="a文字型"><h4>文字型</h4></a>
<!-- So far we’ve worked only with numbers, but Rust supports letters too. Rust’s -->
<!-- `char` type is the language’s most primitive alphabetic type, and the following -->
<!-- code shows one way to use it. (Note that the `char` type is specified with -->
<!-- single quotes, as opposed to strings, which use double quotes.) -->
<p>ここまで、数値型のみ扱ってきましたが、Rustには文字も用意されています。Rustの<code>char</code>型は、
言語の最も基本的なアルファベット型であり、以下のコードでその使用方法の一例を見ることができます。
(<code>char</code>は、ダブルクォーテーションマークを使用する文字列に対して、シングルクォートで指定されることに注意してください。)</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let c = 'z';
   let z = 'ℤ';
   let heart_eyed_cat = '😻';    //ハート目の猫
}
</code></pre></pre>
<!-- Rust’s `char` type represents a Unicode Scalar Value, which means it can -->
<!-- represent a lot more than just ASCII. Accented letters; Chinese, Japanese and -->
<!-- Korean characters; emoji; and zero-width spaces are all valid `char` types in -->
<!-- Rust. Unicode Scalar Values range from `U+0000` to `U+D7FF` and `U+E000` to -->
<!-- `U+10FFFF` inclusive. However, a “character” isn’t really a concept in Unicode, -->
<!-- so your human intuition for what a “character” is may not match up with what a -->
<!-- `char` is in Rust. We’ll discuss this topic in detail in the “Strings” in Chapter 8. -->
<p>Rustの<code>char</code>型は、ユニコードのスカラー値を表します。これはつまり、アスキーよりもずっとたくさんのものを表せるということです。
アクセント文字; 中国語、日本語、韓国語文字;
絵文字; ゼロ幅スペースは、全てRustでは、有効な<code>char</code>型になります。ユニコードスカラー値は、
<code>U+0000</code>から<code>U+D7FF</code>までと<code>U+E0000</code>から<code>U+10FFFF</code>までの範囲になります。
ところが、「文字」は実はユニコードの概念ではないので、文字とは何かという人間としての直観は、
Rustにおける<code>char</code>値が何かとは合致しない可能性があります。この話題については、第8章の「文字列」で詳しく議論しましょう。</p>
<!-- ### Compound Types -->
<a class="header" href="print.html#a複合型" id="a複合型"><h3>複合型</h3></a>
<!-- *Compound types* can group multiple values into one type. Rust has two -->
<!-- primitive compound types: tuples and arrays. -->
<p><em>複合型</em>により、複数の値を一つの型にまとめることができます。Rustには、
2種類の基本的な複合型があります: タプルと配列です。</p>
<!-- #### The Tuple type -->
<a class="header" href="print.html#aタプル型" id="aタプル型"><h4>タプル型</h4></a>
<!-- A tuple is a general way of grouping together some number of other values with -->
<!-- a variety of types into one compound type. -->
<p>タプルは、複数の型の何らかの値を一つの複合型にまとめ上げる一般的な手段です。</p>
<!-- We create a tuple by writing a comma-separated list of values inside -->
<!-- parentheses. Each position in the tuple has a type, and the types of the -->
<!-- different values in the tuple don’t have to be the same. We’ve added optional -->
<!-- type annotations in this example: -->
<p>タプルは、丸かっこの中にカンマ区切りの値リストを書くことで生成します。タプルの位置ごとに型があり、
タプル内の値はそれぞれ全てが同じ型である必要はありません。今回の例では、型注釈をあえて追加してみました:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<!-- The variable `tup` binds to the entire tuple, because a tuple is considered a -->
<!-- single compound element. To get the individual values out of a tuple, we can -->
<!-- use pattern matching to destructure a tuple value, like this: -->
<p>変数<code>tup</code>は、タプル全体に束縛されています。なぜなら、タプルは、一つの複合要素と考えられるからです。
タプルから個々の値を取り出すには、パターンマッチングを使用して分解することができます。以下のように:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<!-- This program first creates a tuple and binds it to the variable `tup`. It then -->
<!-- uses a pattern with `let` to take `tup` and turn it into three separate -->
<!-- variables, `x`, `y`, and `z`. This is called *destructuring*, because it breaks -->
<!-- the single tuple into three parts. Finally, the program prints the value of -->
<!-- `y`, which is `6.4`. -->
<p>このプログラムは、まずタプルを生成し、それを変数<code>tup</code>に束縛しています。
それから<code>let</code>文とパターンを使って<code>tup</code>変数の中身を3つの個別の変数(<code>x</code>、<code>y</code>、<code>z</code>ですね)に変換しています。
この過程は、<em>分配</em>と呼ばれます。単独のタプルを破壊して三分割しているからです。最後に、
プログラムは<code>y</code>変数の値を出力し、<code>6.4</code>と表示されます。</p>
<!-- In addition to destructuring through pattern matching, we can also access a tuple -->
<!-- element directly by using a period (`.`) followed by the index of the value we -->
<!-- want to access. For example: -->
<p>パターンマッチングを通しての分配の他にも、アクセスしたい値の番号をピリオド(<code>.</code>)に続けて書くことで、
タプルの要素に直接アクセスすることもできます。例です:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<!-- This program creates a tuple, `x`, and then makes new variables for each -->
<!-- element by using their index. As with most programming languages, the first -->
<!-- index in a tuple is 0. -->
<p>このプログラムは、新しいタプル<code>x</code>を作成し、添え字アクセスで各要素に対して新しい変数も作成しています。
多くのプログラミング言語同様、タプルの最初の添え字は0です。</p>
<!-- #### The Array Type -->
<a class="header" href="print.html#a配列型" id="a配列型"><h4>配列型</h4></a>
<!-- Another way to have a collection of multiple values is with an *array*. Unlike -->
<!-- a tuple, every element of an array must have the same type. Arrays in Rust are -->
<!-- different than arrays in some other languages because arrays in Rust have a -->
<!-- fixed length: once declared, they cannot grow or shrink in size. -->
<p><em>配列</em>によっても、複数の値のコレクションを得ることができます。タプルと異なり、配列の全要素は、
同じ型でなければなりません。Rustの配列は、他の言語と異なっています。Rustの配列は、
固定長なのです: 一度宣言されたら、サイズを伸ばすことも縮めることもできません。</p>
<!-- In Rust, the values going into an array are written as a comma-separated list -->
<!-- inside square brackets: -->
<p>Rustでは、配列に入れる要素は、角かっこ内にカンマ区切りリストとして記述します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<!-- Arrays are useful when you want your data allocated on the stack rather than -->
<!-- the heap (we will discuss the stack and the heap more in Chapter 4) or when -->
<!-- you want to ensure you always have a fixed number of elements. An array isn't -->
<!-- as flexible as the vector type, though. A vector is a similar collection type -->
<!-- provided by the standard library that *is* allowed to grow or shrink in size. -->
<!-- If you’re unsure whether to use an array or a vector, you should probably use a -->
<!-- vector. Chapter 8 discusses vectors in more detail. -->
<p>配列は、ヒープよりもスタック(スタックとヒープについては第4章で<ruby>詳<rp>(</rp><rt>つまび</rt><rp>)</rp></ruby>らかに議論します)にデータのメモリを確保したい時、または、常に固定長の要素があることを確認したい時に有効です。
ただ、配列は、ベクタ型ほど柔軟ではありません。ベクタは、標準ライブラリによって提供されている配列と似たようなコレクション型で、
こちらは、サイズを伸縮させることが<em>できます</em>。配列とベクタ型、どちらを使うべきか確信が持てない時は、
おそらくベクタ型を使うべきです。第8章でベクタについて詳細に議論します。</p>
<!-- An example of when you might want to use an array rather than a vector is in a -->
<!-- program that needs to know the names of the months of the year. It’s very -->
<!-- unlikely that such a program will need to add or remove months, so you can use -->
<!-- an array because you know it will always contain 12 items: -->
<p>ベクタ型よりも配列を使いたくなるかもしれない例は、1年の月の名前を扱うプログラムです。そのようなプログラムで、
月を追加したり削除したりすることまずないので、配列を使用できます。常に12個要素があることもわかってますしね:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
#}</code></pre></pre>
<!-- ##### Accessing Array Elements -->
<a class="header" href="print.html#a配列の要素にアクセスする" id="a配列の要素にアクセスする"><h5>配列の要素にアクセスする</h5></a>
<!-- An array is a single chunk of memory allocated on the stack. You can access -->
<!-- elements of an array using indexing, like this: -->
<p>配列は、スタック上に確保される一塊のメモリです。添え字によって、
配列の要素にこのようにアクセスすることができます:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<!-- In this example, the variable named `first` will get the value `1`, because -->
<!-- that is the value at index `[0]` in the array. The variable named `second` will -->
<!-- get the value `2` from index `[1]` in the array. -->
<p>この例では、<code>first</code>という名前の変数には<code>1</code>という値が格納されます。配列の<code>[0]</code>番目にある値が、
それだからですね。<code>second</code>という名前の変数には、配列の<code>[1]</code>番目の値<code>2</code>が格納されます。</p>
<!-- ##### Invalid Array Element Access -->
<a class="header" href="print.html#a配列要素への無効なアクセス" id="a配列要素への無効なアクセス"><h5>配列要素への無効なアクセス</h5></a>
<!-- What happens if you try to access an element of an array that is past the end -->
<!-- of the array? Say you change the example to the following code, which will -->
<!-- compile but exit with an error when it runs: -->
<p>配列の終端を越えて要素にアクセスしようとしたら、どうなるでしょうか？
先ほどの例を以下のように変えたとすると、コンパイルは通りますが、実行するとエラーで終了します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;The value of element is: {}&quot;, element);   // 要素の値は{}です
}
</code></pre>
<!-- Running this code using `cargo run` produces the following result: -->
<p>このコードを<code>cargo run</code>で走らせると、以下のような結果になります:</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
スレッド'&lt;main&gt;'は'範囲外アクセス: 長さは5ですが、添え字は10でした', src/main.rs:6
でパニックしました
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!-- The compilation didn’t produce any errors, but the program results in a -->
<!-- *runtime* error and didn’t exit successfully. When you attempt to access an -->
<!-- element using indexing, Rust will check that the index you’ve specified is less -->
<!-- than the array length. If the index is greater than the length, Rust will -->
<!-- *panic*, which is the term Rust uses when a program exits with an error. -->
<p>コンパイルでは何もエラーが出なかったものの、プログラムは<em>実行時</em>エラーに陥り、
正常終了しませんでした。要素に添え字アクセスを試みると、言語は、
指定されたその添え字が配列長よりも小さいかを確認してくれます。添え字が配列長よりも大きければ、言語は<em>パニック</em>します。
パニックとは、プログラムがエラーで終了したことを表すRust用語です。</p>
<!-- This is the first example of Rust’s safety principles in action. In many -->
<!-- low-level languages, this kind of check is not done, and when you provide an -->
<!-- incorrect index, invalid memory can be accessed. Rust protects you against this -->
<!-- kind of error by immediately exiting instead of allowing the memory access and -->
<!-- continuing. Chapter 9 discusses more of Rust’s error handling. -->
<p>これは、実際に稼働しているRustの安全機構の最初の例になります。低レベル言語の多くでは、
この種のチェックは行われないため、間違った添え字を与えると、無効なメモリにアクセスできてしまいます。
Rustでは、メモリアクセスを許可し、処理を継続する代わりに即座にプログラムを終了することで、
この種のエラーからプログラマを保護しています。Rustのエラー処理については、第9章でもっと議論します。</p>
<!-- ## Functions -->
<a class="header" href="print.html#a関数" id="a関数"><h2>関数</h2></a>
<!-- Functions are pervasive in Rust code. You’ve already seen one of the most -->
<!-- important functions in the language: the `main` function, which is the entry -->
<!-- point of many programs. You’ve also seen the `fn` keyword, which allows you to -->
<!-- declare new functions. -->
<p>関数は、Rustのコードにおいてよく見かける存在です。すでに、言語において最も重要な関数のうちの一つを目撃していますね:
そう、<code>main</code>関数です。これは、多くのプログラムのエントリーポイント(<code>訳注</code>: プログラム実行時に最初に走る関数のこと)になります。
<code>fn</code>キーワードもすでに見かけましたね。これによって新しい関数を宣言することができます。</p>
<!-- Rust code uses *snake case* as the conventional style for function and variable -->
<!-- names. In snake case, all letters are lowercase and underscores separate words. -->
<!-- Here’s a program that contains an example function definition: -->
<p>Rustの関数と変数の命名規則は、<em>スネークケース</em>(<code>訳注</code>: some_variableのような命名規則)を使うのが慣例です。
スネークケースとは、全文字を小文字にし、単語区切りにアンダースコアを使うことです。
以下のプログラムで、サンプルの関数定義をご覧ください:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);  // 別の関数
}
</code></pre></pre>
<!-- Function definitions in Rust start with `fn` and have a set of parentheses -->
<!-- after the function name. The curly brackets tell the compiler where the function -->
<!-- body begins and ends. -->
<p>Rustにおいて関数定義は、<code>fn</code>キーワードで始まり、関数名の後に丸かっこの組が続きます。
波かっこが、コンパイラに関数本体の開始と終了の位置を伝えます。</p>
<!-- We can call any function we’ve defined by entering its name followed by a set -->
<!-- of parentheses. Because `another_function` is defined in the program, it can be -->
<!-- called from inside the `main` function. Note that we defined `another_function` -->
<!-- *after* the `main` function in the source code; we could have defined it before -->
<!-- as well. Rust doesn’t care where you define your functions, only that they’re -->
<!-- defined somewhere. -->
<p>定義した関数は、名前に丸かっこの組を続けることで呼び出すことができます。
<code>another_function</code>関数がプログラム内で定義されているので、<code>main</code>関数内から呼び出すことができるわけです。
ソースコード中で<code>another_function</code>を<code>main</code>関数の<em>後</em>に定義していることに注目してください;
勿論、main関数の前に定義することもできます。コンパイラは、関数がどこで定義されているかは気にしません。
どこかで定義されていることのみ気にします。</p>
<!-- Let’s start a new binary project named *functions* to explore functions -->
<!-- further. Place the `another_function` example in *src/main.rs* and run it. You -->
<!-- should see the following output: -->
<p><em>functions</em>という名前の新しいバイナリ生成プロジェクトを始めて、関数についてさらに深く探求していきましょう。
<code>another_function</code>の例を<em>src/main.rs</em>ファイルに配置して、走らせてください。
以下のような出力が得られるはずです:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<!-- The lines execute in the order in which they appear in the `main` function. -->
<!-- First, the “Hello, world!” message prints, and then `another_function` is -->
<!-- called and its message is printed. -->
<p>行出力は、<code>main</code>関数内に書かれた順序で実行されています。最初に&quot;Hello, world&quot;メッセージが出て、
それから<code>another_function</code>が呼ばれて、こちらのメッセージが出力されています。</p>
<!-- ### Function Parameters -->
<a class="header" href="print.html#a関数の引数" id="a関数の引数"><h3>関数の引数</h3></a>
<!-- Functions can also be defined to have *parameters*, which are special variables -->
<!-- that are part of a function's signature. When a function has parameters, you -->
<!-- can provide it with concrete values for those parameters. Technically, the -->
<!-- concrete values are called *arguments*, but in casual conversation people tend -->
<!-- to use the words “parameter” and “argument” interchangeably for either the -->
<!-- variables in a function's definition or the concrete values passed in when you -->
<!-- call a function. -->
<p>関数は、引数を持つようにも定義できます。引数とは、関数シグニチャの一部になる特別な変数のことです。
関数に引数があると、引数の位置に実際の値を与えることができます。技術的にはこの実際の値は
<em>実引数</em>と呼ばれますが、普段の会話では、仮引数(&quot;parameter&quot;)と実引数(&quot;argument&quot;)を関数定義の変数と関数呼び出し時に渡す実際の値、
両方の意味に区別なく使います(<code>訳注</code>: 日本語では、どちらも単に引数と呼ぶことが多いでしょう)。</p>
<!-- The following rewritten version of `another_function` shows what parameters -->
<!-- look like in Rust: -->
<p>以下の書き直した<code>another_function</code>では、Rustの仮引数がどのようなものかを示しています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);   // xの値は{}です
}
</code></pre></pre>
<!-- Try running this program; you should get the following output: -->
<p>このプログラムを走らせてみてください; 以下のような出力が得られるはずです:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<!-- The declaration of `another_function` has one parameter named `x`. The type of -->
<!-- `x` is specified as `i32`. When `5` is passed to `another_function`, the -->
<!-- `println!` macro puts `5` where the pair of curly brackets were in the format -->
<!-- string. -->
<p><code>another_function</code>の宣言には、<code>x</code>という名前の仮引数があります。<code>x</code>の型は、
<code>i32</code>と指定されています。値<code>5</code>が<code>another_function</code>に渡されると、<code>println!</code>マクロにより、
フォーマット文字列中の1組の波かっこがある位置に値<code>5</code>が出力されます。</p>
<!-- In function signatures, you *must* declare the type of each parameter. This is -->
<!-- a deliberate decision in Rust’s design: requiring type annotations in function -->
<!-- definitions means the compiler almost never needs you to use them elsewhere in -->
<!-- the code to figure out what you mean. -->
<p>関数シグニチャにおいて、各仮引数の型を宣言しなければ<em>なりません</em>。これは、Rustの設計において、
意図的な判断です: 関数定義で型注釈が必要不可欠ということは、コンパイラがその意図するところを推し量るのに、
コードの他の箇所で使用する必要がないということを意味します。</p>
<!-- When you want a function to have multiple parameters, separate the parameter -->
<!-- declarations with commas, like this: -->
<p>関数に複数の仮引数をもたせたいときは、仮引数定義をカンマで区切ってください。
こんな感じです:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<!-- This example creates a function with two parameters, both of which are `i32` -->
<!-- types. The function then prints the values in both of its parameters. Note that -->
<!-- function parameters don't all need to be the same type, they just happen to be -->
<!-- in this example. -->
<p>この例では、2引数の関数を生成しています。そして、引数はどちらも<code>i32</code>型です。それからこの関数は、
仮引数の値を両方出力します。関数引数は、全てが同じ型である必要はありません。今回は、
偶然同じになっただけです。</p>
<!-- Let’s try running this code. Replace the program currently in your *functions* -->
<!-- project’s *src/main.rs* file with the preceding example and run it using `cargo -->
<!-- run`: -->
<p>このコードを走らせてみましょう。今、<em>function</em>プロジェクトの<em>src/main.rs</em>ファイルに記載されているプログラムを先ほどの例と置き換えて、
<code>cargo run</code>で走らせてください:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<!-- Because we called the function with `5` as the value for  `x` and `6` is passed -->
<!-- as the value for `y`, the two strings are printed with these values. -->
<p><code>x</code>に対して値<code>5</code>、<code>y</code>に対して値<code>6</code>を渡して関数を呼び出したので、この二つの文字列は、
この値で出力されました。</p>
<!-- ### Function Bodies Contain Statements and Expressions -->
<a class="header" href="print.html#a関数本体は文と式を含む" id="a関数本体は文と式を含む"><h3>関数本体は、文と式を含む</h3></a>
<!-- Function bodies are made up of a series of statements optionally ending in an -->
<!-- expression. So far, we’ve only covered functions without an ending expression, -->
<!-- but we have seen an expression as part of a statement. Because Rust is an -->
<!-- expression-based language, this is an important distinction to understand. -->
<!-- Other languages don’t have the same distinctions, so let’s look at what -->
<!-- statements and expressions are and how their differences affect the bodies of -->
<!-- functions. -->
<p>関数本体は、文が並び、最後に式を置くか文を置くという形で形成されます。現在までには、
式で終わらない関数だけを見てきたわけですが、式が文の一部になっているものなら見かけましたね。Rustは、式指向言語なので、
これは理解しておくべき重要な差異になります。他の言語にこの差異はありませんので、文と式がなんなのかと、
その違いが関数本体にどんな影響を与えるかを見ていきましょう。</p>
<!-- We’ve actually already used statements and expressions. *Statements* are -->
<!-- instructions that perform some action and do not return a value. *Expressions* -->
<!-- evaluate to a resulting value. Let’s look at some examples. -->
<p>実のところ、もう文と式は使っています。<em>文</em>とは、なんらかの動作をして値を返さない命令です。
<em>式</em>は結果値に評価されます。ちょっと例を眺めてみましょう。</p>
<!-- Creating a variable and assigning a value to it with the `let` keyword is a -->
<!-- statement. In Listing 3-1, `let y = 6;` is a statement. -->
<p><code>let</code>キーワードを使用して変数を生成し、値を代入することは文になります。
リスト3-1で<code>let y = 6;</code>は文です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<!-- <span class="caption">Listing 3-1: A `main` function declaration containing one statement</span> -->
<p><span class="caption">リスト3-1: 1文を含む<code>main</code>関数宣言</span></p>
<!-- Function definitions are also statements; the entire preceding example is a -->
<!-- statement in itself. -->
<p>関数定義も文になります。つまり、先の例は全体としても文になるわけです。</p>
<!-- Statements do not return values. Therefore, you can’t assign a `let` statement -->
<!-- to another variable, as the following code tries to do; you'll get an error: -->
<p>文は値を返しません。故に、<code>let</code>文を他の変数に代入することはできません。
以下のコードではそれを試みていますが、エラーになります:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = (let y = 6);
}
</code></pre>
<!-- When you run this program, the error you’ll get looks like this: -->
<p>このプログラムを実行すると、以下のようなエラーが出るでしょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
(エラー: 式を予期しましたが、文が見つかりました (`let`))
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
    (注釈: `let`を使う変数宣言は、文です)
</code></pre>
<!-- The `let y = 6` statement does not return a value, so there isn’t anything for -->
<!-- `x` to bind to. This is different from what happens in other languages, such as -->
<!-- C and Ruby, where the assignment returns the value of the assignment. In those -->
<!-- languages, you can write `x = y = 6` and have both `x` and `y` have the value -->
<!-- `6`; that is not the case in Rust. -->
<p>この<code>let y = 6</code>という文は値を返さないので、<code>x</code>に束縛するものがないわけです。これは、
CやRubyなどの言語とは異なる動作です。CやRubyでは、代入は代入値を返します。これらの言語では、
<code>x = y = 6</code>と書いて、<code>x</code>も<code>y</code>も値6になるようにできるのですが、Rustにおいては、
そうは問屋が卸さないわけです。</p>
<!-- Expressions evaluate to something and make up most of the rest of the code that -->
<!-- you’ll write in Rust. Consider a simple math operation, such as `5 + 6`, which -->
<!-- is an expression that evaluates to the value `11`. Expressions can be part of -->
<!-- statements: in Listing 3-1, the `6` in the statement `let y = 6;` is an -->
<!-- expression that evaluates to the value `6`. Calling a function is an -->
<!-- expression. Calling a macro is an expression. The block that we use to create -->
<!-- new scopes, `{}`, is an expression, for example: -->
<p>式は何かに評価され、これからあなたが書くRustコードの多くを構成します。
簡単な数学演算(<code>5 + 6</code>など)を思い浮かべましょう。この例は、値<code>11</code>に評価される式です。式は文の一部になりえます:
リスト3-1において、<code>let y = 6</code>という文の<code>6</code>は値<code>6</code>に評価される式です。関数呼び出しも式です。マクロ呼び出しも式です。
新しいスコープを作る際に使用するブロック(<code>{}</code>)も式です:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<!-- This expression: -->
<p>以下の式:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<!-- is a block that, in this case, evaluates to `4`. That value gets bound to `y` -->
<!-- as part of the `let` statement. Note the `x + 1` line without a semicolon at -->
<!-- the end, which is unlike most of the lines you’ve seen so far. Expressions do -->
<!-- not include ending semicolons. If you add a semicolon to the end of an -->
<!-- expression, you turn it into a statement, which will then not return a value. -->
<!-- Keep this in mind as you explore function return values and expressions next. -->
<p>は今回の場合、<code>4</code>に評価されるブロックです。その値が、<code>let</code>文の一部として<code>y</code>に束縛されます。
今まで見かけてきた行と異なり、文末にセミコロンがついていない<code>x + 1</code>の行に気をつけてください。
式は終端にセミコロンを含みません。式の終端にセミコロンを付けたら、文に変えてしまいます。そして、文は値を返しません。
次に関数の戻り値や式を見ていく際にこのことを肝に命じておいてください。</p>
<!-- ### Functions with Return Values -->
<a class="header" href="print.html#a戻り値のある関数" id="a戻り値のある関数"><h3>戻り値のある関数</h3></a>
<!-- Functions can return values to the code that calls them. We don’t name return -->
<!-- values, but we do declare their type after an arrow (`->`). In Rust, the return -->
<!-- value of the function is synonymous with the value of the final expression in -->
<!-- the block of the body of a function. You can return early from a function by -->
<!-- using the `return` keyword and specifying a value, but most functions return -->
<!-- the last expression implicitly. Here’s an example of a function that -->
<!-- returns a value: -->
<p>関数は、それを呼び出したコードに値を返すことができます。戻り値に名前を付けはしませんが、
矢印(<code>-&gt;</code>)の後に型を書いて宣言します。Rustでは、関数の戻り値は、関数本体ブロックの最後の式の値と同義です。
<code>return</code>キーワードで関数から早期リターンし、値を指定することもできますが、多くの関数は最後の式を暗黙的に返します。
こちらが、値を返す関数の例です:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<!-- There are no function calls, macros, or even `let` statements in the `five` -->
<!-- function—just the number `5` by itself. That’s a perfectly valid function in -->
<!-- Rust. Note that the function’s return type is specified, too, as `-> i32`. Try -->
<!-- running this code; the output should look like this: -->
<p><code>five</code>関数内には、関数呼び出しもマクロ呼び出しも、<code>let</code>文でさえ存在しません。数字の5が単独であるだけです。
これは、Rustにおいて、完璧に問題ない関数です。関数の戻り値型が<code>-&gt; i32</code>と指定されていることにも注目してください。
このコードを実行してみましょう; 出力はこんな感じになるはずです:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<!-- The `5` in `five` is the function’s return value, which is why the return type -->
<!-- is `i32`. Let’s examine this in more detail. There are two important bits: -->
<!-- first, the line `let x = five();` shows that we’re using the return value of a -->
<!-- function to initialize a variable. Because the function `five` returns a `5`, -->
<!-- that line is the same as the following: -->
<p><code>five</code>内の<code>5</code>が関数の戻り値です。だから、戻り値型が<code>i32</code>なのです。これについてもっと深く考察しましょう。
重要な箇所は2つあります: まず、<code>let x = five()</code>という行は、関数の戻り値を使って変数を初期化していることを示しています。
関数<code>five</code>は<code>5</code>を返すので、この行は以下のように書くのと同義です:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<!-- Second, the `five` function has no parameters and defines the type of the -->
<!-- return value, but the body of the function is a lonely `5` with no semicolon -->
<!-- because it’s an expression whose value we want to return. -->
<p>2番目に、<code>five</code>関数は仮引数をもたず、戻り値型を定義していますが、関数本体はセミコロンなしの<code>5</code>単独です。
なぜなら、これが返したい値になる式だからです。</p>
<!-- Let's look at another example: -->
<p>もう一つ別の例を見ましょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<!-- Running this code will print `The value of x is: 6`. But if we place a -->
<!-- semicolon at the end of the line containing `x + 1`, changing it from an -->
<!-- expression to a statement, we'll get an error: -->
<p>このコードを走らせると、<code>The value of x is: 6</code>と出力されるでしょう。しかし、
<code>x + 1</code>を含む行の終端にセミコロンを付けて、式から文に変えたら、エラーになるでしょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<!-- Running this code produces an error, as follows: -->
<p>このコードを実行すると、以下のようにエラーが出ます:</p>
<pre><code class="language-text">error[E0308]: mismatched types
              (型が合いません)
 --&gt; src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -&gt; i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |     (i32を予期したのに、()型が見つかりました)
  |
  = note: expected type `i32`
             found type `()`
</code></pre>
<!-- The main error message, “mismatched types,” reveals the core issue with this -->
<!-- code. The definition of the function `plus_one` says that it will return an -->
<!-- `i32`, but statements don’t evaluate to a value, which is expressed by `()`, -->
<!-- the empty tuple. Therefore, nothing is returned, which contradicts the function -->
<!-- definition and results in an error. In this output, Rust provides a message to -->
<!-- possibly help rectify this issue: it suggests removing the semicolon, which -->
<!-- would fix the error. -->
<p>メインのエラーメッセージである「型が合いません」でこのコードの根本的な問題が明らかになるでしょう。
関数<code>plus_one</code>の定義では、<code>i32</code>型を返すと言っているのに、文は値に評価されないからです。このことは、
<code>()</code>、つまり空のタプルとして表現されています。それゆえに、何も戻り値がなく、これが関数定義と矛盾するので、
結果としてエラーになるわけです。この出力内で、コンパイラは問題を修正する手助けになりそうなメッセージも出していますね:
セミコロンを削除するよう提言しています。そして、そうすれば、エラーは直るわけです。</p>
<!-- ## Comments -->
<a class="header" href="print.html#aコメント" id="aコメント"><h2>コメント</h2></a>
<!-- All programmers strive to make their code easy to understand, but sometimes -->
<!-- extra explanation is warranted. In these cases, programmers leave notes, or -->
<!-- *comments*, in their source code that the compiler will ignore but people -->
<!-- reading the source code may find useful. -->
<p>全プログラマは、自分のコードがわかりやすくなるよう努めますが、時として追加の説明が許されることもあります。
このような場合、プログラマは注釈または<em>コメント</em>をソースコードに残し、コメントをコンパイラは無視しますが、
ソースコードを読む人間には有益なものと思えるでしょう。</p>
<!-- Here’s a simple comment: -->
<p>こちらが単純なコメントです:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// hello, world
#}</code></pre></pre>
<!-- In Rust, comments must start with two slashes and continue until the end of the -->
<!-- line. For comments that extend beyond a single line, you’ll need to include -->
<!-- `//` on each line, like this: -->
<p>Rustでは、コメントは2連スラッシュで始め、行の終わりまで続きます。コメントが複数行にまたがる場合、
各行に<code>//</code>を含める必要があります。こんな感じに:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
// ここで何か複雑なことをしていて、長すぎるから複数行のコメントが必要なんだ。
// ふう！願わくば、このコメントで何が起きているか説明されていると嬉しい。
#}</code></pre></pre>
<!-- Comments can also be placed at the end of lines containing code: -->
<p>コメントは、コードが書かれた行の末尾にも配置することができます:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today(今日はラッキーな気がするよ)
}
</code></pre></pre>
<!-- But you’ll more often see them used in this format, with the comment on a -->
<!-- separate line above the code it's annotating: -->
<p>しかし、こちらの形式のコメントの方が見かける機会は多いでしょう。注釈しようとしているコードの1行上に書く形式です:</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // I’m feeling lucky today
    // 今日はラッキーな気がするよ
    let lucky_number = 7;
}
</code></pre></pre>
<!-- Rust also has another kind of comment, documentation comments, which we’ll -->
<!-- discuss in Chapter 14. -->
<p>Rustには他の種類のコメント、ドキュメントコメントもあり、それについては第14章で議論します。</p>
<!-- ## Control Flow -->
<a class="header" href="print.html#aフロー制御" id="aフロー制御"><h2>フロー制御</h2></a>
<!-- Deciding whether or not to run some code depending on if a condition is true -->
<!-- and deciding to run some code repeatedly while a condition is true are basic -->
<!-- building blocks in most programming languages. The most common constructs that -->
<!-- let you control the flow of execution of Rust code are `if` expressions and -->
<!-- loops. -->
<p>条件が真かどうかによってコードを走らせるかどうかを決定したり、
条件が真の間繰り返しコードを走らせるか決定したりすることは、多くのプログラミング言語において、基本的な構成ブロックです。
Rustコードの実行フローを制御する最も一般的な文法要素は、<code>if</code>式とループです。</p>
<!-- ### `if` Expressions -->
<a class="header" href="print.html#if式" id="if式"><h3><code>if</code>式</h3></a>
<!-- An `if` expression allows us to branch your code depending on conditions. We -->
<!-- provide a condition and then state, “If this condition is met, run this block -->
<!-- of code. If the condition is not met, do not run this block of code.” -->
<p>if式によって、条件に依存して枝分かれをさせることができます。条件を与え、以下のように宣言します。
「もし条件が合ったら、この一連のコードを実行しろ。条件に合わなければ、この一連のコードは実行するな」と。</p>
<!-- Create a new project called *branches* in your *projects* directory to explore -->
<!-- the `if` expression. In the *src/main.rs* file, input the following: -->
<p><em>projects</em>ディレクトリに<em>branches</em>という名のプロジェクトを作って<code>if</code>式について掘り下げていきましょう。
<em>src/main.rs</em>ファイルに、以下のように入力してください:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);       // 条件は真です
    } else {
        println!(&quot;condition was false&quot;);      // 条件は偽です
    }
}
</code></pre></pre>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<!-- All `if` expressions start with the keyword `if`, which is followed by a -->
<!-- condition. In this case, the condition checks whether or not the variable -->
<!-- `number` has a value less than 5. The block of code we want to execute if the -->
<!-- condition is true is placed immediately after the condition inside curly -->
<!-- brackets. Blocks of code associated with the conditions in `if` expressions are -->
<!-- sometimes called *arms*, just like the arms in `match` expressions that we -->
<!-- discussed in the “Comparing the Guess to the Secret Number” section of -->
<!-- Chapter 2. -->
<p><code>if</code>式は全て、キーワードの<code>if</code>から始め、条件式を続けます。今回の場合、
条件式は変数<code>number</code>が５未満の値になっているかどうかをチェックします。
条件が真の時に実行したい一連のコードを条件式の直後に波かっこで包んで配置します。<code>if</code>式の条件式と紐付けられる一連のコードは、
時として<em>アーム</em>と呼ばれることがあります。
第2章の「予想と秘密の数字を比較する」の節で議論した<code>match</code>式のアームのようですね。</p>
<!-- Optionally, we can also include an `else` expression, which we chose -->
<!-- to do here, to give the program an alternative block of code to execute should -->
<!-- the condition evaluate to false. If you don’t provide an `else` expression and -->
<!-- the condition is false, the program will just skip the `if` block and move on -->
<!-- to the next bit of code. -->
<p>オプションとして、<code>else</code>式を含むこともでき(ここではそうしています)、これによりプログラムは、
条件式が偽になった時に実行するコードを与えられることになります。仮に、<code>else</code>式を与えずに条件式が偽になったら、
プログラムは単に<code>if</code>ブロックを無視して次のコードを実行しにいきます。</p>
<!-- Try running this code; you should see the following output: -->
<p>このコードを走らせてみましょう; 以下のような出力を目の当たりにするはずです:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was true
</code></pre>
<!-- Let’s try changing the value of `number` to a value that makes the condition -->
<!-- `false` to see what happens: -->
<p><code>number</code>の値を条件が<code>false</code>になるような値に変更してどうなるか確かめてみましょう:</p>
<pre><code class="language-rust ignore">let number = 7;
</code></pre>
<!-- Run the program again, and look at the output: -->
<p>再度プログラムを実行して、出力に注目してください:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was false
</code></pre>
<!-- It’s also worth noting that the condition in this code *must* be a `bool`. If -->
<!-- the condition isn’t a `bool`, we’ll get an error. For example, try running the -->
<!-- following code: -->
<p>このコード内の条件式は、<code>bool</code>型で<em>なければならない</em>ことにも触れる価値があります。
条件式が、<code>bool</code>型でない時は、エラーになります。例えば、試しに以下のコードを実行してみてください:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);     // 数値は3です
    }
}
</code></pre>
<!-- The `if` condition evaluates to a value of `3` this time, and Rust throws an -->
<!-- error: -->
<p>今回、<code>if</code>の条件式は<code>3</code>という値に評価され、コンパイラがエラーを投げます:</p>
<pre><code class="language-text">error[E0308]: mismatched types
              (型が合いません)
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected bool, found integral variable
  |               (bool型を予期したのに、整数変数が見つかりました)
  |
  = note: expected type `bool`
             found type `{integer}`
</code></pre>
<!-- The error indicates that Rust expected a `bool` but got an integer. Unlike -->
<!-- languages such as Ruby and JavaScript, Rust will not automatically try to -->
<!-- convert non-Boolean types to a Boolean. You must be explicit and always provide -->
<!-- `if` with a Boolean as its condition. If we want the `if` code block to run -->
<!-- only when a number is not equal to `0`, for example, we can change the `if` -->
<!-- expression to the following: -->
<p>このエラーは、コンパイラは<code>bool</code>型を予期していたのに、整数だったことを示唆しています。
RubyやJavaScriptなどの言語とは異なり、Rustでは、論理値以外の値が、自動的に論理値に変換されることはありません。
明示的に必ず<code>if</code>には条件式として、<code>論理値</code>を与えなければなりません。
例えば、数値が<code>0</code>以外の時だけ<code>if</code>のコードを走らせたいなら、以下のように<code>if</code>式を変更することができます:</p>
<!--<span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);   // 数値は0以外の何かです
    }
}
</code></pre></pre>
<!-- Running this code will print `number was something other than zero`. -->
<p>このコードを実行したら、<code>number was something other than zero</code>と表示されるでしょう。</p>
<!-- #### Handling Multiple Conditions with `else if` -->
<a class="header" href="print.html#else-ifで複数の条件を扱う" id="else-ifで複数の条件を扱う"><h4><code>else if</code>で複数の条件を扱う</h4></a>
<!-- You can have multiple conditions by combining `if` and `else` in an `else if` -->
<!-- expression. For example: -->
<p><code>if</code>と<code>else</code>を組み合わせて<code>else if</code>式にすることで複数の条件を持たせることもできます。例です:</p>
<!--<span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        // 数値は4で割り切れます
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        // 数値は3で割り切れます
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        // 数値は2で割り切れます
        println!(&quot;number is divisible by 2&quot;);
    } else {
        // 数値は4、3、2で割り切れません
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<!-- This program has four possible paths it can take. After running it, you should -->
<!-- see the following output: -->
<p>このプログラムには、通り道が4つあります。実行後、以下のような出力を目の当たりにするはずです:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<!-- When this program executes, it checks each `if` expression in turn and executes -->
<!-- the first body for which the condition holds true. Note that even though 6 is -->
<!-- divisible by 2, we don’t see the output `number is divisible by 2`, nor do we -->
<!-- see the `number is not divisible by 4, 3, or 2` text from the `else` block. -->
<!-- That's because Rust will only execute the block for the first true condition, and -->
<!-- once it finds one, it won’t even check the rest. -->
<p>このプログラムを実行すると、<code>if</code>式が順番に吟味され、最初に条件が真になった本体が実行されます。
6は2で割り切れるものの、<code>number is devisible by 2</code>や、
<code>else</code>ブロックの<code>number is not divisible by 4, 3, or 2</code>という出力はされないことに注目してください。
それは、言語が最初の真条件のブロックのみを実行し、
条件に合ったものが見つかったら、残りはチェックすらしないからです。</p>
<!-- Using too many `else if` expressions can clutter your code, so if you have more -->
<!-- than one, you might want to refactor your code. Chapter 6 describes a powerful -->
<!-- Rust branching construct called `match` for these cases. -->
<p><code>else if</code>式を使いすぎると、コードがめちゃくちゃになってしまうので、1つ以上あるなら、
コードをリファクタリングしたくなるかもしれません。これらのケースに有用な<code>match</code>と呼ばれる、
強力なRustの枝分かれ文法要素については第6章で解説します。</p>
<!-- #### Using `if` in a `let` Statement -->
<a class="header" href="print.html#let文内でif式を使う" id="let文内でif式を使う"><h4><code>let</code>文内で<code>if</code>式を使う</h4></a>
<!-- Because `if` is an expression, we can use it on the right side of a `let` -->
<!-- statement, as in Listing 3-2. -->
<p><code>if</code>は式なので、<code>let</code>文の右辺に持ってくることができます。リスト3-2のようにですね。</p>
<!--<span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    // numberの値は、{}です
    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<!-- <span class="caption">Listing 3-2: Assigning the result of an `if` expression
to a variable</span> -->
<p><span class="caption">リスト3-2: <code>if</code>式の結果を変数に代入する</span></p>
<!-- The `number` variable will be bound to a value based on the outcome of the `if` -->
<!-- expression. Run this code to see what happens: -->
<p>この<code>number</code>変数は、<code>if</code>式の結果に基づいた値に束縛されます。このコードを走らせてどうなるか確かめてください:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<!-- Remember that blocks of code evaluate to the last expression in them, and -->
<!-- numbers by themselves are also expressions. In this case, the value of the -->
<!-- whole `if` expression depends on which block of code executes. This means the -->
<!-- values that have the potential to be results from each arm of the `if` must be -->
<!-- the same type; in Listing 3-2, the results of both the `if` arm and the `else` -->
<!-- arm were `i32` integers. If the types are mismatched, as in the following -->
<!-- example, we'll get an error: -->
<p>一連のコードは、そのうちの最後の式に評価され、数値はそれ単独でも式になることを思い出してください。
今回の場合、この<code>if</code>式全体の値は、どのブロックのコードが実行されるかに基づきます。これはつまり、
<code>if</code>の各アームの結果になる可能性がある値は、同じ型でなければならないということになります;
リスト3-4で、<code>if</code>アームも<code>else</code>アームも結果は、<code>i32</code>の整数でした。以下の例のように、
型が合わない時には、エラーになるでしょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        &quot;six&quot;
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<!-- When we try to compile this code, we’ll get an error. The `if` and `else` arms -->
<!-- have value types that are incompatible, and Rust indicates exactly where to -->
<!-- find the problem in the program: -->
<p>このコードをコンパイルしようとすると、エラーになります。<code>if</code>と<code>else</code>アームは互換性のない値の型になり、
コンパイラがプログラム内で問題の見つかった箇所をスバリ指摘してくれます:</p>
<pre><code class="language-text">error[E0308]: if and else have incompatible types
              (ifとelseの型に互換性がありません)
 --&gt; src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;six&quot;
8 | |     };
  | |_____^ expected integral variable, found &amp;str
  |         (整数変数を予期しましたが、&amp;strが見つかりました)
  |
  = note: expected type `{integer}`
             found type `&amp;str`
</code></pre>
<!-- The expression in the `if` block evaluates to an integer, and the expression in -->
<!-- the `else` block evaluates to a string. This won’t work because variables must -->
<!-- have a single type. Rust needs to know at compile time what type the `number` -->
<!-- variable is, definitively, so it can verify at compile time that its type is -->
<!-- valid everywhere we use `number`. Rust wouldn’t be able to do that if the type -->
<!-- of `number` was only determined at runtime; the compiler would be more complex -->
<!-- and would make fewer guarantees about the code if it had to keep track of -->
<!-- multiple hypothetical types for any variable. -->
<p><code>if</code>ブロックの式は整数に評価され、<code>else</code>ブロックの式は文字列に評価されます。これでは動作しません。
変数は単独の型でなければならないからです。コンパイラは、コンパイル時に<code>number</code>変数の型を確実に把握する必要があるため、
コンパイル時に<code>number</code>が使われている箇所全部で型が有効かどうか検査することができるのです。
<code>number</code>の型が実行時にしか決まらないのであれば、コンパイラはそれを実行することができなくなってしまいます;
どの変数に対しても、架空の複数の型があることを追いかけなければならないのであれば、コンパイラはより複雑になり、
コードに対して行える保証が少なくなってしまうでしょう。</p>
<!-- ### Repetition with Loops -->
<a class="header" href="print.html#aループでの繰り返し" id="aループでの繰り返し"><h3>ループでの繰り返し</h3></a>
<!-- It’s often useful to execute a block of code more than once. For this task, -->
<!-- Rust provides several *loops*. A loop runs through the code inside the loop -->
<!-- body to the end and then starts immediately back at the beginning. To -->
<!-- experiment with loops, let’s make a new project called *loops*. -->
<p>一連のコードを1回以上実行できると、しばしば役に立ちます。この作業用に、
Rustにはいくつかの<em>ループ</em>が用意されています。ループは、本体内のコードを最後まで実行し、
直後にまた最初から処理を開始します。
ループを試してみるのに、<em>loops</em>という名の新プロジェクトを作りましょう。</p>
<!-- Rust has three kinds of loops: `loop`, `while`, and `for`. Let’s try each one. -->
<p>Rustには3種類のループが存在します: <code>loop</code>と<code>while</code>と<code>for</code>です。 それぞれ試してみましょう。</p>
<!-- #### Repeating Code with `loop` -->
<a class="header" href="print.html#loopでコードを繰り返す" id="loopでコードを繰り返す"><h4><code>loop</code>でコードを繰り返す</h4></a>
<!-- The `loop` keyword tells Rust to execute a block of code over and over again -->
<!-- forever or until you explicitly tell it to stop. -->
<p><code>loop</code>キーワードを使用すると、同じコードを何回も何回も永遠に明示的にやめさせるまで実行します。</p>
<!-- As an example, change the *src/main.rs* file in your *loops* directory to look -->
<!-- like this: -->
<p>例として、<em>loops</em>ディレクトリの<em>src/main.rs</em>ファイルを以下のような感じに書き換えましょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);   // また
    }
}
</code></pre>
<!-- When we run this program, we’ll see `again!` printed over and over continuously -->
<!-- until we stop the program manually. Most terminals support a keyboard shortcut, -->
<!-- <span class="keystroke">ctrl-c</span>, to halt a program that is stuck in a -->
<!-- continual loop. Give it a try: -->
<p>このプログラムを実行すると、プログラムを手動で止めるまで、何度も何度も続けて<code>again!</code>と出力するでしょう。
ほとんどのターミナルで<span class="keystroke">ctrl-c</span>というショートカットが使え、
永久ループに囚われてしまったプログラムを終了させられます。試しにやってみましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<!-- The symbol `^C` represents where you pressed <span class="keystroke">ctrl-c -->
<!-- </span>. You may or may not see the word `again!` printed after the `^C`, -->
<!-- depending on where the code was in the loop when it received the halt signal. -->
<p><code>^C</code>という記号が出た場所が、<span class="keystroke">ctrl-c</span>を押した場所です。<code>^C</code>の後には<code>again!</code>と表示されたり、
されなかったりします。ストップシグナルをコードが受け取った時にループのどこにいたかによります。</p>
<!-- Fortunately, Rust provides another, more reliable way to break out of a loop. -->
<!-- You can place the `break` keyword within the loop to tell the program when to -->
<!-- stop executing the loop. Recall that we did this in the guessing game in the -->
<!-- “Quitting After a Correct Guess” section of Chapter 2 to exit the program when -->
<!-- the user won the game by guessing the correct number. -->
<p>幸いなことに、Rustにはループを抜け出す別のより信頼できる手段があります。
ループ内に<code>break</code>キーワードを配置することでプログラムに実行を終了すべきタイミングを教えることができます。
第2章の「正しい予想をした後に終了する」節の数当てゲーム内でこれをして、ユーザが予想を的中させ、
ゲームに勝った時にプログラムを終了させたことを思い出してください。</p>
<!-- #### Conditional Loops with `while` -->
<a class="header" href="print.html#whileで条件付きループ" id="whileで条件付きループ"><h4><code>while</code>で条件付きループ</h4></a>
<!-- It’s often useful for a program to evaluate a condition within a loop. While -->
<!-- the condition is true, the loop runs. When the condition ceases to be true, the -->
<!-- program calls `break`, stopping the loop. This loop type could be implemented -->
<!-- using a combination of `loop`, `if`, `else`, and `break`; you could try that -->
<!-- now in a program, if you’d like. -->
<p>プログラムにとってループ内で条件式を評価できると、有益なことがしばしばあります。条件が真の間、
ループが走るわけです。条件が真でなくなった時にプログラムは<code>break</code>を呼び出し、ループを終了します。
このタイプのループは、<code>loop</code>、<code>if</code>、<code>else</code>、<code>break</code>を組み合わせることでも実装できます;
お望みなら、プログラムで試してみるのもいいでしょう。</p>
<!-- However, this pattern is so common that Rust has a built-in language construct -->
<!-- for it, called a `while` loop. Listing 3-3 uses `while`: the program loops -->
<!-- three times, counting down each time, and then, after the loop, it prints -->
<!-- another message and exits: -->
<p>しかし、このパターンは頻出するので、Rustにはそれ用の文法要素が用意されていて、<code>while</code>ループと呼ばれます。
リスト3-3は、<code>while</code>を使用しています: プログラムは3回ループし、それぞれカウントダウンします。
それから、ループ後に別のメッセージを表示して終了します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number = number - 1;
    }

    // 発射！
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<!-- <span class="caption">Listing 3-3: Using a `while` loop to run code while a -->
<!-- condition holds true</span> -->
<p><span class="caption">リスト3-3: 条件が真の間、コードを走らせる<code>while</code>ループを使用する</span></p>
<!-- This construct eliminates a lot of nesting that would be necessary if you used -->
<!-- `loop`, `if`, `else`, and `break`, and it’s clearer. While a condition holds -->
<!-- true, the code runs; otherwise, it exits the loop. -->
<p>この文法要素により、<code>loop</code>、<code>if</code>、<code>else</code>、<code>break</code>を使った時に必要になるネストがなくなり、
より明確になります。条件が真の間、コードは実行されます; そうでなければ、ループを抜けます.</p>
<!-- #### Looping Through a Collection with `for` -->
<a class="header" href="print.html#forでコレクションを覗き見る" id="forでコレクションを覗き見る"><h4><code>for</code>でコレクションを覗き見る</h4></a>
<!-- You could use the `while` construct to loop over the elements of a collection, -->
<!-- such as an array. For example, let's look at Listing 3-4. -->
<p><code>while</code>要素を使って配列などのコレクションの要素を覗き見ることができます。例えば、リスト3-4を見ましょう。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        // 値は{}です
        println!(&quot;the value is: {}&quot;, a[index]);

        index = index + 1;
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 3-4: Looping through each element of a collection -->
<!-- using a `while` loop</span> -->
<p><span class="caption">リスト3-4: <code>while</code>ループでコレクションの各要素を覗き見る</span></p>
<!-- Here, the code counts up through the elements in the array. It starts at index -->
<!-- `0`, and then loops until it reaches the final index in the array (that is, -->
<!-- when `index < 5` is no longer true). Running this code will print every element -->
<!-- in the array: -->
<p>ここで、コードは配列の要素を順番にカウントアップして覗いています。番号0から始まり、
配列の最終番号に到達するまでループします(つまり、<code>index &lt; 5</code>が真でなくなる時です)。
このコードを走らせると、配列内の全要素が出力されます:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<!-- All five array values appear in the terminal, as expected. Even though `index` -->
<!-- will reach a value of `5` at some point, the loop stops executing before trying -->
<!-- to fetch a sixth value from the array. -->
<p>予想通り、配列の5つの要素が全てターミナルに出力されています。<code>index</code>変数の値はどこかで<code>5</code>という値になるものの、
配列から6番目の値を拾おうとする前にループは実行を終了します。</p>
<!-- But this approach is error prone; we could cause the program to panic if the -->
<!-- index length is incorrect. It’s also slow, because the compiler adds runtime -->
<!-- code to perform the conditional check on every element on every iteration -->
<!-- through the loop. -->
<p>しかし、このアプローチは間違いが発生しやすいです; 添え字の長さが間違っていれば、
プログラムはパニックしてしまいます。また遅いです。
コンパイラが実行時にループの各回ごとに境界値チェックを行うようなコードを追加するからです。</p>
<!-- As a more efficient alternative, you can use a `for` loop and execute some code -->
<!-- for each item in a collection. A `for` loop looks like this code in Listing 3-5. -->
<p>より効率的な対立案として、<code>for</code>ループを使ってコレクションの各アイテムに対してコードを実行することができます。
<code>for</code>ループはリスト3-5のこんな見た目です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        // 値は{}です
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 3-5: Looping through each element of a collection -->
<!-- using a `for` loop</span> -->
<p><span class="caption">リスト3-4: <code>for</code>ループを使ってコレクションの各要素を覗き見る</span></p>
<!-- When we run this code, we’ll see the same output as in Listing 3-4. More -->
<!-- importantly, we’ve now increased the safety of the code and eliminated the -->
<!-- chance of bugs that might result from going beyond the end of the array or not -->
<!-- going far enough and missing some items. -->
<p>このコードを走らせたら、リスト3-4と同じ出力が得られるでしょう。より重要なのは、
コードの安全性を向上させ、配列の終端を超えてアクセスしたり、
終端に届く前にループを終えてアイテムを見逃してしまったりするバグの可能性を完全に排除したことです。</p>
<!-- For example, in the code in Listing 3-4, if you removed an item from the `a` -->
<!-- array but forgot to update the condition to `while index < 4`, the code would -->
<!-- panic. Using the `for` loop, you don’t need to remember to change any other -->
<!-- code if you changed the number of values in the array. -->
<p>例えば、リスト3-4のコードで、<code>a</code>配列からアイテムを1つ削除したのに、条件式を<code>while index &lt; 4</code>にするのを忘れていたら、
コードはパニックします。<code>for</code>ループを使っていれば、配列の要素数を変えても、
他のコードをいじることを覚えておく必要はなくなるわけです。</p>
<!-- The safety and conciseness of `for` loops make them the most commonly used loop -->
<!-- construct in Rust. Even in situations in which you want to run some code a -->
<!-- certain number of times, as in the countdown example that used a `while` loop -->
<!-- in Listing 3-3, most Rustaceans would use a `for` loop. The way to do that -->
<!-- would be to use a `Range`, which is a type provided by the standard library -->
<!-- that generates all numbers in sequence starting from one number and ending -->
<!-- before another number. -->
<p><code>for</code>ループのこの安全性と簡潔性により、Rustで使用頻度の最も高いループになっています。
リスト3-5で<code>while</code>ループを使ったカウントダウンサンプルのように、一定の回数、同じコードを実行したいような状況であっても、
多くのRustaceanは、<code>for</code>ループを使うでしょう。どうやってやるかといえば、
<code>Range</code>型を使うのです。Range型は、標準ライブラリで提供される片方の数字から始まって、
もう片方の数字未満の数値を順番に生成する型です。</p>
<!-- Here’s what the countdown would look like using a `for` loop and another method -->
<!-- we’ve not yet talked about, `rev`, to reverse the range: -->
<p><code>for</code>ループを使い、まだ話していない別のメソッド<code>rev</code>を使って範囲を逆順にしたカウントダウンはこうなります:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<!-- This code is a bit nicer, isn’t it? -->
<p>こちらのコードの方が少しいいでしょう？</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-2" id="aまとめ-2"><h2>まとめ</h2></a>
<!-- You made it! That was a sizable chapter: you learned about variables, scalar -->
<!-- and compound data types, functions, comments, `if` expressions, and loops! If -->
<!-- you want to practice with the concepts discussed in this chapter, try building -->
<!-- programs to do the following: -->
<p>やりましたね！結構長い章でした: 変数とスカラー値、複合データ型、関数、コメント、<code>if</code>式、そして、ループについて学びました！
この章で議論した概念について経験を積みたいのであれば、以下のことをするプログラムを組んでみてください:</p>
<!-- * Convert temperatures between Fahrenheit and Celsius. -->
<!-- * Generate the nth Fibonacci number. -->
<!-- * Print the lyrics to the Christmas carol “The Twelve Days of Christmas,” -->
<!--   taking advantage of the repetition in the song. -->
<ul>
<li>温度を華氏と摂氏で変換する。</li>
<li>フィボナッチ数列のn番目を生成する。</li>
<li>クリスマスキャロルの定番、&quot;The Twelve Days of Christmas&quot;の歌詞を、
曲の反復性を利用して出力する。</li>
</ul>
<!-- When you’re ready to move on, we’ll talk about a concept in Rust that *doesn’t* -->
<!-- commonly exist in other programming languages: ownership. -->
<p>次に進む準備ができたら、他の言語にはあまり存在<em>しない</em>Rustの概念について話しましょう: 所有権です。</p>
<!-- # Understanding Ownership -->
<a class="header" href="print.html#a所有権を理解する" id="a所有権を理解する"><h1>所有権を理解する</h1></a>
<!-- Ownership is Rust’s most unique feature, and it enables Rust to make memory -->
<!-- safety guarantees without needing a garbage collector. Therefore, it’s -->
<!-- important to understand how ownership works in Rust. In this chapter we’ll -->
<!-- talk about ownership as well as several related features: borrowing, slices, -->
<!-- and how Rust lays data out in memory. -->
<p>所有権はRustの最もユニークな機能であり、これのおかげでガベージコレクタなしで安全性担保を行うことができるのです。
故に、Rustにおいて、所有権がどう動作するのかを理解するのは重要です。この章では、所有権以外にも、関連する機能を
いくつか話していきます: 借用、スライス、そして、コンパイラがデータをメモリにどう配置するかです。</p>
<!-- ## What Is Ownership? -->
<a class="header" href="print.html#a所有権とは" id="a所有権とは"><h2>所有権とは？</h2></a>
<!-- Rust’s central feature is *ownership*. Although the feature is straightforward -->
<!-- to explain, it has deep implications for the rest of the language. -->
<p>Rustの中心的な機能は、<em>所有権</em>です。機能は説明するのに単純なのですが、言語の残りの機能全てにかかるほど
深い裏の意味を含んでいるのです。</p>
<!-- All programs have to manage the way they use a computer’s memory while running. -->
<!-- Some languages have garbage collection that constantly looks for no longer used -->
<!-- memory as the program runs; in other languages, the programmer must explicitly -->
<!-- allocate and free the memory. Rust uses a third approach: memory is managed -->
<!-- through a system of ownership with a set of rules that the compiler checks at -->
<!-- compile time. None of the ownership features slow down your proram while it's -->
<!-- running. -->
<p>全てのプログラムは、実行中にコンピュータのメモリの使用方法を管理する必要があります。プログラムが動作するにつれて、
定期的に使用されていないメモリを検索するガベージコレクションを持つ言語もありますが、他の言語では、
プログラマが明示的にメモリを確保したり、解放したりしなければなりません。Rustでは第3の選択肢を取っています:
メモリは、コンパイラがコンパイル時にチェックする一定の規則とともに所有権システムを通じて管理されています。
どの所有権機能も、実行中にプログラムの動作を遅くすることはありません。</p>
<!-- Because ownership is a new concept for many programmers, it does take some time -->
<!-- to get used to. The good news is that the more experienced you become with Rust -->
<!-- and the rules of the ownership system, the more you’ll be able to naturally -->
<!-- develop code that is safe and efficient. Keep at it!  -->
<p>所有権は多くのプログラマにとって新しい概念なので、慣れるまでに時間がかかります。
Rustと所有権システムの規則と経験を積むにつれて、自然に安全かつ効率的なコードを構築できるようになることは、
素晴らしいお知らせです。その調子でいきましょう！</p>
<!-- When you understand ownership, you’ll have a solid foundation for understanding -->
<!-- the features that make Rust unique. In this chapter, you’ll learn ownership by -->
<!-- working through some examples that focus on a very common data structure: -->
<!-- strings. -->
<p>所有権を理解した時、Rustを際立たせる機能の理解に対する強固な礎を得ることになるでしょう。この章では、
非常に一般的なデータ構造に着目した例を取り扱うことで所有権を学んでいくでしょう: 文字列です。</p>
<!-- PROD: START BOX -->
<!-- 引用符付きの行は、日本語と英語を交互に書くとmdbookに正しく解析してもらえないので、英語、日本語の順にまとめて配置します -->
<!-- ### The Stack and the Heap -->
<!-- > In many programming languages, you don’t have to think about the stack and -->
<!-- > the heap very often. But in a systems programming language like Rust, whether -->
<!-- > a value is on the stack or the heap has more of an effect on how the language -->
<!-- > behaves and why you have to make certain decisions. Parts of ownership will -->
<!-- > be described in relation to the stack and the heap later in this chapter, so -->
<!-- > here is a brief explanation in preparation. -->
<!-- > Both the stack and the heap are parts of memory that is available to your code -->
<!-- > to use at runtime, but they are structured in different ways. The stack stores -->
<!-- > values in the order it gets them and removes the values in the opposite order. -->
<!-- > This is referred to as *last in, first out*. Think of a stack of plates: when -->
<!-- > you add more plates, you put them on top of the pile, and when you need a -->
<!-- > plate, you take one off the top. Adding or removing plates from the middle or -->
<!-- > bottom wouldn’t work as well! Adding data is called *pushing onto the stack*, -->
<!-- > and removing data is called *popping off the stack*. -->
<!-- > The stack is fast because of the way it accesses the data: it never has to -->
<!-- > search for a place to put new data or a place to get data from because that -->
<!-- > place is always the top. Another property that makes the stack fast is that all -->
<!-- > data on the stack must take up a known, fixed size. -->
<!-- > Data with a size unknown at compile time or a size that might change can be -->
<!-- > stored on the heap instead. The heap is less organized: when you put data on -->
<!-- > the heap, you ask for some amount of space. The operating system finds an -->
<!-- > empty spot somewhere in the heap that is big enough, marks it as being in -->
<!-- > use, and returns a *pointer*, which is the address of that location. This -->
<!-- > process is called *allocating on the heap*, sometimes abbreviated as just -->
<!-- > “allocating.” Pushing values onto the stack is not considered allocating. -->
<!-- > Because the pointer is a known, fixed size, you can store the pointer on the -->
<!-- > stack, but when you want the actual data, you have to follow the pointer. -->
<!-- > Think of being seated at a restaurant. When you enter, you state the number of -->
<!-- > people in your group, and the staff finds an empty table that fits everyone and -->
<!-- > leads you there. If someone in your group comes late, they can ask where -->
<!-- > you've been seated to find you. -->
<!-- > Accessing data in the heap is slower than accessing data on the stack because -->
<!-- > you have to follow a pointer to get there. Contemporary processors are faster -->
<!-- > if they jump around less in memory. Continuing the analogy, consider a server -->
<!-- > at a restaurant taking orders from many tables. It’s most efficient to get -->
<!-- > all the orders at one table before moving on to the next table. Taking an -->
<!-- > order from table A, then an order from table B, then one from A again, and -->
<!-- > then one from B again would be a much slower process. By the same token, a -->
<!-- > processor can do its job better if it works on data that’s close to other -->
<!-- > data (as it is on the stack) rather than farther away (as it can be on the -->
<!-- > heap). Allocating a large amount of space on the heap can also take time. -->
<!-- > When your code calls a function, the values passed into the function -->
<!-- > (including, potentially, pointers to data on the heap) and the function’s -->
<!-- > local variables get pushed onto the stack. When the function is over, those -->
<!-- > values get popped off the stack. -->
<!-- > Keeping track of what parts of code are using what data on the heap, -->
<!-- > minimizing the amount of duplicate data on the heap, and cleaning up unused -->
<!-- > data on the heap so we don’t run out of space are all problems that ownership -->
<!-- > addresses. Once you understand ownership, you won’t need to think about the -->
<!-- > stack and the heap very often, but knowing that managing heap data is why -->
<!-- > ownership exists can help explain why it works the way it does. -->
<blockquote>
<a class="header" href="print.html#aスタックとヒープ" id="aスタックとヒープ"><h3>スタックとヒープ</h3></a>
<p>多くのプログラミング言語において、スタックとヒープについて考える機会はそう多くないでしょう。
しかし、Rustのようなシステムプログラミング言語においては、値がスタックに載るかヒープに載るかは、
言語の振る舞い方や、特定の決断を下す理由などに影響以上のものを与えるのです。
この章の後半でスタックとヒープを絡めて所有権に一部は解説されるので、ここでちょっと予行演習をしておきましょう。</p>
<p>スタックもヒープも、実行時にコードが使用できるメモリの一部になりますが、異なる手段で構成されています。
スタックは、得た順番に値を並べ、逆の順で値を取り除いていきます。これは、
<em>last in, first out</em>(<code>訳注</code>: あえて日本語にするなら、けつ入れ頭出しといったところでしょうか)と呼ばれます。
お皿の山を思い浮かべてください: お皿を追加する時には、山の一番上に置き、お皿が必要になったら、一番上から1枚を取り去りますよね。
途中や一番下に追加したり、取り除いたりすることは同じようにはできません。データを追加することは、
<em>スタックにpushする</em>といい、データを取り除くことは、<em>スタックからpopする</em>と表現します(<code>訳注</code>:
これらの動作に対する画一的な日本語訳を見かけたことはありません)。</p>
<p>データへのアクセス方法のおかげで、スタックは高速です: 新データを置いたり、
データを取得する場所を探す必要が絶対にないわけです。というのも、その場所は常に一番上だからですね。スタックを高速にする特性は、
他にもあり、それはスタック上のデータは全て既知の固定サイズにならなければならないということです。</p>
<p>コンパイル時にサイズがわからなかったり、サイズが可変のデータについては、代わりにヒープに格納することができます。
ヒープは、もっとごちゃごちゃしています: ヒープにデータを置く時、あるサイズのスペースを求めます。
OSはヒープ上に十分な大きさの空の領域を見つけ、使用中にし、<em>ポインタ</em>を返してきます。ポインタとは、その場所へのアドレスです。
この過程は、<em>ヒープに領域を確保する</em>と呼ばれ、時としてそのフレーズを単に<em>allocateする</em>などと省略したりします。
(<code>訳注</code>: こちらもこなれた日本語訳はないでしょう。allocateはメモリを確保すると訳したいところですが)
スタックに値を載せることは、メモリ確保とは考えられません。ポインタは、既知の固定サイズなので、
スタックに保管することができますが、実データが必要になったら、ポインタを追いかける必要があります。</p>
<p>レストランで席を確保することを考えましょう。入店したら、グループの人数を告げ、
店員が全員座れる空いている席を探し、そこまで誘導します。もしグループの誰かが遅れて来るのなら、
着いた席の場所を尋ねてあなたを発見することができます。</p>
<p>ヒープへのデータアクセスは、スタックのデータへのアクセスよりも低速です。
ポインタを追って目的の場所に到達しなければならないからです。現代のプロセッサは、メモリをあちこち行き来しなければ、
より速くなります。似た例えを続けましょう。レストランで多くのテーブルから注文を受ける給仕人を考えましょう。最も効率的なのは、
次のテーブルに移らずに、一つのテーブルで全部の注文を受け付けてしまうことです。テーブルAで注文を受け、
それからテーブルBの注文、さらにまたA、それからまたBと渡り歩くのは、かなり低速な過程になってしまうでしょう。
同じ意味で、プロセッサは、
データが隔離されている(ヒープではそうなっている可能性がある)よりも近くにある(スタックではこうなる)ほうが、
仕事をうまくこなせるのです。ヒープに大きな領域を確保する行為も時間がかかることがあります。</p>
<p>コードが関数を呼び出すと、関数に渡された値(ヒープのデータへのポインタも含まれる可能性あり)と、
関数のローカル変数がスタックに載ります。関数の実行が終了すると、それらの値はスタックから取り除かれます。</p>
<p>どの部分のコードがどのヒープ上のデータを使用しているか把握すること、ヒープ上の重複するデータを最小化すること、
メモリ不足にならないようにヒープ上の未使用のデータを掃除することは全て、所有権が解決する問題です。
一度所有権を理解したら、あまり頻繁にスタックとヒープに関して考える必要はなくなるでしょうが、
ヒープデータを管理することが所有権の存在する理由だと知っていると、所有権がありのままで動作する理由を
説明するのに役立つこともあります。</p>
</blockquote>
<!-- PROD: END BOX -->
<!-- ### Ownership Rules -->
<a class="header" href="print.html#a所有権規則" id="a所有権規則"><h3>所有権規則</h3></a>
<!-- First, let’s take a look at the ownership rules. Keep these rules in mind as we -->
<!-- work through the examples that illustrate them: -->
<p>まず、所有権のルールについて見ていきましょう。この規則を具体化する例を
扱っていく間もこれらのルールを肝に命じておいてください:</p>
<!-- * Each value in Rust has a variable that’s called its *owner*. -->
<!-- * There can only be one owner at a time. -->
<!-- * When the owner goes out of scope, the value will be dropped. -->
<ul>
<li>Rustの各値は、<em>所有者</em>と呼ばれる変数と対応している。</li>
<li>いかなる時も所有者は一つである。</li>
<li>所有者がスコープから外れたら、値は破棄される。</li>
</ul>
<!-- ### Variable Scope -->
<a class="header" href="print.html#a変数スコープ" id="a変数スコープ"><h3>変数スコープ</h3></a>
<!-- We’ve walked through an example of a Rust program already in Chapter 2. Now -->
<!-- that we’re past basic syntax, we won’t include all the `fn main() {` code in -->
<!-- examples, so if you’re following along, you’ll have to put the following -->
<!-- examples inside a `main` function manually. As a result, our examples will be a -->
<!-- bit more concise, letting us focus on the actual details rather than -->
<!-- boilerplate code. -->
<p>第2章で、Rustプログラムの例はすでに見ています。もう基本的な記法は通り過ぎたので、
<code>fn main() {</code>というコードはもう例に含みません。従って、例をなぞっているなら、
これからの例は<code>main</code>関数に手動で入れ込まなければいけなくなるでしょう。結果的に、例は少々簡潔になり、
定型コードよりも具体的な詳細に集中しやすくなります。</p>
<!-- As a first example of ownership, we’ll look at the *scope* of some variables. A -->
<!-- scope is the range within a program for which an item is valid. Let’s say we -->
<!-- have a variable that looks like this: -->
<p>所有権の最初の例として、何らかの変数の<em>スコープ</em>について見ていきましょう。スコープとは、
要素が有効になるプログラム内の範囲のことです。以下のような変数があるとしましょう:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;hello&quot;;
#}</code></pre></pre>
<!-- The variable `s` refers to a string literal, where the value of the string is -->
<!-- hardcoded into the text of our program. The variable is valid from the point at -->
<!-- which it’s declared until the end of the current *scope*. Listing 4-1 has -->
<!-- comments annotating where the variable `s` is valid. -->
<p>変数<code>s</code>は、文字列リテラルを参照し、ここでは、文字列の値はプログラムのテキストとしてハードコードされています。
この変数は、宣言された地点から、現在の<em>スコープ</em>の終わりまで有効になります。リスト4-1には、
変数<code>s</code>が有効な場所に関する注釈がコメントで付記されています。</p>
<!-- ```rust -->
<!-- {                      // s is not valid here, it’s not yet declared -->
<!--    let s = "hello";   // s is valid from this point forward -->
<!--    // do stuff with s -->
<!-- }                      // this scope is now over, and s is no longer valid -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{                      // sは、ここでは有効ではない。まだ宣言されていない
    let s = &quot;hello&quot;;   // sは、ここから有効になる

    // sで作業をする
}                      // このスコープは終わり。もうsは有効ではない
#}</code></pre></pre>
<!-- <span class="caption">Listing 4-1: A variable and the scope in which it is
valid</span> -->
<p><span class="caption">リスト4-1: 変数と有効なスコープ</span></p>
<!-- In other words, there are two important points in time here: -->
<p>言い換えると、ここまでに重要な点は二つあります:</p>
<!-- * When `s` comes *into scope*, it is valid. -->
<!-- * It remains valid until it goes *out of scope*. -->
<ol>
<li><code>s</code>が<em>スコープに入る</em>と、有効になる</li>
<li><em>スコープを抜ける</em>まで、有効なまま</li>
</ol>
<!-- At this point, the relationship between scopes and when variables are valid is -->
<!-- similar to other programming languages. Now we’ll build on top of this -->
<!-- understanding by introducing the `String` type. -->
<p>ここで、スコープと変数が有効になる期間の関係は、他の言語に類似しています。さて、この理解のもとに、
<code>String</code>型を導入して構築していきましょう。</p>
<!-- ### The `String` Type -->
<a class="header" href="print.html#string型" id="string型"><h3><code>String</code>型</h3></a>
<!-- To illustrate the rules of ownership, we need a data type that is more complex -->
<!-- than the ones we covered in the "Data Types" section of Chapter 3. The types -->
<!-- covered previously are all stored on the stack and popped off the stack when -->
<!-- their scope is over, but we want to look at data that is stored on the heap and -->
<!-- explore how Rust knows when to clean up that data. -->
<p>所有権の規則を具体化するには、第3章の「データ型」節で講義したものよりも、より複雑なデータ型が必要になります。
以前講義した型は全てスタックに保管され、スコープが終わるとスタックから取り除かれますが、
ヒープに確保されるデータ型を観察して、
コンパイラがどうそのデータを掃除すべきタイミングを把握しているかを掘り下げていきたいです。</p>
<!-- We’ll use `String` as the example here and concentrate on the parts of `String` -->
<!-- that relate to ownership. These aspects also apply to other complex data types -->
<!-- provided by the standard library and that you create. We’ll discuss `String` in -->
<!-- more depth in Chapter 8. -->
<p>ここでは、例として<code>String</code>型を使用し、<code>String</code>型の所有権にまつわる部分に着目しましょう。
また、この観点は、標準ライブラリや自分で生成する他の複雑なデータ型にも適用されます。
<code>String</code>型については、第8章でより深く議論します。</p>
<!-- We’ve already seen string literals, where a string value is hardcoded into our -->
<!-- program. String literals are convenient, but they aren’t suitable for every -->
<!-- situation in which we may want to use text. One reason is that they’re -->
<!-- immutable. Another is that not every string value can be known when we write -->
<!-- our code: for example, what if we want to take user input and store it? For -->
<!-- these situations, Rust has a second string type, `String`. This type is -->
<!-- allocated on the heap and as such is able to store an amount of text that is -->
<!-- unknown to us at compile time. You can create a `String` from a string literal -->
<!-- using the `from` function, like so: -->
<p>すでに文字列リテラルは見かけましたね。文字列リテラルでは、文字列の値はプログラムにハードコードされます。
文字列リテラルは便利ですが、テキストを使いたいかもしれない場面全てに最適なわけではありません。一因は、
文字列リテラルが不変であることに起因します。別の原因は、コードを書く際に、全ての文字列値が判明するわけではないからです:
例えば、ユーザ入力を受け付け、それを保持したいとしたらどうでしょうか？このような場面用に、Rustには、
2種類目の文字列型、<code>String</code>型があります。この型はヒープにメモリを確保するので、
コンパイル時にはサイズが不明なテキストも保持することができるのです。<code>from</code>関数を使用して、
文字列リテラルから<code>String</code>型を生成できます。以下のように:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);
#}</code></pre></pre>
<!-- The double colon (`::`) is an operator that allows us to namespace this -->
<!-- particular `from` function under the `String` type rather than using some sort -->
<!-- of name like `string_from`. We’ll discuss this syntax more in the “Method -->
<!-- Syntax” section of Chapter 5 and when we talk about namespacing with modules in -->
<!-- "Module DEfinitions" in Chapter 7. -->
<p>この二重コロンは、<code>string_from</code>などの名前を使うのではなく、
<code>String</code>型直下の<code>from</code>関数を特定する働きをする演算子です。この記法について詳しくは、
第5章の「メソッド記法」節と、第7章の「モジュール定義」でモジュールを使った名前空間分けについて話をするときに議論します。</p>
<!-- This kind of string *can* be mutated: -->
<p>この種の文字列は、可変化することが<em>できます</em>:</p>
<!-- ```rust -->
<!-- let mut s = String::from("hello"); -->
<!-- s.push_str(", world!"); // push_str() appends a literal to a String -->
<!-- println!("{}", s); // This will print `hello, world!` -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str()関数は、リテラルをStringに付け加える

println!(&quot;{}&quot;, s); // これは`hello, world!`と出力する
#}</code></pre></pre>
<!-- So, what’s the difference here? Why can `String` be mutated but literals -->
<!-- cannot? The difference is how these two types deal with memory. -->
<p>では、ここでの違いは何でしょうか？なぜ、<code>String</code>型は可変化できるのに、リテラルはできないのでしょうか？
違いは、これら二つの型がメモリを扱う方法にあります。</p>
<!-- ### Memory and Allocation -->
<a class="header" href="print.html#aメモリと確保" id="aメモリと確保"><h3>メモリと確保</h3></a>
<!-- In the case of a string literal, we know the contents at compile time, so the -->
<!-- text is hardcoded directly into the final executable. This is why string -->
<!-- literals are fast and efficient. But these properties only come from the string -->
<!-- literal's immutability. Unfortunately, we can’t put a blob of memory into the -->
<!-- binary for each piece of text whose size is unknown at compile time and whose -->
<!-- size might change while running the program. -->
<p>文字列リテラルの場合、中身はコンパイル時に判明しているので、テキストは最終的なバイナリファイルに直接ハードコードされます。
このため、文字列リテラルは、高速で効率的になるのです。しかし、これらの特性は、
その文字列リテラルの不変性にのみ端を発するものです。残念なことに、コンパイル時にサイズが不明だったり、
プログラム実行に合わせてサイズが可変なテキスト片用に一塊のメモリをバイナリに確保しておくことは不可能です。</p>
<!-- With the `String` type, in order to support a mutable, growable piece of text, -->
<!-- we need to allocate an amount of memory on the heap, unknown at compile time, -->
<!-- to hold the contents. This means: -->
<p><code>String</code>型では、可変かつ伸長可能なテキスト破片をサポートするために、コンパイル時には不明な量のメモリを
ヒープに確保して内容を保持します。つまり:</p>
<!-- * The memory must be requested from the operating system at runtime. -->
<!-- * We need a way of returning this memory to the operating system when we’re -->
<!-- done with our `String`. -->
<ul>
<li>メモリは、実行時にOSに要求される。</li>
<li><code>String</code>型を使用し終わったら、OSにこのメモリを返還する方法が必要である。</li>
</ul>
<!-- That first part is done by us: when we call `String::from`, its implementation -->
<!-- requests the memory it needs. This is pretty much universal in programming -->
<!-- languages. -->
<p>この最初の部分は、すでにしています: <code>String::from</code>関数を呼んだら、その実装が必要なメモリを要求するのです。
これは、プログラミング言語において、極めて普遍的です。</p>
<!-- However, the second part is different. In languages with a *garbage collector -->
<!-- (GC)*, the GC keeps track and cleans up memory that isn’t being used anymore, -->
<!-- and we don’t need to think about it. Without a GC, it’s our responsibility to -->
<!-- identify when memory is no longer being used and call code to explicitly return -->
<!-- it, just as we did to request it. Doing this correctly has historically been a -->
<!-- difficult programming problem. If we forget, we’ll waste memory. If we do it -->
<!-- too early, we’ll have an invalid variable. If we do it twice, that’s a bug too. -->
<!-- We need to pair exactly one `allocate` with exactly one `free`. -->
<!-- かっこがあると、*が機能しないようなので、(GC)の部分には指定していません -->
<p>しかしながら、2番目の部分は異なります。<em>ガベージコレクタ</em>(GC)付きの言語では、GCがこれ以上、
使用されないメモリを検知して片付けるため、プログラマは、そのことを考慮する必要はありません。
GCがないなら、メモリがもう使用されないことを見計らって、明示的に返還するコードを呼び出すのは、
プログラマの責任になります。ちょうど要求の際にしたようにですね。これを正確にすることは、
歴史的にも難しいプログラミング問題の一つであり続けています。もし、忘れていたら、メモリを無駄にします。
タイミングが早すぎたら、無効な変数を作ってしまいます。2回解放してしまっても、バグになるわけです。
<code>allocate</code>と<code>free</code>は完璧に1対1対応にしなければならないのです。</p>
<!-- Rust takes a different path: the memory is automatically returned once the -->
<!-- variable that owns it goes out of scope. Here’s a version of our scope example -->
<!-- from Listing 4-1 using a `String` instead of a string literal: -->
<p>Rustは、異なる道を歩んでいます: ひとたび、メモリを所有している変数がスコープを抜けたら、
メモリは自動的に返還されます。こちらの例は、
リスト4-1のスコープ例を文字列リテラルから<code>String</code>型を使うものに変更したバージョンになります:</p>
<!-- ```rust -->
<!-- { -->
<!--    let s = String::from("hello"); // s is valid from this point forward -->
<!--    // do stuff with s -->
<!--}                                  // this scope is now over, and s is no -->
<!--                                   // longer valid -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;hello&quot;); // sはここから有効になる

    // sで作業をする
}                                  // このスコープはここでおしまい。sは
                                   // もう有効ではない
#}</code></pre></pre>
<!-- There is a natural point at which we can return the memory our `String` needs -->
<!-- to the operating system: when `s` goes out of scope. When a variable goes out -->
<!-- of scope, Rust calls a special function for us. This function is called `drop`, -->
<!-- and it’s where the author of `String` can put the code to return the memory. -->
<!-- Rust calls `drop` automatically at the closing curly bracket. -->
<p><code>String</code>型が必要とするメモリをOSに返還することが自然な地点があります: <code>s</code>変数がスコープを抜ける時です。
変数がスコープを抜ける時、Rustは特別な関数を呼んでくれます。この関数は、<code>drop</code>と呼ばれ、
ここに<code>String</code>型の書き手はメモリ返還するコードを配置することができます。Rustは、閉じ波括弧で自動的に<code>drop</code>関数を呼び出します。</p>
<!-- Note: In C++, this pattern of deallocating resources at the end of an item's -->
<!-- lifetime is sometimes called *Resource Acquisition Is Initialization (RAII)*. -->
<!-- The `drop` function in Rust will be familiar to you if you’ve used RAII -->
<!-- patterns. -->
<blockquote>
<p>注釈: C++では、要素の生存期間の終了地点でリソースを解放するこのパターンを時に、
<em>RAII</em>(Resource Aquisition Is Initialization: リソースの獲得は、初期化である)と呼んだりします。
Rustの<code>drop</code>関数は、あなたがRAIIパターンを使ったことがあれば、馴染み深いものでしょう。</p>
</blockquote>
<!-- This pattern has a profound impact on the way Rust code is written. It may seem -->
<!-- simple right now, but the behavior of code can be unexpected in more -->
<!-- complicated situations when we want to have multiple variables use the data -->
<!-- we’ve allocated on the heap. Let’s explore some of those situations now. -->
<p>このパターンは、Rustコードの書かれ方に甚大な影響をもたらします。現状は簡単そうに見えるかもしれませんが、
ヒープ上に確保されたデータを複数の変数に使用させるようなもっと複雑な場面では、コードの振る舞いは、
予期しないものになる可能性もあります。これから、そのような場面を掘り下げてみましょう。</p>
<!-- #### Ways Variables and Data Interact: Move -->
<a class="header" href="print.html#a変数とデータの相互作用法-ムーブ" id="a変数とデータの相互作用法-ムーブ"><h4>変数とデータの相互作用法: ムーブ</h4></a>
<!-- Multiple variables can interact with the same data in different ways in Rust. -->
<!-- Let’s look at an example using an integer in Listing 4-2. -->
<p>Rustにおいては、複数の変数が同じデータに対して異なる手段で相互作用することができます。
整数を使用したリスト4-2の例を見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<!-- <span class="caption">Listing 4-2: Assigning the integer value of variable `x`
to `y`</span> -->
<p><span class="caption">リスト4-2: 変数<code>x</code>の整数値を<code>y</code>に代入する</span></p>
<!-- We can probably guess what this is doing: “bind the value `5` to `x`; then make -->
<!-- a copy of the value in `x` and bind it to `y`.” We now have two variables, `x` -->
<!-- and `y`, and both equal `5`. This is indeed what is happening, because integers -->
<!-- are simple values with a known, fixed size, and these two `5` values are pushed -->
<!-- onto the stack. -->
<p>もしかしたら、何をしているのか予想することができるでしょう:
「値<code>5</code>を<code>x</code>に束縛する; それから<code>x</code>の値をコピーして<code>y</code>に束縛する。」これで、
二つの変数(<code>x</code>と<code>y</code>)が存在し、両方、値は<code>5</code>になりました。これは確かに起こっている現象を説明しています。
なぜなら、整数は既知の固定サイズの単純な値で、これら二つの<code>5</code>という値は、スタックに積まれるからです。</p>
<!-- Now let’s look at the `String` version: -->
<p>では、<code>String</code>バージョンを見ていきましょう:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
#}</code></pre></pre>
<!-- This looks very similar to the previous code, so we might assume that the way -->
<!-- it works would be the same: that is, the second line would make a copy of the -->
<!-- value in `s1` and bind it to `s2`. But this isn’t quite what happens. -->
<p>このコードは先ほどのコードに酷似していますので、動作方法も同じだと思い込んでしまうかもしれません:
要するに、2行目で<code>s1</code>の値をコピーし、<code>s2</code>に束縛するということです。ところが、
これは全く起こることを言い当てていません。</p>
<!-- Take a look at Figure 4-1 to see what is happening to `String` under the -->
<!-- covers. A `String` is made up of three parts, shown on the left: a pointer to -->
<!-- the memory that holds the contents of the string, a length, and a capacity. -->
<!-- This group of data is stored on the stack. On the right is the memory on the -->
<!-- heap that holds the contents. -->
<p>図4-1を見て、ベールの下で<code>String</code>に何が起きているかを確かめてください。
<code>String</code>型は、左側に示されているように、3つの部品でできています:
文字列の中身を保持するメモリへのポインタと長さ、そして、許容量です。この種のデータは、スタックに保持されます。
右側には、中身を保持したヒープ上のメモリがあります。</p>
<!-- <img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" /> -->
<p><img alt="メモリ上の文字列" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<!-- <span class="caption">Figure 4-1: Representation in memory of a `String`
holding the value `"hello"` bound to `s1`</span> -->
<p><span class="caption">図4-1: <code>s1</code>に束縛された<code>&quot;hello&quot;</code>という値を保持する<code>String</code>のメモリ上の表現</span></p>
<!-- The length is how much memory, in bytes, the contents of the `String` is -->
<!-- currently using. The capacity is the total amount of memory, in bytes, that the -->
<!-- `String` has received from the operating system. The difference between length -->
<!-- and capacity matters, but not in this context, so for now, it’s fine to ignore -->
<!-- the capacity. -->
<p>長さは、<code>String</code>型の中身が現在使用しているメモリ量をバイトで表したものです。許容量は、
<code>String</code>型がOSから受け取った全メモリ量をバイトで表したものです。長さと許容量の違いは問題になることですが、
この文脈では違うので、とりあえずは、許容量を無視しても構わないでしょう。</p>
<!-- When we assign `s1` to `s2`, the `String` data is copied, meaning we copy the -->
<!-- pointer, the length, and the capacity that are on the stack. We do not copy the -->
<!-- data on the heap that the pointer refers to. In other words, the data -->
<!-- representation in memory looks like Figure 4-2. -->
<p><code>s1</code>を<code>s2</code>に代入すると、<code>String</code>型のデータがコピーされます。つまり、スタックにあるポインタ、長さ、
許容量をコピーするということです。ポインタが指すヒープ上のデータはコピーしません。言い換えると、
メモリ上のデータ表現は図4-2のようになるということです。</p>
<!-- <img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" /> -->
<p><img alt="同じ値を指すs1とs2" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<!-- <span class="caption">Figure 4-2: Representation in memory of the variable `s2`
that has a copy of the pointer, length, and capacity of `s1`</span> -->
<p><span class="caption">図4-2: <code>s1</code>のポインタ、長さ、許容量のコピーを保持する変数<code>s2</code>のメモリ上での表現</span></p>
<!-- The representation does *not* look like Figure 4-3, which is what memory would -->
<!-- look like if Rust instead copied the heap data as well. If Rust did this, the -->
<!-- operation `s2 = s1` could be very expensive in terms of runtime performance if -->
<!-- the data on the heap ware large. -->
<p>メモリ上の表現は、図4-3のようにはなり<em>ません</em>。これは、
Rustが代わりにヒープデータもコピーするという選択をしていた場合のメモリ表現ですね。Rustがこれをしていたら、
ヒープ上のデータが大きい時に<code>s2 = s1</code>という処理の実行時性能がとても悪くなっていた可能性があるでしょう。</p>
<!-- <img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" /> -->
<p><img alt="2箇所へのs1とs2" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<!-- <span class="caption">Figure 4-3: Another possibility of what `s2 = s1` might
do if Rust copied the heap data as well</span> -->
<p><span class="caption">図4-3: Rustがヒープデータもコピーしていた場合に<code>s2 = s1</code>という処理が行なった可能性のあること</span></p>
<!-- Earlier, we said that when a variable goes out of scope, Rust automatically -->
<!-- calls the `drop` function and cleans up the heap memory for that variable. But -->
<!-- Figure 4-2 shows both data pointers pointing to the same location. This is a -->
<!-- problem: when `s2` and `s1` go out of scope, they will both try to free the -->
<!-- same memory. This is known as a *double free* error and is one of the memory -->
<!-- safety bugs we mentioned previously. Freeing memory twice can lead to memory -->
<!-- corruption, which can potentially lead to security vulnerabilities. -->
<p>先ほど、変数がスコープを抜けたら、Rustは自動的に<code>drop</code>関数を呼び出し、
その変数が使っていたヒープメモリを片付けると述べました。しかし、図4-4は、
両方のデータポインタが同じ場所を指していることを示しています。これは問題です: <code>s2</code>と<code>s1</code>がスコープを抜けたら、
両方とも同じメモリを解放しようとします。これは<em>二重解放</em>エラーとして知られ、以前触れたメモリ安全性上のバグの一つになります。
メモリを2回解放することは、メモリの退廃につながり、さらにセキュリティ上の脆弱性を生む可能性があります。</p>
<!-- To ensure memory safety, there’s one more detail to what happens in this -->
<!-- situation in Rust. Instead of trying to copy the allocated memory, Rust -->
<!-- considers `s1` to no longer be valid and, therefore, Rust doesn’t need to free -->
<!-- anything when `s1` goes out of scope. Check out what happens when you try to -->
<!-- use `s1` after `s2` is created, it won't work: -->
<!-- この最初の文は、こなれた日本語にしにくい -->
<p>メモリ安全性を保証するために、Rustにおいてこの場面で知っておきたい起こる事の詳細がもう一つあります。
確保されたメモリをコピーしようとする代わりに、コンパイラは、<code>s1</code>が最早有効ではないと考え、
故に<code>s1</code>がスコープを抜けた際に何も解放する必要がなくなるわけです。<code>s2</code>の生成後に<code>s1</code>を使用しようとしたら、
どうなるかを確認してみましょう。動かないでしょう:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre>
<!-- You’ll get an error like this because Rust prevents you from using the -->
<!-- invalidated reference: -->
<p>コンパイラが無効化された参照は使用させてくれないので、以下のようなエラーが出るでしょう:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
              (ムーブされた値の使用: `s1`)
 --&gt; src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |                               (ムーブ後にここで使用されています)
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
    (注釈: ムーブが起きたのは、`s1`が`std::string::String`という
    `Copy`トレイトを実装していない型だからです)
</code></pre>
<!-- If you’ve heard the terms “shallow copy” and “deep copy” while working with -->
<!-- other languages, the concept of copying the pointer, length, and capacity -->
<!-- without copying the data probably sounds like a shallow copy. But -->
<!-- because Rust also invalidates the first variable, instead of being called a -->
<!-- shallow copy, it’s known as a *move*. In this example, we would say that `s1` -->
<!-- was *moved* into `s2`. So what actually happens is shown in Figure 4-4. -->
<p>他の言語を触っている間に&quot;shallow copy&quot;と&quot;deep copy&quot;という用語を耳にしたことがあるなら、
データのコピーなしにポインタと長さ、許容量をコピーするという概念は、shallow copyのように思えるかもしれません。
ですが、コンパイラは最初の変数をも無効化するので、shallow copyと呼ばれる代わりに、
ムーブとして知られているわけです。この例では、<code>s1</code>は<code>s2</code>に<em>ムーブ</em>されたと表現するでしょう。
以上より、実際に起きることを図4-4に示してみました。</p>
<!-- <img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /> -->
<p><img alt="s2にムーブされたs1" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<!-- <span class="caption">Figure 4-4: Representation in memory after `s1` has been
invalidated</span> -->
<p><span class="caption">図4-4: <code>s1</code>が無効化された後のメモリ表現</span></p>
<!-- That solves our problem! With only `s2` valid, when it goes out of scope, it -->
<!-- alone will free the memory, and we’re done. -->
<p>これにて一件落着です。<code>s2</code>だけが有効なので、スコープを抜けたら、それだけがメモリを解放して、
終わりになります。</p>
<!-- In addition, there’s a design choice that’s implied by this: Rust will never -->
<!-- automatically create “deep” copies of your data. Therefore, any *automatic* -->
<!-- copying can be assumed to be inexpensive in terms of runtime performance. -->
<p>付け加えると、これにより暗示される設計上の選択があります: Rustでは、
自動的にデータの&quot;deep copy&quot;が行われることは絶対にないわけです。それ故に、あらゆる<em>自動</em>コピーは、実行時性能の観点で言うと、
悪くないと考えてよいことになります。</p>
<!-- #### Ways Variables and Data Interact: Clone -->
<a class="header" href="print.html#a変数とデータの相互作用法-クローン" id="a変数とデータの相互作用法-クローン"><h4>変数とデータの相互作用法: クローン</h4></a>
<!-- If we *do* want to deeply copy the heap data of the `String`, not just the -->
<!-- stack data, we can use a common method called `clone`. We’ll discuss method -->
<!-- syntax in Chapter 5, but because methods are a common feature in many -->
<!-- programming languages, you’ve probably seen them before. -->
<p>仮に、スタック上のデータだけでなく、本当に<code>String</code>型のヒープデータのdeep copyが必要ならば、
<code>clone</code>と呼ばれるよくあるメソッドを使うことができます。メソッド記法については第5章で議論しますが、
メソッドは多くのプログラミング言語に見られる機能なので、以前に見かけたこともあるんじゃないでしょうか。</p>
<!-- Here’s an example of the `clone` method in action: -->
<p>こちらで、<code>clone</code>メソッドの稼働例をご覧ください:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<!-- This works just fine and explicitly produces the behavior shown in Figure 4-3, -->
<!-- where the heap data *does* get copied. -->
<p>これは単純にうまく動き、図4-3で示した動作を明示的に生み出します。ここでは、
ヒープデータが<em>実際に</em>コピーされています。</p>
<!-- When you see a call to `clone`, you know that some arbitrary code is being -->
<!-- executed and that code may be expensive. It’s a visual indicator that something -->
<!-- different is going on. -->
<p><code>clone</code>メソッドの呼び出しを見かけたら、何らかの任意のコードが実行され、その実行コストは高いと把握できます。
何か違うことが起こっているなと見た目でわかるわけです。</p>
<!-- #### Stack-Only Data: Copy -->
<a class="header" href="print.html#aスタックのみのデータ-コピー" id="aスタックのみのデータ-コピー"><h4>スタックのみのデータ: コピー</h4></a>
<!-- There’s another wrinkle we haven’t talked about yet. This code using integers, -->
<!-- part of which was shown in Listing 4-2, works and is valid: -->
<p>まだ話題にしていない別のしわ(<code>訳注</code>: 「気になるもの」程度の意味と思われる)の話があります。
この整数を使用したコードは、一部をリスト4-2で示しましたが、うまく動作し、有効です:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<!-- But this code seems to contradict what we just learned: we don’t have a call to -->
<!-- `clone`, but `x` is still valid and wasn’t moved into `y`. -->
<p>ですが、このコードは一見、今学んだことと矛盾しているように見えます:
<code>clone</code>メソッドの呼び出しがないのに、<code>x</code>は有効で、<code>y</code>にムーブされませんでした。</p>
<!-- The reason is that types such as integers that have a known size at compile -->
<!-- time are stored entirely on the stack, so copies of the actual values are quick -->
<!-- to make. That means there’s no reason we would want to prevent `x` from being -->
<!-- valid after we create the variable `y`. In other words, there’s no difference -->
<!-- between deep and shallow copying here, so calling `clone` wouldn’t do anything -->
<!-- differently from the usual shallow copying and we can leave it out. -->
<p>その理由は、整数のようなコンパイル時に既知のサイズを持つ型は、スタック上にすっぽり保持されるので、
実際の値をコピーするのも高速だからです。これは、変数<code>y</code>を生成した後にも<code>x</code>を無効化したくなる理由がないことを意味します。
換言すると、ここでは、shallow copyとdeep copyの違いがないことになり、
<code>clone</code>メソッドを呼び出しても、一般的なshallow copy以上のことをしなくなり、
そのまま放置しておけるということです。</p>
<!-- Rust has a special annotation called the `Copy` trait that we can place on -->
<!-- types like integers that are stored on the stack (we’ll talk more about traits -->
<!-- in Chapter 10). If a type has the `Copy` trait, an older variable is still -->
<!-- usable after assignment. Rust won’t let us annotate a type with the `Copy` -->
<!-- trait if the type, or any of its parts, has implemented the `Drop` trait. If -->
<!-- the type needs something special to happen when the value goes out of scope and -->
<!-- we add the `Copy` annotation to that type, we’ll get a compile-time error. To -->
<!-- learn about how to add the `Copy` annotation to your type, see "Derivable -->
<!-- Traits" in Appendix C. -->
<p>Rustには<code>Copy</code>トレイトと呼ばれる特別な注釈があり、
整数のようなスタックに保持される型に対して配置することができます(トレイトについては第10章でもっと詳しく話します)。
型が<code>Copy</code>トレイトに適合していれば、代入後も古い変数が使用可能になります。コンパイラは、
型やその一部分でも<code>Drop</code>トレイトを実装している場合、<code>Copy</code>トレイトによる注釈をさせてくれません。
型の値がスコープを外れた時に何か特別なことを起こす必要がある場合に、<code>Copy</code>注釈を追加すると、コンパイルエラーが出ます。
型に<code>Copy</code>注釈をつける方法について学ぶには、付録Cの「継承可能トレイト」をご覧ください。</p>
<!-- So what types are `Copy`? You can check the documentation for the given type to -->
<!-- be sure, but as a general rule, any group of simple scalar values can be -->
<!-- `Copy`, and nothing that requires allocation or is some form of resource is -->
<!-- `Copy`. Here are some of the types that are `Copy`: -->
<p>では、どの型が<code>Copy</code>なのでしょうか？ある型について、ドキュメントをチェックすればいいのですが、
一般規則として、単純なスカラー値の集合は何でも<code>Copy</code>であり、メモリ確保が必要だったり、
何らかの形態のリソースだったりするものは<code>Copy</code>ではありません。ここに<code>Copy</code>の型を並べておきます。</p>
<!-- * All the integer types, like `u32`. -->
<!-- * The Boolean type, `bool`, with values `true` and `false`. -->
<!-- * All the floating point types, like `f64`. -->
<!-- * The character type, `char`. -->
<!-- * Tuples, but only if they contain types that are also `Copy`. For example -->
<!-- `(i32, i32)` is `Copy`, but `(i32, String)` is not. -->
<ul>
<li>あらゆる整数型。<code>u32</code>など。</li>
<li>論理値型、<code>bool</code>、<code>true</code>と<code>false</code>という値がある。</li>
<li>あらゆる浮動小数点型、<code>f64</code>など。</li>
<li>文字型、<code>char</code>。</li>
<li>タプル。ただ、<code>Copy</code>の型だけを含む場合。例えば、<code>(i32, i32)</code>は<code>Copy</code>だが、
<code>(i32, String)</code>は違う。</li>
</ul>
<!-- ### Ownership and Functions -->
<a class="header" href="print.html#a所有権と関数" id="a所有権と関数"><h3>所有権と関数</h3></a>
<!-- The semantics for passing a value to a function are similar to those for -->
<!-- assigning a value to a variable. Passing a variable to a function will move or -->
<!-- copy, just as assignment does. Listing 4-3 has an example with some annotations -->
<!-- showing where variables go into and out of scope. -->
<p>意味論的に、関数に値を渡すことと、値を変数に代入することは似ています。関数に変数を渡すと、
代入のようにムーブやコピーされます。リスト4-7は変数がスコープに入ったり、
抜けたりする地点について注釈してある例です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- ```rust -->
<!-- fn main() { -->
<!--    let s = String::from("hello");  // s comes into scope -->
<!--    takes_ownership(s);             // s's value moves into the function... -->
<!--                                    // ... and so is no longer valid here -->
<!--    let x = 5;                      // x comes into scope -->
<!--    makes_copy(x);                  // x would move into the function, -->
<!--                                    // but i32 is Copy, so it’s okay to still -->
<!--                                    // use x afterward -->
<!-- } // Here, x goes out of scope, then s. But since s's value was moved, nothing -->
<!--  // special happens. -->
<!-- fn takes_ownership(some_string: String) { // some_string comes into scope. -->
<!--    println!("{}", some_string); -->
<!-- } // Here, some_string goes out of scope and `drop` is called. The backing -->
<!--  // memory is freed. -->
<!-- fn makes_copy(some_integer: i32) { // some_integer comes into scope -->
<!--    println!("{}", some_integer); -->
<!-- } // Here, some_integer goes out of scope. Nothing special happens. -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // sがスコープに入る

    takes_ownership(s);             // sの値が関数にムーブされ...
                                    // ... ここではもう有効ではない

    let x = 5;                      // xがスコープに入る

    makes_copy(x);                  // xも関数にムーブされるが、
                                    // i32はCopyなので、この後にxを使っても
                                    // 大丈夫

} // ここでxがスコープを抜け、sも。だけど、sの値はムーブされてるので、何も特別なことはない。
  //

fn takes_ownership(some_string: String) { // some_stringがスコープに入る。
    println!(&quot;{}&quot;, some_string);
} // ここでsome_stringがスコープを抜け、`drop`が呼ばれる。後ろ盾してたメモリが解放される。
  // 

fn makes_copy(some_integer: i32) { // some_integerがスコープに入る
    println!(&quot;{}&quot;, some_integer);
} // ここでsome_integerがスコープを抜ける。何も特別なことはない。
</code></pre></pre>
<!-- <span class="caption">Listing 4-3: Functions with ownership and scope
annotated</span> -->
<p><span class="caption">リスト4-3: 所有権とスコープが注釈された関数群</span></p>
<!-- If we tried to use `s` after the call to `takes_ownership`, Rust would throw a -->
<!-- compile-time error. These static checks protect us from mistakes. Try adding -->
<!-- code to `main` that uses `s` and `x` to see where you can use them and where -->
<!-- the ownership rules prevent you from doing so. -->
<p><code>takes_ownership</code>の呼び出し後に<code>s</code>を呼び出そうとすると、コンパイラは、コンパイルエラーを投げるでしょう。
これらの静的チェックにより、ミスを犯さないでいられます。<code>s</code>や<code>x</code>を使用するコードを<code>main</code>に追加してみて、
どこで使えて、そして、所有権規則により、どこで使えないかを確認してください。</p>
<!-- ### Return Values and Scope -->
<a class="header" href="print.html#a戻り値とスコープ" id="a戻り値とスコープ"><h3>戻り値とスコープ</h3></a>
<!-- Returning values can also transfer ownership. Listing 4-4 is an example with -->
<!-- similar annotations to those in Listing 4-3. -->
<p>値を返すことでも、所有権は移動します。リスト4-4は、リスト4-3と似た注釈のついた例です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- ```rust -->
<!-- fn main() { -->
<!--    let s1 = gives_ownership();         // gives_ownership moves its return -->
<!--                                        // value into s1 -->
<!--    let s2 = String::from("hello");     // s2 comes into scope -->
<!--    let s3 = takes_and_gives_back(s2);  // s2 is moved into -->
<!--                                        // takes_and_gives_back, which also -->
<!--                                        // moves its return value into s3 -->
<!-- } // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was -->
<!--  // moved, so nothing happens. s1 goes out of scope and is dropped. -->
<!-- fn gives_ownership() -> String {             // gives_ownership will move its -->
<!--                                             // return value into the function -->
<!--                                             // that calls it -->
<!--    let some_string = String::from("hello"); // some_string comes into scope -->
<!--    some_string                              // some_string is returned and -->
<!--                                             // moves out to the calling -->
<!--                                             // function -->
<!-- } -->
<!-- // takes_and_gives_back will take a String and return one. -->
<!-- fn takes_and_gives_back(a_string: String) -> String { // a_string comes into -->
<!--                                                       // scope -->
<!--    a_string  // a_string is returned and moves out to the calling function -->
<!-- } -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownershipは、戻り値をs1に
                                        // ムーブする

    let s2 = String::from(&quot;hello&quot;);     // s2がスコープに入る

    let s3 = takes_and_gives_back(s2);  // s2はtakes_and_gives_backにムーブされ
                                        // 戻り値もs3にムーブされる
} // ここで、s3はスコープを抜け、ドロップされる。s2もスコープを抜けるが、ムーブされているので、
  // 何も起きない。s1もスコープを抜け、ドロップされる。

fn gives_ownership() -&gt; String {             // gives_ownershipは、戻り値を
                                             // 呼び出した関数にムーブする

    let some_string = String::from(&quot;hello&quot;); // some_stringがスコープに入る

    some_string                              // some_stringが返され、呼び出し元関数に
                                             // ムーブされる
}

// takes_and_gives_backは、Stringを一つ受け取り、返す。
fn takes_and_gives_back(a_string: String) -&gt; String { // a_stringがスコープに入る。

    a_string  // a_stringが返され、呼び出し元関数にムーブされる
}
</code></pre></pre>
<!-- <span class="caption">Listing 4-4: Transferring ownership of return -->
<!-- values</span> -->
<p><span class="caption">リスト4-4: 戻り値の所有権を移動する</span></p>
<!-- The ownership of a variable follows the same pattern every time: assigning a -->
<!-- value to another variable moves it. When a variable that includes data on the -->
<!-- heap goes out of scope, the value will be cleaned up by `drop` unless the data -->
<!-- has been moved to be owned by another variable. -->
<p>変数の所有権は、毎回同じパターンを辿っています: 別の変数に値を代入すると、ムーブされます。
ヒープにデータを含む変数がスコープを抜けると、データが別の変数に所有されるようムーブされていない限り、
<code>drop</code>により片付けられるでしょう。</p>
<!-- Taking ownership and then returning ownership with every function is a bit -->
<!-- tedious. What if we want to let a function use a value but not take ownership? -->
<!-- It’s quite annoying that anything we pass in also needs to be passed back if we -->
<!-- want to use it again, in addition to any data resulting from the body of the -->
<!-- function that we might want to return as well. -->
<p>所有権を得ては返すを全ての関数でしていたら、ちょっとめんどくさいですね。関数に値を使わせたいけど、
所有権は保持させたくない場合はどうすればいいのでしょうか？
返したいと思うかもしれない関数本体で発生したあらゆるデータとともに再利用したかったら、渡されたものをまた返さなきゃいけないのは、
非常に煩わしいことです。</p>
<!-- It’s possible to return multiple values using a tuple, as shown in Listing 4-5. -->
<p>タプルで、複数の値を返すことは可能です。リスト4-5のようにですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- ```rust -->
<!-- fn main() { -->
<!--    let s1 = String::from("hello"); -->
<!--    let (s2, len) = calculate_length(s1); -->
<!--    println!("The length of '{}' is {}.", s2, len); -->
<!-- } -->
<!-- fn calculate_length(s: String) -> (String, usize) { -->
<!--    let length = s.len(); // len() returns the length of a String -->
<!--    (s, length) -->
<!-- } -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    //'{}'の長さは、{}です
    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len()メソッドは、Stringの長さを返します

    (s, length)
}
</code></pre></pre>
<!-- <span class="caption">Listing 4-5: Returning ownership of parameters</span> -->
<p><span class="caption">リスト4-5: 引数の所有権を返す</span></p>
<!-- But this is too much ceremony and a lot of work for a concept that should be -->
<!-- common. Luckily for us, Rust has a feature for this concept, called -->
<!-- *references*. -->
<p>でも、これでは、大袈裟すぎますし、ありふれているはずの概念に対して、作業量が多すぎます。
私たちにとって幸運なことに、Rustにはこの概念に対する機能があり、<em>参照</em>と呼ばれます。</p>
<!-- ## References and Borrowing -->
<a class="header" href="print.html#a参照と借用" id="a参照と借用"><h2>参照と借用</h2></a>
<!-- The issue with the tuple code in Listing 4-5 is that we have to return the -->
<!-- `String` to the calling function so we can still use the `String` after the -->
<!-- call to `calculate_length`, because the `String` was moved into -->
<!-- `calculate_length`. -->
<p>リスト4-5のタプルコードの問題は、<code>String</code>型を呼び出し元の関数に戻さないと、<code>calculate_length</code>を呼び出した後に、
<code>String</code>オブジェクトが使えなくなることであり、これは<code>String</code>オブジェクトが<code>calculate_length</code>にムーブされてしまうためでした。</p>
<!-- Here is how you would define and use a `calculate_length` function that has a -->
<!-- reference to an object as a parameter instead of taking ownership of the -->
<!-- value: -->
<p>ここで、値の所有権をもらう代わりに引数としてオブジェクトへの参照を取る<code>calculate_length</code>関数を定義し、
使う方法を見てみましょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    // '{}'の長さは、{}です
    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<!-- First, notice that all the tuple code in the variable declaration and the -->
<!-- function return value is gone. Second, note that we pass `&s1` into -->
<!-- `calculate_length` and, in its definition, we take `&String` rather than -->
<!-- `String`. -->
<p>まず、変数宣言と関数の戻り値にあったタプルコードは全てなくなったことに気付いてください。
2番目に、<code>&amp;s1</code>を<code>calcuate_length</code>に渡し、その定義では、<code>String</code>型ではなく、<code>&amp;String</code>を受け取っていることに注目してください。</p>
<!-- These ampersands are *references*, and they allow you to refer to some value -->
<!-- without taking ownership of it. Figure 4-5 shows a diagram. -->
<p>これらのアンド記号が参照であり、これのおかげで所有権をもらうことなく値を参照することができるのです。
図4-5はその図解です。</p>
<!-- <img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" /> -->
<p><img alt="文字列s1を指す&amp;String型のs" src="img/trpl04-05.svg" class="center" /></p>
<!-- <span class="caption">Figure 4-5: A diagram of `&String s` pointing at `String -->
<!-- s1`</span> -->
<p><span class="caption">図4-5: <code>String s1</code>を指す<code>&amp;String</code>の図表</span></p>
<!-- Note: The opposite of referencing by using `&` is *dereferencing*, which is -->
<!-- accomplished with the dereference operator, `*`. We’ll see some uses of the -->
<!-- dereference operator in Chapter 8 and discuss details of dereferencing in -->
<!-- Chapter 15. -->
<blockquote>
<p>注釈: <code>&amp;</code>による参照の逆は、<em>参照外し</em>であり、参照外し演算子の<code>*</code>で達成できます。
第8章で参照外し演算子の使用例を眺め、第15章で参照外しについて詳しく議論します。</p>
</blockquote>
<!-- Let’s take a closer look at the function call here: -->
<p>ここの関数呼び出しについて、もっと詳しく見てみましょう:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn calculate_length(s: &amp;String) -&gt; usize {
#     s.len()
# }
let s1 = String::from(&quot;hello&quot;);

let len = calculate_length(&amp;s1);
#}</code></pre></pre>
<!-- The `&s1` syntax lets us create a reference that *refers* to the value of `s1` -->
<!-- but does not own it. Because it does not own it, the value it points to will -->
<!-- not be dropped when the reference goes out of scope. -->
<p>この<code>&amp;s1</code>という記法により、<code>s1</code>の値を<em>参照する</em>参照を生成することができますが、これを所有することはありません。
所有してないということは、指している値は、参照がスコープを抜けてもドロップされないということです。</p>
<!-- Likewise, the signature of the function uses `&` to indicate that the type of -->
<!-- the parameter `s` is a reference. Let’s add some explanatory annotations: -->
<p>同様に、関数のシグニチャでも、<code>&amp;</code>を使用して引数<code>s</code>の型が参照であることを示しています。
説明的な注釈を加えてみましょう:</p>
<!-- ```rust -->
<!-- fn calculate_length(s: &String) -> usize { // s is a reference to a String -->
<!--     s.len() -->
<!-- } // Here, s goes out of scope. But because it does not have ownership of what -->
<!--   // it refers to, nothing happens. -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn calculate_length(s: &amp;String) -&gt; usize { // sはStringへの参照
    s.len()
} // ここで、sはスコープ外になる。けど、参照しているものの所有権を持っているわけではないので
  // 何も起こらない
#}</code></pre></pre>
<!-- The scope in which the variable `s` is valid is the same as any function -->
<!-- parameter's scope, but we don’t drop what the reference points to when it goes -->
<!-- out of scope because we don’t have ownership. When functions have references as -->
<!-- parameters instead of the actual values, we won’t need to return the values in -->
<!-- order to give back ownership, since we never had ownership. -->
<p>変数<code>s</code>が有効なスコープは、あらゆる関数の引数のものと同じですが、所有権はないので、<code>s</code>がスコープを抜けても、
参照が指しているものをドロップすることはありません。関数が実際の値の代わりに参照を引数に取ると、
所有権をもらわないので、所有権を返す目的で値を返す必要はありません。</p>
<!-- We call having references as function parameters *borrowing*. As in real life, -->
<!-- if a person owns something, you can borrow it from them. When you’re done, you -->
<!-- have to give it back. -->
<p>関数の引数に参照を取ることを<em>借用</em>と呼びます。現実生活のように、誰かが何かを所有していたら、
それを借りることができます。用が済んだら、返さなきゃいけないわけです。</p>
<!-- So what happens if we try to modify something we’re borrowing? Try the code in -->
<!-- Listing 4-6. Spoiler alert: it doesn’t work! -->
<p>では、借用した何かを変更しようとしたら、どうなるのでしょうか？リスト4-6のコードを試してください。
ネタバレ注意: 動きません！</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<!-- <span class="caption">Listing 4-6: Attempting to modify a borrowed value</span> -->
<p><span class="caption">リスト4-6: 借用した値を変更しようと試みる</span></p>
<!-- Here’s the error: -->
<p>これがエラーです:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable
(エラー: 不変な借用をした中身`*some_string`を可変で借用できません)
 --&gt; error.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- use `&amp;mut String` here to make mutable
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<!-- Just as variables are immutable by default, so are references. We’re not -->
<!-- allowed to modify something we have a reference to. -->
<p>変数が標準で不変なのと全く同様に、参照も不変なのです。参照している何かを変更することは叶わないわけです。</p>
<!-- ### Mutable References -->
<a class="header" href="print.html#a可変な参照" id="a可変な参照"><h3>可変な参照</h3></a>
<!-- We can fix the error in the code from Listing 4-6 with just a small tweak: -->
<p>一捻り加えるだけでリスト4-6のコードのエラーは解決します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<!-- First, we had to change `s` to be `mut`. Then we had to create a mutable -->
<!-- reference with `&mut s` and accept a mutable reference with `some_string: &mut -->
<!-- String`. -->
<p>始めに、<code>s</code>を<code>mut</code>に変えなければなりませんでした。そして、<code>&amp;mut s</code>で可変な参照を生成し、
<code>some_string: &amp;mut String</code>で可変な参照を受け入れなければなりませんでした。</p>
<!-- But mutable references have one big restriction: you can have only one mutable -->
<!-- reference to a particular piece of data in a particular scope. This code will -->
<!-- fail: -->
<p>ところが、可変な参照には大きな制約が一つあります: 特定のスコープである特定のデータに対しては、
一つしか可変な参照を持てないことです。こちらのコードは失敗します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;
</code></pre>
<!-- Here’s the error: -->
<p>これがエラーです:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
(エラー: 一度に`s`を可変として2回以上借用することはできません)
 --&gt; borrow_twice.rs:5:19
  |
4 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
  |                    (最初の可変な参照はここ)
5 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
  |                    (二つ目の可変な参照はここ)
6 | }
  | - first borrow ends here
  |   (最初の借用はここで終わり)
</code></pre>
<!-- This restriction allows for mutation but in a very controlled fashion. It’s -->
<!-- something that new Rustaceans struggle with, because most languages let you -->
<!-- mutate whenever you’d like. -->
<p>この制約は、可変化を許可するものの、それを非常に統制の取れた形で行えます。これは、新たなRustaceanにとっては、
壁です。なぜなら、多くの言語では、いつでも好きな時に可変化できるからです。</p>
<!-- The benefit of having this restriction is that Rust can prevent data races at -->
<!-- compile time. A *data race* is similar to a race condition and happens when -->
<!-- these three behaviors occur: -->
<p>この制約がある利点は、コンパイラがコンパイル時にデータ競合を防ぐことができる点です。
データ競合とは、競合条件と類似していて、これら3つの振る舞いが起きる時に発生します:</p>
<!-- * Two or more pointers access the same data at the same time. -->
<!-- * At least one of the pointers is being used to write to the data. -->
<!-- * There’s no mechanism being used to synchronize access to the data. -->
<ul>
<li>2つ以上のポインタが同じデータに同時にアクセスする。</li>
<li>少なくとも一つのポインタがデータに書き込みを行っている。</li>
<li>データへのアクセスを同期する機構が使用されていない。</li>
</ul>
<!-- Data races cause undefined behavior and can be difficult to diagnose and fix -->
<!-- when you’re trying to track them down at runtime; Rust prevents this problem -->
<!-- from happening because it won’t even compile code with data races! -->
<p>データ競合は未定義の振る舞いを引き起こし、実行時に追いかけようとした時に特定し解決するのが難しい問題です。
しかし、Rustは、データ競合が起こるコードをコンパイルさえしないので、この問題が発生しないようにしてくれるわけです。</p>
<!-- As always, we can use curly brackets to create a new scope, allowing for -->
<!-- multiple mutable references, just not *simultaneous* ones: -->
<p>いつものように、波かっこを使って新しいスコープを生成し、<em>同時並行</em>なものでなく、複数の可変な参照を作ることができます。</p>
<!-- ```rust -->
<!-- let mut s = String::from("hello"); -->
<!-- { -->
<!--     let r1 = &mut s; -->
<!-- } // r1 goes out of scope here, so we can make a new reference with no problems. -->
<!-- let r2 = &mut s; -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1はここでスコープを抜けるので、問題なく新しい参照を作ることができる

let r2 = &amp;mut s;
#}</code></pre></pre>
<!-- A similar rule exists for combining mutable and immutable references. This code -->
<!-- results in an error: -->
<p>可変と不変な参照を組み合わせることに関しても、似たような規則が存在しています。このコードはエラーになります:</p>
<!-- ```rust,ignore -->
<!-- let mut s = String::from("hello"); -->
<!-- let r1 = &s; // no problem -->
<!-- let r2 = &s; // no problem -->
<!-- let r3 = &mut s; // BIG PROBLEM -->
<!-- ``` -->
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // 問題なし
let r2 = &amp;s; // 問題なし
let r3 = &amp;mut s; // 大問題！
</code></pre>
<!-- Here’s the error: -->
<p>これがエラーです:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
(エラー: `s`は不変で借用されているので、可変で借用できません)
 --&gt; borrow_thrice.rs:6:19
  |
4 |     let r1 = &amp;s; // no problem
  |               - immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |                   ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<!-- Whew! We *also* cannot have a mutable reference while we have an immutable one. -->
<!-- Users of an immutable reference don’t expect the values to suddenly change out -->
<!-- from under them! However, multiple immutable references are okay because no one -->
<!-- who is just reading the data has the ability to affect anyone else’s reading of -->
<!-- the data. -->
<p>ふう！<em>さらに</em>不変な参照をしている間は、可変な参照をすることはできません。不変参照の使用者は、
それ以降に値が突然変わることなんて予想してません！しかしながら、複数の不変参照をすることは可能です。
データを読み込んでいるだけの人に、他人がデータを読み込むことに対して影響を与える能力はないからです。</p>
<!-- Even though these errors may be frustrating at times, remember that it’s the -->
<!-- Rust compiler pointing out a potential bug early (at compile time rather than -->
<!-- at runtime) and showing you exactly where the problem is. Then you don't have -->
<!-- to track down why your data isn’t what you thought it was. -->
<p>これらのエラーは、時としてイライラするものではありますが、Rustコンパイラがバグの可能性を早期に指摘してくれ(それも実行時ではなくコンパイル時に)、
問題の発生箇所をズバリ示してくれるのだと覚えておいてください。そうして想定通りにデータが変わらない理由を追いかける必要がなくなります。</p>
<!-- ### Dangling References -->
<a class="header" href="print.html#a宙に浮いた参照" id="a宙に浮いた参照"><h3>宙に浮いた参照</h3></a>
<!-- In languages with pointers, it’s easy to erroneously create a *dangling -->
<!-- pointer*, a pointer that references a location in memory that may have been -->
<!-- given to someone else, by freeing some memory while preserving a pointer to -->
<!-- that memory. In Rust, by contrast, the compiler guarantees that references will -->
<!-- never be dangling references: if you have a reference to some data, the -->
<!-- compiler will ensure that the data will not go out of scope before the -->
<!-- reference to the data does. -->
<p>ポインタのある言語では、誤ってダングリングポインタを生成してしまいやすいです。ダングリングポインタとは、
他人に渡されてしまった可能性のあるメモリを指すポインタのことであり、その箇所へのポインタを保持している間に、
メモリを解放してしまうことで発生します。対照的にRustでは、コンパイラが、
参照がダングリング参照に絶対ならないよう保証してくれます:つまり、何らかのデータへの参照があったら、
コンパイラは参照がスコープを抜けるまで、データがスコープを抜けることがないよう確認してくれるわけです。</p>
<!-- Let’s try to create a dangling reference, which Rust will prevent with a -->
<!-- compile-time error: -->
<p>ダングリング参照作りを試してみますが、コンパイラはこれをコンパイルエラーで阻止します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<!-- Here’s the error: -->
<p>こちらがエラーです:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
(エラー: ライフタイム指定子がありません)
 --&gt; main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no
    value for it to be borrowed from
    (助言: この関数の戻り値型は、借用した値を含んでいますが、借用される値がどこにもありません)
  = help: consider giving it a 'static lifetime
  ('staticライフタイムを与えることを考慮してみてください)
</code></pre>
<!-- This error message refers to a feature we haven’t covered yet: *lifetimes*. We'll -->
<!-- discuss lifetimes in detail in Chapter 10. But, if you disregard the parts -->
<!-- parts about lifetimes, the message does contain the key to why this code is a problem: -->
<p>このエラーメッセージは、まだ解説していない機能について触れています: <em>ライフタイム</em>です。
ライフタイムについては第10章で詳しく議論しますが、ライフタイムに関する部分を無視すれば、
このメッセージは、このコードが問題になる理由に関する鍵を握っています:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<!-- Let’s take a closer look at exactly what’s happening at each stage of our -->
<!-- `dangle` code: -->
<p><code>dangle</code>コードの各段階で一体何が起きているのかを詳しく見ていきましょう:</p>
<!-- ```rust,ignore -->
<!-- fn dangle() -> &String { // dangle returns a reference to a String -->
<!--     let s = String::from("hello"); // s is a new String -->
<!--     &s // we return a reference to the String, s -->
<!-- } // Here, s goes out of scope, and is dropped. Its memory goes away. -->
<!--   // Danger! -->
<!-- ``` -->
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn dangle() -&gt; &amp;String { // dangleはStringへの参照を返す

    let s = String::from(&quot;hello&quot;); // sは新しいString

    &amp;s // String sへの参照を返す
} // ここで、sはスコープを抜け、ドロップされる。そのメモリは吹き飛ばされる。
  // 危険だ
</code></pre>
<!-- Because `s` is created inside `dangle`, when the code of `dangle` is finished, -->
<!-- `s` will be deallocated. But we tried to return a reference to it. That means -->
<!-- this reference would be pointing to an invalid `String` That’s no good! Rust -->
<!-- won’t let us do this. -->
<p><code>s</code>は、<code>dangle</code>内で生成されているので、<code>dangle</code>のコードが終わったら、<code>s</code>は解放されてしまいますが、
そこへの参照を返そうとしました。つまり、この参照は無効な<code>String</code>を指していると思われるのです。
よくないことです！コンパイラは、これを阻止してくれるのです。</p>
<!-- The solution here is to return the `String` directly: -->
<p>ここでの解決策は、<code>String</code>を直接返すことです:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
#}</code></pre></pre>
<!-- This works without any problems. Ownership is moved out, and nothing is -->
<!-- deallocated. -->
<p>これは何の問題もなく動きます。所有権はムーブされ、何も解放されることはありません。</p>
<!-- ### The Rules of References -->
<a class="header" href="print.html#a参照の規則" id="a参照の規則"><h3>参照の規則</h3></a>
<!-- Let’s recap what we’ve discussed about references: -->
<p>参照について議論したことを再確認しましょう:</p>
<!-- * At any given time, you can have *either* one mutable reference *or* any -->
<!--   number of immutable references. -->
<!-- * References must always be valid. -->
<ul>
<li>任意のタイミングで、一つの可変参照<em>か</em>不変な参照いくつでもの<em>どちらか</em>を行える。</li>
<li>参照は常に有効でなければならない。</li>
</ul>
<!-- Next, we’ll look at a different kind of reference: slices. -->
<p>次は、違う種類の参照を見ていきましょう: スライスです。</p>
<!-- ## The Slice Type -->
<a class="header" href="print.html#aスライス型" id="aスライス型"><h2>スライス型</h2></a>
<!-- Another data type that does not have ownership is the *slice*. Slices let you -->
<!-- reference a contiguous sequence of elements in a collection rather than the -->
<!-- whole collection. -->
<p>所有権のない別のデータ型は、<em>スライス</em>です。スライスにより、コレクション全体というより、
その内の一連の要素を参照することができます。</p>
<!-- Here’s a small programming problem: write a function that takes a string and -->
<!-- returns the first word it finds in that string. If the function doesn’t find a -->
<!-- space in the string, the whole string must be one word, so the entire string -->
<!-- should be returned. -->
<p>ここに小さなプログラミング問題があります: 文字列を受け取って、その文字列中の最初の単語を返す関数を書いてください。
関数が文字列中に空白を見つけなかったら、文字列全体が一つの単語に違いないので、文字列全体が返されるべきです。</p>
<!-- Let’s think about the signature of this function: -->
<p>この関数のシグニチャについて考えてみましょう:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<!-- This function, `first_word`, has a `&String` as a parameter. We don’t want -->
<!-- ownership, so this is fine. But what should we return? We don’t really have a -->
<!-- way to talk about *part* of a string. However, we could return the index of the -->
<!-- end of the word. Let’s try that as shown in Listing 4-7. -->
<p>この関数、<code>first_word</code>は引数に<code>&amp;String</code>をとります。所有権はいらないので、これで十分です。
ですが、何を返すべきでしょうか？文字列の<em>一部</em>について語る方法が全くありません。しかし、
単語の終端の番号を返すことができますね。リスト4-7に示したように、その方法を試してみましょう。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 4-7: The `first_word` function that returns a -->
<!-- byte index value into the `String` parameter</span> -->
<p><span class="caption">リスト4-7: <code>String</code>引数へのバイト数で表された番号を返す<code>first_word</code>関数</span></p>
<!-- Because we need to go through the `String` element by element and check whether -->
<!-- a value is a space, we’ll convert our `String` to an array of bytes using the -->
<!-- `as_bytes` method: -->
<p><code>String</code>の値を要素ごとに見て、空白かどうかを確かめる必要があるので、
<code>as_bytes</code>メソッドを使って、<code>String</code>オブジェクトをバイト配列に変換しています。</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<!-- Next, we create an iterator over the array of bytes using the `iter` method: -->
<p>次に、そのバイト配列に対して、<code>iter</code>メソッドを使用してイテレータを生成しています:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<!-- We’ll discuss iterators in more detail in Chapter 13. For now, know that `iter` -->
<!-- is a method that returns each element in a collection and that `enumerate` -->
<!-- wraps the result of `iter` and returns each element as part of a tuple instead. -->
<!-- The first element of the tuple returned from `enumerate` is the index, and the -->
<!-- second element is a reference to the element. This is a bit more convenient -->
<!-- than calculating the index ourselves. -->
<p>イテレータについて詳しくは、第13章で議論します。今は、<code>iter</code>は、コレクション内の各要素を返すメソッドであること、
<code>enumerate</code>が<code>iter</code>の結果を包んで、代わりにタプルの一部として各要素を返すことを知っておいてください。
<code>enumerate</code>から返ってくるタプルの第1要素は、番号であり、2番目の要素は、(コレクションの)要素への参照になります。
これは、手動で番号を計算するよりも少しだけ便利です。</p>
<!-- Because the `enumerate` method returns a tuple, we can use patterns to -->
<!-- destructure that tuple, just like everywhere else in Rust. So in the `for` -->
<!-- loop, we specify a pattern that has `i` for the index in the tuple and `&item` -->
<!-- for the single byte in the tuple. Because we get a reference to the element -->
<!-- from `.iter().enumerate()`, we use `&` in the pattern. -->
<p><code>enumerate</code>メソッドがタプルを返すので、Rustのあらゆる場所同様、パターンを使って、そのタプルを分解できます。
従って、<code>for</code>ループ内で、タプルの番号に対する<code>i</code>とタプルの1バイトに対応する<code>&amp;item</code>を含むパターンを指定しています。
<code>.iter().enumerate()</code>から要素への参照を取得するので、パターンに<code>&amp;</code>を使っています。</p>
<!-- Inside the `for` loop, We search for the byte that represents the space by -->
<!-- using the byte literal syntax. If we find a space, we return the position. -->
<!-- Otherwise, we return the length of the string by using `s.len()`: -->
<p><code>for</code>ループ内で、バイトリテラル表記を使用して空白を表すバイトを検索しています。空白が見つかったら、その位置を返します。
それ以外の場合、<code>s.len()</code>を使って文字列の長さを返します。</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}

s.len()
</code></pre>
<!-- We now have a way to find out the index of the end of the first word in the -->
<!-- string, but there’s a problem. We’re returning a `usize` on its own, but it’s -->
<!-- only a meaningful number in the context of the `&String`. In other words, -->
<!-- because it’s a separate value from the `String`, there’s no guarantee that it -->
<!-- will still be valid in the future. Consider the program in Listing 4-8 that -->
<!-- uses the `first_word` function from Listing 4-7. -->
<p>さて、文字列内の最初の単語の終端の番号を見つけ出せるようになりましたが、問題があります。
<code>usize</code>型を単独で返していますが、これは<code>&amp;String</code>の文脈でのみ意味を持つ数値です。
言い換えると、<code>String</code>から切り離された値なので、将来的にも有効である保証がないのです。
リスト4-7の<code>first_word</code>関数を使用するリスト4-8のプログラムを考えてください。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- ```rust -->
<!-- # fn first_word(s: &String) -> usize { -->
<!-- #     let bytes = s.as_bytes(); -->
<!-- # -->
<!-- #     for (i, &item) in bytes.iter().enumerate() { -->
<!-- #         if item == b' ' { -->
<!-- #             return i; -->
<!-- #         } -->
<!-- #     } -->
<!-- # -->
<!-- #     s.len() -->
<!-- # } -->
<!-- # -->
<!-- fn main() { -->
<!--     let mut s = String::from("hello world"); -->
<!--     let word = first_word(&s); // word will get the value 5 -->
<!--     s.clear(); // This empties the String, making it equal to "" -->
<!--     // word still has the value 5 here, but there's no more string that -->
<!--     // we could meaningfully use the value 5 with. word is now totally invalid! -->
<!-- } -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;String) -&gt; usize {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // wordの中身は、値5になる

    s.clear(); // Stringを空にする。つまり、&quot;&quot;と等しくする

    // wordはまだ値5を保持しているが、もうこの値を有効に使用できる文字列は存在しない。
    // wordは完全に無効なのだ！
}
</code></pre></pre>
<!-- <span class="caption">Listing 4-8: Storing the result from calling the -->
<!-- `first_word` function then changing the `String` contents</span> -->
<p><span class="caption">リスト4-8: <code>first_word</code>関数の呼び出し結果を保持し、<code>String</code>の中身を変更する</span></p>
<!-- This program compiles without any errors and also would if we used `word` -->
<!-- after calling `s.clear()`. Because `word` isn’t connected to the state of `s` -->
<!-- at all, `word` still contains the value `5`. We could use that value `5` with -->
<!-- the variable `s` to try to extract the first word out, but this would be a bug -->
<!-- because the contents of `s` have changed since we saved `5` in `word`. -->
<p>このプログラムは何のエラーもなくコンパイルが通り、<code>word</code>を<code>s.clear()</code>の呼び出し後に使用しても、
コンパイルが通ります。<code>word</code>は<code>s</code>の状態に全く関連づけられていないので、その中身はまだ値<code>5</code>のままです。
その値<code>5</code>を変数<code>s</code>に使用し、最初の単語を取り出そうとすることはできますが、これはバグでしょう。
というのも、<code>s</code>の中身は、<code>5</code>を<code>word</code>に保存してから変わってしまったからです。</p>
<!-- Having to worry about the index in `word` getting out of sync with the data in -->
<!-- `s` is tedious and error prone! Managing these indices is even more brittle if -->
<!-- we write a `second_word` function. Its signature would have to look like this: -->
<p><code>word</code>内の番号が<code>s</code>に格納されたデータと同期されなくなるのを心配することは、面倒ですし間違いになりやすいです！
これらの番号を管理するのは、<code>second_word</code>関数を書いたら、さらに脆くなります。
そのシグニチャは以下のようにならなければおかしいです:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<!-- Now we’re tracking a starting *and* an ending index, and we have even more -->
<!-- values that were calculated from data in a particular state but aren’t tied to -->
<!-- that state at all. We now have three unrelated variables floating around that -->
<!-- need to be kept in sync. -->
<p>今、私たちは開始<em>と</em>終端の番号を追うようになりました。特定の状態のデータから計算されたけど、
その状態に全く紐付かない値が増えました。同期を取る必要のある宙に浮いた関連性のない変数が3つになってしまいました。</p>
<!-- Luckily, Rust has a solution to this problem: string slices. -->
<p>運のいいことに、Rustにはこの問題への解決策が用意されています: 文字列スライスです。</p>
<!-- ### String Slices -->
<a class="header" href="print.html#a文字列スライス" id="a文字列スライス"><h3>文字列スライス</h3></a>
<!-- A *string slice* is a reference to part of a `String`, and it looks like this: -->
<p><em>文字列スライス</em>とは、<code>String</code>の一部への参照で、こんな見た目をしています:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
#}</code></pre></pre>
<!-- This is similar to taking a reference to the whole `String` but with the extra -->
<!-- `[0..5]` bit. Rather than a reference to the entire `String`, it’s a reference -->
<!-- to a portion of the `String`. The `start..end` syntax is a range that begins at -->
<!-- `start` and continues up to, but not including, `end`. -->
<p>これは、<code>String</code>全体への参照を取ることに似ていますが、余計な<code>[0..5]</code>という部分が付いています。
<code>String</code>全体への参照というよりも、<code>String</code>の一部への参照です。<code>開始..終点</code>という記法は、<code>開始</code>から始まり、
<code>終点</code>未満までずっと続く範囲です。</p>
<!-- We can create slices using a range within brackets by specifying -->
<!-- `[starting_index..ending_index]`, where `starting_index` is the first position -->
<!-- in the slice and `ending_index` is one more than the last position in the -->
<!-- slice. Internally, the slice data structure stores the starting position and -->
<!-- the length of the slice, which corresponds to `ending_index` minus -->
<!-- `starting_index`. So in the case of `let world = &s[6..11];`, `world` would be -->
<!-- a slice that contains a pointer to the 7th byte of `s` with a length value of 5. -->
<p><code>[starting_index..ending_index]</code>と指定することで、角かっこに範囲を使い、スライスを生成できます。
ここで、<code>starting_index</code>はスライスの最初の位置、<code>ending_index</code>はスライスの終端位置よりも、
1大きくなります。内部的には、スライスデータ構造は、開始地点とスライスの長さを保持しており、
スライスの長さは<code>ending_index</code>から<code>starting_index</code>を引いたものに対応します。以上より、
<code>let world = &amp;s[6..11];</code>の場合には、<code>world</code>は<code>s</code>の7バイト目へのポインタと5という長さを保持するスライスになるでしょう。</p>
<!-- Figure 4-6 shows this in a diagram. -->
<p>図4-6は、これを図解しています。</p>
<!-- <img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /> -->
<p><img alt="文字列sの6バイト目へのポインタと長さ5を保持するworld" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<!-- <span class="caption">Figure 4-6: String slice referring to part of a -->
<!-- `String`</span> -->
<p><span class="caption">図4-6: <code>String</code>オブジェクトの一部を参照する文字列スライス</span></p>
<!-- With Rust’s `..` range syntax, if you want to start at the first index (zero), -->
<!-- you can drop the value before the two periods. In other words, these are equal: -->
<p>Rustの<code>..</code>という範囲記法で、最初の番号(ゼロ)から始めたければ、2連ピリオドの前に値を書かなければいいのです。
換言すれば、これらは等価です:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
#}</code></pre></pre>
<!-- By the same token, if your slice includes the last byte of the `String`, you -->
<!-- can drop the trailing number. That means these are equal: -->
<p>同様の意味で、<code>String</code>の最後のバイトをスライスが含むのならば、末尾の数値を書かなければいいのです。
つまり、これらは等価になります:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
#}</code></pre></pre>
<!-- You can also drop both values to take a slice of the entire string. So these -->
<!-- are equal: -->
<p>さらに、両方の値を省略すると、文字列全体のスライスを得られます。故に、これらは等価です:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
#}</code></pre></pre>
<!-- Note: String slice range indices must occur at valid UTF-8 character -->
<!-- boundaries. If you attempt to create a string slice in the middle of a -->
<!-- multibyte character, your program will exit with an error. For the purposes -->
<!-- of introducing string slices, we are assuming ASCII only in this section; a -->
<!-- more thorough discussion of UTF-8 handling is in the “Storing UTF-8 Encoded -->
<!-- Text with Strings” section of Chapter 8. -->
<blockquote>
<p>注釈: 文字列スライスの範囲インデックスは、有効なUTF-8文字境界に置かなければなりません。
マルチバイト文字の真ん中で文字列スライスを生成しようとしたら、エラーでプログラムは落ちるでしょう。
文字列スライスを導入する目的で、この節ではASCIIのみを想定しています; UTF-8に関する
より徹底した議論は、第8章の「文字列でUTF-8エンコードされたテキストを格納する」節で行います。</p>
</blockquote>
<!-- With all this information in mind, let’s rewrite `first_word` to return a -->
<!-- slice. The type that signifies “string slice” is written as `&str`: -->
<p>これら全ての情報を心に留めて、<code>first_word</code>を書き直してスライスを返すようにしましょう。
文字列スライスを意味する型は、<code>&amp;str</code>と記述します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<!-- We get the index for the end of the word in the same way as we did in Listing -->
<!-- 4-7, by looking for the first occurrence of a space. When we find a space, we -->
<!-- return a string slice using the start of the string and the index of the space -->
<!-- as the starting and ending indices. -->
<p>リスト4-7で取った手段と同じ方法で単語の終端番号を取得しています。つまり、最初の空白を探すことです。
空白を発見したら、文字列の最初と、空白の番号を開始、終了地点として使用して文字列スライスを返しています。</p>
<!-- Now when we call `first_word`, we get back a single value that is tied to the -->
<!-- underlying data. The value is made up of a reference to the starting point of -->
<!-- the slice and the number of elements in the slice. -->
<p>これで、<code>first_word</code>を呼び出すと、元のデータに紐付けられた単独の値を得られるようになりました。
この値は、スライスの開始地点への参照とスライス中の要素数から構成されています。</p>
<!-- Returning a slice would also work for a `second_word` function: -->
<p><code>second_word</code>関数についても、スライスを返すことでうまくいくでしょう:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!-- We now have a straightforward API that’s much harder to mess up, because the -->
<!-- compiler will ensure the references into the `String` remain valid. Remember -->
<!-- the bug in the program in Listing 4-8, when we got the index to the end of the -->
<!-- first word but then cleared the string so our index was invalid? That code was -->
<!-- logically incorrect but didn’t show any immediate errors. The problems would -->
<!-- show up later if we kept trying to use the first word index with an emptied -->
<!-- string. Slices make this bug impossible and let us know we have a problem with -->
<!-- our code much sooner. Using the slice version of `first_word` will throw a -->
<!-- compile-time error: -->
<p>これで、ずっと混乱しにくい素直なAPIになりました。なぜなら、<code>String</code>への参照が有効なままであることをコンパイラが、
保証してくれるからです。最初の単語の終端番号を得た時に、
文字列を空っぽにして先ほどの番号が無効になってしまったリスト4-8のプログラムのバグを覚えていますか？
そのコードは、論理的に正しくないのですが、即座にエラーにはなりませんでした。問題は後になってから発生し、
それは空の文字列に対して、最初の単語の番号を使用し続けようとした時でした。スライスならこんなバグはあり得ず、
コードに問題があるなら、もっと迅速に判明します。スライスバージョンの<code>first_word</code>を使用すると、
コンパイルエラーが発生します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!    (エラー！)
}
</code></pre>
<!-- Here’s the compiler error: -->
<p>こちらがコンパイルエラーです:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
(エラー: 不変として借用されているので、`s`を可変で借用できません)
 --&gt; src/main.rs:6:5
  |
4 |     let word = first_word(&amp;s);
  |                            - immutable borrow occurs here (不変借用はここで起きています)
5 |
6 |     s.clear(); // error!        (エラー！)
  |     ^ mutable borrow occurs here (可変借用はここで起きています)
7 | }
  | - immutable borrow ends here (不変借用はここで終わっています)
</code></pre>
<!-- Recall from the borrowing rules that if we have an immutable reference to -->
<!-- something, we cannot also take a mutable reference. Because `clear` needs to -->
<!-- truncate the `String`, it tries to take a mutable reference, which fails. Not -->
<!-- only has Rust made our API easier to use, but it has also eliminated an entire -->
<!-- class of errors at compile time! -->
<p>借用規則から、何かへの不変な参照がある時、さらに可変な参照を得ることはできないことを思い出してください。
<code>clear</code>が<code>String</code>を切り詰める必要があるので、可変な参照を得ようとして失敗しているわけです。
RustのおかげでAPIが使いやすくなるだけでなく、ある種のエラー全てを完全にコンパイル時に排除してくれるのです！</p>
<!-- #### String Literals Are Slices -->
<a class="header" href="print.html#a文字列リテラルはスライスである" id="a文字列リテラルはスライスである"><h4>文字列リテラルはスライスである</h4></a>
<!-- Recall that we talked about string literals being stored inside the binary. Now -->
<!-- that we know about slices, we can properly understand string literals: -->
<p>文字列は、バイナリに埋め込まれると話したことを思い出してください。今やスライスのことを知ったので、
文字列リテラルを正しく理解することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;Hello, world!&quot;;
#}</code></pre></pre>
<!-- The type of `s` here is `&str`: it’s a slice pointing to that specific point of -->
<!-- the binary. This is also why string literals are immutable; `&str` is an -->
<!-- immutable reference. -->
<p>ここでの<code>s</code>の型は、<code>&amp;str</code>です: バイナリのその特定の位置を指すスライスです。
これは、文字列が不変である理由にもなっています。要するに、<code>&amp;str</code>は不変な参照なのです。</p>
<!-- #### String Slices as Parameters -->
<a class="header" href="print.html#a引数としての文字列スライス" id="a引数としての文字列スライス"><h4>引数としての文字列スライス</h4></a>
<!-- Knowing that you can take slices of literals and `String` values leads us to -->
<!-- one more improvement on `first_word`, and that’s its signature: -->
<p>リテラルや<code>String</code>値のスライスを得ることができると知ると、<code>first_word</code>に対して、もう一つ改善点を見出すことができます。
シグニチャです:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!-- A more experienced Rustacean would write the signature shown in Listing 4-9 -->
<!-- instead because it allows us to use the same function on both `String` values -->
<!-- and `&str` values. -->
<p>もっと経験を積んだRustaceanなら、代わりにリスト4-9のようなシグニチャを書くでしょう。というのも、こうすると、
同じ関数を<code>String</code>値と<code>&amp;str</code>値両方に使えるようになるからです。</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<!-- <span class="caption">Listing 4-9: Improving the `first_word` function by using -->
<!-- a string slice for the type of the `s` parameter</span> -->
<p><span class="caption">リスト4-9: <code>s</code>引数の型に文字列スライスを使用して<code>first_word</code>関数を改善する</span></p>
<!-- If we have a string slice, we can pass that directly. If we have a `String`, we -->
<!-- can pass a slice of the entire `String`. Defining a function to take a string -->
<!-- slice instead of a reference to a `String` makes our API more general and useful -->
<!-- without losing any functionality: -->
<p>もし、文字列スライスがあるなら、それを直接渡せます。<code>String</code>オブジェクトがあるなら、
その<code>String</code>全体のスライスを渡せます。<code>String</code>への参照の代わりに文字列スライスを取るよう関数を定義すると、
何も機能を失うことなくAPIをより一般的で有益なものにできるのです。</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- ```rust -->
<!-- # fn first_word(s: &str) -> &str { -->
<!-- #     let bytes = s.as_bytes(); -->
<!-- # -->
<!-- #     for (i, &item) in bytes.iter().enumerate() { -->
<!-- #         if item == b' ' { -->
<!-- #             return &s[0..i]; -->
<!-- #         } -->
<!-- #     } -->
<!-- # -->
<!-- #     &s[..] -->
<!-- # } -->
<!-- fn main() { -->
<!--     let my_string = String::from("hello world"); -->
<!--     // first_word works on slices of `String`s -->
<!--     let word = first_word(&my_string[..]); -->
<!--     let my_string_literal = "hello world"; -->
<!--     // first_word works on slices of string literals -->
<!--     let word = first_word(&my_string_literal[..]); -->
<!--     // Because string literals *are* string slices already, -->
<!--     // this works too, without the slice syntax! -->
<!--     let word = first_word(my_string_literal); -->
<!-- } -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;str) -&gt; &amp;str {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &amp;s[0..i];
#         }
#     }
#
#     &amp;s[..]
# }
fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_wordは`String`のスライスに対して機能する
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_wordは文字列リテラルのスライスに対して機能する
    let word = first_word(&amp;my_string_literal[..]);

    // 文字列リテラルは、すでに文字列スライス*な*ので、
    // スライス記法なしでも機能するのだ！
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<!-- ### Other Slices -->
<a class="header" href="print.html#a他のスライス" id="a他のスライス"><h3>他のスライス</h3></a>
<!-- String slices, as you might imagine, are specific to strings. But there’s a -->
<!-- more general slice type, too. Consider this array: -->
<p>文字列リテラルは、想像通り、文字列に特化したものです。ですが、もっと一般的なスライス型も存在します。
この配列を考えてください:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<!-- Just as we might want to refer to a part of a string, we might want to refer -->
<!-- to part of an array. We'd do so like this: -->
<p>文字列の一部を参照したくなる可能性があるのと同様、配列の一部を参照したくなる可能性もあります。
以下のようにすれば、参照することができます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<!-- This slice has the type `&[i32]`. It works the same way as string slices do, by -->
<!-- storing a reference to the first element and a length. You’ll use this kind of -->
<!-- slice for all sorts of other collections. We’ll discuss these collections in -->
<!-- detail when we talk about vectors in Chapter 8. -->
<p>このスライスは、<code>&amp;[i32]</code>という型になります。これも文字列スライスと全く同じように動作します。
つまり、最初の要素への参照と長さを保持することです。他のすべての種類のコレクションに対して、
この種のスライスは使用することができるでしょう。これらのコレクションについて詳しくは、
第8章でベクタ型について話すときに議論します。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-3" id="aまとめ-3"><h2>まとめ</h2></a>
<!-- The concepts of ownership, borrowing, and slices ensure memory safety in Rust -->
<!-- programs at compile time. The Rust language gives you control over your memory -->
<!-- usage in the same way as like other systems programming languages, but having the -->
<!-- owner of data automatically clean up that data when the owner goes out of scope -->
<!-- means you don’t have to write and debug extra code to get this control. -->
<p>所有権、借用、スライスの概念は、コンパイル時にRustプログラムにおいて、メモリ安全性を保証します。
Rust言語も他のシステムプログラミング言語と同じように、メモリの使用法について制御させてくれるわけですが、
所有者がスコープを抜けたときにデータの所有者に自動的にデータを片付けさせることは、この制御を得るために、
余計なコードを書いてデバッグする必要がないことを意味します。</p>
<!-- Ownership affects how lots of other parts of Rust work, so we’ll talk about -->
<!-- these concepts further throughout the rest of the book. Let’s move on to -->
<!-- Chapter 5 and look at grouping pieces of data together in a `struct`. -->
<p>所有権は、Rustの他のいろんな部分が動作する方法に影響を与えるので、これ以降もこれらの概念についてさらに語っていく予定です。
第5章に移って、<code>struct</code>でデータをグループ化することについて見ていきましょう。</p>
<!-- # Using Structs to Structure Related Data -->
<a class="header" href="print.html#a構造体を使用して関係のあるデータを構造化する" id="a構造体を使用して関係のあるデータを構造化する"><h1>構造体を使用して関係のあるデータを構造化する</h1></a>
<!-- A *struct*, or *structure*, is a custom data type that lets us name and -->
<!-- package together multiple related values that make up a meaningful group. If -->
<!-- you're familiar with an object-oriented language, a *struct* is like an -->
<!-- object's data attributes. In this chapter, we’ll compare and contrast tuples -->
<!-- with structs demonstrate how to use structs, and discuss how to define methods -->
<!-- and associated functions to specify behavior associated with a struct’s data. -->
<!-- Structs and enums (discussed in Chapter 6) are the building blocks for creating -->
<!-- new types in your program’s domain to take full advantage of Rust's compile -->
<!-- time type checking. -->
<p><em>struct</em>または、<em>構造体</em>は、意味のあるグループを形成する複数の関連した値をまとめ、名前付けできる独自のデータ型です。
オブジェクト指向言語に造詣が深いなら、<em>struct</em>はオブジェクトのデータ属性みたいなものです。
この章では、タプルと構造体を対照的に比較し、構造体の使用法をデモし、メソッドや関連関数を定義して、
構造体のデータに紐付く振る舞いを指定する方法について議論します。構造体と<em>enum</em>(第6章で議論します)は、
自分のプログラム領域で新しい型を定義し、Rustのコンパイル時型精査機能をフル活用する構成要素になります。</p>
<!-- ## Defining and Instantiating Structs -->
<a class="header" href="print.html#a構造体を定義しインスタンス化する" id="a構造体を定義しインスタンス化する"><h2>構造体を定義し、インスタンス化する</h2></a>
<!-- Structs are similar to tuples, which were discussed in Chapter 3. Like tuples, -->
<!-- the pieces of a struct can be different types. Unlike with tuples, you'll name -->
<!-- each piece of data so it’s clear what the values mean. As a result of these -->
<!-- names, structs are more flexible than tuples: we don’t have to rely on the -->
<!-- order of the data to specify or access the values of an instance. -->
<p>構造体は第3章で議論したタプルと似ています。タプル同様、構造体の一部を異なる型にできます。
一方タプルとは違って、各データ片には名前をつけるので、値の意味が明確になります。
この名前のおかげで、構造体はタプルに比して、より柔軟になるわけです: データの順番に頼って、
インスタンスの値を指定したり、アクセスしたりする必要がないのです。</p>
<!-- To define a struct, we enter the keyword `struct` and name the entire struct. A -->
<!-- struct’s name should describe the significance of the pieces of data being -->
<!-- grouped together. Then, inside curly brackets, we define the names and types of -->
<!-- the pieces of data, which we call *fields*. For example, Listing 5-1 shows a -->
<!-- struct that stores information about a user account. -->
<p>構造体の定義は、<code>struct</code>キーワードを入れ、構造体全体に名前を付けます。構造体名は、
一つにグループ化されるデータ片の意義を表すものであるべきです。そして、波かっこ内に、
データ片の名前と型を定義し、これは<em>フィールド</em>と呼ばれます。例えば、リスト5-1では、
ユーザアカウントに関する情報を保持する構造体を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 5-1: A `User` struct definition</span> -->
<p><span class="caption">リスト5-1: <code>User</code>構造体定義</span></p>
<!-- To use a struct after we’ve defined it, we create an *instance* of that struct -->
<!-- by specifying concrete values for each of the fields. We create an instance by -->
<!-- stating the name of the struct, and then add curly brackets containing `key: -->
<!-- value` pairs, where the keys are the names of the fields and the values are the -->
<!-- data we want to store in those fields. We don’t have to specify the fields in -->
<!-- the same order in which we declared them in the struct. In other words, the -->
<!-- struct definition is like a general template for the type, and instances fill -->
<!-- in that template with particular data to create values of the type. For -->
<!-- example, we can declare a particular user as shown in Listing 5-2. -->
<p>構造体を定義した後に使用するには、各フィールドに対して具体的な値を指定して構造体の<em>インスタンス</em>を生成します。
インスタンスは、構造体名を記述し、<code>key: value</code>ペアを含む波かっこを付け加えることで生成します。
ここで、キーはフィールド名、値はそのフィールドに格納したいデータになります。フィールドは、
構造体で宣言した通りの順番に指定する必要はありません。換言すると、構造体定義とは、
型に対する一般的な雛形のようなものであり、インスタンスは、その雛形を特定のデータで埋め、その型の値を生成するわけです。
例えば、リスト5-2で示されたように特定のユーザを宣言することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
#}</code></pre></pre>
<!-- <span class="caption">Listing 5-2: Creating an instance of the `User` -->
<!-- struct</span> -->
<p><span class="caption">リスト5-2: <code>User</code>構造体のインスタンスを生成する</span></p>
<!-- To get a specific value from a struct, we can use dot notation. If we wanted -->
<!-- just this user’s email address, we can use `user1.email` wherever we wanted -->
<!-- to use this value. If the instance is mutable, we can change a value by using -->
<!-- the dot notation and assigning into a particular field. Listing 5-3 shows how -->
<!-- to change the value in the `email` field of a mutable `User` instance. -->
<p>構造体から特定の値を得るには、ドット記法が使えます。このユーザのEメールアドレスだけが欲しいなら、
この値を使いたかった場所全部で<code>user1.email</code>が使えます。インスタンスが可変であれば、
ドット記法を使い特定のフィールドに代入することで値を変更できます。リスト5-3では、
可変な<code>User</code>インスタンスの<code>email</code>フィールド値を変更する方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let mut user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from(&quot;anotheremail@example.com&quot;);
#}</code></pre></pre>
<!-- <span class="caption">Listing 5-3: Changing the value in the `email` field of a -->
<!-- `User` instance</span> -->
<p><span class="caption">リスト5-3: ある<code>User</code>インスタンスの<code>email</code>フィールド値を変更する</span></p>
<!-- Note that the entire instance must be mutable; Rust doesn’t allow us to mark -->
<!-- only certain fields as mutable. As with any expression, we can construct a new -->
<!-- instance of the struct as the last expression in the function body to -->
<!-- implicitly return that new instance. -->
<p>インスタンス全体が可変でなければならないことに注意してください; Rustでは、一部のフィールドのみを可変にすることはできないのです。
また、あらゆる式同様、構造体の新規インスタンスを関数本体の最後の式として生成して、
そのインスタンスを返すことを暗示できます。</p>
<!-- Listing 5-4 shows a `build_user` function that returns a `User` instance with -->
<!-- the given email and username. The `active` field gets the value of `true`, and -->
<!-- the `sign_in_count` gets a value of `1`. -->
<p>リスト5-4は、与えられたemailとusernameで<code>User</code>インスタンスを生成する<code>build_user</code>関数を示しています。
<code>active</code>フィールドには<code>true</code>値が入り、<code>sign_in_count</code>には値<code>1</code>が入ります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 5-4: A `build_user` function that takes an email -->
<!-- and username and returns a `User` instance</span> -->
<p><span class="caption">リスト5-4: Eメールとユーザ名を取り、<code>User</code>インスタンスを返す<code>build_user</code>関数</span></p>
<!-- It makes sense to name the function parameters with the same name as the struct -->
<!-- fields, but having to repeat the `email` and `username` field names and -->
<!-- variables is a bit tedious. If the struct had more fields, repeating each name -->
<!-- would get even more annoying. Luckily, there's a convenient shorthand! -->
<p>構造体のフィールドと同じ名前を関数の引数にもつけることは筋が通っていますが、
<code>email</code>と<code>username</code>というフィールド名と変数を繰り返さなきゃいけないのは、ちょっと面倒です。
構造体にもっとフィールドがあれば、名前を繰り返すことはさらに煩わしくなるでしょう。
幸運なことに、便利な省略記法があります！</p>
<!-- ### Using the Field Init Shorthand when Variables and Fields Have the Same Name -->
<a class="header" href="print.html#aフィールドと変数が同名の時にフィールド初期化省略記法を使う" id="aフィールドと変数が同名の時にフィールド初期化省略記法を使う"><h3>フィールドと変数が同名の時にフィールド初期化省略記法を使う</h3></a>
<!-- Because the parameter names and the struct field names are exactly the same in -->
<!-- Listing 5-4, we can use the *field init shorthand* syntax to rewrite -->
<!-- `build_user` so that it behaves exactly the same but doesn’t have the -->
<!-- repetition of `email` and `username`, as shown in Listing 5-5. -->
<p>仮引数名と構造体のフィールド名がリスト5-4では、全く一緒なので、<em>フィールド初期化省略</em>記法を使って<code>build_user</code>を書き換えても、
振る舞いは全く同じにしつつ、リスト5-5に示したように<code>email</code>と<code>username</code>を繰り返さなくてもよくなります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 5-5: A `build_user` function that uses field init -->
<!-- shorthand because the `email` and `username` parameters have the same name as -->
<!-- struct fields</span> -->
<p><span class="caption">リスト5-5: <code>email</code>と<code>username</code>引数が構造体のフィールドと同名なので、
フィールド初期化省略法を使用する<code>build_user</code>関数</span></p>
<!-- Here, we’re creating a new instance of the `User` struct, which has a field -->
<!-- named `email`. We want to set the `email` field’s value to the value in the -->
<!-- `email` parameter of the `build_user` function. Because the `email` field and -->
<!-- the `email` parameter have the same name, we only need to write `email` rather -->
<!-- than `email: email`. -->
<p>ここで、<code>email</code>というフィールドを持つ<code>User</code>構造体の新規インスタンスを生成しています。
<code>email</code>フィールドを<code>build_user</code>関数の<code>email</code>引数の値にセットしたいわけです。
<code>email</code>フィールドと<code>email</code>引数は同じ名前なので、<code>email: email</code>と書くよりも、
<code>email</code>と書くだけで済むのです。</p>
<!-- ### Creating Instances From Other Instances With Struct Update Syntax -->
<a class="header" href="print.html#a構造体更新記法で他のインスタンスからインスタンスを生成する" id="a構造体更新記法で他のインスタンスからインスタンスを生成する"><h3>構造体更新記法で他のインスタンスからインスタンスを生成する</h3></a>
<!-- It’s often useful to create a new instance of a struct that uses most of an old -->
<!-- instance’s values, but changes some. You'll do this using *struct update syntax*. -->
<p>多くは前のインスタンスの値を使用しつつ、変更する箇所もある形で新しいインスタンスを生成できるとしばしば有用です。
<em>構造体更新記法</em>でそうすることができます。</p>
<!-- First, Listing 5-6 shows how we create a new `User` instance in `user2` without -->
<!-- the update syntax. We set new values for `email` and `username`, but otherwise -->
<!-- use the same values from `user1` that we created in Listing 5-2. -->
<p>まず、リスト5-6では、更新記法なしで<code>user2</code>に新しい<code>User</code>インスタンスを生成する方法を示しています。
<code>email</code>と<code>username</code>には新しい値をセットしていますが、それ以外にはリスト5-2で生成した<code>user1</code>の値を使用しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from(&quot;someone@example.com&quot;),
#     username: String::from(&quot;someusername123&quot;),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
#}</code></pre></pre>
<!-- <span class="caption">Listing 5-6: Creating a new `User` instance using some of -->
<!-- the values from `user1`</span> -->
<p><span class="caption">リスト5-6: <code>user1</code>の一部の値を使用しつつ、新しい<code>User</code>インスタンスを生成する</span></p>
<!-- Using struct update syntax, we can achieve the same effect with less code, -->
<!-- shown in Listing 5-7. The syntax `..` specifies that the remaining fields not -->
<!-- explicitly set should have the same value as the fields in the given instance. -->
<p>構造体更新記法を使用すると、リスト5-7に示したように、コード量を減らしつつ、同じ効果を達成できます。<code>..</code>という記法により、
明示的にセットされていない残りのフィールドが、与えられたインスタンスのフィールドと同じ値になるように指定します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from(&quot;someone@example.com&quot;),
#     username: String::from(&quot;someusername123&quot;),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    ..user1
};
#}</code></pre></pre>
<!-- <span class="caption">Listing 5-7: Using struct update syntax to set new -->
<!-- `email` and `username` values for a `User` instance but use the rest of the -->
<!-- values from the fields of the instance in the `user1` variable</span> -->
<p><span class="caption">リスト5-7: 構造体更新記法を使用して、新しい<code>User</code>インスタンス用の値に新しい<code>email</code>と<code>username</code>をセットしつつ、
残りの値は、<code>user1</code>変数のフィールド値を使う</span></p>
<!-- The code in Listing 5-7 also creates an instance in `user2` that has a -->
<!-- different value for `email` and `username` but has the same values for the -->
<!-- `active` and `sign_in_count` fields from `user1`. -->
<p>リスト5-7のコードも、<code>email</code>と<code>username</code>については異なる値、<code>active</code>と<code>sign_in_count</code>フィールドについては、
<code>user1</code>と同じ値になるインスタンスを<code>user2</code>に生成します。</p>
<!-- ### Using Tuple Structs without Named Fields to Create Different Types -->
<a class="header" href="print.html#a異なる型を生成する名前付きフィールドのないタプル構造体を使用する" id="a異なる型を生成する名前付きフィールドのないタプル構造体を使用する"><h3>異なる型を生成する名前付きフィールドのないタプル構造体を使用する</h3></a>
<!-- We can also define structs that look similar to tuples, called *tuple-->
<!-- structs*. Tuple structs have the added meaning the struct name provides but -->
<!-- don’t have names associated with their fields; rather, they just have the types -->
<!-- of the fields. Tuple structs are useful when you want to give the whole tuple a -->
<!-- name and make the tuple be a different type than other tuples, and naming each -->
<!-- field as in a regular struct would be verbose or redundant. -->
<p>構造体名により追加の意味を含むものの、フィールドに紐づけられた名前がなく、むしろフィールドの型だけの<em>タプル構造体</em>と呼ばれる、
タプルに似た構造体を定義することもできます。タプル構造体は、構造体名が提供する追加の意味は含むものの、
フィールドに紐付けられた名前はありません; むしろ、フィールドの型だけが存在します。タプル構造体は、タプル全体に名前をつけ、
そのタプルを他のタプルとは異なる型にしたい場合に有用ですが、普通の構造体のように各フィールド名を与えるのは、
冗長、または余計になるでしょう。</p>
<!-- To define a tuple struct, you start with the `struct` keyword and the struct name -->
<!-- followed by the types in the tuple. For example, here are definitions and -->
<!-- usages of two tuple structs named `Color` and `Point`: -->
<p>タプル構造体を定義するには、<code>struct</code>キーワードの後に構造体名、さらにタプルに含まれる型を続けます。
例えば、こちらは、<code>Color</code>と<code>Point</code>という2種類のタプル構造体の定義と使用法です:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
#}</code></pre></pre>
<!-- Note that the `black` and `origin` values are different types, because they’re -->
<!-- instances of different tuple structs. Each struct we define is its own type, -->
<!-- even though the fields within the struct have the same types. For example, a -->
<!-- function that takes a parameter of type `Color` cannot take a `Point` as an -->
<!-- argument, even though both types are made up of three `i32` values. Otherwise, -->
<!-- tuple struct instances behave like tuples: you destructure them into their -->
<!-- individual pieces, you can use a `.` followed by the index to access an -->
<!-- individual value, and so on. -->
<p><code>black</code>と<code>origin</code>の値は、違う型であることに注目してください。これらは、異なるタプル構造体のインスタンスだからですね。
定義された各構造体は、構造体内のフィールドが同じ型であっても、それ自身が独自の型になります。
例えば、<code>Color</code>型を引数に取る関数は、<code>Point</code>を引数に取ることはできません。たとえ、両者の型が、
3つの<code>i32</code>値からできているにもかかわらずです。それ以外については、タプル構造体のインスタンスは、
タプルと同じように振る舞います: 分解して個々の部品にしたり、<code>.</code>と番号を使用して個々の値にアクセスするなどです。</p>
<!-- ### Unit-Like Structs without Any Fields -->
<a class="header" href="print.html#aフィールドのないユニットruby様rprprtようrtrprpruby構造体" id="aフィールドのないユニットruby様rprprtようrtrprpruby構造体"><h3>フィールドのないユニット<ruby>様<rp>(</rp><rt>よう</rt><rp>)</rp></ruby>構造体</h3></a>
<!-- We can also define structs that don’t have any fields! These are called -->
<!-- *unit-like structs* because they behave similarly to `()`, the unit type. -->
<!-- Unit-like structs can be useful in situations in which you need to implement a -->
<!-- trait on some type but you don’t have any data that you want to store in the type -->
<!-- itself. We’ll discuss traits in Chapter 10. -->
<p>また、一切フィールドのない構造体を定義することもできます！これらは、<code>()</code>、ユニット型と似たような振る舞いをすることから、
<em>ユニット様構造体</em>と呼ばれます。ユニット様構造体は、ある型にトレイトを実装するけれども、
型自体に保持させるデータは一切ない場面に有効になります。トレイトについては第10章で議論します。</p>
<!-- 以下のパラグラフでは、引用されてるブロックの後に、和訳を示します。こうしないと、意図通りのレイアウトにならないようです -->
<!-- ### Ownership of Struct Data -->
<!--  In the `User` struct definition in Listing 5-1, we used the owned `String` -->
<!--  type rather than the `&str` string slice type. This is a deliberate choice -->
<!--  because we want instances of this struct to own all of its data and for that -->
<!--  data to be valid for as long as the entire struct is valid. -->
<!--  -->
<!-- It’s possible for structs to store references to data owned by something else, -->
<!-- but to do so requires the use of *lifetimes*, a Rust feature that we’ll -->
<!-- discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct -->
<!-- is valid for as long as the struct is. Let’s say you try to store a reference -->
<!-- in a struct without specifying lifetimes, like this, which won't work: -->
<!--  -->
<!--  <span class="filename">Filename: src/main.rs</span> -->
<!--  -->
<!--  ```rust,ignore -->
<!--  struct User { -->
<!--      username: &str, -->
<!--      email: &str, -->
<!--      sign_in_count: u64, -->
<!--      active: bool, -->
<!--  } -->
<!--  -->
<!--  fn main() { -->
<!--      let user1 = User { -->
<!--          email: "someone@example.com", -->
<!--          username: "someusername123", -->
<!--          active: true, -->
<!--          sign_in_count: 1, -->
<!--      }; -->
<!--  } -->
<!--  ``` -->
<!--  -->
<!--  The compiler will complain that it needs lifetime specifiers: -->
<!--  -->
<!--  ```text -->
<!--  error[E0106]: missing lifetime specifier -->
<!--   -->
<!-- >   | -->
<!-- > 2 |     username: &str, -->
<!-- >   |               ^ expected lifetime parameter -->
<!-- > -->
<!-- > error[E0106]: missing lifetime specifier -->
<!-- >  -->
<!-- >   | -->
<!-- > 3 |     email: &str, -->
<!-- >   |            ^ expected lifetime parameter -->
<!-- > ``` -->
<!-- > -->
<!-- > In Chapter 10, we’ll discuss how to fix these errors so you can store -->
<!-- > references in structs, but for now, we’ll fix errors like these using owned -->
<!-- > types like `String` instead of references like `&str`. -->
<blockquote>
<a class="header" href="print.html#a構造体データの所有権" id="a構造体データの所有権"><h3>構造体データの所有権</h3></a>
<p>リスト5-1の<code>User</code>構造体定義において、<code>&amp;str</code>文字列スライス型ではなく、所有権のある<code>String</code>型を使用しました。
これは意図的な選択です。というのも、この構造体のインスタンスには全データを所有してもらう必要があり、
このデータは、構造体全体が有効な間はずっと有効である必要があるのです。</p>
<p>構造体に、他の何かに所有されたデータへの参照を保持させることもできますが、
そうするには<em>ライフタイム</em>という第10章で議論するRustの機能を使用しなければなりません。
ライフタイムのおかげで構造体に参照されたデータが、構造体自体が有効な間、ずっと有効であることを保証してくれるのです。
ライフタイムを指定せずに構造体に参照を保持させようとしたとしましょう。以下の通りですが、これは動きません:</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>コンパイラは、ライフタイム指定子が必要だと怒るでしょう:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
(エラー: ライフタイム指定子がありません)
 --&gt;
  | 
2 |     username: &amp;str,
  |               ^ expected lifetime parameter
                   (ライフタイム引数を予期しました)

error[E0106]: missing lifetime specifier
 --&gt;
  | 
3 |     email: &amp;str,
  |            ^ expected lifetime parameter
</code></pre>
<p>第10章で、これらのエラーを解消して構造体に参照を保持する方法について議論しますが、
当面、今回のようなエラーは、<code>&amp;str</code>のような参照の代わりに、<code>String</code>のような所有された型を使うことで解消します。</p>
</blockquote>
<!-- ## An Example Program Using Structs -->
<a class="header" href="print.html#a構造体を使ったプログラム例" id="a構造体を使ったプログラム例"><h2>構造体を使ったプログラム例</h2></a>
<!-- To understand when we might want to use structs, let’s write a program that -->
<!-- calculates the area of a rectangle. We’ll start with single variables, and then -->
<!-- refactor the program until we’re using structs instead. -->
<p>構造体を使用したくなる可能性のあるケースを理解するために、四角形の面積を求めるプログラムを書きましょう。
単一の変数から始め、代わりに構造体を使うようにプログラムをリファクタリングします。</p>
<!-- Let’s make a new binary project with Cargo called *rectangles* that will take -->
<!-- the width and height of a rectangle specified in pixels and will calculate the area -->
<!-- of the rectangle. Listing 5-8 shows a short program with one way of doing -->
<!-- exactly that in our project’s *src/main.rs*. -->
<p>Cargoで<em>rectangles</em>という新規バイナリプロジェクトを作成しましょう。このプロジェクトは、
四角形の幅と高さをピクセルで指定し、その面積を求めます。リスト5-8に、プロジェクトの<em>src/main.rs</em>で、
正にそうする一例を短いプログラムとして示しました。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    // 四角形の面積は、{}平方ピクセルです
    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<!-- <span class="caption">Listing 5-8: Calculating the area of a rectangle -->
<!-- specified by separate width and height variables</span> -->
<p><span class="caption">リスト5-8: 個別の幅と高さ変数を指定して四角形の面積を求める</span></p>
<!-- Now, run this program using `cargo run`: -->
<p>では、<code>cargo run</code>でこのプログラムを走らせてください:</p>
<pre><code class="language-text">The area of the rectangle is 1500 square pixels.
(四角形の面積は、1500平方ピクセルです)
</code></pre>
<!-- ### Refactoring with Tuples -->
<a class="header" href="print.html#aタプルでリファクタリングする" id="aタプルでリファクタリングする"><h3>タプルでリファクタリングする</h3></a>
<!-- Even though Listing 5-8 works and figures out the area of the rectangle by -->
<!-- calling the `area` function with each dimension, we can do better. The width -->
<!-- and the height are related to each other because together they describe one -->
<!-- rectangle. -->
<p>リスト5-8のコードはうまく動き、各次元で<code>area</code>関数を呼び出すことで四角形の面積を割り出しますが、
改善点があります。幅と高さは、組み合わせると一つの四角形を表すので、相互に関係があるわけです。</p>
<!-- The issue with this code is evident in the signature of `area`: -->
<p>このコードの問題点は、<code>area</code>のシグニチャから明らかです:</p>
<pre><code class="language-rust ignore">fn area(width: u32, height: u32) -&gt; u32 {
</code></pre>
<!-- The `area` function is supposed to calculate the area of one rectangle, but the -->
<!-- function we wrote has two parameters. The parameters are related, but that’s -->
<!-- not expressed anywhere in our program. It would be more readable and more -->
<!-- manageable to group width and height together. We’ve already discussed one way -->
<!-- we might do that in the "The Tuple Type" section of Chapter 3: by using tuples. -->
<p><code>area</code>関数は、1四角形の面積を求めるものと考えられますが、今書いた関数には、引数が2つあります。
引数は関連性があるのに、このプログラム内のどこにもそのことは表現されていません。
幅と高さを一緒にグループ化する方が、より読みやすく、扱いやすくなるでしょう。
それをする一つの方法については、第3章の「タプル型」節ですでに議論しました: タプルを使うのです。</p>
<!-- ### Refactoring with Tuples -->
<a class="header" href="print.html#aタプルでリファクタリングする-1" id="aタプルでリファクタリングする-1"><h3>タプルでリファクタリングする</h3></a>
<!-- Listing 5-9 shows another version of our program that uses tuples. -->
<p>リスト5-9は、タプルを使う別バージョンのプログラムを示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<!-- <span class="caption">Listing 5-9: Specifying the width and height of the -->
<!-- rectangle with a tuple</span> -->
<p><span class="caption">リスト5-9: タプルで四角形の幅と高さを指定する</span></p>
<!-- In one way, this program is better. Tuples let us add a bit of structure, and -->
<!-- we’re now passing just one argument. But in another way, this version is less -->
<!-- clear: tuples don’t name their elements, so our calculation has become more -->
<!-- confusing because we have to index into the parts of the tuple. -->
<p>ある意味では、このプログラムはマシです。タプルのおかげで少し構造的になり、一引数を渡すだけになりました。
しかし別の意味では、このバージョンは明確性を失っています: タプルは要素に名前を付けないので、
計算が不明瞭になったのです。なぜなら、タプルの一部に添え字アクセスする必要があるからです。</p>
<!-- It doesn’t matter if we mix up width and height for the area calculation, but -->
<!-- if we want to draw the rectangle on the screen, it would matter! We would have -->
<!-- to keep in mind that `width` is the tuple index `0` and `height` is the tuple -->
<!-- index `1`. If someone else worked on this code, they would have to figure this -->
<!-- out and keep it in mind as well. It would be easy to forget or mix up these -->
<!-- values and cause errors, because we haven’t conveyed the meaning of our data in -->
<!-- our code. -->
<p>面積計算で幅と高さを混在させるのなら問題はないのですが、四角形を画面に描画したいとなると、問題になるのです！
タプルの添え字<code>0</code>が<code>幅</code>で、添え字<code>1</code>が<code>高さ</code>であることを肝に命じておかなければなりません。
他人がこのコードをいじることになったら、このことを割り出し、同様に肝に命じなければならないでしょう。
容易く、このことを忘れたり、これらの値を混ぜこぜにしたりしてエラーを発生させてしまうでしょう。
データの意味をコードに載せていないからです。</p>
<!-- ### Refactoring with Structs: Adding More Meaning -->
<a class="header" href="print.html#a構造体でリファクタリングする-より意味付けする" id="a構造体でリファクタリングする-より意味付けする"><h3>構造体でリファクタリングする: より意味付けする</h3></a>
<!-- We use structs to add meaning by labeling the data. We can transform the tuple -->
<!-- we’re using into a data type with a name for the whole as well as names for the -->
<!-- parts, as shown in Listing 5-10. -->
<p>データにラベル付けをして意味付けを行い、構造体を使います。現在使用しているタプルを全体と一部に名前のあるデータ型に、
変形することができます。そう、リスト5-10に示したように。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<!-- <span class="caption">Listing 5-10: Defining a `Rectangle` struct</span> -->
<p><span class="caption">リスト5-10: <code>Rectangle</code>構造体を定義する</span></p>
<!-- Here we’ve defined a struct and named it `Rectangle`. Inside the curly -->
<!-- brackets, we defined the fields as `width` and `height`, both of which have -->
<!-- type `u32`. Then in `main`, we create a particular instance of a `Rectangle` -->
<!-- that has a width of 30 and a height of 50. -->
<p>ここでは、構造体を定義し、<code>Rectangle</code>という名前にしています。波括弧の中で<code>width</code>と<code>height</code>というフィールドを定義し、
<code>u32</code>という型にしました。それから<code>main</code>内で<code>Rectangle</code>の特定のインスタンスを生成し、
幅を30、高さを50にしました。</p>
<!-- Our `area` function is now defined with one parameter, which we’ve named -->
<!-- `rectangle`, whose type is an immutable borrow of a struct `Rectangle` -->
<!-- instance. As mentioned in Chapter 4, we want to borrow the struct rather than -->
<!-- take ownership of it. This way, `main` retains its ownership and can continue -->
<!-- using `rect1`, which is the reason we use the `&` in the function signature and -->
<!-- where we call the function. -->
<p>これで<code>area</code>関数は引数が一つになり、この引数は名前が<code>rectangle</code>、型は<code>Rectangle</code>構造体インスタンスへの不変借用になりました。
第4章で触れたように、構造体の所有権を奪うよりも借用する必要があります。こうすることで<code>main</code>は所有権を保って、
<code>rect1</code>を使用し続けることができ、そのために関数シグニチャと関数呼び出し時に<code>&amp;</code>を使っているわけです。</p>
<!-- The `area` function accesses the `width` and `height` fields of the `Rectangle` -->
<!-- instance. Our function signature for `area` now indicates exactly what we mean: -->
<!-- calculate the area of a `Rectangle`, using its `width` and `height` fields. This -->
<!-- conveys that the width and height are related to each other, and it gives -->
<!-- descriptive names to the values rather than using the tuple index values of `0` -->
<!-- and `1`. This is a win for clarity. -->
<p><code>area</code>関数は、<code>Rectangle</code>インスタンスの<code>width</code>と<code>height</code>フィールドにアクセスしています。
これで、<code>area</code>の関数シグニチャは、我々の意図をズバリ示すようになりました: <code>width</code>と<code>height</code>フィールドを使って、
<code>Rectangle</code>の面積を計算します。これにより、幅と高さが相互に関係していることが伝わり、
タプルの<code>0</code>や<code>1</code>という添え字を使うのではなく、値に説明的な名前を与えられるのです。簡潔性を勝ち取ったわけですね。</p>
<!-- ### Adding Useful Functionality with Derived Traits -->
<a class="header" href="print.html#aトレイトの継承で有用な機能を追加する" id="aトレイトの継承で有用な機能を追加する"><h3>トレイトの継承で有用な機能を追加する</h3></a>
<!-- It’d be nice to be able to print an instance of `Rectangle` while we’re -->
<!-- debugging our program and see the values for all its fields. Listing 5-11 tries -->
<!-- using the `println!` macro as we have used it in previous chapters. This won't -->
<!-- work, however. -->
<p>プログラムのデバッグをし、フィールドの値を調べている間に<code>Rectangle</code>のインスタンスを出力できると、
素晴らしいわけです。リスト5-11では、以前の章のように、<code>println!</code>マクロを試しに使用しようとしていますが、動きません。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    // rect1は{}です
    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<!-- <span class="caption">Listing 5-11: Attempting to print a `Rectangle` -->
<!-- instance</span> -->
<p><span class="caption">リスト5-11: <code>Rectangle</code>のインスタンスを出力しようとする</span></p>
<!-- When we run this code, we get an error with this core message: -->
<p>このコードを走らせると、こんな感じのエラーが出ます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied
(エラー: トレイト境界`Rectangle: std::fmt::Display`が満たされていません)
</code></pre>
<!-- The `println!` macro can do many kinds of formatting, and by default, the curly -->
<!-- brackets tell `println!` to use formatting known as `Display`: output intended -->
<!-- for direct end user consumption. The primitive types we’ve seen so far -->
<!-- implement `Display` by default, because there’s only one way you’d want to show -->
<!-- a `1` or any other primitive type to a user. But with structs, the way -->
<!-- `println!` should format the output is less clear because there are more -->
<!-- display possibilities: do you want commas or not? Do you want to print the -->
<!-- curly brackets? Should all the fields be shown? Due to this ambiguity, Rust -->
<!-- doesn't try to guess what we want, and structs don’t have a provided -->
<!-- implementation of `Display`. -->
<p><code>println!</code>マクロには、様々な整形があり、標準では、波括弧は<code>Display</code>として知られる整形をするよう、
<code>println!</code>に指示するのです: 直接エンドユーザ向けの出力です。これまでに見てきた基本型は、
標準で<code>Display</code>を実装しています。というのも、<code>1</code>や他の基本型をユーザに見せる方法は一つしかないからです。
しかし構造体では、<code>println!</code>が出力を整形する方法は自明ではなくなります。出力方法がいくつもあるからです:
カンマは必要なの？波かっこを出力する必要はある？全フィールドが見えるべき？この曖昧性のため、
Rustは必要なものを推測しようとせず、構造体には<code>Display</code>実装が提供されないのです。</p>
<!-- If we continue reading the errors, we’ll find this helpful note: -->
<p>エラーを読み下すと、こんな有益な注意書きがあります:</p>
<pre><code class="language-text">`Rectangle` cannot be formatted with the default formatter; try using
`:?` instead if you are using a format string
(注釈: `Rectangle`は、デフォルト整形機では、整形できません; フォーマット文字列を使うのなら
代わりに`:?`を試してみてください)
</code></pre>
<!-- Let’s try it! The `println!` macro call will now look like `println!("rect1 is -->
<!-- {:?}", rect1);`. Putting the specifier `:?` inside the curly brackets tells -->
<!-- `println!` we want to use an output format called `Debug`. The `Debug` trait -->
<!-- enables us to print our struct in a way that is useful for developers so we can -->
<!-- see its value while we’re debugging our code. -->
<p>試してみましょう！<code>pritnln!</code>マクロ呼び出しは、<code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>という見た目になるでしょう。
波括弧内に<code>:?</code>という指定子を書くと、<code>println!</code>に<code>Debug</code>と呼ばれる出力整形を使いたいと指示するのです。
<code>Debug</code>トレイトは、開発者にとって有用な方法で構造体を出力させてくれるので、
コードをデバッグしている最中に、値を確認することができます。</p>
<!-- Run the code with this change. Drat! We still get an error: -->
<p>変更してコードを走らせてください。なに！まだエラーが出ます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Debug` is not satisfied
(エラー: トレイト境界`Rectangle: std::fmt::Debug`は満たされていません)
</code></pre>
<!-- But again, the compiler gives us a helpful note: -->
<p>しかし今回も、コンパイラは有益な注意書きを残してくれています:</p>
<pre><code class="language-text">`Rectangle` cannot be formatted using `:?`; if it is defined in your
crate, add `#[derive(Debug)]` or manually implement it
(注釈: `Rectangle`は`:?`を使って整形できません; 自分のクレートで定義しているのなら
`#[derive(Debug)]`を追加するか、手動で実装してください)
</code></pre>
<!-- Rust *does* include functionality to print out debugging information, but we -->
<!-- have to explicitly opt in to make that functionality available for our struct. -->
<!-- To do that, we add the annotation `#[derive(Debug)]` just before the struct -->
<!-- definition, as shown in Listing 5-12. -->
<p><em>確かに</em>Rustにはデバッグ用の情報を出力する機能が備わっていますが、この機能を構造体で使えるようにするには、
明示的な選択をしなければならないのです。そうするには、構造体定義の直前に<code>#[derive(Debug)]</code>という注釈を追加します。
そう、リスト5-12で示されている通りです。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<!-- <span class="caption">Listing 5-12: Adding the annotation to derive the `Debug` -->
<!-- trait and printing the `Rectangle` instance using debug formatting</span> -->
<p><span class="caption">リスト5-12: <code>Debug</code>トレイトを継承する注釈を追加し、
<code>Rectangle</code>インスタンスをデバッグ用整形機で出力する</span></p>
<!-- Now when we run the program, we won’t get any errors, and we’ll see the -->
<!-- following output: -->
<p>これでプログラムを実行すれば、エラーは出ず、以下のような出力が得られるでしょう:</p>
<pre><code class="language-text">rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<!-- Nice! It’s not the prettiest output, but it shows the values of all the fields -->
<!-- for this instance, which would definitely help during debugging. When we have -->
<!-- larger structs, it’s useful to have output that’s a bit easier to read; in -->
<!-- those cases, we can use `{:#?}` instead of `{:?}` in the `println!` string. -->
<!-- When we use the `{:#?}` style in the example, the output will look like this: -->
<p>素晴らしい！最善の出力ではないものの、このインスタンスの全フィールドの値を出力しているので、
デバッグ中には間違いなく役に立つでしょう。より大きな構造体があるなら、もう少し読みやすい出力の方が有用です;
そのような場合には、<code>println!</code>文字列中の<code>{:?}</code>の代わりに<code>{:#?}</code>を使うことができます。
この例で<code>{:#?}</code>というスタイルを使用したら、出力は以下のようになるでしょう:</p>
<pre><code class="language-text">rect1 is Rectangle {
    width: 30,
    height: 50
}
</code></pre>
<!-- Rust has provided a number of traits for us to use with the `derive` annotation -->
<!-- that can add useful behavior to our custom types. Those traits and their -->
<!-- behaviors are listed in Appendix C. We’ll cover how to implement these traits -->
<!-- with custom behavior as well as how to create your own traits in Chapter 10. -->
<p>Rustには、<code>derive</code>注釈で使えるトレイトが多く提供されており、独自の型に有用な振る舞いを追加することができます。
そのようなトレイトとその振る舞いは、付録Cで一覧になっています。
これらのトレイトを独自の動作とともに実装する方法だけでなく、独自のトレイトを生成する方法については、第10章で解説します。</p>
<!-- Our `area` function is very specific: it only computes the area of rectangles. -->
<!-- It would be helpful to tie this behavior more closely to our `Rectangle` -->
<!-- struct, because it won’t work with any other type. Let’s look at how we can -->
<!-- continue to refactor this code by turning the `area` function into an `area` -->
<!-- *method* defined on our `Rectangle` type. -->
<p><code>area</code>関数は、非常に特殊です: 四角形の面積を算出するだけです。<code>Rectangle</code>構造体とこの動作をより緊密に結び付けられると、
役に立つでしょう。なぜなら、他のどんな型でもうまく動作しなくなるからです。
<code>area</code>関数を<code>Rectangle</code>型に定義された<code>area</code><em>メソッド</em>に変形することで、
このコードをリファクタリングし続けられる方法について見ていきましょう。</p>
<!-- ## Method Syntax -->
<a class="header" href="print.html#aメソッド記法" id="aメソッド記法"><h2>メソッド記法</h2></a>
<!-- *Methods* are similar to functions: they’re declared with the `fn` keyword and -->
<!-- their name, they can have parameters and a return value, and they contain some -->
<!-- code that is run when they’re called from somewhere else. However, methods are -->
<!-- different from functions in that they’re defined within the context of a struct -->
<!-- (or an enum or a trait object, which we cover in Chapters 6 and 17, -->
<!-- respectively), and their first parameter is always `self`, which represents the -->
<!-- instance of the struct the method is being called on. -->
<p><em>メソッド</em>は関数に似ています: <code>fn</code>キーワードと名前で宣言されるし、引数と返り値があるし、
どこか別の場所で呼び出された時に実行されるコードを含みます。ところが、
メソッドは構造体の文脈(あるいはenumかトレイトオブジェクトの。これらについては各々第6章と17章で解説します)で定義されるという点で、
関数とは異なり、最初の引数は必ず<code>self</code>になり、これはメソッドが呼び出されている構造体インスタンスを表します。</p>
<!-- ### Defining Methods -->
<a class="header" href="print.html#aメソッドを定義する" id="aメソッドを定義する"><h3>メソッドを定義する</h3></a>
<!-- Let’s change the `area` function that has a `Rectangle` instance as a parameter -->
<!-- and instead make an `area` method defined on the `Rectangle` struct, as shown -->
<!-- in Listing 5-13. -->
<p><code>Rectangle</code>インスタンスを引数に取る<code>area</code>関数を変え、代わりに<code>Rectangle</code>構造体上に<code>area</code>メソッドを作りましょう。
リスト5-13に示した通りですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<!-- <span class="caption">Listing 5-13: Defining an `area` method on the -->
<!-- `Rectangle` struct</span> -->
<p><span class="caption">リスト5-13: <code>Rectangle</code>構造体上に<code>area</code>メソッドを定義する</span></p>
<!-- To define the function within the context of `Rectangle`, we start an `impl` -->
<!-- (implementation) block. Then we move the `area` function within the `impl` -->
<!-- curly brackets and change the first (and in this case, only) parameter to be -->
<!-- `self` in the signature and everywhere within the body. In `main`, where we -->
<!-- called the `area` function and passed `rect1` as an argument, we can instead -->
<!-- use *method syntax* to call the `area` method on our `Rectangle` instance. -->
<!-- The method syntax goes after an instance: we add a dot followed by the method -->
<!-- name, parentheses, and any arguments. -->
<p><code>Rectangle</code>の文脈内で関数を定義するには、<code>impl</code>(implementation; 実装)ブロックを始めます。
それから<code>area</code>関数を<code>impl</code>の波かっこ内に移動させ、最初の(今回は唯一の)引数をシグニチャ内と本体内全てで<code>self</code>に変えます。
<code>area</code>関数を呼び出し、<code>rect1</code>を引数として渡す<code>main</code>では、代替としてメソッド記法を使用して、
<code>Rectangle</code>インスタンスの<code>area</code>メソッドを呼び出せます。メソッド記法は、インスタンスの後に続きます:
ドット、メソッド名、かっこ、そして引数と続くわけです。</p>
<!-- In the signature for `area`, we use `&self` instead of `rectangle: &Rectangle` -->
<!-- because Rust knows the type of `self` is `Rectangle` due to this method being -->
<!-- inside the `impl Rectangle` context. Note that we still need to use the `&` -->
<!-- before `self`, just like we did in `&Rectangle`. Methods can take ownership of -->
<!-- `self`, borrow `self` immutably as we’ve done here, or borrow `self` mutably, -->
<!-- just as they can any other parameter. -->
<p><code>area</code>のシグニチャでは、<code>rectangle: &amp;Rectangle</code>の代わりに<code>&amp;self</code>を使用しています。
というのも、コンパイラは、このメソッドが<code>impl Rectangle</code>という文脈内に存在するために、
<code>self</code>の型が<code>Rectangle</code>であると把握しているからです。<code>&amp;Rectangle</code>と同様に、
<code>self</code>の直前に<code>&amp;</code>を使用していることに注意してください。メソッドは、<code>self</code>の所有権を奪ったり、
ここでしているように不変で<code>self</code>を借用したり、可変で<code>self</code>を借用したりできるのです。
他の引数と全く同じですね。</p>
<!-- We’ve chosen `&self` here for the same reason we used `&Rectangle` in the -->
<!-- function version: we don’t want to take ownership, and we just want to read the -->
<!-- data in the struct, not write to it. If we wanted to change the instance that -->
<!-- we’ve called the method on as part of what the method does, we’d use `&mut -->
<!-- self` as the first parameter. Having a method that takes ownership of the -->
<!-- instance by using just `self` as the first parameter is rare; this technique is -->
<!-- usually used when the method transforms `self` into something else and we want -->
<!-- to prevent the caller from using the original instance after the transformation. -->
<p>ここで<code>&amp;self</code>を選んでいるのは、関数バージョンで<code>&amp;Rectangle</code>を使用していたのと同様の理由です:
所有権はいらず、構造体のデータを読み込みたいだけで、書き込む必要はないわけです。
メソッドの一部でメソッドを呼び出したインスタンスを変更したかったら、第1引数に<code>&amp;mut self</code>を使用するでしょう。
<code>self</code>だけを第1引数にしてインスタンスの所有権を奪うメソッドを定義することは稀です; このテクニックは、
通常メソッドが<code>self</code>を何か別のものに変形し、変形後に呼び出し元が元のインスタンスを使用できないようにしたい場合に使用されます。</p>
<!-- The main benefit of using methods instead of functions, in addition to using -->
<!-- method syntax and not having to repeat the type of `self` in every method’s -->
<!-- signature, is for organization. We’ve put all the things we can do with an -->
<!-- instance of a type in one `impl` block rather than making future users of our -->
<!-- code search for capabilities of `Rectangle` in various places in the library we -->
<!-- provide. -->
<p>関数の代替としてメソッドを使う主な利点は、メソッド記法を使用して全メソッドのシグニチャで<code>self</code>の型を繰り返す必要がなくなる以外だと、
体系化です。コードの将来的な利用者に<code>Rectangle</code>の機能を提供しているライブラリ内の各所でその機能を探させるのではなく、
この型のインスタンスでできることを一つの<code>impl</code>ブロックにまとめあげています。</p>
<!-- 例によって、以下の節では、引用ブロックの後に和訳を示します -->
<!--  ### Where’s the `->` Operator? -->
<!--  -->
<!--  In C and C++, two different operators are used for calling methods: you use -->
<!--  `.` if you’re calling a method on the object directly and `->` if you're -->
<!--  calling the method on a pointer to the object and need to dereference the -->
<!--  pointer first. In other words, if `object` is a pointer, -->
<!--  `object->something()` is similar to `(*object).something()`. -->
<!--  -->
<!--  Rust doesn’t have an equivalent to the `->` operator; instead, Rust has a -->
<!--  feature called *automatic referencing and dereferencing*. Calling methods is -->
<!--  one of the few places in Rust that has this behavior. -->
<!--  -->
<!--  Here’s how it works: when you call a method with `object.something()`, Rust -->
<!--  automatically adds in `&`, `&mut`, or `*` so `object` matches the signature of -->
<!--  the method. In other words, the following are the same: -->
<!--  -->
<!--  ```rust -->
<!--  # #[derive(Debug,Copy,Clone)] -->
<!--  # struct Point { -->
<!--  #     x: f64, -->
<!--  #     y: f64, -->
<!--  # } -->
<!--  # -->
<!--  # impl Point { -->
<!--  #    fn distance(&self, other: &Point) -> f64 { -->
<!--  #        let x_squared = f64::powi(other.x - self.x, 2); -->
<!--  #        let y_squared = f64::powi(other.y - self.y, 2); -->
<!--  # -->
<!--  #        f64::sqrt(x_squared + y_squared) -->
<!--  #    } -->
<!--  # } -->
<!--  # let p1 = Point { x: 0.0, y: 0.0 }; -->
<!--  # let p2 = Point { x: 5.0, y: 6.5 }; -->
<!--  p1.distance(&p2); -->
<!--  (&p1).distance(&p2); -->
<!--  ``` -->
<!--  -->
<!--  The first one looks much cleaner. This automatic referencing behavior works -->
<!--  because methods have a clear receiver—the type of `self`. Given the receiver -->
<!--  and name of a method, Rust can figure out definitively whether the method is -->
<!--  reading (`&self`), mutating (`&mut self`), or consuming (`self`). The fact -->
<!--  that Rust makes borrowing implicit for method receivers is a big part of -->
<!--  making ownership ergonomic in practice. -->
<blockquote>
<a class="header" href="print.html#a-演算子はどこに行ったの" id="a-演算子はどこに行ったの"><h3><code>-&gt;</code>演算子はどこに行ったの？</h3></a>
<p>CとC++では、メソッド呼び出しには2種類の異なる演算子が使用されます:
オブジェクトに対して直接メソッドを呼び出すのなら、<code>.</code>を使用するし、オブジェクトのポインタに対してメソッドを呼び出し、
先にポインタを参照外しする必要があるなら、<code>-&gt;</code>を使用するわけです。
言い換えると、<code>object</code>がポインタなら、<code>object-&gt;something()</code>は、<code>(*object).something()</code>と同等なのです。</p>
<p>Rustには<code>-&gt;</code>演算子の代わりとなるようなものはありません; その代わり、Rustには、
<em>自動参照および参照外し</em>という機能があります。Rustにおいてメソッド呼び出しは、
この動作が行われる数少ない箇所なのです。</p>
<p>動作方法はこうです: <code>object.something()</code>とメソッドを呼び出すと、
コンパイラは<code>object</code>がメソッドのシグニチャと合致するように、自動で<code>&amp;</code>か<code>&amp;mut</code>、<code>*</code>を付与するのです。
要するに、以下のコードは同じものです:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug,Copy,Clone)]
# struct Point {
#     x: f64,
#     y: f64,
# }
#
# impl Point {
#    fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
#        let x_squared = f64::powi(other.x - self.x, 2);
#        let y_squared = f64::powi(other.y - self.y, 2);
#
#        f64::sqrt(x_squared + y_squared)
#    }
# }
# let p1 = Point { x: 0.0, y: 0.0 };
# let p2 = Point { x: 5.0, y: 6.5 };
p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
#}</code></pre></pre>
<p>前者の方がずっと明確です。メソッドには自明な受け手(<code>self</code>の型)がいるので、この自動参照機能は動作するのです。
受け手とメソッド名が与えられれば、コンパイラは確実にメソッドが読み込み専用(<code>&amp;self</code>)か、書き込みもする(<code>&amp;mut self</code>)のか、
所有権を奪う(<code>self</code>)のか判断できるわけです。Rustにおいて、メソッドの受け手に関して借用が明示されないという事実は、
所有権を現実世界でプログラマフレンドリーにさせる大部分を占めているのです。</p>
</blockquote>
<!-- ### Methods with More Parameters -->
<a class="header" href="print.html#aより引数の多いメソッド" id="aより引数の多いメソッド"><h3>より引数の多いメソッド</h3></a>
<!-- Let’s practice using methods by implementing a second method on the `Rectangle` -->
<!-- struct. This time, we want an instance of `Rectangle` to take another instance -->
<!-- of `Rectangle` and return `true` if the second `Rectangle` can fit completely -->
<!-- within `self`; otherwise it should return `false`. That is, we want to be able -->
<!-- to write the program shown in Listing 5-14, once we’ve defined the `can_hold` -->
<!-- method. -->
<p><code>Rectangle</code>構造体に2番目のメソッドを実装して、メソッドを使う鍛錬をしましょう。今回は、<code>Rectangle</code>のインスタンスに、
別の<code>Rectangle</code>のインスタンスを取らせ、2番目の<code>Rectangle</code>が<code>self</code>に完全にはめ込まれたら、<code>true</code>を返すようにしたいのです;
そうでなければ、<code>false</code>を返すべきです。つまり、一旦<code>can_hold</code>メソッドを定義したら、
リスト5-14のようなプログラムを書けるようになりたいのです。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    // rect1にrect2ははまり込む？
    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<!-- <span class="caption">Listing 5-14: Using the as-yet-unwritten `can_hold` -->
<!-- method</span> -->
<p><span class="caption">リスト5-14: 未完成の<code>can_hold</code>を使用する</span></p>
<!-- And the expected output would look like the following, because both dimensions -->
<!-- of `rect2` are smaller than the dimensions of `rect1` but `rect3` is wider than -->
<!-- `rect1`: -->
<p>そして、予期される出力は以下のようになります。なぜなら、<code>rect2</code>の各次元は<code>rect1</code>よりも小さいものの、
<code>rect3</code>は<code>rect1</code>より幅が広いからです:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<!-- We know we want to define a method, so it will be within the `impl Rectangle` -->
<!-- block. The method name will be `can_hold`, and it will take an immutable borrow -->
<!-- of another `Rectangle` as a parameter. We can tell what the type of the -->
<!-- parameter will be by looking at the code that calls the method: -->
<!-- `rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow to -->
<!-- `rect2`, an instance of `Rectangle`. This makes sense because we only need to -->
<!-- read `rect2` (rather than write, which would mean we’d need a mutable borrow), -->
<!-- and we want `main` to retain ownership of `rect2` so we can use it again after -->
<!-- calling the `can_hold` method. The return value of `can_hold` will be a -->
<!-- Boolean, and the implementation will check whether the width and height of -->
<!-- `self` are both greater than the width and height of the other `Rectangle`, -->
<!-- respectively. Let’s add the new `can_hold` method to the `impl` block from -->
<!-- Listing 5-13, shown in Listing 5-15. -->
<p>メソッドを定義したいことはわかっているので、<code>impl Rectangle</code>ブロック内での話になります。
メソッド名は、<code>can_hold</code>になり、引数として別の<code>Rectangle</code>を不変借用で取るでしょう。
メソッドを呼び出すコードを見れば、引数の型が何になるかわかります: <code>rect1.can_hold(&amp;rect2)</code>は、
<code>&amp;rect2</code>、<code>Rectangle</code>のインスタンスである<code>rect2</code>への不変借用を渡しています。
これは道理が通っています。なぜなら、<code>rect2</code>を読み込む(書き込みではなく。この場合、可変借用が必要になります)だけでよく、
<code>can_hold</code>メソッドを呼び出した後にも<code>rect2</code>が使えるよう、所有権を<code>main</code>に残したままにしたいからです。
<code>can_hold</code>の返り値は、論理型になり、メソッドの中身は、<code>self</code>の幅と高さがもう一つの<code>Rectangle</code>の幅と高さよりも、
それぞれ大きいことを確認します。リスト5-13の<code>impl</code>ブロックに新しい<code>can_hold</code>メソッドを追記しましょう。
リスト5-15に示した通りです。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 5-15: Implementing the `can_hold` method on -->
<!-- `Rectangle` that takes another `Rectangle` instance as a parameter</span> -->
<p><span class="caption">リスト5-15: 別の<code>Rectangle</code>のインスタンスを引数として取る<code>can_hold</code>メソッドを、
<code>Rectangle</code>に実装する</span></p>
<!-- When we run this code with the `main` function in Listing 5-14, we’ll get our -->
<!-- desired output. Methods can take multiple parameters that we add to the -->
<!-- signature after the `self` parameter, and those parameters work just like -->
<!-- parameters in functions. -->
<p>このコードをリスト5-14の<code>main</code>関数と合わせて実行すると、望み通りの出力が得られます。
メソッドは、<code>self</code>引数の後にシグニチャに追加した引数を複数取ることができ、
その引数は、関数の引数と同様に動作するのです。</p>
<!-- ### Associated Functions -->
<a class="header" href="print.html#a関連関数" id="a関連関数"><h3>関連関数</h3></a>
<!-- Another useful feature of `impl` blocks is that we’re allowed to define -->
<!-- functions within `impl` blocks that *don’t* take `self` as a parameter. These -->
<!-- are called *associated functions* because they’re associated with the struct. -->
<!-- They’re still functions, not methods, because they don’t have an instance of -->
<!-- the struct to work with. You’ve already used the `String::from` associated -->
<!-- function. -->
<p><code>impl</code>ブロックの別の有益な機能は、<code>impl</code>ブロック内に<code>self</code>を引数に取ら<em>ない</em>関数を定義できることです。
これは、構造体に関連付けられているので、<em>関連関数</em>と呼ばれます。それでも、関連関数は関数であり、メソッドではありません。
というのも、対象となる構造体のインスタンスが存在しないからです。もう<code>String::from</code>という関連関数を使用したことがありますね。</p>
<!-- Associated functions are often used for constructors that will return a new -->
<!-- instance of the struct. For example, we could provide an associated function -->
<!-- that would have one dimension parameter and use that as both width and height, -->
<!-- thus making it easier to create a square `Rectangle` rather than having to -->
<!-- specify the same value twice: -->
<p>関連関数は、構造体の新規インスタンスを返すコンストラクタによく使用されます。例えば、一次元の引数を取り、
長さと幅両方に使用する関連関数を提供することができ、その結果、同じ値を2回指定する必要なく、
正方形の<code>Rectangle</code>を生成しやすくすることができます。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}
#}</code></pre></pre>
<!-- To call this associated function, we use the `::` syntax with the struct name; -->
<!-- `let sq = Rectangle::square(3);` is an example. This function is namespaced by -->
<!-- the struct: the `::` syntax is used for both associated functions and -->
<!-- namespaces created by modules. We’ll discuss modules in Chapter 7. -->
<p>この関連関数を呼び出すために、構造体名と一緒に<code>::</code>記法を使用します; 一例は<code>let sq = Rectangle::square(3);</code>です。
この関数は、構造体によって名前空間分けされています: <code>::</code>という記法は、関連関数とモジュールによって作り出される名前空間両方に使用されます。
モジュールについては第7章で議論します。</p>
<!-- ### Multiple `impl` Blocks -->
<a class="header" href="print.html#a複数のimplブロック" id="a複数のimplブロック"><h3>複数の<code>impl</code>ブロック</h3></a>
<!-- Each struct is allowed to have multiple `impl` blocks. For example, Listing -->
<!-- 5-15 is equivalent to the code shown in Listing 5-16, which has each method -->
<!-- in its own `impl` block. -->
<p>各構造体には、複数の<code>impl</code>ブロックを存在させることができます。例えば、リスト5-15はリスト5-16に示したコードと等価で、
リスト5-16では、各メソッドごとに<code>impl</code>ブロックを用意しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple `impl` -->
<!-- blocks</span> -->
<p><span class="caption">リスト5-16: 複数の<code>impl</code>ブロックを使用してリスト5-15を書き直す</span></p>
<!-- There’s no reason to separate these methods into multiple `impl` blocks here, -->
<!-- but this is valid syntax. We'll see a case in which multiple `impl` blocks are -->
<!-- useful in Chapter 10, where we discuss generic types and traits. -->
<p>ここでこれらのメソッドを個々の<code>impl</code>ブロックに分ける理由はないのですが、有効な書き方です。
複数の<code>impl</code>ブロックが有用になるケースは第10章で見ますが、そこではジェネリクスのある型と、トレイトについて議論します。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-4" id="aまとめ-4"><h2>まとめ</h2></a>
<!-- Structs let us create custom types that are meaningful for your domain. By -->
<!-- using structs, we can keep associated pieces of data connected to each other -->
<!-- and name each piece to make our code clear. Methods let us specify the -->
<!-- behavior that instances of our structs have, and associated functions let you -->
<!-- namespace functionality that is particular to our struct without having an -->
<!-- instance available. -->
<p>構造体により、自分の領域で意味のある独自の型を作成することができます。構造体を使用することで、
関連のあるデータ片を相互に結合させたままにし、各部品に名前を付け、コードを明確にすることができます。
メソッドにより、構造体のインスタンスが行う動作を指定することができ、関連関数により、
構造体に特有の機能をインスタンスを利用することなく、名前空間分けすることができます。</p>
<!-- But structs aren’t the only way we can create custom types: let’s turn to -->
<!-- Rust’s enum feature to add another tool to our toolbox. -->
<p>しかし、構造体だけが独自の型を作成する手段ではありません: Rustのenum機能に目を向けて、
別の道具を道具箱に追加しましょう。</p>
<!-- # Enums and Pattern Matching -->
<a class="header" href="print.html#enumとパターンマッチング" id="enumとパターンマッチング"><h1>Enumとパターンマッチング</h1></a>
<!-- イーナムとカタカナで表記するのも変なので、Enumという表記で統一します -->
<!-- In this chapter we’ll look at *enumerations*, also referred to as *enums*. -->
<!-- Enums allow you to define a type by enumerating its possible values. First, -->
<!-- we’ll define and use an enum to show how an enum can encode meaning along with -->
<!-- data. Next, we’ll explore a particularly useful enum, called `Option`, which -->
<!-- expresses that a value can be either something or nothing. Then we’ll look at -->
<!-- how pattern matching in the `match` expression makes it easy to run different -->
<!-- code for different values of an enum. Finally, we’ll cover how the `if let` -->
<!-- construct is another convenient and concise idiom available to you to handle -->
<!-- enums in your code. -->
<p>この章では、<em>列挙型</em>について見ていきます。列挙型は、<em>enum</em>とも称されます。enumは、取りうる値を列挙することで、
型を定義させてくれます。最初に、enumを定義し、使用して、enumがデータとともに意味をコード化する方法を示します。
次に、特別に有用なenumである<code>Option</code>について掘り下げていきましょう。この型は、
値が何かかなんでもないかを表現します。それから、<code>match</code>式のパターンマッチングにより、
どうenumの色々な値に対して異なるコードを走らせやすくなるかを見ます。最後に、<code>if let</code>文法要素も、
<ruby>如何<rp>(</rp><rt>いか</rt><rp>)</rp></ruby>にenumをコードで扱う際に使用可能な便利で簡潔な慣用句であるかを解説します。</p>
<!-- Enums are a feature in many languages, but their capabilities differ in each -->
<!-- language. Rust’s enums are most similar to *algebraic data types* in functional -->
<!-- languages like F#, OCaml, and Haskell. -->
<p>enumは多くの言語に存在する機能ですが、その能力は言語ごとに異なります。Rustのenumは、F#、OCaml、Haskellなどの、
関数型言語に存在する<em>代数的データ型</em>に最も酷似しています。</p>
<!-- ## Defining an Enum -->
<a class="header" href="print.html#enumを定義する" id="enumを定義する"><h2>Enumを定義する</h2></a>
<!-- Let’s look at a situation we might want to express in code and see why enums -->
<!-- are useful and more appropriate than structs in this case. Say we need to work -->
<!-- with IP addresses. Currently, two major standards are used for IP addresses: -->
<!-- version four and version six. These are the only possibilities for an IP -->
<!-- address that our program will come across: we can *enumerate* all possible -->
<!-- values, which is where enumeration gets its name. -->
<p>コードで表現したくなるかもしれない場面に目を向けて、enumが有効でこの場合、構造体よりも適切である理由を確認しましょう。
IPアドレスを扱う必要が出たとしましょう。現在、IPアドレスの規格は二つあります: バージョン4とバージョン6です。
これらは、プログラムが遭遇するIPアドレスのすべての可能性です: 列挙型は、取りうる値をすべて<em>列挙</em>でき、
これが列挙型の名前の由来です。</p>
<!-- Any IP address can be either a version four or a version six address, but not -->
<!-- both at the same time. That property of IP addresses makes the enum data -->
<!-- structure appropriate, because enum values can only be one of the variants. -->
<!-- Both version four and version six addresses are still fundamentally IP -->
<!-- addresses, so they should be treated as the same type when the code is handling -->
<!-- situations that apply to any kind of IP address. -->
<p>どんなIPアドレスも、バージョン4かバージョン6のどちらかになりますが、同時に両方にはなり得ません。
IPアドレスのその特性によりenumデータ構造が適切なものになります。というのも、
enumの値は、そのバリアントのいずれか一つにしかなり得ないからです。バージョン4とバージョン6のアドレスは、
どちらも根源的にはIPアドレスですから、コードがいかなる種類のIPアドレスにも適用される場面を扱う際には、
同じ型として扱われるべきです。</p>
<!-- We can express this concept in code by defining an `IpAddrKind` enumeration and -->
<!-- listing the possible kinds an IP address can be, `V4` and `V6`. These are known -->
<!-- as the *variants* of the enum: -->
<p>この概念をコードでは、<code>IpAddrKind</code>列挙型を定義し、IPアドレスがなりうる種類、<code>V4</code>と<code>V6</code>を列挙することで、
表現できます。これらは、enumの<em>列挙子</em>として知られています:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}
#}</code></pre></pre>
<!-- `IpAddrKind` is now a custom data type that we can use elsewhere in our code. -->
<p>これで、<code>IpAddrKind</code>はコードの他の場所で使用できる独自のデータ型になります。</p>
<!-- ### Enum Values -->
<a class="header" href="print.html#enumの値" id="enumの値"><h3>Enumの値</h3></a>
<!-- We can create instances of each of the two variants of `IpAddrKind` like this: -->
<p>以下のようにして、<code>IpAddrKind</code>の各バリアントのインスタンスは生成できます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
#}</code></pre></pre>
<!-- Note that the variants of the enum are namespaced under its identifier, and we -->
<!-- use a double colon to separate the two. The reason this is useful is that now -->
<!-- both values `IpAddrKind::V4` and `IpAddrKind::V6` are of the same type: -->
<!-- `IpAddrKind`. We can then, for instance, define a function that takes any -->
<!-- `IpAddrKind`: -->
<p>enumの列挙子は、その識別子の元に名前空間分けされていることと、
2連コロンを使ってその二つを区別していることに注意してください。
これが有効な理由は、こうすることで、値<code>IpAddrKind::V4</code>と<code>IpAddrKind::V6</code>という値は両方とも、
同じ型<code>IpAddrKind</code>になったからです。そうしたら、例えば、どんな<code>IpAddrKind</code>を取る関数も定義できるようになります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
fn route(ip_type: IpAddrKind) { }
#}</code></pre></pre>
<!-- And we can call this function with either variant: -->
<p>そして、この関数をどちらのバリアントに対しても呼び出せます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
# fn route(ip_type: IpAddrKind) { }
#
route(IpAddrKind::V4);
route(IpAddrKind::V6);
#}</code></pre></pre>
<!-- Using enums has even more advantages. Thinking more about our IP address type, -->
<!-- at the moment we don’t have a way to store the actual IP address *data*; we -->
<!-- only know what *kind* it is. Given that you just learned about structs in -->
<!-- Chapter 5, you might tackle this problem as shown in Listing 6-1. -->
<p>enumの利用には、さらなる利点さえもあります。このIPアドレス型についてもっと考えてみると、現状では、
実際のIPアドレスの<em>データ</em>を保持する方法がありません。つまり、どんな<em>種類</em>であるかを知っているだけです。
構造体について第5章で学んだばっかりとすると、この問題に対しては、リスト6-1のように対処するかもしれません。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<!-- <span class="caption">Listing 6-1: Storing the data and `IpAddrKind` variant of -->
<!-- an IP address using a `struct`</span> -->
<p><span class="caption">リスト6-1: IPアドレスのデータと<code>IpAddrKind</code>のバリアントを<code>struct</code>を使って保持する</span></p>
<!-- Here, we’ve defined a struct `IpAddr` that has two fields: a `kind` field that -->
<!-- is of type `IpAddrKind` (the enum we defined previously) and an `address` field -->
<!-- of type `String`. We have two instances of this struct. The first, `home`, has -->
<!-- the value `IpAddrKind::V4` as its `kind` with associated address data of -->
<!-- `127.0.0.1`. The second instance, `loopback`, has the other variant of -->
<!-- `IpAddrKind` as its `kind` value, `V6`, and has address `::1` associated with -->
<!-- it. We’ve used a struct to bundle the `kind` and `address` values together, so -->
<!-- now the variant is associated with the value. -->
<p>ここでは、二つのフィールドを持つ<code>IpAddr</code>という構造体を定義しています: <code>IpAddrKind</code>型(先ほど定義したenumですね)の<code>kind</code>フィールドと、
<code>String</code>型の<code>address</code>フィールドです。この構造体のインスタンスが2つあります。最初のインスタンス、
<code>home</code>には<code>kind</code>として<code>IpAddrKind::V4</code>があり、紐付けられたアドレスデータは<code>127.0.0.1</code>です。
2番目のインスタンス、<code>loopback</code>には、<code>kind</code>の値として、<code>IpAddrKind</code>のもう一つの列挙子、<code>V6</code>があり、
アドレス<code>::1</code>が紐付いています。構造体を使って<code>kind</code>と<code>address</code>値を一緒に包んだので、
もう列挙子は値と紐付けられています。</p>
<!-- We can represent the same concept in a more concise way using just an enum -->
<!-- rather than an enum inside a struct, by putting data directly into each enum -->
<!-- variant. This new definition of the `IpAddr` enum says that both `V4` and `V6` -->
<!-- variants will have associated `String` values: -->
<p>各enumの列挙子に直接データを格納して、enumを構造体内に使うというよりもenumだけを使って、
同じ概念をもっと簡潔な方法で表現することができます。この新しい<code>IpAddr</code>の定義は、
<code>V4</code>と<code>V6</code>列挙子両方に<code>String</code>値が紐付けられていることを述べています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<!-- We attach data to each variant of the enum directly, so there is no need for an -->
<!-- extra struct. -->
<p>enumの各列挙子にデータを直接添付できるので、余計な構造体を作る必要は全くありません。</p>
<!-- There’s another advantage to using an enum rather than a struct: each variant -->
<!-- can have different types and amounts of associated data. Version four type IP -->
<!-- addresses will always have four numeric components that will have values -->
<!-- between 0 and 255. If we wanted to store `V4` addresses as four `u8` values but -->
<!-- still express `V6` addresses as one `String` value, we wouldn’t be able to with -->
<!-- a struct. Enums handle this case with ease: -->
<p>構造体よりもenumを使うことには、別の利点もあります: 各列挙子に紐付けるデータの型と量は、異なってもいいのです。
バージョン4のIPアドレスには、常に0から255の値を持つ4つの数値があります。<code>V4</code>のアドレスは、4つの<code>u8</code>型の値として、
格納するけれども、<code>V6</code>のアドレスは引き続き、単独の<code>String</code>型の値で格納したかったとしても、構造体では不可能です。
enumなら、こんな場合も容易に対応できます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<!-- We’ve shown several different ways to define data structures to store version -->
<!-- four and version six IP addresses. However, as it turns out, wanting to store -->
<!-- IP addresses and encode which kind they are is so common that [the standard -->
<!-- library has a definition we can use!][IpAddr] Let’s look at how -->
<!-- the standard library defines `IpAddr`: it has the exact enum and variants that -->
<!-- we’ve defined and used, but it embeds the address data inside the variants in -->
<!-- the form of two different structs, which are defined differently for each -->
<!-- variant: -->
<p>バージョン4とバージョン6のIPアドレスを格納するデータ構造を定義する複数の異なる方法を示してきました。
しかしながら、蓋を開けてみれば、IPアドレスを格納してその種類をコード化したくなるということは一般的なので、
<a href="../../std/net/enum.IpAddr.html">標準ライブラリに使用可能な定義があります！</a> 標準ライブラリでの<code>IpAddr</code>の定義のされ方を見てみましょう:
私たちが定義し、使用したのと全く同じenumと列挙子がありますが、アドレスデータを二種の異なる構造体の形で列挙子に埋め込み、
この構造体は各列挙子用に異なる形で定義されています。</p>
<!-- ```rust -->
<!-- struct Ipv4Addr { -->
<!--     // details elided -->
<!-- } -->
<!-- struct Ipv6Addr { -->
<!--     // details elided -->
<!-- } -->
<!-- enum IpAddr { -->
<!--     V4(Ipv4Addr), -->
<!--     V6(Ipv6Addr), -->
<!-- } -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // 省略
}

struct Ipv6Addr {
    // 省略
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<!-- This code illustrates that you can put any kind of data inside an enum variant: -->
<!-- strings, numeric types, or structs, for example. You can even include another -->
<!-- enum! Also, standard library types are often not much more complicated than -->
<!-- what you might come up with. -->
<p>このコードは、enum列挙子内にいかなる種類のデータでも格納できることを描き出しています:
例を挙げれば、文字列、数値型、構造体などです。他のenumを含むことさえできます！また、
標準ライブラリの型は、あなたが思い付いたよりも複雑ではないことがしばしばあります。</p>
<!-- Note that even though the standard library contains a definition for `IpAddr`, -->
<!-- we can still create and use our own definition without conflict because we -->
<!-- haven’t brought the standard library’s definition into our scope. We’ll talk -->
<!-- more about bringing types into scope in Chapter 7. -->
<p>標準ライブラリに<code>IpAddr</code>に対する定義は含まれるものの、標準ライブラリの定義をスコープに導入していないので、
まだ、干渉することなく自分自身の定義を生成して使用できることに注意してください。型をスコープに導入することについては、
第7章でもっと詳しく言及します。</p>
<!-- Let’s look at another example of an enum in Listing 6-2: this one has a wide -->
<!-- variety of types embedded in its variants. -->
<p>リスト6-2でenumの別の例を見てみましょう: 今回のコードは、幅広い種類の型が列挙子に埋め込まれています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 6-2: A `Message` enum whose variants each store -->
<!-- different amounts and types of values</span> -->
<p><span class="caption">リスト6-2: 列挙子各々が異なる型と量の値を格納する<code>Message</code> enum</span></p>
<!-- This enum has four variants with different types: -->
<p>このenumには、異なる型の列挙子が4つあります:</p>
<!-- * `Quit` has no data associated with it at all. -->
<!-- * `Move` includes an anonymous struct inside it. -->
<!-- * `Write` includes a single `String`. -->
<!-- * `ChangeColor` includes three `i32` values. -->
<ul>
<li><code>Quit</code>には紐付けられたデータは全くなし。</li>
<li><code>Move</code>は、中に匿名構造体を含む。</li>
<li><code>Write</code>は、単独の<code>String</code>オブジェクトを含む。</li>
<li><code>ChangeColor</code>は、3つの<code>i32</code>値を含む。</li>
</ul>
<!-- Defining an enum with variants such as the ones in Listing 6-2 is similar to -->
<!-- defining different kinds of struct definitions, except the enum doesn’t use the -->
<!-- `struct` keyword and all the variants are grouped together under the `Message` -->
<!-- type. The following structs could hold the same data that the preceding enum -->
<!-- variants hold: -->
<p>リスト6-2のような列挙子を含むenumを定義することは、enumの場合、<code>struct</code>キーワードを使わず、
全部の列挙子が<code>Message</code>型の元に分類される点を除いて、異なる種類の構造体定義を定義するのと類似しています。
以下の構造体も、先ほどのenumの列挙子が保持しているのと同じデータを格納することができるでしょう:</p>
<!-- ```rust -->
<!-- struct QuitMessage; // unit struct -->
<!-- struct MoveMessage { -->
<!--     x: i32, -->
<!--     y: i32, -->
<!-- } -->
<!-- struct WriteMessage(String); // tuple struct -->
<!-- struct ChangeColorMessage(i32, i32, i32); // tuple struct -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct QuitMessage; // ユニット構造体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // タプル構造体
struct ChangeColorMessage(i32, i32, i32); // タプル構造体
#}</code></pre></pre>
<!-- But if we used the different structs, which each have their own type, we -->
<!-- couldn't as easily define a function to take any of these kinds of messages as -->
<!-- we could with the `Message` enum defined in Listing 6-2, which is a single type. -->
<!-- ちょっと文意を適切に表せているか怪しいかも -->
<p>ですが、異なる構造体を使っていたら、各々、それ自身の型があるので、単独の型になるリスト6-2で定義した<code>Message</code> enumほど、
これらの種のメッセージいずれもとる関数を簡単に定義することはできないでしょう。</p>
<!-- There is one more similarity between enums and structs: just as we’re able to -->
<!-- define methods on structs using `impl`, we’re also able to define methods on -->
<!-- enums. Here’s a method named `call` that we could define on our `Message` enum: -->
<p>enumと構造体にはもう1点似通っているところがあります: <code>impl</code>を使って構造体にメソッドを定義できるのと全く同様に、
enumにもメソッドを定義することができるのです。こちらは、<code>Message</code> enum上に定義できる<code>call</code>という名前のメソッドです:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Message {
#     Quit,
#     Move { x: i32, y: i32 },
#     Write(String),
#     ChangeColor(i32, i32, i32),
# }
#
impl Message {
    fn call(&amp;self) {
        // method body would be defined here
        // メソッド本体はここに定義される
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
#}</code></pre></pre>
<!-- The body of the method would use `self` to get the value that we called the -->
<!-- method on. In this example, we’ve created a variable `m` that has the value -->
<!-- `Message::Write(String::from("hello"))`, and that is what `self` will be in the -->
<!-- body of the `call` method when `m.call()` runs. -->
<p>メソッドの本体では、<code>self</code>を使用して、メソッドを呼び出した相手の値を取得できるでしょう。この例では、
<code>Message::Write(String::from(&quot;hello&quot;))</code>という値を持つ、変数<code>m</code>を生成したので、これが<code>m.call()</code>を走らせた時に、
<code>call</code>メソッドの本体内で<code>self</code>が表す値になります。</p>
<!-- Let’s look at another enum in the standard library that is very common and -->
<!-- useful: `Option`. -->
<p>非常に一般的で有用な別の標準ライブラリのenumを見てみましょう: <code>Option</code>です。</p>
<!-- ### The `Option` Enum and Its Advantages Over Null Values -->
<a class="header" href="print.html#option-enumとnull値に勝る利点" id="option-enumとnull値に勝る利点"><h3><code>Option</code> enumとNull値に勝る利点</h3></a>
<!-- In the previous section, we looked at how the `IpAddr` enum let us use Rust’s -->
<!-- type system to encode more information than just the data into our program. -->
<!-- This section explores a case study of `Option`, which is another enum defined -->
<!-- by the standard library. The `Option` type is used in many places because it -->
<!-- encodes the very common scenario in which a value could be something or it -->
<!-- could be nothing. Expressing this concept in terms of the type system means the -->
<!-- compiler can check that you’ve handled all the cases you should be handling; -->
<!-- this functionality can prevent bugs that are extremely common in other -->
<!-- programming languages. -->
<p>前節で、<code>IpAddr</code> enumがRustの型システムを使用して、プログラムにデータ以上の情報をコード化できる方法を目撃しました。
この節では、<code>Option</code>のケーススタディを掘り下げていきます。この型も標準ライブラリにより定義されているenumです。
この<code>Option</code>型はいろんな箇所で使用されます。なぜなら、値が何かかそうでないかという非常に一般的な筋書きをコード化するからです。
この概念を型システムの観点で表現することは、コンパイラが、プログラマが処理すべき場面全てを処理していることをチェックできることを意味します;
この機能は、他の言語において、究極的にありふれたバグを阻止することができます。</p>
<!-- Programming language design is often thought of in terms of which features you -->
<!-- include, but the features you exclude are important too. Rust doesn’t have the -->
<!-- null feature that many other languages have. *Null* is a value that means there -->
<!-- is no value there. In languages with null, variables can always be in one of -->
<!-- two states: null or not-null. -->
<p>プログラミング言語のデザインは、しばしばどの機能を入れるかという観点で考えられるが、
除いた機能も重要なのです。Rustには、他の多くの言語にはあるnull機能がありません。
<em>null</em>とはそこに何も値がないことを意味する値です。nullのある言語において、
変数は常に二者択一どちらかの状態になります: nullかそうでないかです。</p>
<!-- In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony -->
<!-- Hoare, the inventor of null, has this to say: -->
<p>nullの開発者であるTony Hoareの2009年のプレゼンテーション、&quot;Null References: The Billion Dollar Mistake&quot;では、こんなことが語られています。</p>
<!-- > I call it my billion-dollar mistake. At that time, I was designing the first -->
<!-- > comprehensive type system for references in an object-oriented language. My -->
<!-- > goal was to ensure that all use of references should be absolutely safe, with -->
<!-- > checking performed automatically by the compiler. But I couldn't resist the -->
<!-- > temptation to put in a null reference, simply because it was so easy to -->
<!-- > implement. This has led to innumerable errors, vulnerabilities, and system -->
<!-- > crashes, which have probably caused a billion dollars of pain and damage in -->
<!-- > the last forty years. -->
<blockquote>
<p>私はそれを10億ドルの失敗と呼んでいます。その頃、私は、オブジェクト指向言語の参照に対する、
最初のわかりやすい型システムを設計していました。私の目標は、
どんな参照の使用も全て完全に安全であるべきことを、コンパイラにそのチェックを自動で行ってもらって保証することだったのです。
しかし、null参照を入れるという誘惑に打ち勝つことができませんでした。それは、単純に実装が非常に容易だったからです。
これが無数のエラーや脆弱性、システムクラッシュにつながり、過去40年で10億ドルの苦痛や損害を引き起こしたであろうということなのです。</p>
</blockquote>
<!-- The problem with null values is that if you try to use a null value as a -->
<!-- not-null value, you’ll get an error of some kind. Because this null or not-null -->
<!-- property is pervasive, it’s extremely easy to make this kind of error. -->
<p>null値の問題は、nullの値をnullでない値のように使用しようとしたら、何らかの種類のエラーが出ることです。
このnullかそうでないかという特性は広く存在するので、この種の間違いを大変犯しやすいのです。</p>
<!-- However, the concept that null is trying to express is still a useful one: a -->
<!-- null is a value that is currently invalid or absent for some reason. -->
<p>しかしながら、nullが表現しようとしている概念は、それでも役に立つものです: nullは、
何らかの理由で現在無効、または存在しない値のことなのです。</p>
<!-- The problem isn’t really with the concept but with the particular -->
<!-- implementation. As such, Rust does not have nulls, but it does have an enum -->
<!-- that can encode the concept of a value being present or absent. This enum is -->
<!-- `Option<T>`, and it is [defined by the standard library][option] -->
<!-- as follows: -->
<p>問題は、全く概念にあるのではなく、特定の実装にあるのです。そんな感じなので、Rustにはnullがありませんが、
値が存在するか不在かという概念をコード化するenumならあります。このenumが<code>Option&lt;T&gt;</code>で、
以下のように<a href="../../std/option/enum.Option.html">標準ライブラリに定義</a>されています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<!-- The `Option<T>` enum is so useful that it’s even included in the prelude; you -->
<!-- don’t need to bring it into scope explicitly. In addition, so are its variants: -->
<!-- you can use `Some` and `None` directly without the `Option::` prefix. The -->
<!-- `Option<T>` is still just a regular enum, and `Some(T)` and `None` are -->
<!-- still variants of type `Option<T>`. -->
<p><code>Option&lt;T&gt;</code>は有益すぎて、初期化処理(prelude)にさえ含まれています。つまり、明示的にスコープに導入する必要がないのです。
さらに、列挙子もそうなっています: <code>Some</code>と<code>None</code>を<code>Option::</code>の接頭辞なしに直接使えるわけです。
ただ、<code>Option&lt;T&gt;</code>はそうは言っても、普通のenumであり、<code>Some(T)</code>と<code>None</code>も<code>Option&lt;T&gt;</code>型のただの列挙子です。</p>
<!-- The `<T>` syntax is a feature of Rust we haven’t talked about yet. It’s a -->
<!-- generic type parameter, and we’ll cover generics in more detail in Chapter 10. -->
<!-- For now, all you need to know is that `<T>` means the `Some` variant of the -->
<!-- `Option` enum can hold one piece of data of any type. Here are some examples of -->
<!-- using `Option` values to hold number types and string types: -->
<p><code>&lt;T&gt;</code>という記法は、まだ語っていないRustの機能です。これは、ジェネリック型引数であり、ジェネリクスについて詳しくは、
第10章で解説します。とりあえず、知っておく必要があることは、<code>&lt;T&gt;</code>は、<code>Option</code> enumの<code>Some</code>列挙子が、
あらゆる型のデータを1つだけ持つことができることを意味していることだけです。こちらは、
<code>Option</code>値を使って、数値型や文字列型を保持する例です。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<!-- If we use `None` rather than `Some`, we need to tell Rust what type of -->
<!-- `Option<T>` we have, because the compiler can't infer the type that the `Some` -->
<!-- variant will hold by looking only at a `None` value. -->
<p><code>Some</code>ではなく、<code>None</code>を使ったら、コンパイラに<code>Option&lt;T&gt;</code>の型が何になるかを教えなければいけません。
というのも、<code>None</code>値を見ただけでは、<code>Some</code>列挙子が保持する型をコンパイラが推論できないからです。</p>
<!-- When we have a `Some` value, we know that a value is present and the value is -->
<!-- held within the `Some`. When we have a `None` value, in some sense, it means -->
<!-- the same thing as null: we don’t have a valid value. So why is having -->
<!-- `Option<T>` any better than having null? -->
<p><code>Some</code>値がある時、値が存在するとわかり、その値は、<code>Some</code>に保持されています。<code>None</code>値がある場合、
ある意味、nullと同じことを意図します: 有効な値がないのです。では、なぜ<code>Option&lt;T&gt;</code>の方が、
nullよりも少しでも好ましいのでしょうか？</p>
<!-- In short, because `Option<T>` and `T` (where `T` can be any type) are different -->
<!-- types, the compiler won’t let us use an `Option<T>` value as if it was -->
<!-- definitely a valid value. For example, this code won’t compile because it’s -->
<!-- trying to add an `i8` to an `Option<i8>`: -->
<p>簡潔に述べると、<code>Option&lt;T&gt;</code>と<code>T</code>(ここで<code>T</code>はどんな型でもいい)は異なる型なので、
コンパイラが<code>Option&lt;T&gt;</code>値を確実に有効な値かのようには使用させてくれません。
例えば、このコードは<code>i8</code>を<code>Option&lt;i8&gt;</code>に足そうとしているので、コンパイルできません。</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
<!-- If we run this code, we get an error message like this: -->
<p>このコードを動かしたら、以下のようなエラーメッセージが出ます。</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
(エラー: `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;`というトレイト境界が満たされていません)
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<!-- Intense! In effect, this error message means that Rust doesn’t understand how -->
<!-- to add an `i8` and an `Option<i8>`, because they’re different types. When we -->
<!-- have a value of a type like `i8` in Rust, the compiler will ensure that we -->
<!-- always have a valid value. We can proceed confidently without having to check -->
<!-- for null before using that value. Only when we have an `Option<i8>` (or -->
<!-- whatever type of value we’re working with) do we have to worry about possibly -->
<!-- not having a value, and the compiler will make sure we handle that case before -->
<!-- using the value. -->
<p>なんて強烈な！実際に、このエラーメッセージは、<code>i8</code>と<code>Option&lt;i8&gt;</code>が異なる型なので、
足し合わせる方法がコンパイラにはわからないことを意味します。Rustにおいて、<code>i8</code>のような型の値がある場合、
コンパイラが常に有効な値であることを確認してくれます。この値を使う前にnullであることをチェックする必要なく、
自信を持って先に進むことができるのです。<code>Option&lt;i8&gt;</code>がある時(あるいはどんな型を扱おうとしていても)のみ、
値を保持していない可能性を心配する必要はないわけであり、
コンパイラはプログラマが値を使用する前にそのような場面を扱っているか確かめてくれます。</p>
<!-- In other words, you have to convert an `Option<T>` to a `T` before you can -->
<!-- perform `T` operations with it. Generally, this helps catch one of the most -->
<!-- common issues with null: assuming that something isn’t null when it actually -->
<!-- is. -->
<p>言い換えると、<code>T</code>型の処理を行う前には、<code>Option&lt;T&gt;</code>を<code>T</code>に変換する必要があるわけです。一般的に、
これにより、nullの最もありふれた問題の一つを捕捉する一助になります: 実際にはnullなのに、
そうでないかのように想定することです。</p>
<!-- Not having to worry about incorrectly assuming a not-null value helps you to be -->
<!-- more confident in your code. In order to have a value that can possibly be -->
<!-- null, you must explicitly opt in by making the type of that value `Option<T>`. -->
<!-- Then, when you use that value, you are required to explicitly handle the case -->
<!-- when the value is null. Everywhere that a value has a type that isn’t an -->
<!-- `Option<T>`, you *can* safely assume that the value isn’t null. This was a -->
<!-- deliberate design decision for Rust to limit null’s pervasiveness and increase -->
<!-- the safety of Rust code. -->
<p>不正確にnullでない値を想定する心配をしなくてもよいということは、コード内でより自信を持てることになります。
nullになる可能性のある値を保持するには、その値の型を<code>Option&lt;T&gt;</code>にすることで明示的に同意しなければなりません。
それからその値を使用する際には、値がnullである場合を明示的に処理する必要があります。
値が<code>Option&lt;T&gt;</code>以外の型であるとこ全てにおいて、値がnullでないと安全に想定することが<em>できます</em>。
これは、Rustにとって、意図的な設計上の決定であり、nullの普遍性を制限し、Rustコードの安全性を向上させます。</p>
<!-- So, how do you get the `T` value out of a `Some` variant when you have a value -->
<!-- of type `Option<T>` so you can use that value? The `Option<T>` enum has a large -->
<!-- number of methods that are useful in a variety of situations; you can check -->
<!-- them out in [its documentation][docs]. Becoming familiar with -->
<!-- the methods on `Option<T>` will be extremely useful in your journey with Rust. -->
<p>では、<code>Option&lt;T&gt;</code>型の値がある時、その値を使えるようにするには、どのように<code>Some</code>列挙子から<code>T</code>型の値を取り出せばいいのでしょうか？
<code>Option&lt;T&gt;</code>には様々な場面で有効に活用できる非常に多くのメソッドが用意されています;
<a href="../../std/option/enum.Option.html">ドキュメント</a>でそれらを確認できます。<code>Option&lt;T&gt;</code>のメソッドに馴染むと、
Rustの旅が極めて有益になるでしょう。</p>
<!-- In general, in order to use an `Option<T>` value, you want to have code that -->
<!-- will handle each variant. We want some code that will run only when you have a -->
<!-- `Some(T)` value, and this code is allowed to use the inner `T`. We want some -->
<!-- other code to run if we have a `None` value, and that code doesn’t have a `T` -->
<!-- value available. The `match` expression is a control flow construct that does -->
<!-- just this when used with enums: it will run different code depending on which -->
<!-- variant of the enum it has, and that code can use the data inside the matching -->
<!-- value. -->
<p>一般的に、<code>Option&lt;T&gt;</code>値を使うには、各列挙子を処理するコードが欲しくなります。
<code>Some(T)</code>値がある時だけ走る何らかのコードが欲しくなり、このコードが内部の<code>T</code>を使用できます。
<code>None</code>値があった場合に走る別のコードが欲しくなり、そちらのコードは<code>T</code>値は使用できない状態になります。
<code>match</code>式が、enumとともに使用した時にこれだけの動作をするフロー制御文法要素になります:
enumの列挙子によって、違うコードが走り、そのコードがマッチした値の中のデータを使用できるのです。</p>
<!-- ## The `match` Control Flow Operator -->
<a class="header" href="print.html#matchフロー制御演算子" id="matchフロー制御演算子"><h2><code>match</code>フロー制御演算子</h2></a>
<!-- Rust has an extremely powerful control flow operator called `match` that allows -->
<!-- us to compare a value against a series of patterns and then execute code based -->
<!-- on which pattern matches. Patterns can be made up of literal values, variable -->
<!-- names, wildcards, and many other things; Chapter 18 covers all the different -->
<!-- kinds of patterns and what they do. The power of `match` comes from the -->
<!-- expressiveness of the patterns and the fact that the compiler confirms that all -->
<!-- possible cases are handled. -->
<p>Rustには、一連のパターンに対して値を比較し、マッチしたパターンに応じてコードを実行させてくれる<code>match</code>と呼ばれる、
非常に強力なフロー制御演算子があります。パターンは、リテラル値、変数名、ワイルドカードやその他多数のもので構成することができます;
第18章で、全ての種類のパターンと、その目的については解説します。<code>match</code>のパワーは、
パターンの表現力とコンパイラが全てのありうるパターンを処理しているかを確認してくれるという事実に由来します。</p>
<!-- Think of a `match` expression kind of like a coin sorting machine: coins slide -->
<!-- down a track with variously sized holes along it, and each coin falls through -->
<!-- the first hole it encounters that it fits into. In the same way, values go -->
<!-- through each pattern in a `match`, and at the first pattern the value “fits,” -->
<!-- the value falls into the associated code block to be used during execution. -->
<p><code>match</code>式をコイン並べ替え装置のようなものと考えてください: コインは、様々なサイズの穴が空いた通路を流れ落ち、
各コインは、サイズのあった最初の穴に落ちます。同様に、値は<code>match</code>の各パターンを通り抜け、値が「適合する」最初のパターンで、
値は紐付けられたコードブロックに落ち、実行中に使用されるわけです。</p>
<!-- Because we just mentioned coins, let’s use them as an example using `match`! We -->
<!-- can write a function that can take an unknown United States coin and, in a -->
<!-- similar way as the counting machine, determine which coin it is and return its -->
<!-- value in cents, as shown here in Listing 6-3. -->
<p>コインについて話したので、それを<code>match</code>を使用する例にとってみましょう！数え上げ装置と同じ要領で未知のアメリカコインを一枚取り、
どの種類のコインなのか決定し、その価値をセントで返す関数をリスト6-3で示したように記述することができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 6-3: An enum and a `match` expression that has -->
<!-- the variants of the enum as its patterns.</span> -->
<p><span class="caption">リスト6-3: enumとそのenumの列挙子をパターンにした<code>match</code>式</span></p>
<!-- Let’s break down the `match` in the `value_in_cents` function. First, we list -->
<!-- the `match` keyword followed by an expression, which in this case is the value -->
<!-- `coin`. This seems very similar to an expression used with `if`, but there’s a -->
<!-- big difference: with `if`, the expression needs to return a Boolean value, but -->
<!-- here, it can be any type. The type of `coin` in this example is the `Coin` enum -->
<!-- that we defined on 1. -->
<p><code>value_in_cents</code>関数内の<code>match</code>を噛み砕きましょう。まず、<code>match</code>キーワードに続けて式を並べています。
この式は今回の場合、値<code>coin</code>です。<code>if</code>で使用した式と非常に酷似しているみたいですね。しかし、大きな違いがあります:
<code>if</code>では、式は論理値を返す必要がありますが、ここでは、どんな型でも構いません。この例における<code>coin</code>の型は、
1行目で定義した<code>Coin</code> enumです。</p>
<!-- Next are the `match` arms. An arm has two parts: a pattern and some code. The -->
<!-- first arm here has a pattern that is the value `Coin::Penny` and then the `=>` -->
<!-- operator that separates the pattern and the code to run. The code in this case -->
<!-- is just the value `1`. Each arm is separated from the next with a comma. -->
<p>次は、<code>match</code>アームです。一本のアームには2つの部品があります: パターンと何らかのコードです。
今回の最初のアームは<code>Coin::Penny</code>という値のパターンであり、パターンと動作するコードを区別する<code>=&gt;</code>演算子が続きます。
この場合のコードは、ただの値<code>1</code>です。各アームは次のアームとカンマで区切られています。</p>
<!-- When the `match` expression executes, it compares the resulting value against -->
<!-- the pattern of each arm, in order. If a pattern matches the value, the code -->
<!-- associated with that pattern is executed. If that pattern doesn’t match the -->
<!-- value, execution continues to the next arm, much as in a coin-sorting machine. -->
<!-- We can have as many arms as we need: in Listing 6-3, our `match` has four arms. -->
<p>この<code>match</code>式が実行されると、結果の値を各アームのパターンと順番に比較します。パターンに値がマッチしたら、
そのコードに紐付けられたコードが実行されます。パターンが値にマッチしなければ、コイン並べ替え装置と全く同じように、
次のアームが継続して実行されます。必要なだけパターンは存在できます: リスト6-3では、<code>match</code>には4本のアームがあります。</p>
<!-- The code associated with each arm is an expression, and the resulting value of -->
<!-- the expression in the matching arm is the value that gets returned for the -->
<!-- entire `match` expression. -->
<p>各アームに紐付けられるコードは式であり、マッチしたアームの式の結果が<code>match</code>式全体の戻り値になります。</p>
<!-- Curly brackets typically aren’t used if the match arm code is short, as it is -->
<!-- in Listing 6-3 where each arm just returns a value. If you want to run multiple -->
<!-- lines of code in a match arm, you can use curly brackets. For example, the -->
<!-- following code would print out “Lucky penny!” every time the method was called with -->
<!-- a `Coin::Penny` but would still return the last value of the block, `1`: -->
<p>典型的に、アームのコードが短い場合、波かっこは使用されません。リスト6-3では、各アームが値を返すだけなので、
これに倣っています。マッチのアームで複数行のコードを走らせたいのなら、波かっこを使用することができます。
例えば、以下のコードは、メソッドが<code>Coin::Penny</code>とともに呼び出されるたびに「Lucky penny!」と表示しつつ、
ブロックの最後の値、<code>1</code>を返すでしょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<!-- ### Patterns that Bind to Values -->
<a class="header" href="print.html#a値に束縛されるパターン" id="a値に束縛されるパターン"><h3>値に束縛されるパターン</h3></a>
<!-- Another useful feature of match arms is that they can bind to parts of the -->
<!-- values that match the pattern. This is how we can extract values out of enum -->
<!-- variants. -->
<p>マッチのアームの別の有益な機能は、パターンにマッチした値の一部に束縛できる点です。こうして、
enumの列挙子から値を取り出すことができます。</p>
<!-- As an example, let’s change one of our enum variants to hold data inside it. -->
<!-- From 1999 through 2008, the United States minted quarters with different -->
<!-- designs for each of the 50 states on one side. No other coins got state -->
<!-- designs, so only quarters have this extra value. We can add this information to -->
<!-- our `enum` by changing the `Quarter` variant to include a `UsState` value stored -->
<!-- inside it, which we've done here in Listing 6-4. -->
<p>例として、enumの列挙子の一つを中にデータを保持するように変えましょう。1999年から2008年まで、
アメリカは、片側に50の州それぞれで異なるデザインをしたクォーターコインを鋳造していました。
他のコインは州のデザインがなされることはなかったので、クォーターだけがこのおまけの値を保持します。
<code>Quarter</code>列挙子を変更して、<code>UsState</code>値が中に保持されるようにすることで<code>enum</code>にこの情報を追加でき、
それをしたのがリスト6-4のコードになります。</p>
<!-- ```rust -->
<!-- #[derive(Debug)] // so we can inspect the state in a minute -->
<!-- enum UsState { -->
<!--     Alabama, -->
<!--     Alaska, -->
<!--     // ... etc -->
<!-- } -->
<!-- enum Coin { -->
<!--     Penny, -->
<!--     Nickel, -->
<!--     Dime, -->
<!--     Quarter(UsState), -->
<!-- } -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // すぐに州を点検できるように
enum UsState {
    Alabama,
    Alaska,
    // ... などなど
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 6-4: A `Coin` enum in which the `Quarter` variant -->
<!-- also holds a `UsState` value</span> -->
<p><span class="caption">リスト6-4: <code>Quarter</code>列挙子が<code>UsState</code>の値も保持する<code>Coin</code> enum</span></p>
<!-- Let’s imagine that a friend of ours is trying to collect all 50 state quarters. -->
<!-- While we sort our loose change by coin type, we’ll also call out the name of -->
<!-- the state associated with each quarter so if it’s one our friend doesn’t have, -->
<!-- they can add it to their collection. -->
<!-- この段落は、言いたいことがよくわからない -->
<p>友人の一人が50州全部のクォーターコインを収集しようとしているところを想像しましょう。コインの種類で並べ替えつつ、
各クォーターに関連した州の名前を出力すると、友人が持っていない種類だったら、コレクションに追加することができます。</p>
<!-- In the match expression for this code, we add a variable called `state` to the -->
<!-- pattern that matches values of the variant `Coin::Quarter`. When a -->
<!-- `Coin::Quarter` matches, the `state` variable will bind to the value of that -->
<!-- quarter’s state. Then we can use `state` in the code for that arm, like so: -->
<p>このコードのmatch式では、<code>Coin::Quarter</code>列挙子の値にマッチする<code>state</code>という名の変数をパターンに追加します。
<code>Coin::Quarter</code>がマッチすると、<code>state</code>変数はそのクォーターのstateの値に束縛されます。それから、
<code>state</code>をそのアームのコードで使用できます。以下のようにですね:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
#
fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
#}</code></pre></pre>
<!-- If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` -->
<!-- would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each -->
<!-- of the match arms, none of them match until we reach `Coin::Quarter(state)`. At -->
<!-- that point, the binding for `state` will be the value `UsState::Alaska`. We can -->
<!-- then use that binding in the `println!` expression, thus getting the inner -->
<!-- state value out of the `Coin` enum variant for `Quarter`. -->
<p><code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>と呼び出すつもりだったなら、<code>coin</code>は
<code>Coin::Quarter(UsState::Alaska)</code>になります。その値をmatchの各アームと比較すると、
<code>Coin::Quater(state)</code>に到達するまで、どれにもマッチしません。その時に、<code>state</code>に束縛されるのは、
<code>UsState::Alaska</code>という値です。そして、<code>println!</code>式でその束縛を使用することができ、
そのため、<code>Coin</code> enumの列挙子から<code>Quarter</code>に対する中身のstateの値を取得できたわけです。</p>
<!-- ### Matching with `Option<T>` -->
<a class="header" href="print.html#optiontとのマッチ" id="optiontとのマッチ"><h3><code>Option&lt;T&gt;</code>とのマッチ</h3></a>
<!-- In the previous section we wanted to get the inner `T` value out of the `Some` -->
<!-- case when using `Option<T>`; we can also handle `Option<T>` using `match` as we -->
<!-- did with the `Coin` enum! Instead of comparing coins, we’ll compare the -->
<!-- variants of `Option<T>`, but the way that the `match` expression works remains -->
<!-- the same. -->
<p>前節では、<code>Option&lt;T&gt;</code>を使用する際に、<code>Some</code>ケースから中身の<code>T</code>の値を取得したくなりました。要するに、
<code>Coin</code> enumに対して行ったように、<code>match</code>を使って<code>Option&lt;T&gt;</code>を扱うこともできるというわけです！
コインを比較する代わりに、<code>Option&lt;T&gt;</code>の列挙子を比較するのですが、<code>match</code>式の動作の仕方は同じままです。</p>
<!-- Let’s say we want to write a function that takes an `Option<i32>` and, if -->
<!-- there’s a value inside, adds 1 to that value. If there isn’t a value inside, -->
<!-- the function should return the `None` value and not attempt to perform any -->
<!-- operations. -->
<p><code>Option&lt;i32&gt;</code>を取る関数を書きたくなったとし、中に値があったら、その値に1を足すことにしましょう。
中に値がなければ、関数は<code>None</code>値を返し、何も処理を試みるべきではありません。</p>
<!-- This function is very easy to write, thanks to `match`, and will look like -->
<!-- Listing 6-5. -->
<p><code>match</code>のおかげで、この関数は大変書きやすく、リスト6-5のような見た目になります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#}</code></pre></pre>
<!-- <span class="caption">Listing 6-5: A function that uses a `match` expression on -->
<!-- an `Option<i32>`</span> -->
<p><span class="caption">リスト6-5: <code>Option&lt;i32&gt;</code>に<code>match</code>式を使う関数</span></p>
<!-- Let’s examine the first execution of `plus_one` in more detail. When we call -->
<!-- `plus_one(five)`, the variable `x` in the body of `plus_one` will have the -->
<!-- value `Some(5)`. We then compare that against each match arm. -->
<p><code>plus_one</code>の最初の実行についてもっと詳しく検証しましょう。<code>plus_one(five)</code>と呼び出した時、
<code>plus_one</code>の本体の変数<code>x</code>は<code>Some(5)</code>になります。そして、これをマッチの各アームと比較します。</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<!-- The `Some(5)` value doesn’t match the pattern `None`, so we continue to the -->
<!-- next arm. -->
<p><code>Some(5)</code>という値は、<code>None</code>というパターンにはマッチしませんので、次のアームに処理が移ります。</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<!-- Does `Some(5)` match `Some(i)`? Why yes it does! We have the same variant. The -->
<!-- `i` binds to the value contained in `Some`, so `i` takes the value `5`. The -->
<!-- code in the match arm is then executed, so we add one to the value of `i` and -->
<!-- create a new `Some` value with our total `6` inside. -->
<p><code>Some(5)</code>は<code>Some(i)</code>にマッチしますか？えっと、します！列挙子が同じです。<code>i</code>は<code>Some</code>に含まれる値に束縛されるので、
<code>i</code>は値<code>5</code>になります。それから、このマッチのアームのコードが実行されるので、<code>i</code>の値に1を足し、
合計の<code>6</code>を中身にした新しい<code>Some</code>値を生成します。</p>
<!-- Now let’s consider the second call of `plus_one` in Listing 6-5, where `x` is -->
<!-- `None`. We enter the `match` and compare to the first arm. -->
<p>さて、<code>x</code>が<code>None</code>になるリスト6-5の2回目の<code>plus_one</code>の呼び出しを考えましょう。<code>match</code>に入り、
最初のアームと比較します。</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<!-- It matches! There’s no value to add to, so the program stops and returns the -->
<!-- `None` value on the right side of `=>`. Because the first arm matched, no other -->
<!-- arms are compared. -->
<p>マッチします！足し算する値がないので、プログラムは停止し、<code>=&gt;</code>の右辺にある<code>None</code>値が返ります。
最初のアームがマッチしたため、他のアームは比較されません。</p>
<!-- Combining `match` and enums is useful in many situations. You’ll see this -->
<!-- pattern a lot in Rust code: `match` against an enum, bind a variable to the -->
<!-- data inside, and then execute code based on it. It’s a bit tricky at first, but -->
<!-- once you get used to it, you’ll wish you had it in all languages. It’s -->
<!-- consistently a user favorite. -->
<p><code>match</code>とenumの組み合わせは、多くの場面で有効です。Rustコードにおいて、このパターンはよく見かけるでしょう:
enumに対し<code>match</code>し、内部のデータに変数を束縛させ、それに基づいたコードを実行します。最初はちょっと巧妙ですが、
一旦慣れてしまえば、全ての言語にあってほしいと願うことになるでしょう。一貫してユーザのお気に入りなのです。</p>
<!-- ### Matches Are Exhaustive -->
<!-- いい単語を探したい(Exhaustive) -->
<a class="header" href="print.html#aマッチは包括的" id="aマッチは包括的"><h3>マッチは包括的</h3></a>
<!-- There’s one other aspect of `match` we need to discuss. Consider this version -->
<!-- of our `plus_one` function that has a bug and won't compile: -->
<p>もう一つ議論する必要のある<code>match</code>の観点があります。1点バグがありコンパイルできないこんなバージョンの<code>plus_one</code>関数を考えてください:</p>
<pre><code class="language-rust ignore">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<!-- We didn’t handle the `None` case, so this code will cause a bug. Luckily, it’s -->
<!-- a bug Rust knows how to catch. If we try to compile this code, we’ll get this -->
<!-- error: -->
<p><code>None</code>の場合を扱っていないため、このコードはバグを生みます。幸い、コンパイラが捕捉できるバグです。
このコードのコンパイルを試みると、こんなエラーが出ます:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
(エラー: 包括的でないパターン: `None`がカバーされてません)
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<!-- Rust knows that we didn’t cover every possible case and even knows which -->
<!-- pattern we forgot! Matches in Rust are *exhaustive*: we must exhaust every last -->
<!-- possibility in order for the code to be valid. Especially in the case of -->
<!-- `Option<T>`, when Rust prevents us from forgetting to explicitly handle the -->
<!-- `None` case, it protects us from assuming that we have a value when we might -->
<!-- have null, thus making the billion dollar mistake discussed earlier. -->
<p>全可能性を網羅していないことをコンパイラは検知しています。もっと言えば、どのパターンを忘れているかさえ知っているのです。
Rustにおけるマッチは、<em>包括的</em>です: 全てのあらゆる可能性を網羅し尽くさなければ、コードは有効にならないのです。
特に<code>Option&lt;T&gt;</code>の場合には、コンパイラが明示的に<code>None</code>の場合を扱うのを忘れないようにする時、
nullになるかもしれない値があることを想定しないように、故に、前に議論した10億ドルの失敗を犯さないよう、
保護してくれるわけです。</p>
<!-- ### The `_` Placeholder -->
<a class="header" href="print.html#a_というプレースホルダー" id="a_というプレースホルダー"><h3><code>_</code>というプレースホルダー</h3></a>
<!-- Rust also has a pattern we can use when we don’t want to list all possible -->
<!-- values. For example, a `u8` can have valid values of 0 through 255. If we only -->
<!-- care about the values 1, 3, 5, and 7, we don’t want to have to list out 0, 2, -->
<!-- 4, 6, 8, 9 all the way up to 255. Fortunately, we don’t have to: we can use the -->
<!-- special pattern `_` instead: -->
<p>Rustには、全ての可能性を列挙したくない時に使用できるパターンもあります。例えば、<code>u8</code>は、有効な値として、
0から255までを取ります。1、3、5、7の値にだけ興味があったら、0、2、4、6、8、9と255までの数値を列挙する必要に迫られたくはないです。
幸運なことに、する必要はありません: 代わりに特別なパターンの<code>_</code>を使用できます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<!-- The `_` pattern will match any value. By putting it after our other arms, the -->
<!-- `_` will match all the possible cases that aren’t specified before it. The `()` -->
<!-- is just the unit value, so nothing will happen in the `_` case. As a result, we -->
<!-- can say that we want to do nothing for all the possible values that we don’t -->
<!-- list before the `_` placeholder. -->
<p><code>_</code>というパターンは、どんな値にもマッチします。他のアームの後に記述することで、<code>_</code>は、
それまでに指定されていない全ての可能性にマッチします。<code>()</code>は、ただのユニット値なので、<code>_</code>の場合には、
何も起こりません。結果として、<code>_</code>プレースホルダーの前に列挙していない可能性全てに対しては、
何もしたくないと言えるわけです。</p>
<!-- However, the `match` expression can be a bit wordy in a situation in which we -->
<!-- care about only *one* of the cases. For this situation, Rust provides `if let`. -->
<p>ですが、<em>一つ</em>のケースにしか興味がないような場面では、<code>match</code>式はちょっと長ったらしすぎます。
このような場面用に、Rustには、<code>if let</code>が用意されています。</p>
<!-- ## Concise Control Flow with `if let` -->
<a class="header" href="print.html#if-letで簡潔なフロー制御" id="if-letで簡潔なフロー制御"><h2><code>if let</code>で簡潔なフロー制御</h2></a>
<!-- The `if let` syntax lets you combine `if` and `let` into a less verbose way to -->
<!-- handle values that match one pattern while ignoring the rest. Consider the -->
<!-- program in Listing 6-6 that matches on an `Option<u8>` value but only wants to -->
<!-- execute code if the value is 3. -->
<p><code>if let</code>記法で<code>if</code>と<code>let</code>をより冗長性の少ない方法で組み合わせ、残りを無視しつつ、一つのパターンにマッチする値を扱うことができます。
<code>Option&lt;u8&gt;</code>にマッチするけれど、値が3の時にだけコードを実行したい、リスト6-6のプログラムを考えてください。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 6-6: A `match` that only cares about executing -->
<!-- code when the value is `Some(3)`</span> -->
<p><span class="caption">リスト6-6: 値が<code>Some(3)</code>の時だけコードを実行する<code>match</code></span></p>
<!-- We want to do something with the `Some(3)` match but do nothing with any other -->
<!-- `Some<u8>` value or the `None` value. To satisfy the `match` expression, we -->
<!-- have to add `_ => ()` after processing just one variant, which is a lot of -->
<!-- boilerplate code to add. -->
<p><code>Some(3)</code>にマッチした時だけ何かをし、他の<code>Some&lt;u8&gt;</code>値や<code>None</code>値の時には何もしたくありません。
<code>match</code>式を満たすためには、列挙子を一つだけ処理した後に<code>_ =&gt; ()</code>を追加しなければなりません。
これでは、追加すべき定型コードが多すぎます。</p>
<!-- Instead, we could write this in a shorter way using `if let`. The following -->
<!-- code behaves the same as the `match` in Listing 6-6: -->
<p>その代わり、<code>if let</code>を使用してもっと短く書くことができます。以下のコードは、
リスト6-6の<code>match</code>と全く同じように振る舞います:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_u8_value = Some(0u8);
if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
#}</code></pre></pre>
<!-- The syntax `if let` takes a pattern and an expression separated by an equal -->
<!-- sign. It works the same way as a `match`, where the expression is given to the -->
<!-- `match` and the pattern is its first arm. -->
<p><code>if let</code>という記法は等号記号で区切られたパターンと式を取り、式が<code>match</code>に与えられ、パターンが最初のアームになった<code>match</code>と、
同じ動作をします。</p>
<!-- Using `if let` means less typing, less indentation, and less boilerplate code. -->
<!-- However, you lose the exhaustive checking that `match` enforces. Choosing -->
<!-- between `match` and `if let` depends on what you’re doing in your particular -->
<!-- situation and whether gaining conciseness is an appropriate trade-off for -->
<!-- losing exhaustive checking. -->
<p><code>if let</code>を使うと、タイプ数が減り、インデントも少なくなり、定型コードも減ります。しかしながら、
<code>match</code>では強制された包括性チェックを失ってしまいます。<code>match</code>か<code>if let</code>かの選択は、
特定の場面でどんなことをしたいかと簡潔性を得ることが包括性チェックを失うのに適切な代償となるかによります。</p>
<!-- In other words, you can think of `if let` as syntax sugar for a `match` that -->
<!-- runs code when the value matches one pattern and then ignores all other values. -->
<p>言い換えると、<code>if let</code>は値が一つのパターンにマッチした時にコードを走らせ、
他は無視する<code>match</code>への糖衣構文と考えることができます。</p>
<!-- We can include an `else` with an `if let`. The block of code that goes with the -->
<!-- `else` is the same as the block of code that would go with the `_` case in the -->
<!-- `match` expression that is equivalent to the `if let` and `else`. Recall the -->
<!-- `Coin` enum definition in Listing 6-4, where the `Quarter` variant also held a -->
<!-- `UsState` value. If we wanted to count all non-quarter coins we see while also -->
<!-- announcing the state of the quarters, we could do that with a `match` -->
<!-- expression like this: -->
<p><code>if let</code>では、<code>else</code>を含むこともできます。<code>else</code>に入るコードブロックは、
<code>if let</code>と<code>else</code>に等価な<code>match</code>式の<code>_</code>の場合に入るコードブロックと同じになります。
リスト6-4の<code>Coin</code> enum定義を思い出してください。ここでは、<code>Quarter</code>列挙子は、
<code>UsState</code>の値も保持していましたね。クォーターコインの状態を告げつつ、
見かけたクォーター以外のコインの枚数を数えたいなら、以下のように<code>match</code>式で実現することができるでしょう:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
match coin {
    // {:?}州のクォーターコイン
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
    _ =&gt; count += 1,
}
#}</code></pre></pre>
<!-- Or we could use an `if let` and `else` expression like this: -->
<p>または、以下のように<code>if let</code>と<code>else</code>を使うこともできるでしょう:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
} else {
    count += 1;
}
#}</code></pre></pre>
<!-- If you have a situation in which your program has logic that is too verbose to -->
<!-- express using a `match`, remember that `if let` is in your Rust toolbox as well. -->
<p><code>match</code>を使って表現するには冗長的すぎるロジックがプログラムにあるようなシチュエーションに遭遇したら、
<code>if let</code>もRust道具箱にあることを思い出してください。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-5" id="aまとめ-5"><h2>まとめ</h2></a>
<!-- We’ve now covered how to use enums to create custom types that can be one of a -->
<!-- set of enumerated values. We’ve shown how the standard library’s `Option<T>` -->
<!-- type helps you use the type system to prevent errors. When enum values have -->
<!-- data inside them, you can use `match` or `if let` to extract and use those -->
<!-- values, depending on how many cases you need to handle. -->
<p>これで、enumを使用してワンセットの列挙された値のどれかになりうる独自の型を生成する方法を解説しました。
標準ライブラリの<code>Option&lt;T&gt;</code>が型システムを使用して、エラーを回避する際に役立つ方法についても示しました。
enumの値がデータを内部に含む場合、処理すべきケースの数に応じて、<code>match</code>か<code>if let</code>を使用して値を取り出し、
使用できます。</p>
<!-- Your Rust programs can now express concepts in your domain using structs and -->
<!-- enums. Creating custom types to use in your API ensures type safety: the -->
<!-- compiler will make certain your functions get only values of the type each -->
<!-- function expects. -->
<p>もうRustプログラムで構造体とenumを使用して、自分の領域の概念を表現できます。API内で使用するために独自の型を生成することで、
型安全性を保証することができます: コンパイラが、各関数の予期する型の値のみを関数が得ることを確かめてくれるのです。</p>
<!-- In order to provide a well-organized API to your users that is straightforward -->
<!-- to use and only exposes exactly what your users will need, let’s now turn to -->
<!-- Rust’s modules. -->
<p>使用するのに率直な整理整頓されたAPIをユーザに提供し、ユーザが必要とするものだけを公開するために、
今度は、Rustのモジュールに目を向けてみましょう。</p>
<!-- # Using Modules to Reuse and Organize Code -->
<a class="header" href="print.html#aモジュールを使用してコードを体系化し再利用する" id="aモジュールを使用してコードを体系化し再利用する"><h1>モジュールを使用してコードを体系化し、再利用する</h1></a>
<!-- When you start writing programs in Rust, your code might live solely in the -->
<!-- `main` function. As your code grows, you’ll eventually move functionality into -->
<!-- other functions for reuse and better organization. By splitting your code into -->
<!-- smaller chunks, you make each chunk easier to understand on its own. But what -->
<!-- happens if you have too many functions? Rust has a module system that enables -->
<!-- the reuse of code in an organized fashion. -->
<p>Rustでのプログラミングをし始めた頃は、コードは全て<code>main</code>関数内に収まったかもしれません。コードが肥大化するにつれ、
最終的に機能を別の関数に移して再利用性とまとまりを高めるでしょう。コードを細切りにすることで、
個々のコード片をそれだけで理解しやすくします。しかし、あまりにも多くの関数があったらどうなるでしょうか？
Rustには、コードの再利用を体系化された形で行うことのできるモジュールシステムが組み込まれています。</p>
<!-- In the same way that you extract lines of code into a function, you can extract -->
<!-- functions (and other code, like structs and enums) into different modules. A -->
<!-- *module* is a namespace that contains definitions of functions or types, and -->
<!-- you can choose whether those definitions are visible outside their module -->
<!-- (public) or not (private). Here’s an overview of how modules work: -->
<p>コードを関数に抽出するのと同様に、関数(や他のコード、構造体やenumなど)を異なるモジュールに抽出することができます。
<em>モジュール</em>とは、関数や型定義を含む名前空間のことで、それらの定義がモジュール外からも見えるようにするか(public)否か(private)は、
選択することができます。以下が、モジュールの動作法の概要です:</p>
<!-- * The `mod` keyword declares a new module. Code within the module appears -->
<!--   either immediately following this declaration within curly brackets or in -->
<!--   another file. -->
<!-- * By default, functions, types, constants, and modules are private. The `pub` -->
<!--   keyword makes an item public and therefore visible outside its namespace. -->
<!-- * The `use` keyword brings modules, or the definitions inside modules, into -->
<!--   scope so it’s easier to refer to them. -->
<ul>
<li><code>mod</code>キーワードで新規モジュールを宣言します。モジュール内のコードは、この宣言の直後の波かっこ内か、
別のファイルに存在します。</li>
<li>標準では、関数、型、定数、モジュールは非公開です。<code>pub</code>キーワードで要素は公開され、
名前空間の外からも見えるようになります。</li>
<li><code>use</code>キーワードでモジュールやモジュール内の定義をスコープに入れることができるので、
参照するのが楽になります。</li>
</ul>
<!-- We’ll look at each of these parts to see how they fit into the whole. -->
<p>この各部品を見て、それらが全体にどうはまり込むかを理解します。</p>
<!-- ## `mod` and the Filesystem -->
<a class="header" href="print.html#modとファイルシステム" id="modとファイルシステム"><h2><code>mod</code>とファイルシステム</h2></a>
<!-- We’ll start our module example by making a new project with Cargo, but instead -->
<!-- of creating a binary crate, we’ll make a library crate: a project that other -->
<!-- people can pull into their projects as a dependency. For example, the `rand` -->
<!-- crate discussed in Chapter 2 is a library crate that we used as a dependency in -->
<!-- the guessing game project. -->
<p>モジュールの例をCargoで新規プロジェクトを生成することから始めるが、バイナリクレートの代わりに、
ライブラリクレートを作成します: 他人が依存として自分のプロジェクトに引き込めるプロジェクトです。
例を挙げると、第2章で議論した<code>rand</code>クレートは、数当てゲームプロジェクトで依存に使用したライブラリクレートです。</p>
<!-- We’ll create a skeleton of a library that provides some general networking -->
<!-- functionality; we’ll concentrate on the organization of the modules and -->
<!-- functions, but we won’t worry about what code goes in the function bodies. -->
<!-- We'll call our library `communicator`. To create a library, pass the `--lib` -->
<!-- option instead of `--bin`: -->
<p>何らかの一般的なネットワーク機能を提供するライブラリの骨格を作成します; モジュールと関数の体系化に集中し、
関数の本体にどんなコードが入るかについては気にかけません。このライブラリを<code>communicator</code>と呼びましょう。
ライブラリを生成するために、<code>--bin</code>の代わりに<code>--lib</code>オプションを渡してください:</p>
<pre><code class="language-text">$ cargo new communicator --lib
$ cd communicator
</code></pre>
<!-- Notice that Cargo generated *src/lib.rs* instead of *src/main.rs*. Inside -->
<!-- *src/lib.rs* we’ll find the following: -->
<p>Cargoが<em>src/main.rs</em>の代わりに<em>src/lib.rs</em>を生成したことに注目してください。<em>src/lib.rs</em>には、
以下のような記述があります:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<!-- Cargo creates an empty test to help us get our library started, rather than the -->
<!-- the “Hello, world!” binary that we get when we use the `--bin` option. We’ll -->
<!-- look at the `#[]` and `mod tests` syntax in the “Using `super` to Access a -->
<!-- Parent Module” section later in this chapter, but for now, leave this code at -->
<!-- the bottom of *src/lib.rs*. -->
<p>Cargoは、<code>--bin</code>オプションを使った時に得られる&quot;Hello, world!&quot;バイナリではなく、空のテストを生成して、
ライブラリの事始めをしてくれました。<code>#[]</code>と<code>mod tests</code>という記法については、この章の後ほど、
「<code>super</code>を使用して親モジュールにアクセスする」節で見ますが、今のところは、
このコードを<em>src/lib.rs</em>の最後に残しておきましょう。</p>
<!-- Because we don’t have a *src/main.rs* file, there’s nothing for Cargo to -->
<!-- execute with the `cargo run` command. Therefore, we’ll use the `cargo build` -->
<!-- command to compile our library crate’s code. -->
<p><em>src/main.rs</em>ファイルがないので、<code>cargo run</code>コマンドでCargoが実行できるものは何もないわけです。
従って、<code>cargo build</code>コマンドを使用してライブラリクレートのコードをコンパイルします。</p>
<!-- We’ll look at different options for organizing your library’s code that will be -->
<!-- suitable in a variety of situations, depending on the intent of the code. -->
<p>コードの意図によって、いろんなシチュエーションで最適になるライブラリコードを体系化する別のオプションをお目にかけます。</p>
<!-- ### Module Definitions -->
<a class="header" href="print.html#aモジュール定義" id="aモジュール定義"><h3>モジュール定義</h3></a>
<!-- For our `communicator` networking library, we’ll first define a module named -->
<!-- `network` that contains the definition of a function called `connect`. Every -->
<!-- module definition in Rust starts with the `mod` keyword. Add this code to the -->
<!-- beginning of the *src/lib.rs* file, above the test code: -->
<p><code>communicator</code>ネットワークライブラリについて、まずは<code>connect</code>という関数定義を含む<code>network</code>という名前のモジュールを定義します。
Rustにおいて、モジュール定義は全て、<code>mod</code>キーワードから開始します。このコードを<em>src/lib.rs</em>ファイルの頭、
テストコードの上に追記してください。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<!-- After the `mod` keyword, we put the name of the module, `network`, and then a -->
<!-- block of code in curly brackets. Everything inside this block is inside the -->
<!-- namespace `network`. In this case, we have a single function, `connect`. If we -->
<!-- wanted to call this function from a script outside the `network` module, we -->
<!-- would need to specify the module and use the namespace syntax `::`, like so: -->
<!-- `network::connect()`. -->
<p><code>mod</code>キーワードに続いて、モジュール名の<code>network</code>、さらに一連のコードを波かっこ内に記述します。
このブロック内に存在するものは全て、<code>network</code>という名前空間に属します。今回の場合、
<code>connect</code>という単独の関数があります。この関数を<code>network</code>モジュール外のスクリプトから呼び出したい場合、
モジュールを指定し、以下のように名前空間記法の<code>::</code>を使用する必要があるでしょう:
<code>network::connect()</code>。</p>
<!-- We can also have multiple modules, side by side, in the same *src/lib.rs* file. -->
<!-- For example, to also have a `client` module that has a function named -->
<!-- `connect`, we can add it as shown in Listing 7-1. -->
<p>同じ<em>src/lib.rs</em>ファイル内に複数のモジュールを並べることもできます。例として、
<code>connect</code>という関数を含む<code>client</code>モジュールも用意するには、リスト7-1に示したように追記すればいいわけです。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 7-1: The `network` module and the `client` module -->
<!-- defined side by side in *src/lib.rs*</span> -->
<p><span class="caption">リスト7-1: <em>src/lib.rs</em>に並べて定義された<code>network</code>モジュールと<code>client</code>モジュール</span></p>
<!-- Now we have a `network::connect` function and a `client::connect` function. -->
<!-- These can have completely different functionality, and the function names do -->
<!-- not conflict with each other because they’re in different modules. -->
<p>これで、<code>network::connect</code>関数と<code>client::connect</code>関数が用意できました。これらは全く異なる機能を有する可能性があり、
異なるモジュールに存在するので、関数名がお互いに衝突することはありません。</p>
<!-- In this case, because we’re building a library, the file that serves as the -->
<!-- entry point for building our library is *src/lib.rs*. However, in respect to -->
<!-- creating modules, there’s nothing special about *src/lib.rs*. We could also -->
<!-- create modules in *src/main.rs* for a binary crate in the same way as we’re -->
<!-- creating modules in *src/lib.rs* for the library crate. In fact, we can put -->
<!-- modules inside of modules, which can be useful as your modules grow to keep -->
<!-- related functionality organized together and separate functionality apart. The -->
<!-- way you choose to organize your code depends on how you think about the -->
<!-- relationship between the parts of your code. For instance, the `client` code -->
<!-- and its `connect` function might make more sense to users of our library if -->
<!-- they were inside the `network` namespace instead, as in Listing 7-2. -->
<p>今回の場合、ライブラリを構成しているので、ライブラリビルド時にエントリーポイントとなるファイルは、
<em>src/lib.rs</em>になります。しかし、モジュールを作成するという点に関しては、<em>src/lib.rs</em>には何も特別なことはありません。
ライブラリクレートに対して<em>src/lib.rs</em>にモジュールを生成するのと全く同様に、
バイナリクレートに対して<em>src/main.rs</em>にモジュールを生成することもできます。実は、モジュール内にモジュールを書くこともでき、
モジュールが肥大化するにつれて、関連のある機能を一緒くたにし、機能を切り離すのに有用なのです。
コードを体系化すると選択する方法は、コードの部分部分の関連性に対する考え方によって選択することになります。
例ですが、<code>client</code>コードとその<code>connect</code>関数は、リスト7-2のように、代わりに<code>network</code>名前空間内に存在したら、
ライブラリの使用者にとって意味のあるものになるかもしれません。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 7-2: Moving the `client` module inside the -->
<!-- `network` module</span> -->
<p><span class="caption">リスト7-2: <code>client</code>モジュールを<code>network</code>モジュール内に移動させる</span></p>
<!-- In your *src/lib.rs* file, replace the existing `mod network` and `mod client` -->
<!-- definitions with the ones in Listing 7-2, which have the `client` module as an -->
<!-- inner module of `network`. The functions `network::connect` and -->
<!-- `network::client::connect` are both named `connect`, but they don’t conflict -->
<!-- with each other because they’re in different namespaces. -->
<p><em>src/lib.rs</em>ファイル内で、すでにある<code>mod network</code>と<code>mod client</code>の定義をリスト7-2のものと置き換えると、
<code>client</code>モジュールは<code>network</code>の内部モジュールになるわけです。関数、
<code>network::connect</code>と<code>network::client::connect</code>はどちらも<code>connect</code>という名前ですが、
異なる名前空間にあるので、互いに干渉することはありません。</p>
<!-- In this way, modules form a hierarchy. The contents of *src/lib.rs* are at the -->
<!-- topmost level, and the submodules are at lower levels. Here’s what the -->
<!-- organization of our example in Listing 7-1 looks like when thought of as a -->
<!-- hierarchy: -->
<p>このように、モジュールは階層構造を形成します。<em>src/lib.rs</em>の中身が頂点に立ち、サブモジュールが子供になるわけです。
リスト7-1の例を階層構造という観点で見たときの構造は、以下のような感じになります:</p>
<pre><code class="language-text">communicator
 ├── network
 └── client
</code></pre>
<!-- And here’s the hierarchy corresponding to the example in Listing 7-2: -->
<p>さらに、リスト7-2の例に対応する階層構造は、以下の通りです:</p>
<pre><code class="language-text">communicator
 └── network
     └── client
</code></pre>
<!-- The hierarchy shows that in Listing 7-2, `client` is a child of the `network` -->
<!-- module rather than a sibling. More complicated projects can have many modules, -->
<!-- and they’ll need to be organized logically in order fro you to keep track of -->
<!-- them. What “logically” means in your project is up to you and depends on how -->
<!-- you and your library’s users think about your project’s domain. Use the -->
<!-- techniques shown here to create side-by-side modules and nested modules in -->
<!-- whatever structure you would like. -->
<p>この階層構造は、リスト7-2において、<code>client</code>モジュールは<code>network</code>モジュールの兄弟というよりも、子供になっていることを示しています。
より複雑なプロジェクトなら、たくさんのモジュールが存在し、把握するのに論理的に体系化しておく必要があるでしょう。
プロジェクト内で「論理的」とは、あなた次第であり、ライブラリ作成者と使用者がプロジェクトの領域についてどう考えるか次第でもあるわけです。
こちらで示したテクニックを使用して、並列したモジュールや、ネストしたモジュールなど、どんな構造のモジュールでも、
作成してください。</p>
<!-- ### Moving Modules to Other Files -->
<a class="header" href="print.html#aモジュールを別ファイルに移す" id="aモジュールを別ファイルに移す"><h3>モジュールを別ファイルに移す</h3></a>
<!-- Modules form a hierarchical structure, much like another structure in computing -->
<!-- that you’re used to: filesystems! We can use Rust’s module system along with -->
<!-- multiple files to split up Rust projects so not everything lives in -->
<!-- *src/lib.rs* or *src/main.rs*. For this example, let’s start with the code in -->
<!-- Listing 7-3. -->
<p>モジュールは階層構造をなす……コンピュータにおいて、もっと見慣れた構造に似ていませんか: そう、ファイルシステムです！
Rustのモジュールシステムを複数のファイルで使用して、プロジェクトを分割するので、
全部が<em>src/lib.rs</em>や<em>src/main.rs</em>に存在することにはならなくなります。これの例として、
リスト7-3のようなコードから始めましょう。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 7-3: Three modules, `client`, `network`, and -->
<!-- `network::server`, all defined in *src/lib.rs*</span> -->
<p><span class="caption">リスト7-3: 全て<em>src/lib.rs</em>に定義された三つのモジュール、
<code>client</code>、<code>network</code>、<code>network::server</code></span></p>
<!-- The file *src/lib.rs* has this module hierarchy: -->
<p><em>src/lib.rs</em>ファイルのモジュール階層は、こうなっています:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<!-- If these modules had many functions, and those functions were becoming lengthy, -->
<!-- it would be difficult to scroll through this file to find the code we wanted to -->
<!-- work with. Because the functions are nested inside one or more mod blocks, -->
<!-- the lines of code inside the functions will start getting lengthy as well. -->
<!-- These would be good reasons to separate the `client`, `network`, and `server` -->
<!-- modules from *src/lib.rs* and place them into their own files. -->
<p>これらのモジュールが多数の関数を含み、その関数が長ったらしくなってきたら、このファイルをスクロールして、
弄りたいコードを探すのが困難になるでしょう。関数が一つ以上のmodブロックにネストされているので、
関数の中身となるコードも長ったらしくなってしまうのです。これだけで、<code>client</code>、<code>network</code>、<code>server</code>モジュールを<em>src/lib.rs</em>から分け、
単独のファイルに配置するには十分でしょう。</p>
<!-- First, let's replace the `client` module code with only the declaration of the -->
<!-- `client` module so that your *src/lib.rs* looks like code shown in Listing 7-4. -->
<p>最初に、<code>client</code>モジュールのコードを<code>client</code>モジュールの宣言だけに置き換えましょう。
すると、<em>src/lib.rs</em>はリスト7-4のコードのようになります。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<!-- <span class="caption">Listing 7-4: Extracting the contents of the `client` module but leaving the declaration in *src/lib.rs*</span> -->
<p><span class="caption">リスト7-4: <code>client</code>モジュールの中身を抽出するが、宣言は<em>src/lib.rs</em>に残したまま</span></p>
<!-- We’re still *declaring* the `client` module here, but by replacing the block -->
<!-- with a semicolon, we’re telling Rust to look in another location for the code -->
<!-- defined within the scope of the `client` module. In other words, the line `mod -->
<!-- client;` means this: -->
<p>一応、<code>client</code>モジュールをここで<em>宣言</em>していますが、ブロックをセミコロンで置換したことで、
<code>client</code>モジュールのスコープのコードは別の場所を探すようにコンパイラに指示しているわけです。
言い換えると、<code>mod client;</code>の行は、以下のような意味になります:</p>
<pre><code class="language-rust ignore">mod client {
    // contents of client.rs
}
</code></pre>
<!-- Now we need to create the external file with that module name. Create a -->
<!-- *client.rs* file in your *src/* directory and open it. Then enter the -->
<!-- following, which is the `connect` function in the `client` module that we -->
<!-- removed in the previous step: -->
<!-- 何故か「*src/*ディレクトリ内に*client.rs*」までが斜体になってしまう。mdbookのバグ？ -->
<p>さて、このモジュール名の外部ファイルを作成する必要が出てきました。<em>src/<em>ディレクトリ内に</em>client.rs</em>ファイルを作成し、
開いてください。それから以下のように入力してください。前段階で削除した<code>client</code>モジュールの<code>connect</code>関数です:</p>
<!-- <span class="filename">Filename: src/client.rs</span> -->
<p><span class="filename">ファイル名: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<!-- Note that we don’t need a `mod` declaration in this file because we already -->
<!-- declared the `client` module with `mod` in *src/lib.rs*. This file just -->
<!-- provides the *contents* of the `client` module. If we put a `mod client` here, -->
<!-- we’d be giving the `client` module its own submodule named `client`! -->
<p>このファイルには、<code>mod</code>宣言が必要ないことに着目してください。なぜなら、<em>src/lib.rs</em>に<code>mod</code>を使って、
もう<code>client</code>モジュールを宣言しているからです。このファイルは、<code>client</code>モジュールの<em>中身</em>を提供するだけなのです。
ここにも<code>mod client</code>を記述したら、<code>client</code>に<code>client</code>という名前のサブモジュールを与えることになってしまいます！</p>
<!-- Rust only knows to look in *src/lib.rs* by default. If we want to add more -->
<!-- files to our project, we need to tell Rust in *src/lib.rs* to look in other -->
<!-- files; this is why `mod client` needs to be defined in *src/lib.rs* and can’t -->
<!-- be defined in *src/client.rs*. -->
<p>コンパイラは、標準で<em>src/lib.rs</em>だけを検索します。プロジェクトにもっとファイルを追加したかったら、
<em>src/lib.rs</em>で他のファイルも検索するよう、コンパイラに指示する必要があるのです; このため、<code>mod client</code>を<em>src/lib.rs</em>に定義し、
<em>src/client.rs</em>には定義できなかったのです。</p>
<!-- Now the project should compile successfully, although you’ll get a few -->
<!-- warnings. Remember to use `cargo build` instead of `cargo run` because we have -->
<!-- a library crate rather than a binary crate: -->
<p>これでプロジェクトは問題なくコンパイルできるはずです。まあ、警告がいくつか出るんですが。
<code>cargo run</code>ではなく、<code>cargo build</code>を使うことを忘れないでください。バイナリクレートではなく、
ライブラリクレートだからですね:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)

warning: function is never used: `connect`
(警告: 関数は使用されていません: `connect`)
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/lib.rs:4:5
  |
4 | /     fn connect() {
5 | |     }
  | |_____^

warning: function is never used: `connect`
 --&gt; src/lib.rs:8:9
  |
8 | /         fn connect() {
9 | |         }
  | |_________^
</code></pre>
<!-- These warnings tell us that we have functions that are never used. Don’t worry -->
<!-- about these warnings for now; we’ll address them in this chapter in the  -->
<!-- "Controlling Visibility with `pub`” section. The good news is that they’re just -->
<!-- warnings; our project built successfully! -->
<p>これらの警告は、全く使用されていない関数があると忠告してくれています。今は、警告を危惧する必要はありません;
この章の後ほど、「<code>pub</code>で公開するか制御する」節で特定します。嬉しいことにただの警告です;
プロジェクトはビルドに成功しました！</p>
<!-- Next, let’s extract the `network` module into its own file using the same -->
<!-- pattern. In *src/lib.rs*, delete the body of the `network` module and add a -->
<!-- semicolon to the declaration, like so: -->
<p>次に、同様のパターンを使用して<code>network</code>モジュールも単独のファイルに抽出しましょう。
<em>src/lib.rs</em>で、<code>network</code>モジュールの本体を削除し、宣言にセミコロンを付加してください。こんな感じです:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<!-- Then create a new *src/network.rs* file and enter the following: -->
<p>それから新しい<em>src/network.rs</em>ファイルを作成して、以下のように入力してください:</p>
<!-- <span class="filename">Filename: src/network.rs</span> -->
<p><span class="filename">ファイル名: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<!-- Notice that we still have a `mod` declaration within this module file; this is -->
<!-- because we still want `server` to be a submodule of `network`. -->
<p>このモジュールファイル内にもまだ<code>mod</code>宣言があることに気付いてください;
<code>server</code>はまだ<code>network</code>のサブモジュールにしたいからです。</p>
<!-- Run `cargo build` again. Success! We have one more module to extract: `server`. -->
<!-- Because it’s a submodule—that is, a module within a module—our current tactic -->
<!-- of extracting a module into a file named after that module won’t work. We’ll -->
<!-- try anyway so you can see the error. First, change *src/network.rs* to have -->
<!-- `mod server;` instead of the `server` module’s contents: -->
<p>再度<code>cargo build</code>してください。成功！抽出すべきモジュールがもう1個あります: <code>server</code>です。
これはサブモジュール(つまり、モジュール内のモジュール)なので、
モジュール名に倣ったファイルにモジュールを抽出するという今の手法は、通用しません。いずれにしても、
エラーが確認できるように、試してみましょう。まず、<em>src/network.rs</em>ファイルを<code>server</code>モジュールの中身を含む代わりに、
<code>mod server;</code>となるように変更してください。</p>
<!-- <span class="filename">Filename: src/network.rs</span> -->
<p><span class="filename">ファイル名: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<!-- Then create a *src/server.rs* file and enter the contents of the `server` -->
<!-- module that we extracted: -->
<p>そして、<em>src/server.rs</em>ファイルを作成し、抽出した<code>server</code>モジュールの中身を入力してください:</p>
<!-- <span class="filename">Filename: src/server.rs</span> -->
<p><span class="filename">ファイル名: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<!-- When we try to run `cargo build`, we’ll get the error shown in Listing 7-5: -->
<p><code>cargo build</code>を実行しようとすると、リスト7-4に示したようなエラーが出ます:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
(エラー: この箇所では新規モジュールを宣言できません)
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `src/network.rs` to its own directory via `src/network/mod.rs`
(注釈: もしかして、`src/network.rs`というこのモジュールを`src/network/mod.rs`経由で独自のディレクトリに移すの)
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
(注釈: それとも、再度宣言する可能性はなく、`server`というモジュールを`use`したの)
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<!-- <span class="caption">Listing 7-5: Error when trying to extract the `server` -->
<!-- submodule into *src/server.rs*</span> -->
<p><span class="caption">リスト7-5: <code>server</code>サブモジュールを<em>src/server.rs</em>に抽出しようとしたときのエラー</span></p>
<!-- The error says we `cannot declare a new module at this location` and is -->
<!-- pointing to the `mod server;` line in *src/network.rs*. So *src/network.rs* is -->
<!-- different than *src/lib.rs* somehow: keep reading to understand why. -->
<p>エラーは、<code>この箇所では新規モジュールを宣言できません</code>と忠告し、<em>src/network.rs</em>の<code>mod server;</code>行を指し示しています。
故に、<em>src/network.rs</em>は、<em>src/lib.rs</em>と何かしら違うのです: 理由を知るために読み進めましょう。</p>
<!-- The note in the middle of Listing 7-5 is actually very helpful because it -->
<!-- points out something we haven’t yet talked about doing: -->
<p>リスト7-5の真ん中の注釈は、非常に有用です。というのも、まだ話題にしていないことを指摘しているからです。</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<!-- Instead of continuing to follow the same file-naming pattern we used -->
<!-- previously, we can do what the note suggests: -->
<p>以前行ったファイル命名パターンに従い続けるのではなく、注釈が提言していることをすることができます:</p>
<!-- 1. Make a new *directory* named *network*, the parent module’s name. -->
<!-- 2. Move the *src/network.rs* file into the new *network* directory and -->
<!--    rename it *src/network/mod.rs*. -->
<!-- 3. Move the submodule file *src/server.rs* into the *network* directory. -->
<ol>
<li>親モジュール名である<em>network</em>という名前の新規<em>ディレクトリ</em>を作成する。</li>
<li><em>src/network.rs</em>ファイルを<em>network</em>ディレクトリに移し、
<em>src/network/mod.rs</em>と名前を変える。</li>
<li>サブモジュールファイルの<em>src/server.rs</em>を<em>network</em>ディレクトリに移す。</li>
</ol>
<!-- Here are commands to carry out these steps: -->
<p>以下が、これを実行するコマンドです:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<!-- Now when we try to run `cargo build`, compilation will work (we’ll still have -->
<!-- warnings, though). Our module layout still looks exactly the same as it did when -->
<!-- we had all the code in *src/lib.rs* in Listing 7-3: -->
<p><code>cargo build</code>を走らせたら、ようやくコンパイルは通ります(まだ警告はありますけどね)。
それでも、モジュールの配置は、リスト7-3で<em>src/lib.rs</em>に全てのコードを収めていたときと全く同じになります:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<!-- The corresponding file layout now looks like this: -->
<p>対応するファイルの配置は、以下のようになっています:</p>
<pre><code class="language-text">└── src
    ├── client.rs
    ├── lib.rs
    └── network
        ├── mod.rs
        └── server.rs
</code></pre>
<!-- So when we wanted to extract the `network::server` module, why did we have to -->
<!-- also change the *src/network.rs* file to the *src/network/mod.rs* file and put -->
<!-- the code for `network::server` in the *network* directory in -->
<!-- *src/network/server.rs*? Why couldn't we just extract the `network::server` -->
<!-- module into *src/server.rs*? The reason is that Rust wouldn’t be able to -->
<!-- recognize that `server` was supposed to be a submodule of `network` if the -->
<!-- *server.rs* file was in the *src* directory. To clarify Rust’s behavior here, -->
<!-- let’s consider a different example with the following module hierarchy, where -->
<!-- all the definitions are in *src/lib.rs*: -->
<p>では、<code>network::server</code>モジュールを抽出したかったときに、
なぜ、<em>src/network.rs</em>ファイルを<em>src/network/mod.rs</em>ファイルに変更し、
<code>network::server</code>のコードを<em>network</em>ディレクトリ内の<em>src/network/server.rs</em>に置かなければならなかったのでしょうか？
なぜ、単に<code>network::server</code>モジュールを<em>src/server.rs</em>に抽出できなかったのでしょうか？
理由は、<em>server.rs</em>ファイルが<em>src</em>ディレクトリにあると、コンパイラが、
<code>server</code>は<code>network</code>のサブモジュールと考えられることを検知できないからです。
ここでのコンパイラの動作をはっきりさせるために、以下のようなモジュール階層をもつ別の例を考えましょう。
こちらでは、定義は全て<em>src/lib.rs</em>に存在します。</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── client
</code></pre>
<!-- In this example, we have three modules again: `client`, `network`, and -->
<!-- `network::client`. Following the same steps we did earlier for extracting -->
<!-- modules into files, we would create *src/client.rs* for the `client` module. -->
<!-- For the `network` module, we would create *src/network.rs*. But we wouldn’t be -->
<!-- able to extract the `network::client` module into a *src/client.rs* file -->
<!-- because that already exists for the top-level `client` module! If we could put -->
<!-- the code for *both* the `client` and `network::client` modules in the -->
<!-- *src/client.rs* file, Rust wouldn’t have any way to know whether the code was -->
<!-- for `client` or for `network::client`. -->
<p>この例でも、モジュールは3つあります: <code>client</code>、<code>network</code>、<code>network::client</code>です。
以前と同じ段階を経てモジュールをファイルに抽出すると、<code>client</code>モジュール用に<em>src/client.rs</em>を作成することになるでしょう。
<code>network</code>モジュールに関しては、<em>src/network.rs</em>を作成します。しかし、
<code>network::client</code>モジュールを<em>src/client.rs</em>ファイルに抽出することはできません。
もうトップ階層の<code>client</code>モジュールとして存在するからです！
<code>client</code>と<code>network::client</code><em>双方</em>のコードを<em>src/client.rs</em>ファイルに書くことができたら、
コンパイラは、コードが<code>client</code>用なのか、<code>network::client</code>用なのか知る術を失ってしまいます。</p>
<!-- Therefore, in order to extract a file for the `network::client` submodule of -->
<!-- the `network` module, we needed to create a directory for the `network` module -->
<!-- instead of a *src/network.rs* file. The code that is in the `network` module -->
<!-- then goes into the *src/network/mod.rs* file, and the submodule -->
<!-- `network::client` can have its own *src/network/client.rs* file. Now the -->
<!-- top-level *src/client.rs* is unambiguously the code that belongs to the -->
<!-- `client` module. -->
<p>従って、<code>network</code>モジュールの<code>network::client</code>サブモジュールをファイルに抽出するには、
<em>src/network.rs</em>ファイルではなく、<code>network</code>モジュールのディレクトリを作成する必要があったわけです。
そうすれば、<code>network</code>モジュールのコードは、<em>src/network/mod.rs</em>ファイルに移ることになり、
<code>network::client</code>というサブモジュールは専用の<code>src/network/client.rs</code>ファイルを持てるわけです。
これで、頂点にある<em>src/client.rs</em>は間違いなく、<code>client</code>モジュールに属するコードになるわけです。</p>
<!-- ### Rules of Module Filesystems -->
<a class="header" href="print.html#aモジュールファイルシステムの規則" id="aモジュールファイルシステムの規則"><h3>モジュールファイルシステムの規則</h3></a>
<!-- Let’s summarize the rules of modules with regard to files: -->
<p>ファイルに関するモジュール規則をまとめましょう:</p>
<!-- * If a module named `foo` has no submodules, you should put the declarations -->
<!--   for `foo` in a file named *foo.rs*. -->
<!-- * If a module named `foo` does have submodules, you should put the declarations -->
<!--   for `foo` in a file named *foo/mod.rs*. -->
<ul>
<li><code>foo</code>という名前のモジュールにサブモジュールがなければ、<code>foo</code>の定義は、
<em>foo.rs</em>というファイルに書くべきです。</li>
<li><code>foo</code>というモジュールに本当にサブモジュールがあったら、<code>foo</code>の定義は、
<em>foo/mod.rs</em>というファイルに書くべきです。</li>
</ul>
<!-- These rules apply recursively, so if a module named `foo` has a submodule named -->
<!-- `bar` and `bar` does not have submodules, you should have the following files -->
<!-- in your *src* directory: -->
<p>これらのルールは再帰的に適用されるので、<code>foo</code>というモジュールに<code>bar</code>というサブモジュールがあり、
<code>bar</code>にはサブモジュールがなければ、<em>src</em>ディレクトリには以下のようなファイルが存在するはずです:</p>
<pre><code class="language-text">├── foo
│   ├── bar.rs (contains the declarations in `foo::bar`)
│   │          (`foo::bar`内の定義を含む)
│   └── mod.rs (contains the declarations in `foo`, including `mod bar`)
               (`mod bar`を含む、`foo`内の定義を含む)
</code></pre>
<!-- The modules should be declared in their parent module’s file using the `mod` -->
<!-- keyword. -->
<p>モジュールは、親モジュールのファイル内で<code>mod</code>キーワードを使って宣言されるべきなのです。</p>
<!-- Next, we’ll talk about the `pub` keyword and get rid of those warnings! -->
<p>次は、<code>pub</code>キーワードについて話し、警告を取り除きます！</p>
<!-- ## Controlling Visibility with `pub` -->
<a class="header" href="print.html#pubで公開するか制御する" id="pubで公開するか制御する"><h2><code>pub</code>で公開するか制御する</h2></a>
<!-- We resolved the error messages shown in Listing 7-5 by moving the `network` and -->
<!-- `network::server` code into the *src/network/mod.rs* and -->
<!-- *src/network/server.rs* files, respectively. At that point, `cargo build` was -->
<!-- able to build our project, but we still get warning messages saying that the -->
<!-- `client::connect`, `network::connect`, and `network::server::connect` functions -->
<!-- are not being used: -->
<p>リスト7-5に示したエラーメッセージを<code>network</code>と<code>network::server</code>のコードを、
<em>src/network/mod.rs</em>と<em>src/network/server.rs</em>ファイルにそれぞれ移動することで解決しました。
その時点で<code>cargo build</code>はプロジェクトをビルドできましたが、
<code>client::connect</code>と<code>network::connect</code>と<code>network::server::connect</code>関数が、
使用されていないという警告メッセージが出ていました:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<!-- So why are we receiving these warnings? After all, we’re building a library -->
<!-- with functions that are intended to be used by our *users*, not necessarily by -->
<!-- us within our own project, so it shouldn’t matter that these `connect` -->
<!-- functions go unused. The point of creating them is that they will be used by -->
<!-- another project, not our own. -->
<p>では、何故このような警告を受けているのでしょうか？結局のところ、必ずしも自分のプロジェクト内ではなく、
<em>利用者</em>に利用されることを想定した関数を含むライブラリを構成しているので、
これらの<code>connect</code>関数が使用されていかないということは、問題になるはずはありません。
これらの関数を生成することの要点は、自分ではなく、他のプロジェクトで使用することにあるのです。</p>
<!-- To understand why this program invokes these warnings, let’s try using the -->
<!-- `communicator` library from another project, calling it externally. To do that, -->
<!-- we’ll create a binary crate in the same directory as our library crate by -->
<!-- making a *src/main.rs* file containing this code: -->
<p>このプログラムがこのような警告を引き起こす理由を理解するために、外部から<code>communicator</code>ライブラリを呼び出して、
他のプロジェクトからこれを使用してみましょう。そうするには、以下のようなコードを含む<em>src/main.rs</em>を作成して、
ライブラリクレートと同じディレクトリにバイナリクレートを作成します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate communicator;

fn main() {
    communicator::client::connect();
}
</code></pre>
<!-- We use the `extern crate` command to bring the `communicator` library crate -->
<!-- into scope. Our package now contains *two* crates. Cargo treats *src/main.rs* -->
<!-- as the root file of a binary crate, which is separate from the existing library -->
<!-- crate whose root file is *src/lib.rs*. This pattern is quite common for -->
<!-- executable projects: most functionality is in a library crate, and the binary -->
<!-- crate uses that library crate. As a result, other programs can also use the -->
<!-- library crate, and it’s a nice separation of concerns. -->
<p><code>extern crate</code>コマンドを使用して、<code>communicator</code>ライブラリクレートをスコープに導入しています。
パッケージには<em>2つ</em>のクレートが含まれるようになりました。Cargoは、<em>src/main.rs</em>をバイナリクレートのルートファイルとして扱い、
これはルートファイルが<em>src/lib.rs</em>になる既存のライブラリクレートとは区別されます。このパターンは、
実行形式プロジェクトで非常に一般的です: ほとんどの機能はライブラリクレートにあり、バイナリクレートはそれを使用するわけです。
結果として、他のプログラムもまたこのライブラリクレートを使用でき、良い責任の分離になるわけです。</p>
<!-- From the point of view of a crate outside the `communicator` library looking -->
<!-- in, all the modules we’ve been creating are within a module that has the same -->
<!-- name as the crate, `communicator`. We call the top-level module of a crate the -->
<!-- *root module*. -->
<p><code>communicator</code>ライブラリの外部のクレートが検索するという観点から言えば、これまでに作ってきたモジュールは全て、
<code>communicator</code>というクレートと同じ名前を持つモジュール内にあります。クレートのトップ階層のモジュールを、
<em>ルートモジュール</em>と呼びます。</p>
<!-- Also note that even if we’re using an external crate within a submodule of our -->
<!-- project, the `extern crate` should go in our root module (so in *src/main.rs* -->
<!-- or *src/lib.rs*). Then, in our submodules, we can refer to items from external -->
<!-- crates as if the items are top-level modules. -->
<p>プロジェクトのサブモジュール内で外部クレートを使用しているとしても、<code>extern crate</code>はルートモジュール(つまり、<em>src/main.rs</em>、
または<em>src/lib.rs</em>)に書くべきということにも、注目してください。それから、
サブモジュールで外部クレートの要素をトップ階層のモジュールかのように参照できるわけです。</p>
<!-- Right now, our binary crate just calls our library’s `connect` function from -->
<!-- the `client` module. However, invoking `cargo build` will now give us an error -->
<!-- after the warnings: -->
<p>現状、バイナリクレートは、<code>client</code>モジュールからライブラリの<code>connect</code>関数を呼び出しているだけです。
ところが、<code>cargo build</code>を呼び出すと、警告の後にエラーが発生します:</p>
<pre><code class="language-text">error[E0603]: module `client` is private
(エラー: `client`モジュールは非公開です)
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<!-- Ah ha! This error tells us that the `client` module is private, which is the -->
<!-- crux of the warnings. It’s also the first time we’ve run into the concepts of -->
<!-- *public* and *private* in the context of Rust. The default state of all code in -->
<!-- Rust is private: no one else is allowed to use the code. If you don’t use a -->
<!-- private function within your program, because your program is the only code -->
<!-- allowed to use that function, Rust will warn you that the function has gone -->
<!-- unused. -->
<p>ああ！このエラーは、<code>client</code>モジュールが非公開であることを教えてくれ、それが警告の肝だったわけです。
Rustの文脈において、<em>公開</em>とか<em>非公開</em>という概念にぶち当たったのは、これが初めてでもあります。
全コードの初期状態は、非公開です: 誰も他の人はコードを使用できないわけです。プログラム内で非公開の関数を使用していなければ、
自分のプログラムだけがその関数を使用することを許可された唯一のコードなので、コンパイラは関数が未使用と警告してくるのです。</p>
<!-- After you specify that a function like `client::connect` is public, not only -->
<!-- will your call to that function from our binary crate be allowed, but the -->
<!-- warning that the function is unused will go away. Marking a function as public -->
<!-- lets Rust know that the function will be used by code outside of our program. -->
<!-- Rust considers the theoretical external usage that’s now possible as the -->
<!-- function “being used.” Thus, when a function is marked public, Rust will not -->
<!-- require that it be used in our program and will stop warning that the function -->
<!-- is unused. -->
<p><code>client::connect</code>のような関数を公開にすると指定した後は、バイナリクレートからその関数への呼び出しが許可されるだけでなく、
関数が未使用であるという警告も消え去るわけです。関数を公開にすれば、コンパイラは、
関数が自分のプログラム外のコードからも使用されることがあると知ります。コンパイラは、
関数が「使用されている」という架空の外部使用の可能性を考慮してくれます。それ故に、関数が公開とマークされれば、
コンパイラはそれが自分のプログラムで使用されるべきという要求をなくし、その関数が未使用という警告も止めるのです。</p>
<!-- ### Making a Function Public -->
<a class="header" href="print.html#a関数を公開にする" id="a関数を公開にする"><h3>関数を公開にする</h3></a>
<!-- To tell Rust to make a function public, we add the `pub` keyword to the start -->
<!-- of the declaration. We’ll focus on fixing the warning that indicates -->
<!-- `client::connect` has gone unused for now, as well as the `` module `client` is -->
<!-- private `` error from our binary crate. Modify *src/lib.rs* to make the -->
<!-- `client` module public, like so: -->
<p>コンパイラに何かを公開すると指示するには、定義の先頭に<code>pub</code>キーワードを追記します。
今は、<code>client::connect</code>が未使用であるとする警告とバイナリークレートの<code>モジュール`client`が非公開である</code>エラーの解消に努めます。
<em>src/lib.rs</em>を弄って、<code>client</code>モジュールを公開にしてください。そう、こんな感じに:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

mod network;
</code></pre>
<!-- The `pub` keyword is placed right before `mod`. Let’s try building again: -->
<p><code>pub</code>キーワードは、<code>mod</code>の直前に配置されています。再度ビルドしてみましょう:</p>
<pre><code class="language-text">error[E0603]: function `connect` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<!-- Hooray! We have a different error! Yes, different error messages are a cause -->
<!-- for celebration. The new error shows `` function `connect` is private ``, so -->
<!-- let’s edit *src/client.rs* to make `client::connect` public too: -->
<p>やった！違うエラーになりました！そうです、別のエラーメッセージは、祝杯を上げる理由になるのです。
新エラーは、<code>関数`connect`は非公開です</code>と示しているので、<em>src/client.rs</em>を編集して、
<code>client::connect</code>も公開にしましょう:</p>
<!-- <span class="filename">Filename: src/client.rs</span> -->
<p><span class="filename">ファイル名: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn connect() {
}
#}</code></pre></pre>
<!-- Now run `cargo build` again: -->
<p>さて、再び、<code>cargo build</code>を走らせてください:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<!-- The code compiled, and the warning that `client::connect` is not being used is -->
<!-- gone! -->
<p>コードのコンパイルが通り、<code>client:connect</code>が使用されていないという警告はなくなりました！</p>
<!-- 3行目、could be alerting you to code you...のところがちょっと不安 -->
<!-- Unused code warnings don’t always indicate that an item in your code needs to -->
<!-- be made public: if you *didn’t* want these functions to be part of your public -->
<!-- API, unused code warnings could be alerting you to code you no longer need that -->
<!-- you can safely delete. They could also be alerting you to a bug if you had just -->
<!-- accidentally removed all places within your library where this function is -->
<!-- called. -->
<p>コード未使用警告が必ずしも、コード内の要素を公開にしなければならないことを示唆しているわけではありません:
これらの関数を公開APIの一部にしたく<em>なかった</em>ら、未使用コード警告がもう必要なく、安全に削除できるコードに注意を向けてくれている可能性もあります。
また未使用コード警告は、ライブラリ内でこの関数を呼び出している箇所全てを誤って削除した場合に、
バグに目を向けさせてくれている可能性もあります。</p>
<!-- But in this case, we *do* want the other two functions to be part of our -->
<!-- crate’s public API, so let’s mark them as `pub` as well to get rid of the -->
<!-- remaining warnings. Modify *src/network/mod.rs* to look like the following: -->
<p>しかし今回は、本当に他の2つの関数もクレートの公開APIにしたいので、これも<code>pub</code>とマークして残りの警告を除去しましょう。
<em>src/network/mod.rs</em>を変更して以下のようにしてください:</p>
<!-- <span class="filename">Filename: src/network/mod.rs</span> -->
<p><span class="filename">ファイル名: src/network/mod.rs</span></p>
<pre><code class="language-rust ignore">pub fn connect() {
}

mod server;
</code></pre>
<!-- Then compile the code: -->
<p>そして、コードをコンパイルします:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / pub fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<!-- Hmmm, we’re still getting an unused function warning, even though -->
<!-- `network::connect` is set to `pub`. The reason is that the function is public -->
<!-- within the module, but the `network` module that the function resides in is not -->
<!-- public. We’re working from the interior of the library out this time, whereas -->
<!-- with `client::connect` we worked from the outside in. We need to change -->
<!-- *src/lib.rs* to make `network` public too, like so: -->
<p>んんー、<code>nework::connect</code>は<code>pub</code>に設定されたにもかかわらず、まだ未使用関数警告が出ます。
その理由は、関数はモジュール内で公開になったものの、関数が存在する<code>network</code>モジュールは公開ではないからです。
今回は、ライブラリの内部から外に向けて作業をした一方、<code>client::connect</code>では、外から内へ作業をしていました。
<em>src/lib.rs</em>を変えて<code>network</code>も公開にする必要があります。以下のように:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;
</code></pre>
<!-- Now when we compile, that warning is gone: -->
<p>これでコンパイルすれば、あの警告はなくなります:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<!-- Only one warning is left-try to fix this one on your own! -->
<p>残る警告は1つなので、自分で解消してみてください！</p>
<!-- ### Privacy Rules -->
<a class="header" href="print.html#aプライバシー規則" id="aプライバシー規則"><h3>プライバシー規則</h3></a>
<!-- Overall, these are the rules for item visibility: -->
<p>まとめると、要素の公開性は以下のようなルールになります:</p>
<!-- - If an item is public, it can be accessed through any of its parent modules. -->
<!-- - If an item is private, it can be accessed only by its immediate parent -->
<!--   module and any of the parent’s child modules. -->
<ul>
<li>要素が公開なら、どの親モジュールを通してもアクセス可能です。</li>
<li>要素が非公開なら、直接の親モジュールとその親の子モジュールのみアクセスできます。</li>
</ul>
<!-- ### Privacy Examples -->
<a class="header" href="print.html#aプライバシー例" id="aプライバシー例"><h3>プライバシー例</h3></a>
<!-- Let’s look at a few more privacy examples to get some practice. Create a new -->
<!-- library project and enter the code in Listing 7-6 into your new project’s -->
<!-- *src/lib.rs*. -->
<p>もうちょっと鍛錬を得るために、もういくつかプライバシー例を見てみましょう。新しいライブラリプロジェクトを作成し、
リスト7-5のコードを新規プロジェクトの<em>src/lib.rs</em>に入力してください。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod outermost {
    pub fn middle_function() {}

    fn middle_secret_function() {}

    mod inside {
        pub fn inner_function() {}

        fn secret_function() {}
    }
}

fn try_me() {
    outermost::middle_function();
    outermost::middle_secret_function();
    outermost::inside::inner_function();
    outermost::inside::secret_function();
}
</code></pre>
<!-- <span class="caption">Listing 7-6: Examples of private and public functions, -->
<!-- some of which are incorrect</span> -->
<p><span class="caption">リスト7-6: 公開と非公開関数の例。不正なものもあります</span></p>
<!-- Before you try to compile this code, make a guess about which lines in the -->
<!-- `try_me` function will have errors. Then, try compiling the code to see whether -->
<!-- you were right-and read on for the discussion of the errors! -->
<p>このコードをコンパイルする前に、<code>try_me</code>関数のどの行がエラーになるか当ててみてください。
それからコンパイルを試して、合ってたかどうか確かめ、エラーの議論を求めて読み進めてください！</p>
<!-- #### Looking at the Errors -->
<a class="header" href="print.html#aエラーを確かめる" id="aエラーを確かめる"><h4>エラーを確かめる</h4></a>
<!-- The `try_me` function is in the root module of our project. The module named -->
<!-- `outermost` is private, but the second privacy rule states that the `try_me` -->
<!-- function is allowed to access the `outermost` module because `outermost` is in -->
<!-- the current (root) module, as is `try_me`. -->
<p><code>try_me</code>関数は、プロジェクトのルートモジュールに存在しています。<code>outermost</code>という名前のモジュールは非公開ですが、
プライバシー規則の2番目にある通り、<code>try_me</code>そのままに、<code>outermost</code>は現在(ルート)のモジュールなので、
<code>try_me</code>関数は、<code>outermost</code>モジュールにアクセスすることを許可されるのです。</p>
<!-- The call to `outermost::middle_function` will work because `middle_function` is -->
<!-- public and `try_me` is accessing `middle_function` through its parent module -->
<!-- `outermost`. We already determined that this module is accessible. -->
<p><code>middle_function</code>は公開なので、<code>outermost::middle_function</code>という呼び出しも動作し、
<code>try_me</code>は<code>middle_function</code>にその親モジュールの<code>outermost</code>を通してアクセスしています。
このモジュールは、アクセス可能と既に決定しました。</p>
<!-- The call to `outermost::middle_secret_function` will cause a compilation error. -->
<!-- Because `middle_secret_function` is private, the second rule applies. The root -->
<!-- module is neither the current module of `middle_secret_function` (`outermost` -->
<!-- is), nor is it a child module of the current module of `middle_secret_function`. -->
<p><code>outermost::middle_secret_function</code>の呼び出しは、コンパイルエラーになるでしょう。
<code>middle_secret_function</code>は非公開なので、2番目の規則が適用されます。ルートモジュールは、
<code>middle_secret_function</code>の現在のモジュール(<code>outermost</code>がそうです)でも、
<code>middle_secret_function</code>の現在のモジュールの子供でもないのです。</p>
<!-- The module named `inside` is private and has no child modules, so it can be -->
<!-- accessed only by its current module `outermost`. That means the `try_me` -->
<!-- function is not allowed to call `outermost::inside::inner_function` or -->
<!-- `outermost::inside::secret_function`. -->
<p><code>inside</code>という名前のモジュールは非公開で子モジュールを持たないので、現在のモジュールである<code>outermost</code>からのみアクセスできます。
つまり、<code>try_me</code>関数は、<code>outermost::inside::inner_function</code>も<code>outermost::inside::secret_function</code>も呼び出すことを許されないのです。</p>
<!-- #### Fixing the Errors -->
<a class="header" href="print.html#aエラーを修正する" id="aエラーを修正する"><h4>エラーを修正する</h4></a>
<!-- Here are some suggestions for changing the code in an attempt to fix the -->
<!-- errors. Make a guess as to whether it will fix the errors before you try each -->
<!-- one. Then compile the code to see whether or not you’re right, using the -->
<!-- privacy rules to understand why. Feel free to design more experiments and try -->
<!-- them out! -->
<p>エラーを修正しようとする過程でできるコード変更案は、以下の通りです。各々試してみる前に、
エラーを解消できるか当ててみてください。それからコンパイルして正しかったか間違っていたか確かめ、
プライバシー規則を使用して理由を理解してください。もっと実験を企てて試してみるのもご自由に！</p>
<!-- * What if the `inside` module were public? -->
<!-- * What if `outermost` were public and `inside` were private? -->
<!-- * What if, in the body of `inner_function`, you called -->
<!--   `::outermost::middle_secret_function()`? (The two colons at the beginning mean -->
<!--   that we want to refer to the modules starting from the root module.) -->
<ul>
<li><code>inside</code>モジュールが公開だったらどうだろうか？</li>
<li><code>outermost</code>が公開で、<code>inside</code>が非公開ならどうだろうか？</li>
<li><code>inner_function</code>の本体で<code>::outermost::middle_secret_function()</code>を呼び出したらどうだろうか？
(頭の二つのコロンは、ルートモジュールから初めてモジュールを参照したいということを意味します)</li>
</ul>
<!-- Next, let’s talk about bringing items into scope with the `use` keyword. -->
<p>今度は、<code>use</code>キーワードで要素をスコープに導入する話をしましょう。</p>
<!-- ## Referring to Names in Different Modules -->
<a class="header" href="print.html#a異なるモジュールの名前を参照する" id="a異なるモジュールの名前を参照する"><h2>異なるモジュールの名前を参照する</h2></a>
<!-- We’ve covered how to call functions defined within a module using the module -->
<!-- name as part of the call, as in the call to the `nested_modules` function shown -->
<!-- here in Listing 7-7. -->
<p>モジュール名を呼び出しの一部に使用して、モジュール内に定義された関数の呼び出し方法を解説しました。
リスト7-7に示した<code>nested_modules</code>関数の呼び出しのような感じですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

fn main() {
    a::series::of::nested_modules();
}
</code></pre></pre>
<!-- <span class="caption">Listing 7-7: Calling a function by fully specifying its -->
<!-- enclosing module’s path</span> -->
<p><span class="caption">リスト7-7: 囲まれたモジュールをフルパス指定して関数を呼び出す</span></p>
<!-- As you can see, referring to the fully qualified name can get quite lengthy. -->
<!-- Fortunately, Rust has a keyword to make these calls more concise. -->
<p>見てお分かりの通り、フルパス指定した名前を参照すると非常に長ったらしくなります。
幸い、Rustには、これらの呼び出しをもっと簡潔にするキーワードが用意されています。</p>
<!-- ### Bringing Names into Scope with the `use` keyword -->
<a class="header" href="print.html#useキーワードで名前をスコープに導入する" id="useキーワードで名前をスコープに導入する"><h3><code>use</code>キーワードで名前をスコープに導入する</h3></a>
<!-- Rust’s `use` keyword shortens lengthy function calls by bringing the modules of -->
<!-- the function you want to call into scope. Here’s an example of bringing the -->
<!-- `a::series::of` module into a binary crate’s root scope: -->
<p>Rustの<code>use</code>キーワードは、呼び出したい関数のモジュールをスコープに導入することで、
長ったらしい関数呼び出しを短縮します。以下は、
<code>a::series::of</code>モジュールをバイナリクレートのルートスコープに持ってくる例です:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of;

fn main() {
    of::nested_modules();
}
</code></pre></pre>
<!-- The line `use a::series::of;` means that rather than using the full -->
<!-- `a::series::of` path wherever we want to refer to the `of` module, we can use -->
<!-- `of`. -->
<p><code>use a::series::of;</code>の行は、<code>of</code>モジュールを参照したい箇所全部でフルパスの<code>a::series::of</code>を使用するのではなく、
<code>of</code>を利用できることを意味しています。</p>
<!-- The `use` keyword brings only what we’ve specified into scope: it does not -->
<!-- bring children of modules into scope. That’s why we still have to use -->
<!-- `of::nested_modules` when we want to call the `nested_modules` function. -->
<p>この<code>use</code>キーワードは、指定したものだけをスコープに入れます: モジュールの子供はスコープに導入しないのです。
そのため、<code>nested_modules</code>関数を呼び出したい際に、それでもまだ<code>of::nested_modules</code>を使わなければならないのです。</p>
<!-- We could have chosen to bring the function into scope by instead specifying the -->
<!-- function in the `use` as follows: -->
<p>以下のように、代わりに<code>use</code>で関数を指定して、関数をスコープに入れることもできました:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of::nested_modules;

fn main() {
    nested_modules();
}
</code></pre></pre>
<!-- Doing so allows us to exclude all the modules and reference the function -->
<!-- directly. -->
<p>そうすれば、モジュールをすべて取り除き、関数を直接参照することができます。</p>
<!-- Because enums also form a sort of namespace like modules, we can bring an -->
<!-- enum’s variants into scope with `use` as well. For any kind of `use` statement,  -->
<!-- if you're bringing multiple items from one namespace into scope, you can list  -->
<!-- them using curly brackets and commas in the last position, like so: -->
<p>enumもモジュールのようにある種の名前空間をなすので、enumのバリアントを<code>use</code>でスコープに導入することもできます。
どんな<code>use</code>文に関しても、一つの名前空間から複数の要素をスコープに導入する場合、波かっことお尻にカンマを使用することで列挙できます。
こんな感じで:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::{Red, Yellow};

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = TrafficLight::Green;
}
</code></pre></pre>
<!-- We’re still specifying the `TrafficLight` namespace for the `Green` variant -->
<!-- because we didn’t include `Green` in the `use` statement. -->
<p><code>Green</code>を<code>use</code>文に含んでいないので、まだ<code>Green</code>バリアント用に<code>TrafficLight</code>名前空間を指定しています。</p>
<!-- ### Bringing All Names into Scope with a Glob -->
<a class="header" href="print.html#globで全ての名前をスコープに導入する" id="globで全ての名前をスコープに導入する"><h3>Globで全ての名前をスコープに導入する</h3></a>
<!-- To bring all the items in a namespace into scope at once, we can use the `*` -->
<!-- syntax, which is called the *glob operator*. This example brings all the -->
<!-- variants of an enum into scope without having to list each specifically: -->
<p>ある名前空間の要素を全て一度にスコープに導入するには、<code>*</code>表記が使用でき、これはglob(塊)演算子と呼ばれます。
この例は、あるenumの列挙子を各々を列挙せずに全てスコープに導入しています:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::*;

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = Green;
}
</code></pre></pre>
<!-- The `*` operator will bring into scope all the visible items in the -->
<!-- `TrafficLight` namespace. You should use globs sparingly: they are convenient, -->
<!-- but a glob might also pull in more items than you expected and cause naming -->
<!-- conflicts. -->
<p><code>*</code>演算子は<code>TrafficLight</code>名前空間に存在する全て公開要素をスコープに導入します。
あまりglobは使用するべきではありません: 便利ではありますが、globは予想以上の要素を引き込んで、
名前衝突を引き起こす可能性があるのです。</p>
<!-- ### Using `super` to Access a Parent Module -->
<a class="header" href="print.html#superを使用して親モジュールにアクセスする" id="superを使用して親モジュールにアクセスする"><h3><code>super</code>を使用して親モジュールにアクセスする</h3></a>
<!-- As you saw at the beginning of this chapter, when you create a library crate, -->
<!-- Cargo makes a `tests` module for you. Let’s go into more detail about that now. -->
<!-- In your `communicator` project, open *src/lib.rs*: -->
<p>この章の頭で見かけたように、ライブラリクレートを作成する際、Cargoは<code>tests</code>モジュールを用意してくれました。
今からそれについて詳しく掘り下げていくことにしましょう。<code>communicator</code>プロジェクトで<em>src/lib.rs</em>を開いてください:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<!-- Chapter 11 explains more about testing, but parts of this example should make -->
<!-- sense now: we have a module named `tests` that lives next to our other modules -->
<!-- and contains one function named `it_works`. Even though there are special -->
<!-- annotations, the `tests` module is just another module! So our module hierarchy -->
<!-- looks like this: -->
<p>第11章でテストについて詳しく説明しますが、これでこの例の一部が持つ意味がわかったのではないでしょうか:
他のモジュールに隣接する<code>tests</code>という名前のモジュールがあり、このモジュールは<code>it_works</code>という名前の関数を含んでいます。
特別な注釈があるものの、<code>tests</code>モジュールもただのモジュールです！よって、モジュール階層は以下のような見た目になります:</p>
<pre><code class="language-text">communicator
 ├── client
 ├── network
 |   └── client
 └── tests
</code></pre>
<!-- Tests are for exercising the code within our library, so let’s try to call our -->
<!-- `client::connect` function from this `it_works` function, even though we won’t -->
<!-- be checking any functionality right now. This won’t work yet: -->
<p>テストは、ライブラリ内でコードの準備運動を行うためのものなので、この<code>it_works</code>関数から<code>client::connect</code>関数を呼び出してみましょう。
まあ、尤も今のところ、機能の検査は何もしないんですけどね。これはまだ動きません:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<!-- Run the tests by invoking the `cargo test` command: -->
<p><code>cargo test</code>コマンドを呼び出してテストを実行してください:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
error[E0433]: failed to resolve. Use of undeclared type or module `client`
(エラー: 解決に失敗しました。未定義の型、またはモジュール`client`を使用しています)
 --&gt; src/lib.rs:9:9
  |
9 |         client::connect();
  |         ^^^^^^ Use of undeclared type or module `client`
</code></pre>
<!-- The compilation failed, but why? We don’t need to place `communicator::` in -->
<!-- front of the function, as we did in *src/main.rs*, because we are definitely -->
<!-- within the `communicator` library crate here. The reason is that paths are -->
<!-- always relative to the current module, which here is `tests`. The only -->
<!-- exception is in a `use` statement, where paths are relative to the crate root -->
<!-- by default. Our `tests` module needs the `client` module in its scope! -->
<p>コンパイルが失敗しましたが、なぜでしょうか？<em>src/main.rs</em>のように、関数の直前に<code>communicator::</code>を配置する必要はありません。
なぜなら、間違いなくここでは、<code>communicator</code>ライブラリクレート内にいるからです。
原因は、パスが常に現在のモジュールに対して相対的になり、ここでは<code>tests</code>になっているからです。
唯一の例外は、<code>use</code>文内であり、パスは標準でクレートのルートに相対的になります。
<code>tests</code>モジュールは、<code>client</code>モジュールがスコープに存在する必要があるのです！</p>
<!-- So how do we get back up one module in the module hierarchy to call the -->
<!-- `client::connect` function in the `tests` module? In the `tests` module, we can -->
<!-- either use leading colons to let Rust know that we want to start from the root -->
<!-- and list the whole path, like this: -->
<p>では、どうやってモジュール階層を一つ上がり、<code>tests</code>モジュールの<code>client::connect</code>関数を呼び出すのでしょうか？
<code>tests</code>モジュールにおいて、先頭にコロンを使用して、コンパイラにルートから始めて、フルパスを列挙したいと知らせることもできます。
こんな感じで:</p>
<pre><code class="language-rust ignore">::client::connect();
</code></pre>
<!-- Or, we can use `super` to move up one module in the hierarchy from our current -->
<!-- module, like this: -->
<p>あるいは、<code>super</code>を使用して現在のモジュールからモジュール階層を一つ上がることもできます。
以下のように:</p>
<pre><code class="language-rust ignore">super::client::connect();
</code></pre>
<!-- These two options don’t look that different in this example, but if you’re -->
<!-- deeper in a module hierarchy, starting from the root every time would make your -->
<!-- code lengthy. In those cases, using `super` to get from the current module to -->
<!-- sibling modules is a good shortcut. Plus, if you’ve specified the path from the -->
<!-- root in many places in your code and then you rearrange your modules by moving -->
<!-- a subtree to another place, you’ll end up needing to update the path in several -->
<!-- places, which would be tedious. -->
<p>この例では、これら二つの選択はそれほど異なるようには見えませんが、モジュール階層がもっと深ければ、
常にルートから書き始めるのは、コードを冗長にする原因になります。そのような場合、
<code>super</code>を使用して現在のモジュールから兄弟のモジュールに辿り着くのは、いいショートカットになります。
さらに、コードのいろんなところでルートからパスを指定し、モジュール構造を変化させた場合、
複数箇所でパスを更新する必要が陥り、面倒なことになるでしょう。</p>
<!-- It would also be annoying to have to type `super::` in each test, but you’ve -->
<!-- already seen the tool for that solution: `use`! The `super::` functionality -->
<!-- changes the path you give to `use` so it is relative to the parent module -->
<!-- instead of to the root module. -->
<p>各テストで<code>super::</code>と入力しなければならないのも不快なことですが、それを解決してくれる道具をもう見かけています:
<code>use</code>です！<code>super::</code>の機能は、<code>use</code>に与えるパスを変更するので、ルートモジュールではなく、
親モジュールに対して相対的になります。</p>
<!-- For these reasons, in the `tests` module especially, `use super::something` is -->
<!-- usually the best solution. So now our test looks like this: -->
<p>このような理由から、ことに<code>tests</code>モジュールにおいて<code>use super::somthing</code>は通常、
最善策になるわけです。故に、今ではテストはこんな見た目になりました:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::client;

    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<!-- When we run `cargo test` again, the test will pass, and the first part of the -->
<!-- test result output will be the following: -->
<p>再度<code>cargo test</code>を実行すると、テストは通り、テスト結果出力の最初の部分は以下のようになるでしょう:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
     Running target/debug/communicator-92007ddb5330fa5a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-6" id="aまとめ-6"><h2>まとめ</h2></a>
<!-- Now you know some new techniques for organizing your code! Use these techniques -->
<!-- to group related functionality together, keep files from becoming too long, and -->
<!-- present a tidy public API to your library users. -->
<p>これでコードを体系化する新しいテクニックを知りましたね！これらのテクニックを使用して、
関連のある機能をまとめ上げ、ファイルが長くなりすぎるのを防ぎ、ライブラリの使用者に整理整頓された公開APIを提供してください。</p>
<!-- Next, we’ll look at some collection data structures in the standard library -->
<!-- that you can use in your nice, neat code. -->
<p>次は、自分の素晴らしく綺麗なコードで使用できる標準ライブラリのコレクションデータ構造について見ていきましょう。</p>
<!-- # Common Collections -->
<a class="header" href="print.html#a一般的なコレクション" id="a一般的なコレクション"><h1>一般的なコレクション</h1></a>
<!-- Rust’s standard library includes a number of very useful data structures called -->
<!-- *collections*. Most other data types represent one specific value, but -->
<!-- collections can contain multiple values. Unlike the built-in array and tuple -->
<!-- types, the data these collections point to is stored on the heap, which means -->
<!-- the amount of data does not need to be known at compile time and can grow or -->
<!-- shrink as the program runs. Each kind of collection has different capabilities -->
<!-- and costs, and choosing an appropriate one for your current situation is a -->
<!-- skill you’ll develop over time. In this chapter, we’ll discuss three -->
<!-- collections that are used very often in Rust programs: -->
<p>Rustの標準ライブラリは、<em>コレクション</em>と呼ばれる多くの非常に有益なデータ構造を含んでいます。他の多くのデータ型は、
ある一つの値を表しますが、コレクションは複数の値を含むことができます。組み込みの配列とタプル型とは異なり、
これらのコレクションが指すデータはヒープに確保され、データ量はコンパイル時にわかる必要はなく、
プログラムの実行にあわせて、伸縮可能であることになります。各種のコレクションには異なる能力とコストが存在し、
自分の現在の状況に最適なものを選び取るスキルは、時間とともに育っていきます。この章では、
Rustのプログラムにおいて、非常に頻繁に使用される3つのコレクションについて議論しましょう。</p>
<!-- * A *vector* allows us to store a variable number of values next to each other. -->
<!-- * A *string* is a collection of characters. We’ve mentioned the `String` type -->
<!--   previously, but in this chapter we’ll talk about it in depth. -->
<!-- * A *hash map* allows us to associate a value with a particular key. It’s a -->
<!--   particular implementation of the more general data structure called a *map*. -->
<ul>
<li><em>ベクタ型</em>は、可変長の値を並べて保持できる。</li>
<li><em>文字列</em>は、文字のコレクションである。以前、<code>String</code>型について触れたが、
この章ではより掘り下げていく。</li>
<li><em>ハッシュマップ</em>は、値を特定のキーと紐付けさせてくれる。より一般的なデータ構造である、
<em>マップ</em>の特定の実装である。</li>
</ul>
<!-- To learn about the other kinds of collections provided by the standard library, -->
<!-- see [the documentation][collections]. -->
<p>標準ライブラリで提供されている他の種のコレクションについて学ぶには、
<a href="../../std/collections/index.html">ドキュメント</a>を参照されたし。</p>
<!-- We’ll discuss how to create and update vectors, strings, and hash maps, as well -->
<!-- as what makes each special. -->
<p>ベクタ型、文字列、ハッシュマップの生成と更新方法や、各々が特別な点について議論していきましょう。</p>
<!-- ## Storing Lists of Values with Vectors -->
<a class="header" href="print.html#aベクタで一連の値を保持する" id="aベクタで一連の値を保持する"><h2>ベクタで一連の値を保持する</h2></a>
<!-- The first collection type we’ll look at is `Vec<T>`, also known as a *vector*. -->
<!-- Vectors allow us to store more than one value in a single data structure that -->
<!-- puts all the values next to each other in memory. Vectors can only store values -->
<!-- of the same type. They are useful when you have a list of items, such as the -->
<!-- lines of text in a file or the prices of items in a shopping cart. -->
<p>最初に見るコレクションは、<code>Vec&lt;T&gt;</code>であり、<em>ベクタ</em>としても知られています。ベクタは、
メモリ上に値を隣り合わせに並べる単独のデータ構造に2つ以上の値を保持させてくれます。
ベクタには、同じ型の値しか保持できません。要素のリストがある場合に有用です。
例えば、テキストファイルの各行とか、ショッピングカートのアイテムの価格などです。</p>
<!-- ### Creating a New Vector -->
<a class="header" href="print.html#a新しいベクタを生成する" id="a新しいベクタを生成する"><h3>新しいベクタを生成する</h3></a>
<!-- To create a new, empty vector, we can call the `Vec::new` function, as shown in -->
<!-- Listing 8-1. -->
<p>新しい空のベクタを作るには、リスト8-1に示されたように、<code>Vec::new</code>関数を呼ぶことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-1: Creating a new, empty vector to hold values -->
<!-- of type `i32`</span> -->
<p><span class="caption">リスト8-1: 新しい空のベクタを生成して<code>i32</code>型の値を保持する</span></p>
<!-- Note that we added a type annotation here. Because we aren’t inserting any -->
<!-- values into this vector, Rust doesn’t know what kind of elements we intend to -->
<!-- store. This is an important point. Vectors are implemented using generics; -->
<!-- we’ll cover how to use generics with your own types in Chapter 10. For now, -->
<!-- know that the `Vec<T>` type provided by the standard library can hold any type, -->
<!-- and when a specific vector holds a specific type, the type is specified within -->
<!-- angle brackets. In Listing 8-1, we’ve told Rust that the `Vec<T>` in `v` will -->
<!-- hold elements of the `i32` type. -->
<p>ここでは、型注釈を付け足したことに注目してください。このベクタに対して、何も値を挿入していないので、
コンパイラには、どんなデータを保持させるつもりなのかわからないのです。これは重要な点です。ベクタは、
ジェネリクスを使用して実装されているのです; 独自の型でジェネリクスを使用する方法については、
第10章で解説します。今は、標準ライブラリにより提供されている<code>Vec&lt;T&gt;</code>型は、どんな型でも保持でき、
特定のベクタが特定の型を保持するとき、その型は山かっこ内に指定されることを知っておいてください。
リスト8-1では、コンパイラに<code>v</code>の<code>Vec&lt;T&gt;</code>は、<code>i32</code>型の要素を保持すると指示しました。</p>
<!-- In more realistic code, Rust can often infer the type of value you want to -->
<!-- store once you insert values, so you rarely need to do this type annotation. -->
<!-- It's more common to create a `Vec<T>` that has initial values, and Rust -->
<!-- provides the `vec!` macro for convenience. The macro will create a new vector -->
<!-- that holds the values we give it. Listing 8-2 creates a new `Vec<i32>` that -->
<!-- holds the values `1`, `2`, and `3`. -->
<p>より現実的なコードでは、一旦値を挿入したら、コンパイラは保持させたい値の型をしばしば推論できるので、
この型注釈をすることは滅多にありません。初期値のある<code>Vec&lt;T&gt;</code>を生成する方が一般的ですし、
Rustには、利便性のために<code>vec!</code>というマクロも用意されています。このマクロは、
与えた値を保持する新しいベクタ型を生成します。リスト8-2では、<code>1</code>、<code>2</code>、<code>3</code>という値を持つ新しい<code>Vec&lt;i32&gt;</code>を生成しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-2: Creating a new vector containing -->
<!-- values</span> -->
<p><span class="caption">リスト8-2: 値を含む新しいベクタを生成する</span></p>
<!-- Because we’ve given initial `i32` values, Rust can infer that the type of `v` -->
<!-- is `Vec<i32>`, and the type annotation isn’t necessary. Next, we’ll look at how -->
<!-- to modify a vector. -->
<p>初期値の<code>i32</code>値を与えたので、コンパイラは、<code>v</code>の型が<code>Vec&lt;i32&gt;</code>であると推論でき、型注釈は必要なくなりました。
次は、ベクタを変更する方法を見ましょう。</p>
<!-- ### Updating a Vector -->
<a class="header" href="print.html#aベクタを更新する" id="aベクタを更新する"><h3>ベクタを更新する</h3></a>
<!-- To create a vector and then add elements to it, we can use the `push` method, -->
<!-- as shown in Listing 8-3. -->
<p>ベクタを生成し、それから要素を追加するには、リスト8-3に示したように、<code>push</code>メソッドを使用できます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-3: Using the `push` method to add values to a -->
<!-- vector</span> -->
<p><span class="caption">リスト8-3: <code>push</code>メソッドを使用してベクタ型に値を追加する</span></p>
<!-- As with any variable, if we want to be able to change its value, we need to -->
<!-- make it mutable using the `mut` keyword, as discussed in Chapter 3. The numbers -->
<!-- we place inside are all of type `i32`, and Rust infers this from the data, so -->
<!-- we don’t need the `Vec<i32>` annotation. -->
<p>あらゆる変数同様、第3章で議論したように、値を変化させたかったら、<code>mut</code>キーワードで可変にする必要があります。
中に配置する数値は全て<code>i32</code>型であり、コンパイラはこのことをデータから推論するので、
<code>Vec&lt;i32&gt;</code>という注釈は必要なくなります。</p>
<!-- ### Dropping a Vector Drops Its Elements -->
<a class="header" href="print.html#aベクタをドロップすれば要素もドロップする" id="aベクタをドロップすれば要素もドロップする"><h3>ベクタをドロップすれば、要素もドロップする</h3></a>
<!-- Like any other `struct`, a vector is freed when it goes out of scope, as -->
<!-- annotated in Listing 8-4. -->
<p>他のあらゆる<code>構造体</code>同様、ベクタもスコープを抜ければ、解放されます。リスト8-4に注釈したようにですね。</p>
<!-- ```rust -->
<!-- { -->
<!--     let v = vec![1, 2, 3, 4]; -->
<!--     // do stuff with v -->
<!-- } // <- v goes out of scope and is freed here -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // vで作業をする

} // &lt;- vはここでスコープを抜け、解放される
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-4: Showing where the vector and its elements -->
<!-- are dropped</span> -->
<p><span class="caption">リスト8-4: ベクタとその要素がドロップされる箇所を示す</span></p>
<!-- When the vector gets dropped, all of its contents will also be dropped, meaning -->
<!-- those integers it holds will be cleaned up. This may seem like a -->
<!-- straightforward point but can get a bit more complicated when you start to -->
<!-- introduce references to the elements of the vector. Let’s tackle that next! -->
<p>ベクタがドロップされると、その中身もドロップされます。つまり、保持されていた整数値が、
片付けられるということです。これは一見単純な点に見えるかもしれませんが、ベクタの要素への参照を導入した途端、
もうちょっと複雑になる可能性を秘めています。次は、それに挑んでいきましょう！</p>
<!-- ### Reading Elements of Vectors -->
<a class="header" href="print.html#aベクタの要素を読む" id="aベクタの要素を読む"><h3>ベクタの要素を読む</h3></a>
<!-- Now that you know how to create, update, and destroy vectors, knowing how to -->
<!-- read their contents is a good next step. There are two ways to reference a -->
<!-- value stored in a vector. In the examples, we’ve annotated the types of the -->
<!-- values that are returned from these functions for extra clarity. -->
<p>もうベクタを生成し、更新し、破壊する方法を知ったので、コンテンツを読む方法を知るのはいいステップアップです。
ベクタに保持された値を参照する方法は2つあります。例では、さらなる明瞭性を求めて、
これらの関数から返る値の型を注釈しました。</p>
<!-- Listing 8-5 shows both methods of accessing a value in a vector, either with -->
<!-- indexing syntax or the `get` method. -->
<p>リスト8-5に示したのは、両メソッドがベクタの値に対して、添字記法と<code>get</code>メソッドによりアクセスするところです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-5: Using indexing syntax or the `get` method to -->
<!-- access an item in a vector</span> -->
<p><span class="caption">リスト8-5: 添字記法か<code>get</code>メソッドを使用してベクタの要素にアクセスする</span></p>
<!-- Note two details here. First, we use the index value of `2` to get the third -->
<!-- element: vectors are indexed by number, starting at zero. Second, the two ways -->
<!-- to get the third element are by using `&` and `[]`, which gives us a reference, -->
<!-- or by using the `get` method with the index passed as an argument, which gives -->
<!-- us an `Option<&T>`. -->
<p>ここでは、2つのことに気付いてください。まず、3番目の要素を得るのに<code>2</code>という添え字の値を使用していることです:
ベクタは、数値により順序付けされ、添え字は0から始まります。2番目に、3番目の要素を得る2つの方法は、
<code>&amp;</code>と<code>[]</code>を使用して参照を得るものと、番号を引数として<code>get</code>メソッドに渡して、<code>Option&lt;&amp;T&gt;</code>を得るものということです。</p>
<!-- Rust has two ways to reference an element so you can choose how the program -->
<!-- behaves when you try to use an index value that the vector doesn’t have an -->
<!-- element for. As an example, let’s see what a program will do if it has a vector -->
<!-- that holds five elements and then tries to access an element at index 100, as -->
<!-- shown in Listing 8-6. -->
<p>Rustには要素を参照する方法が2通りあるので、ベクタに要素が含まれない番号の値を使用しようとした時に、
プログラムの振る舞いを選択できます。例として、ベクタに5つ要素があり、番号100の要素にアクセスを試みた場合、
プログラムがすることを確認しましょう。リスト8-6に示したようにですね。</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-6: Attempting to access the element at index -->
<!-- 100 in a vector containing five elements</span> -->
<p><span class="caption">リスト8-6: 5つの要素を含むベクタの100番目の要素にアクセスしようとする</span></p>
<!-- When we run this code, the first `[]` method will cause the program to panic -->
<!-- because it references a nonexistent element. This method is best used when you -->
<!-- want your program to crash if there's an attempt to access an element past the -->
<!-- end of the vector. -->
<p>このコードを走らせると、最初の<code>[]</code>メソッドはプログラムをパニックさせます。存在しない要素を参照しているからです。
このメソッドは、ベクタの終端を超えて要素にアクセスしようした時にプログラムをクラッシュさせたい場合に最適です。</p>
<!-- When the `get` method is passed an index that is outside the vector, it returns -->
<!-- `None` without panicking. You would use this method if accessing an element -->
<!-- beyond the range of the vector happens occasionally under normal circumstances. -->
<!-- Your code will then have logic to handle having either `Some(&element)` or -->
<!-- `None`, as discussed in Chapter 6. For example, the index could be coming from -->
<!-- a person entering a number. If they accidentally enter a number that’s too -->
<!-- large and the program gets a `None` value, you could tell the user how many -->
<!-- items are in the current vector and give them another chance to enter a valid -->
<!-- value. That would be more user-friendly than crashing the program due to a typo! -->
<p><code>get</code>メソッドがベクタ外の番号を渡されると、パニックすることなく<code>None</code>を返します。
普通の状態でも、ベクタの範囲外にアクセスする可能性がある場合に、このメソッドを使用することになるでしょう。
そうしたら、コードには<code>Some(&amp;element)</code>か<code>None</code>を扱うロジックが存在することになります。そう、
第6章で議論したように。例えば、番号は人間に数値を入力してもらうことで得ることもできます。
もし大きすぎる値を誤って入力し、プログラムが<code>None</code>値を得てしまったら、現在ベクタに幾つ要素があるかをユーザに教え、
再度正しい値を入力してもらうことができるでしょう。その方が、タイプミスでプログラムをクラッシュさせるより、
ユーザに優しくなるでしょう。</p>
<!-- When the program has a valid reference, the borrow checker enforces the -->
<!-- ownership and borrowing rules (covered in Chapter 4) to ensure this reference -->
<!-- and any other references to the contents of the vector remain valid. Recall the -->
<!-- rule that states we can’t have mutable and immutable references in the same -->
<!-- scope. That rule applies in Listing 8-7, where we hold an immutable reference to -->
<!-- the first element in a vector and try to add an element to the end, which won't -->
<!-- work. -->
<p>プログラムに有効な参照がある場合、borrow checker(借用精査機)は(第4章で解説しましたが)、
所有権と借用規則を強制し、ベクタ型の中身へのこの参照や他のいかなる参照も有効であり続けることを保証してくれます。
同一スコープ上では、可変と不変な参照を同時には存在させられないというルールを思い出してください。
このルールはリスト8-7にも適用され、リスト8-7ではベクタの最初の要素への不変参照を保持し、
終端に要素を追加しようとしていますが、動きません。</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<!-- <span class="caption">Listing 8-7: Attempting to add an element to a vector -->
<!-- while holding a reference to an item</span> -->
<p><span class="caption">リスト8-7: 要素への参照を保持しつつ、ベクタに要素を追加しようとする</span></p>
<!-- Compiling this code will result in this error: -->
<p>このコードをコンパイルすると、こんなエラーになります:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
(エラー: 不変としても借用されているので、`v`を可変で借用できません)
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
  |                  (不変借用はここで発生しています)
5 |
6 |     v.push(6);
  |     ^ mutable borrow occurs here
  |      (可変借用は、ここで発生しています)
7 | }
  | - immutable borrow ends here
  |   (不変借用はここで終了しています)
</code></pre>
<!-- The code in Listing 8-7 might look like it should work: why should a reference -->
<!-- to the first element care about what changes at the end of the vector? This -->
<!-- error is due to the way vectors work: adding a new element onto the end of the -->
<!-- vector might require allocating new memory and copying the old elements to the -->
<!-- new space if there isn’t enough room to put all the elements next to each -->
<!-- other where the vector currently is. In that case, the reference to the first -->
<!-- element would be pointing to deallocated memory. The borrowing rules prevent -->
<!-- programs from ending up in that situation. -->
<p>リスト8-7のコードは、一見動くはずのように見えるかもしれません: なぜ、最初の要素への参照が、
ベクタの終端への変更を気にかける必要があるのでしょうか？このエラーは、ベクタの動作法のせいです:
新規要素をベクタの終端に追加すると、ベクタが現在存在する位置に隣り合って要素を入れるだけの領域がなかった場合に、
メモリの新規確保をして古い要素を新しいスペースにコピーする必要があるかもしれないからです。
その場合、最初の要素を指す参照は、解放されたメモリを指すことになるでしょう。借用規則により、
そのような場面に落ち着かないよう回避されるのです。</p>
<!-- > Note: For more on the implementation details of the `Vec<T>` type, see “The -->
<!-- > Rustonomicon” at https://doc.rust-lang.org/stable/nomicon/vec.html. -->
<blockquote>
<p>注釈: <code>Vec&lt;T&gt;</code>の実装に関する詳細については、https://doc.rust-lang.org/stable/nomicon/vec.htmlの、
&quot;The Rustonomicon&quot;を参照されたし。</p>
</blockquote>
<!-- ### Iterating Over the Values in a Vector -->
<a class="header" href="print.html#aベクタの値を走査する" id="aベクタの値を走査する"><h3>ベクタの値を走査する</h3></a>
<!-- If we want to access each element in a vector in turn, we can iterate through -->
<!-- all of the elements rather than use indexes to access one at a time. Listing -->
<!-- 8-8 shows how to use a `for` loop to get immutable references to each element -->
<!-- in a vector of `i32` values and print them. -->
<p>ベクタの要素に順番にアクセスしたいなら、添え字で1回に1要素にアクセスするのではなく、全要素を走査することができます。
リスト8-8で<code>for</code>ループを使い、<code>i32</code>のベクタの各要素に対する不変な参照を得て、それらを出力する方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-8: Printing each element in a vector by -->
<!-- iterating over the elements using a `for` loop</span> -->
<p><span class="caption">リスト8-8: <code>for</code>ループで要素を走査し、ベクタの各要素を出力する</span></p>
<!-- We can also iterate over mutable references to each element in a mutable vector -->
<!-- in order to make changes to all the elements. The `for` loop in Listing 8-9 -->
<!-- will add `50` to each element. -->
<p>全要素に変更を加える目的で、可変なベクタの各要素への可変な参照を走査することもできます。
リスト8-9の<code>for</code>ループでは、各要素に<code>50</code>を足しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-9: Iterating over mutable references to -->
<!-- elements in a vector</span> -->
<p><span class="caption">リスト8-9: ベクタの要素への可変な参照を走査する</span></p>
<!-- To change the value that the mutable reference refers to, we have to use the  -->
<!-- dereference operator (`*`) to get to the value in `i` before we can use the -->
<!-- `+=` operator. -->
<p>可変参照が参照している値を変更するには、<code>+=</code>演算子を使用する前に、
参照外し演算子(<code>*</code>)を使用して<code>i</code>の値に辿り着かないといけません。</p>
<!-- ### Using an Enum to Store Multiple Types -->
<a class="header" href="print.html#enumを使って複数の型を保持する" id="enumを使って複数の型を保持する"><h3>Enumを使って複数の型を保持する</h3></a>
<!-- At the beginning of this chapter, we said that vectors can only store values -->
<!-- that are the same type. This can be inconvenient; there are definitely use -->
<!-- cases for needing to store a list of items of different types. Fortunately, the -->
<!-- variants of an enum are defined under the same enum type, so when we need to -->
<!-- store elements of a different type in a vector, we can define and use an enum! -->
<p>この章の冒頭で、ベクタは同じ型の値しか保持できないと述べました。これは不便に考えられることもあります;
異なる型の要素を保持する必要性が出てくるユースケースも確かにあるわけです。幸運なことに、
enumの列挙子は、同じenumの型の元に定義されるので、ベクタに異なる型の要素を保持する必要が出たら、
enumを定義して使用することができます！</p>
<!-- For example, say we want to get values from a row in a spreadsheet in which -->
<!-- some of the columns in the row contain integers, some floating-point numbers, -->
<!-- and some strings. We can define an enum whose variants will hold the different -->
<!-- value types, and then all the enum variants will be considered the same type: -->
<!-- that of the enum. Then we can create a vector that holds that enum and so, -->
<!-- ultimately, holds different types. We’ve demonstrated this in Listing 8-10. -->
<p>例えば、スプレッドシートの行から値を得たくなったとしましょう。ここで行の列には、整数を含むものや、
浮動小数点数を含むもの、文字列を含むものがあります。列挙子が異なる値の型を保持するenumを定義できます。
そして、このenumの列挙子は全て同じ型: enumの型と考えられるわけです。それからそのenumを保持するベクタを生成でき、
結果的に異なる型を保持できるようになるわけです。リスト8-10でこれを模擬しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-10: Defining an `enum` to store values of -->
<!-- different types in one vector</span> -->
<p><span class="caption">リスト8-10: <code>enum</code>を定義して、一つのベクタに異なる型の値を保持する</span></p>
<!-- Rust needs to know what types will be in the vector at compile time so it knows -->
<!-- exactly how much memory on the heap will be needed to store each element. A -->
<!-- secondary advantage is that we can be explicit about what types are allowed in -->
<!-- this vector. If Rust allowed a vector to hold any type, there would be a chance -->
<!-- that one or more of the types would cause errors with the operations performed -->
<!-- on the elements of the vector. Using an enum plus a `match` expression means -->
<!-- that Rust will ensure at compile time that every possible case is handled, as -->
<!-- discussed in Chapter 6. -->
<p>各要素を保持するのにヒープ上でズバリどれくらいのメモリが必要になるかをわかるように、
コンパイラがコンパイル時にベクタに入る型を知る必要があります。副次的な利点は、
このベクタではどんな型が許容されるのか明示できることです。もしRustでベクタがどんな型でも保持できたら、
ベクタの要素に対して行われる処理に対して一つ以上の型がエラーを引き起こす可能性があったでしょう。
enumに加えて<code>match</code>式を使うことは、第6章で議論した通り、コンパイル時にありうる場合全てに対処していることをコンパイラが、
確認できることを意味します。</p>
<!-- When you're writing a program, if you don’t know the exhaustive set of types -->
<!-- the program will get at runtime to store in a vector, the enum technique won’t -->
<!-- work. Instead, you can use a trait object, which we’ll cover in Chapter 17. -->
<p>プログラム記述時にプログラムがベクタに実行時に保持するありとあらゆる一連の型をプログラマが知らない場合、
このenumテクニックはうまく動かないでしょう。代わりにトレイトオブジェクトを使用することができ、こちらは第17章で解説します。</p>
<!-- Now that we’ve discussed some of the most common ways to use vectors, be sure -->
<!-- to review the API documentation for all the many useful methods defined on -->
<!-- `Vec<T>` by the standard library. For example, in addition to `push`, a `pop` -->
<!-- method removes and returns the last element. Let’s move on to the next -->
<!-- collection type: `String`! -->
<p>今や、ベクタを使用するべきありふれた方法について議論したので、標準ライブラリで<code>Vec&lt;T&gt;</code>に定義されている多くの有益なメソッドについては、
APIドキュメントを確認することを心得てください。例として、<code>push</code>に加えて、<code>pop</code>メソッドは最後の要素を削除して返します。
次のコレクション型に移りましょう: <code>String</code>です！</p>
<!-- ## Storing UTF-8 Encoded Text with Strings -->
<a class="header" href="print.html#a文字列でutf-8でエンコードされたテキストを保持する" id="a文字列でutf-8でエンコードされたテキストを保持する"><h2>文字列でUTF-8でエンコードされたテキストを保持する</h2></a>
<!-- We talked about strings in Chapter 4, but we’ll look at them in more depth now. -->
<!-- New Rustaceans commonly get stuck on strings for a combination of three -->
<!-- concepts: Rust’s propensity for exposing possible errors, strings being a more -->
<!-- complicated data structure than many programmers give them credit for, and -->
<!-- UTF-8. These factors combine in a way that can seem difficult when you’re -->
<!-- coming from other programming languages. -->
<p>第4章で文字列について語りましたが、今度はより掘り下げていきましょう。新参者のRustaceanは、
3つの概念の組み合わせにより、文字列でよく行き詰まります: Rustのありうるエラーを晒す性質、
多くのプログラマが思っている以上に文字列が複雑なデータ構造であること、そしてUTF-8です。
これらの要因が、他のプログラミング言語から移ってきた場合、一見困難に見えるように絡み合うわけです。</p>
<!-- It's useful to discuss strings in the context of collections because strings -->
<!-- are implemented as a collection of bytes, plus some methods to provide useful -->
<!-- functionality when those bytes are interpreted as text. In this section, we’ll -->
<!-- talk about the operations on `String` that every collection type has, such as -->
<!-- creating, updating, and reading. We’ll also discuss the ways in which `String` -->
<!-- is different from the other collections, namely how indexing into a `String` is -->
<!-- complicated by the differences between how people and computers interpret -->
<!-- `String` data. -->
<p>コレクションの文脈で文字列を議論することは、有用なことです。なぜなら、文字列はテキストとして解釈された時に有用になる機能を提供するメソッドと、
バイトの塊で実装されているからです。この節では、生成、更新、読み込みのような全コレクションが持つ<code>String</code>の処理について語ります。
また、<code>String</code>が他のコレクションと異なる点についても議論します。具体的には、人間とコンピュータが<code>String</code>データを解釈する方法の差異により、
<code>String</code>に添え字アクセスする方法がどう複雑なのかということです。</p>
<!-- ### What Is a String? -->
<a class="header" href="print.html#a文字列とは" id="a文字列とは"><h3>文字列とは？</h3></a>
<!-- We’ll first define what we mean by the term *string*. Rust has only one string -->
<!-- type in the core language, which is the string slice `str` that is usually seen -->
<!-- in its borrowed form `&str`. In Chapter 4, we talked about *string slices*, -->
<!-- which are references to some UTF-8 encoded string data stored elsewhere. String -->
<!-- literals, for example, are stored in the binary output of the program and are -->
<!-- therefore string slices. -->
<p>まずは、<em>文字列</em>という用語の意味を定義しましょう。Rustには、言語の核として1種類しか文字列型を持ちません。
文字列スライスの<code>str</code>で、通常借用された形態<code>&amp;str</code>で見かけます。第4章で、<em>文字列スライス</em>について語りました。
これは、別の場所に保持されたUTF-8エンコードされた文字列データへの参照です。例えば、文字列リテラルは、
プログラムのバイナリ出力に保持されるので、文字列スライスになります。</p>
<!-- The `String` type, which is provided in Rust’s standard library rather than -->
<!-- coded into the core language, is a growable, mutable, owned, UTF-8 encoded -->
<!-- string type. When Rustaceans refer to “strings” in Rust, they usually mean the -->
<!-- `String` and the string slice `&str` types, not just one of those types. -->
<!-- Although this section is largely about `String`, both types are used heavily in -->
<!-- Rust's standard library, and both `String` and string slices are UTF-8 encoded. -->
<p><code>String</code>型は、言語の核として組み込まれるのではなく、Rustの標準ライブラリで提供されますが、伸長可能、
可変、所有権のあるUTF-8エンコードされた文字列型です。RustaceanがRustにおいて「文字列」を指したら、
どちらかではなく、<code>String</code>と文字列スライスの<code>&amp;str</code>のことを通常意味します。この節は、大方、
<code>String</code>についてですが、どちらの型もRustの標準ライブラリで重宝されており、
どちらもUTF-8エンコードされています。</p>
<!-- Rust’s standard library also includes a number of other string types, such as -->
<!-- `OsString`, `OsStr`, `CString`, and `CStr`. Library crates can provide even -->
<!-- more options for storing string data. See how those names all end in `String` -->
<!-- or `Str`? They refer to owned and borrowed variant, just like the `String` and -->
<!-- `str` types you've seen previously. These string types can store text in -->
<!-- different encodings or be represented in memory in a different way, for -->
<!-- example. We won’t discuss these other string types in this chapter; see their -->
<!-- API documentation for more about how to use them and when each is appropriate. -->
<p>また、Rustの標準ライブラリには、他の文字列型も含まれています。<code>OsString</code>、<code>OsStr</code>、<code>CString</code>、<code>CStr</code>などです。
ライブラリクレートにより、文字列データを保持する選択肢はさらに増えます。
それらの名前が全て<code>String</code>か<code>Str</code>で終わっているのがわかりますか？所有権ありと借用されたバージョンを指しているのです。
ちょうど以前見かけた<code>String</code>と<code>&amp;str</code>のようですね。例えば、これらの文字列型は、異なるエンコード方法でテキストを保持していたり、
メモリ上の表現が異なったりします。この章では、これらの他の種類の文字列については議論しません;
使用方法やどれが最適かについては、APIドキュメントを参照してください。</p>
<!-- ### Creating a New String -->
<a class="header" href="print.html#a新規文字列を生成する" id="a新規文字列を生成する"><h3>新規文字列を生成する</h3></a>
<!-- Many of the same operations available with `Vec<T>` are available with `String` -->
<!-- as well, starting with the `new` function to create a string, shown in Listing -->
<!-- 8-11. -->
<p><code>Vec&lt;T&gt;</code>で使用可能な処理の多くが<code>String</code>でも使用できます。文字列を生成する<code>new</code>関数から始めましょうか。
リスト8-11に示したようにですね。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-11: Creating a new, empty `String`</span> -->
<p><span class="caption">リスト8-11: 新しい空の<code>String</code>を生成する</span></p>
<!-- This line creates a new empty string called `s`, which we can then load data -->
<!-- into. Often, we’ll have some initial data that we want to start the string -->
<!-- with. For that, we use the `to_string` method, which is available on any type -->
<!-- that implements the `Display` trait, as string literals do. Listing 8-12 shows -->
<!-- two examples. -->
<p>この行は、新しい空の<code>s</code>という文字列を生成しています。それからここにデータを読み込むことができるわけです。
だいたい、文字列の初期値を決めるデータがあるでしょう。そのために、<code>to_string</code>メソッドを使用します。
このメソッドは、文字列リテラルがしているように、<code>Display</code>トレイトを実装する型ならなんでも使用できます。
リスト8-12に2例、示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// the method also works on a literal directly:
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-12: Using the `to_string` method to create a -->
<!-- `String` from a string literal</span> -->
<p><span class="caption">リスト8-12: <code>to_string</code>メソッドを使用して文字列リテラルから<code>String</code>を生成する</span></p>
<!-- This code creates a string containing `initial contents`. -->
<p>このコードは、<code>initial contents</code>(初期値)を含む文字列を生成します。</p>
<!-- We can also use the function `String::from` to create a `String` from a string -->
<!-- literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 -->
<!-- that uses `to_string`. -->
<p>さらに、<code>String::from</code>関数を使っても、文字列リテラルから<code>String</code>を生成することができます。
リスト8-11のコードは、<code>to_string</code>を使用するリスト8-10のコードと等価です。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-13: Using the `String::from` function to create -->
<!-- a `String` from a string literal</span> -->
<p><span class="caption">リスト8-13: <code>String::from</code>関数を使って文字列リテラルから<code>String</code>を作る</span></p>
<!-- Because strings are used for so many things, we can use many different generic -->
<!-- APIs for strings, providing us with a lot of options. Some of them can seem -->
<!-- redundant, but they all have their place! In this case, `String::from` and -->
<!-- `to_string` do the same thing, so which you choose is a matter of style. -->
<p>文字列は、非常に多くのものに使用されるので、多くの異なる一般的なAPIを使用でき、たくさんの選択肢があるわけです。
冗長に思われるものもありますが、適材適所です！今回の場合、<code>String::from</code>と<code>to_string</code>は全く同じことをします。
従って、どちらを選ぶかは、スタイル次第です。</p>
<!-- Remember that strings are UTF-8 encoded, so we can include any properly encoded -->
<!-- data in them, as shown in Listing 8-14. -->
<p>文字列はUTF-8エンコードされていることを覚えていますか？要するに文字列には、適切にエンコードされていればどんなものでも含めます。
リスト8-14に示したように。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-14: Storing greetings in different languages in -->
<!-- strings</span> -->
<p><span class="caption">リスト8-14: いろんな言語の挨拶を文字列に保持する</span></p>
<!-- All of these are valid `String` values. -->
<p>これらは全て、有効な<code>String</code>の値です。</p>
<!-- ### Updating a String -->
<a class="header" href="print.html#a文字列を更新する" id="a文字列を更新する"><h3>文字列を更新する</h3></a>
<!-- A `String` can grow in size and its contents can change, just like the contents -->
<!-- of a `Vec<T>`, if you push more data into it. In addition, we can conveniently -->
<!-- use the `+` operator or the `format!` macro to concatenate `String` values. -->
<p><code>String</code>は、サイズを伸ばすことができ、中身も変化します。追加のデータをプッシュすれば、<code>Vec&lt;T&gt;</code>の中身のようですね。
付け加えると、<code>String</code>値を連結する<code>+</code>演算子や、<code>format!</code>マクロを便利に使用することができます。</p>
<!-- #### Appending to a String with `push_str` and `push` -->
<a class="header" href="print.html#push_strとpushで文字列に追加する" id="push_strとpushで文字列に追加する"><h4><code>push_str</code>と<code>push</code>で文字列に追加する</h4></a>
<!-- We can grow a `String` by using the `push_str` method to append a string slice, -->
<!-- as shown in Listing 8-15. -->
<p><code>push_str</code>メソッドで文字列スライスを追記することで、<code>String</code>を伸ばすことができます。
リスト8-15の通りです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-15: Appending a string slice to a `String` -->
<!-- using the `push_str` method</span> -->
<p><span class="caption">リスト8-15: <code>push_str</code>メソッドで<code>String</code>に文字列スライスを追記する</span></p>
<!-- After these two lines, `s` will contain `foobar`. The `push_str` method takes a -->
<!-- string slice because we don’t necessarily want to take ownership of the -->
<!-- parameter. For example, the code in Listing 8-16 shows that it would be -->
<!-- unfortunate if we weren’t able to use `s2` after appending its contents to `s1`. -->
<p>この2行の後、<code>s</code>は<code>foobar</code>を含むことになります。<code>push_str</code>メソッドは、必ずしも引数の所有権を得なくていいので、
文字列スライスを取ります。例えば、リスト8-16のコードは、中身を<code>s1</code>に追加した後、
<code>s2</code>を使えなかったら不幸だということを示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 is {}&quot;, s2);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-16: Using a string slice after appending its -->
<!-- contents to a `String`</span> -->
<p><span class="caption">リスト8-16: 中身を<code>String</code>に追加した後に、文字列スライスを使用する</span></p>
<!-- If the `push_str` method took ownership of `s2`, we wouldn’t be able to print -->
<!-- its value on the last line. However, this code works as we’d expect! -->
<p>もし、<code>push_str</code>メソッドが<code>s2</code>の所有権を奪っていたら、最後の行でその値を出力することは不可能でしょう。
ところが、このコードは予想通りに動きます！</p>
<!-- The `push` method takes a single character as a parameter and adds it to the -->
<!-- `String`. Listing 8-17 shows code that adds the letter *l* to a `String` using -->
<!-- the `push` method. -->
<p><code>push</code>メソッドは、1文字を引数として取り、<code>String</code>に追加します。リスト8-15は、
<code>push</code>メソッドで<em>l</em>を<code>String</code>に追加するコードを呈示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-17: Adding one character to a `String` value -->
<!-- using `push`</span> -->
<p><span class="caption">リスト8-17: <code>push</code>で<code>String</code>値に1文字を追加する</span></p>
<!-- As a result of this code, `s` will contain `lol`. -->
<p>このコードの結果、<code>s</code>は<code>lol</code>を含むことになるでしょう。</p>
<blockquote>
<p>編者注: <code>lol</code>は<code>laughing out loud</code>(大笑いする)の頭文字からできたスラングです。
日本語の<code>www</code>みたいなものですね。</p>
</blockquote>
<!-- #### Concatenation with the `+` Operator or the `format!` Macro -->
<a class="header" href="print.html#a演算子またはformatマクロで連結" id="a演算子またはformatマクロで連結"><h4><code>+</code>演算子、または<code>format!</code>マクロで連結</h4></a>
<!-- Often, you’ll want to combine two existing strings. One way is to use the `+` -->
<!-- operator, as shown in Listing 8-18. -->
<p>2つのすでにある文字列を組み合わせたくなることがよくあります。リスト8-18に示したように、
一つ目の方法は、<code>+</code>演算子を使用することです。</p>
<!-- ```rust -->
<!-- let s1 = String::from("Hello, "); -->
<!-- let s2 = String::from("world!"); -->
<!-- let s3 = s1 + &s2; // note that s1 has been moved here and can no longer be used -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // s1はムーブされ、もう使用できないことに注意
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-18: Using the `+` operator to combine two -->
<!-- `String` values into a new `String` value</span> -->
<p><span class="caption">リスト8-18: <code>+</code>演算子を使用して二つの<code>String</code>値を新しい<code>String</code>値にする</span></p>
<!-- The string `s3` will contain `Hello, world!` as a result of this code. The -->
<!-- reason `s1` is no longer valid after the addition and the reason we used a -->
<!-- reference to `s2` has to do with the signature of the method that gets called -->
<!-- when we use the `+` operator. The `+` operator uses the `add` method, whose -->
<!-- signature looks something like this: -->
<p>このコードの結果、<code>s3</code>という文字列は、<code>Hello, world!</code>を含むことになるでしょう。
追記の後、<code>s1</code>がもう有効でなくなった理由と、<code>s2</code>への参照を使用した理由は、
<code>+</code>演算子を使用した時に呼ばれるメソッドのシグニチャと関係があります。<code>+</code>演算子は、<code>add</code>メソッドを使用し、
そのシグニチャは以下のような感じです:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<!-- This isn’t the exact signature that’s in the standard library: in the standard -->
<!-- library, `add` is defined using generics. Here, we’re looking at the signature -->
<!-- of `add` with concrete types substituted for the generic ones, which is what -->
<!-- happens when we call this method with `String` values. We’ll discuss generics -->
<!-- in Chapter 10. This signature gives us the clues we need to understand the -->
<!-- tricky bits of the `+` operator. -->
<p>これは、標準ライブラリにあるシグニチャそのものではありません: 標準ライブラリでは、<code>add</code>はジェネリクスで定義されています。
ここでは、ジェネリックな型を具体的な型に置き換えた<code>add</code>のシグニチャを見ており、これは、
このメソッドを<code>String</code>値とともに呼び出した時に起こることです。ジェネリクスについては、第10章で議論します。
このシグニチャが、<code>+</code>演算子の巧妙な部分を理解するのに必要な手がかりになるのです。</p>
<!-- First, `s2` has an `&`, meaning that we’re adding a *reference* of the second -->
<!-- string to the first string because of the `s` parameter in the `add` function: -->
<!-- we can only add a `&str` to a `String`; we can’t add two `String` values -->
<!-- together. But wait-the type of `&s2` is `&String`, not `&str`, as specified in -->
<!-- the second parameter to `add`. So why does Listing 8-18 compile? -->
<p>まず、<code>s2</code>には<code>&amp;</code>がついてます。つまり、<code>add</code>関数の<code>s</code>引数のために最初の文字列に2番目の文字列の参照を追加するということです:
<code>String</code>には<code>&amp;str</code>を追加することしかできません。要するに2つの<code>String</code>値を追加することはできないのです。
でも待ってください。<code>add</code>の第2引数で指定されているように、<code>&amp;s2</code>の型は、<code>&amp;str</code>ではなく、
<code>&amp;String</code>ではないですか。では、なぜ、リスト8-18は、コンパイルできるのでしょうか？</p>
<!-- The reason we’re able to use `&s2` in the call to `add` is that the compiler -->
<!-- can *coerce* the `&String` argument into a `&str`. When we call the `add` -->
<!-- method, Rust uses a *deref coercion*, which here turns `&s2` into `&s2[..]`. -->
<!-- We’ll discuss deref coercion in more depth in Chapter 15. Because `add` does -->
<!-- not take ownership of the `s` parameter, `s2` will still be a valid `String` -->
<!-- after this operation. -->
<p><code>add</code>呼び出しで<code>&amp;s2</code>を使える理由は、コンパイラが<code>&amp;String</code>引数を<code>&amp;str</code>に<em>型強制</em>してくれるためです。
<code>add</code>メソッド呼び出しの際、コンパイラは、<em>参照外し型強制</em>というものを使用し、ここでは、
<code>&amp;s2</code>を<code>&amp;s2[..]</code>に変えるものと考えることができます。参照外し型強制について詳しくは、第15章で議論します。
<code>add</code>が<code>s</code>引数の所有権を奪わないので、この処理後も<code>s2</code>が有効な<code>String</code>になるわけです。</p>
<!-- Second, we can see in the signature that `add` takes ownership of `self`, -->
<!-- because `self` does *not* have an `&`. This means `s1` in Listing 8-18 will be -->
<!-- moved into the `add` call and no longer be valid after that. So although `let -->
<!-- s3 = s1 + &s2;` looks like it will copy both strings and create a new one, this -->
<!-- statement actually takes ownership of `s1`, appends a copy of the contents of -->
<!-- `s2`, and then returns ownership of the result. In other words, it looks like -->
<!-- it’s making a lot of copies but isn’t; the implementation is more efficient -->
<!-- than copying. -->
<p>2番目に、シグニチャから<code>add</code>は<code>self</code>の所有権をもらうことがわかります。<code>self</code>には<code>&amp;</code>がついてい<em>ない</em>からです。
これはつまり、リスト8-18において<code>s1</code>は<code>add</code>呼び出しにムーブされ、その後は有効ではなくなるということです。
故に、<code>s3 = s1 + &amp;s2;</code>は両文字列をコピーして新しいものを作るように見えますが、
この文は実際には<code>s1</code>の所有権を奪い、<code>s2</code>の中身のコピーを追記し、結果の所有権を返すのです。言い換えると、
たくさんのコピーをしているように見えますが、違います; 実装は、コピーよりも効率的です。</p>
<!-- If we need to concatenate multiple strings, the behavior of `+` operator -->
<!-- gets unwieldy: -->
<p>複数の文字列を連結する必要が出ると、<code>+</code>演算子の振る舞いは扱いにくくなります:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<!-- At this point, `s` will be `tic-tac-toe`. With all of the `+` and `"` -->
<!-- characters, it’s difficult to see what’s going on. For more complicated string -->
<!-- combining, we can use the `format!` macro: -->
<p>ここで、<code>s</code>は<code>tic-tac-toe</code>になるでしょう。<code>+</code>と<code>&quot;</code>文字のせいで何が起きているのかわかりにくいです。
もっと複雑な文字列の連結には、<code>format!</code>マクロを使用することができます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<!-- This code also sets `s` to `tic-tac-toe`. The `format!` macro works in the same -->
<!-- way as `println!`, but instead of printing the output to the screen, it returns -->
<!-- a `String` with the contents. The version of the code using `format!` is much -->
<!-- easier to read and doesn’t take ownership of any of its parameters. -->
<p>このコードでも、<code>s</code>は<code>tic-tac-toe</code>になります。<code>format!</code>マクロは、<code>println!</code>と同様の動作をしますが、
出力をスクリーンに行う代わりに、中身を<code>String</code>で返すのです。<code>format!</code>を使用したコードの方がはるかに読みやすく、
引数の所有権を奪いません。</p>
<!-- ### Indexing into Strings -->
<a class="header" href="print.html#a文字列に添え字アクセスする" id="a文字列に添え字アクセスする"><h3>文字列に添え字アクセスする</h3></a>
<!-- In many other programming languages, accessing individual characters in a -->
<!-- string by referencing them by index is a valid and common operation. However, -->
<!-- if you try to access parts of a `String` using indexing syntax in Rust, you’ll -->
<!-- get an error. Consider the invalid code in Listing 8-19. -->
<p>他の多くのプログラミング言語では、文字列中の文字に、番号で参照してアクセスすることは、有効なコードであり、
一般的な処理です。しかしながら、Rustにおいて、添え字記法で<code>String</code>の一部にアクセスしようとすると、
エラーが発生するでしょう。リスト8-19の非合法なコードを考えてください。</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<!-- <span class="caption">Listing 8-19: Attempting to use indexing syntax with a -->
<!-- String</span> -->
<p><span class="caption">リスト8-19: 文字列に対して添え字記法を試みる</span></p>
<!-- This code will result in the following error: -->
<p>このコードは、以下のようなエラーに落ち着きます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;{Integer}&gt;` is not satisfied
(エラー: トレイト境界`std::string::String: std::ops::Index&lt;{Integer}&gt;`が満たされていません)
  |&gt;
3 |&gt;     let h = s1[0];
  |&gt;             ^^^^^ the type `std::string::String` cannot be indexed by `{Integer}`
  |&gt;                   (型`std::string::String`は`{Integer}`で添え字アクセスできません)
  = help: the trait `std::ops::Index&lt;{Integer}&gt;` is not implemented for `std::string::String`
  (ヘルプ: `std::ops::Index&lt;{Integer}&gt;`というトレイトが`std::string::String`に対して実装されていません)
</code></pre>
<!-- The error and the note tell the story: Rust strings don’t support indexing. But -->
<!-- why not? To answer that question, we need to discuss how Rust stores strings in -->
<!-- memory. -->
<p>エラーと注釈が全てを物語っています: Rustの文字列は、添え字アクセスをサポートしていないのです。
でも、なぜでしょうか？その疑問に答えるには、Rustがメモリにどのように文字列を保持しているかについて議論する必要があります。</p>
<!-- #### Internal Representation -->
<a class="header" href="print.html#a内部表現" id="a内部表現"><h4>内部表現</h4></a>
<!-- A `String` is a wrapper over a `Vec<u8>`. Let’s look at some of our properly -->
<!-- encoded UTF-8 example strings from Listing 8-14. First, this one: -->
<p><code>String</code>は<code>Vec&lt;u8&gt;</code>のラッパです。リスト8-14から適切にUTF-8でエンコードされた文字列の例をご覧ください。
まずは、これ:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<!-- In this case, `len` will be 4, which means the vector storing the string “Hola” -->
<!-- is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But -->
<!-- what about the following line? (Note that this string begins with the capital -->
<!-- Cyrillic letter Ze, not the Arabic number 3.) -->
<p>この場合、<code>len</code>は4になり、これは、文字列&quot;Hola&quot;を保持するベクタの長さが4バイトであることを意味します。
これらの各文字は、UTF-8でエンコードすると、1バイトになるのです。しかし、以下の行ではどうでしょうか？
(この文字列は大文字のキリル文字Zeで始まり、アラビア数字の3では始まっていないことに注意してください)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Здравствуйте&quot;).len();
#}</code></pre></pre>
<!-- Asked how long the string is, you might say 12. However, Rust’s answer is 24: -->
<!-- that’s the number of bytes it takes to encode “Здравствуйте” in UTF-8, because -->
<!-- each Unicode scalar value takes two bytes of storage. Therefore, an index into -->
<!--  the string’s bytes will not always correlate to a valid Unicode scalar value. -->
<!-- To demonstrate, consider this invalid Rust code: -->
<p>文字列の長さはと問われたら、あなたは12と答えるかもしれません。ところが、Rustの答えは、24です:
“Здравствуйте”をUTF-8でエンコードすると、この長さになります。各Unicodeスカラー値は、2バイトの領域を取るからです。
それ故に、文字列のバイト番号は、必ずしも有効なUnicodeのスカラー値とは相互に関係しないのです。
デモ用に、こんな無効なRustコードを考えてください:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<!-- What should the value of `answer` be? Should it be `З`, the first letter? When -->
<!-- encoded in UTF-8, the first byte of `З` is `208`, and the second is `151`, so -->
<!-- `answer` should in fact be `208`, but `208` is not a valid character on its -->
<!-- own. Returning `208` is likely not what a user would want if they asked for the -->
<!-- first letter of this string; however, that’s the only data that Rust has at -->
<!-- byte index 0. Users generally don't want the byte value returned, even if -->
<!-- the string contains only Latin letters: if `&"hello"[0]` was valid code that -->
<!-- returned the byte value, it would return `104`, not `h`. To avoid returning an -->
<!-- unexpected value and causing bugs that might not be discovered immediately, -->
<!-- Rust doesn’t compile this code at all and prevents misunderstandings early in -->
<!-- the development process. -->
<p><code>answer</code>の値は何になるべきでしょうか？最初の文字の<code>З</code>になるべきでしょうか？UTF-8エンコードされた時、
<code>З</code>の最初のバイトは<code>208</code>、2番目は<code>151</code>になるので、<code>answer</code>は実際、<code>208</code>になるべきですが、
<code>208</code>は単独では有効な文字ではありません。この文字列の最初の文字を求めている場合、<code>208</code>を返すことは、
ユーザの望んでいるものではないでしょう; しかしながら、Rustには、番号0の位置には、そのデータしかないのです。
文字列がラテン文字のみを含む場合でも、ユーザは一般的にバイト値が返ることを望みません:
<code>&amp;&quot;hello&quot;[0]</code>がバイト値を返す有効なコードだったら、<code>h</code>ではなく、<code>104</code>を返すでしょう。
予期しない値を返し、すぐには判明しないバグを引き起こさないために、Rustはこのコードを全くコンパイルせず、
開発過程の早い段階で誤解を防いでくれるのです。</p>
<!-- #### Bytes and Scalar Values and Grapheme Clusters! Oh My! -->
<a class="header" href="print.html#aバイトとスカラー値と書記素クラスタなんてこった" id="aバイトとスカラー値と書記素クラスタなんてこった"><h4>バイトとスカラー値と書記素クラスタ！なんてこった！</h4></a>
<!-- Another point about UTF-8 is that there are actually three relevant ways to -->
<!-- look at strings from Rust’s perspective: as bytes, scalar values, and grapheme -->
<!-- clusters (the closest thing to what we would call *letters*). -->
<p>UTF-8について別の要点は、実際Rustの観点から文字列を見るには3つの関連した方法があるということです:
バイトとして、スカラー値として、そして、書記素クラスタ(人間が<em>文字</em>と呼ぶものに一番近い)としてです。</p>
<!-- If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is -->
<!-- stored as a vector of `u8` values that looks like this: -->
<p>ヒンディー語の単語、“नमस्ते”をデーヴァナーガリー(<code>訳注</code>: サンスクリット語とヒンディー語を書くときに使われる書記法)で表記したものを見たら、
以下のような見た目の<code>u8</code>値のベクタとして保持されます:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<!-- That’s 18 bytes and is how computers ultimately store this data. If we look at -->
<!-- them as Unicode scalar values, which are what Rust’s `char` type is, those -->
<!-- bytes look like this: -->
<p>18バイトになり、このようにしてコンピュータは最終的にこのデータを保持しているわけです。これをUnicodeスカラー値として見たら、
Rustの<code>char</code>型はこれなのですが、このバイトは以下のような見た目になります:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<!-- There are six `char` values here, but the fourth and sixth are not letters: -->
<!-- they’re diacritics that don’t make sense on their own. Finally, if we look at -->
<!-- them as grapheme clusters, we’d get what a person would call the four letters -->
<!-- that make up the Hindi word: -->
<p>ここでは、6つ<code>char</code>値がありますが、4番目と6番目は文字ではありません: 単独では意味をなさないダイアクリティックです。
最後に、書記素クラスタとして見たら、このヒンディー語の単語を作り上げる人間が4文字と呼ぶであろうものが得られます:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<!-- Rust provides different ways of interpreting the raw string data that computers -->
<!-- store so that each program can choose the interpretation it needs, no matter -->
<!-- what human language the data is in. -->
<p>Rustには、データが表す自然言語に関わらず、各プログラムが必要な解釈方法を選択できるように、
コンピュータが保持する生の文字列データを解釈する方法がいろいろ用意されています。</p>
<!-- A final reason Rust doesn’t allow us to index into a `String` to get a -->
<!-- character is that indexing operations are expected to always take constant time -->
<!-- (O(1)). But it isn’t possible to guarantee that performance with a `String`, -->
<!-- because Rust would have to walk through the contents from the beginning to the -->
<!-- index to determine how many valid characters there were. -->
<p>Rustで文字を得るのに<code>String</code>に添え字アクセスすることが許されない最後の理由は、
添え字アクセスという処理が常に定数時間(O(1))になると期待されるからです。
しかし、<code>String</code>でそのパフォーマンスを保証することはできません。というのも、
有効な文字がいくつあるか決定するのに、最初から番号まで中身を走査する必要があるからです。</p>
<!-- ### Slicing Strings -->
<a class="header" href="print.html#a文字列をスライスする" id="a文字列をスライスする"><h3>文字列をスライスする</h3></a>
<!-- Indexing into a string is often a bad idea because it’s not clear what the -->
<!-- return type of the string indexing operation should be: a byte value, a -->
<!-- character, a grapheme cluster, or a string slice. Therefore, Rust asks you to -->
<!-- be more specific if you really need to use indices to create string slices. To -->
<!-- be more specific in your indexing and indicate that you want a string slice, -->
<!-- rather than indexing using `[]` with a single number, you can use `[]` with a -->
<!-- range to create a string slice containing particular bytes: -->
<p>文字列に添え字アクセスするのは、しばしば悪い考えです。文字列添え字処理の戻り値の型が明瞭ではないからです:
バイト値、文字、書記素クラスタ、あるいは文字列スライスにもなります。故に、文字列スライスを生成するのに、
添え字を使う必要が本当に出た場合にコンパイラは、もっと特定するよう求めてきます。添え字アクセスを特定し、
文字列スライスが欲しいと示唆するためには、<code>[]</code>で1つの数値により添え字アクセスするのではなく、
範囲とともに<code>[]</code>を使って、特定のバイトを含む文字列スライスを作ることができます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<!-- Here, `s` will be a `&str` that contains the first 4 bytes of the string. -->
<!-- Earlier, we mentioned that each of these characters was 2 bytes, which means -->
<!-- `s` will be `Зд`. -->
<p>ここで、<code>s</code>は文字列の最初の4バイトを含む<code>&amp;str</code>になります。先ほど、これらの文字は各々2バイトになると指摘しましたから、
<code>s</code>は<code>Зд</code>になります。</p>
<!-- What would happen if we used `&hello[0..1]`? The answer: Rust would panic at -->
<!-- runtime in the same way as if an invalid index were accessed in a vector: -->
<p><code>&amp;hello[0..1]</code>と使用したら、何が起きるでしょうか？答え: Rustはベクタの無効な番号にアクセスしたかのように、
実行時にパニックするでしょう:</p>
<pre><code class="language-text">thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
('main'スレッドは「バイト番号1は文字の境界ではありません; `Здравствуйте`の'З'(バイト番号0から2)の中です」でパニックしました)
</code></pre>
<!-- You should use ranges to create string slices with caution, because doing so -->
<!-- can crash your program. -->
<p>範囲を使用して文字列スライスを作る際にはプログラムをクラッシュさせることがあるので、気をつけるべきです。</p>
<!-- ### Methods for Iterating Over Strings -->
<a class="header" href="print.html#a文字列を走査するメソッド群" id="a文字列を走査するメソッド群"><h3>文字列を走査するメソッド群</h3></a>
<!-- Fortunately, you can access elements in a string in other ways. -->
<p>幸いなことに、他の方法でも文字列の要素にアクセスすることができます。</p>
<!-- If you need to perform operations on individual Unicode scalar values, the best -->
<!-- way to do so is to use the `chars` method. Calling `chars` on “नमस्ते” separates -->
<!-- out and returns six values of type `char`, and you can iterate over the result -->
<!-- to access each element: -->
<p>もし、個々のUnicodeスカラー値に対して処理を行う必要があったら、最適な方法は<code>chars</code>メソッドを使用するものです。
“नमस्ते”に対して<code>chars</code>を呼び出したら、分解して6つの<code>char</code>型の値を返すので、各要素にアクセスするには、
その結果を走査すればいいわけです:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<!-- This code will print the following: -->
<p>このコードは、以下のように出力します:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<!-- The `bytes` method returns each raw byte, which might be appropriate for your -->
<!-- domain: -->
<p><code>bytes</code>メソッドは、各バイトをそのまま返すので、最適になることもあるかもしれません:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<!-- This code will print the 18 bytes that make up this `String`: -->
<p>このコードは、<code>String</code>をなす18バイトを出力します:</p>
<pre><code class="language-text">224
164
// --snip--
165
135
</code></pre>
<!-- But be sure to remember that valid Unicode scalar values may be made up of more -->
<!-- than 1 byte. -->
<p>ですが、有効なUnicodeスカラー値は、2バイト以上からなる場合もあることは心得ておいてください。</p>
<!-- Getting grapheme clusters from strings is complex, so this functionality is not -->
<!-- provided by the standard library. Crates are available on -->
<!-- [crates.io](https://crates.io) if this is the functionality you need. -->
<p>書記素クラスタを文字列から得る方法は複雑なので、この機能は標準ライブラリでは提供されていません。
この機能が必要なら、<a href="https://crates.io">crates.io</a>でクレートを入手可能です。</p>
<!-- ### Strings Are Not So Simple -->
<a class="header" href="print.html#a文字列はそう単純じゃない" id="a文字列はそう単純じゃない"><h3>文字列はそう単純じゃない</h3></a>
<!-- To summarize, strings are complicated. Different programming languages make -->
<!-- different choices about how to present this complexity to the programmer. Rust -->
<!-- has chosen to make the correct handling of `String` data the default behavior -->
<!-- for all Rust programs, which means programmers have to put more thought into -->
<!-- handling UTF-8 data upfront. This trade-off exposes more of the complexity of -->
<!-- strings than is apparent in other programming languages, but it prevents you -->
<!-- from having to handle errors involving non-ASCII characters later in your -->
<!-- development life cycle. -->
<p>まとめると、文字列は込み入っています。プログラミング言語ごとにこの複雑性をプログラマに提示する方法は違います。
Rustでは、<code>String</code>データを正しく扱うことが、全てのRustプログラムにとっての規定動作になっているわけであり、
これは、プログラマがUTF-8データを素直に扱う際に、より思考しないといけないことを意味します。
このトレードオフにより、他のプログラミング言語で見えるよりも文字列の複雑性がより露出していますが、
ASCII以外の文字に関するエラーを開発の後半で扱わなければならない可能性が排除されているのです。</p>
<!-- Let’s switch to something a bit less complex: hash maps! -->
<p>もう少し複雑でないものに切り替えていきましょう: ハッシュマップです！</p>
<!-- ## Storing Keys Associated with Values in Hash Maps -->
<a class="header" href="print.html#aハッシュマップに値に紐づいたキーを格納する" id="aハッシュマップに値に紐づいたキーを格納する"><h2>ハッシュマップに値に紐づいたキーを格納する</h2></a>
<!-- The last of our common collections is the *hash map*. The type `HashMap<K, V>` -->
<!-- stores a mapping of keys of type `K` to values of type `V`. It does this via a -->
<!-- *hashing function*, which determines how it places these keys and values into -->
<!-- memory. Many programming languages support this kind of data structure, but -->
<!-- often use a different name, such as hash, map, object, hash table, or -->
<!-- associative array, just to name a few. -->
<p>一般的なコレクションのトリを飾るのは、<em>ハッシュマップ</em>です。型<code>HashMap&lt;K, V&gt;</code>は、
<code>K</code>型のキーと<code>V</code>型の値の対応関係を保持します。これを<em>ハッシュ関数</em>を介して行います。
ハッシュ関数は、キーと値のメモリ配置方法を決めるものです。多くのプログラミング言語でもこの種のデータ構造はサポートされていますが、
しばしば名前が違います。hash、map、object、ハッシュテーブル、連想配列など、枚挙に<ruby>暇<rp>(</rp><rt>いとま</rt><rp>)</rp>はありません。</p>
<!-- Hash maps are useful when you want to look up data not by an index, as -->
<!-- you can with vectors, but by using a key that can be of any type. For example, -->
<!-- in a game, you could keep track of each team’s score in a hash map in which -->
<!-- each key is a team’s name and the values are each team’s score. Given a team -->
<!-- name, you can retrieve its score. -->
<p>ハッシュマップは、ベクタで可能なように番号ではなく、どんな型にもなりうるキーを使ってデータを参照したいときに有用です。
例えば、ゲームにおいて、各チームのスコアをハッシュマップで追いかけることができます。ここで、各キーはチーム名、
値が各チームのスコアになります。チーム名が与えられれば、スコアを扱うことができるわけです。</p>
<!-- We’ll go over the basic API of hash maps in this section, but many more goodies -->
<!-- are hiding in the functions defined on `HashMap<K, V>` by the standard library. -->
<!-- As always, check the standard library documentation for more information. -->
<p>この節でマッシュマップの基礎的なAPIを見ていきますが、より多くのグッズが標準ライブラリにより、
<code>HashMap&lt;K, V&gt;</code>上に定義された関数に隠されています。いつものように、
もっと情報が欲しければ、標準ライブラリのドキュメントをチェックしてください。</p>
<!-- ### Creating a New Hash Map -->
<a class="header" href="print.html#a新規ハッシュマップを生成する" id="a新規ハッシュマップを生成する"><h3>新規ハッシュマップを生成する</h3></a>
<!-- You can create an empty hash map with `new` and add elements with `insert`. In -->
<!-- Listing 8-20, we’re keeping track of the scores of two teams whose names are -->
<!-- Blue and Yellow. The Blue team starts with 10 points, and the Yellow team -->
<!-- starts with 50. -->
<p>空のハッシュマップを<code>new</code>で作り、要素を<code>insert</code>で追加することができます。リスト8-20では、
名前がブルーとイエローの2チームのスコアを追いかけています。ブルーチームは10点から、イエローチームは50点から始まります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-20: Creating a new hash map and inserting some -->
<!-- keys and values</span> -->
<p><span class="caption">リスト8-20: ハッシュマップを生成してキーと値を挿入する</span></p>
<!-- Note that we need to first `use` the `HashMap` from the collections portion of -->
<!-- the standard library. Of our three common collections, this one is the least -->
<!-- often used, so it’s not included in the features brought into scope -->
<!-- automatically in the prelude. Hash maps also have less support from the -->
<!-- the standard library; there's no built-in macro to construct them, for example. -->
<p>最初に標準ライブラリのコレクション部分から<code>HashMap</code>を<code>use</code>する必要があることに注意してください。
今までの3つの一般的なコレクションの内、これが最も使用頻度が低いので、初期化処理で自動的にスコープに導入される機能には含まれていません。
また、標準ライブラリからのサポートもハッシュマップは少ないです; 例えば、生成するための組み込みマクロがありません。</p>
<!-- Just like vectors, hash maps store their data on the heap. This `HashMap` has -->
<!-- keys of type `String` and values of type `i32`. Like vectors, hash maps are -->
<!-- homogeneous: all of the keys must have the same type, and all of the values -->
<!-- must have the same type. -->
<p>ベクタと全く同様に、ハッシュマップはデータをヒープに保持します。この<code>HashMap</code>はキーが<code>String</code>型、
値は<code>i32</code>型です。ベクタのように、ハッシュマップは均質です: キーは全て同じ型でなければならず、
値も全て同じ型でなければなりません。</p>
<!-- Another way of constructing a hash map is by using the `collect` method on a -->
<!-- vector of tuples, where each tuple consists of a key and its value. The -->
<!-- `collect` method gathers data into a number of collection types, including -->
<!-- `HashMap`. For example, if we had the team names and initial scores in two -->
<!-- separate vectors, we can use the `zip` method to create a vector of tuples -->
<!-- where “Blue” is paired with 10, and so forth. Then we can use the `collect` -->
<!-- method to turn that vector of tuples into a hash map, as shown in Listing 8-21. -->
<p>ハッシュマップを生成する別の方法は、タプルのベクタに対して<code>collect</code>メソッドを使用するものです。
ここで、各タプルは、キーと値から構成されています。<code>collect</code>メソッドはいろんなコレクション型にデータをまとめ上げ、
そこには<code>HashMap</code>も含まれています。例として、チーム名と初期スコアが別々のベクタに含まれていたら、
<code>zip</code>メソッドを使ってタプルのベクタを作り上げることができ、そこでは「ブルー」は10とペアになるなどします。
リスト8-21に示したように、それから<code>collect</code>メソッドを使って、そのタプルのベクタをハッシュマップに変換することができるわけです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-21: Creating a hash map from a list of teams -->
<!-- and a list of scores</span> -->
<p><span class="caption">リスト8-21: チームのリストとスコアのリストからハッシュマップを作る</span></p>
<!-- The type annotation `HashMap<_, _>` is needed here because it’s possible to -->
<!-- `collect` into many different data structures and Rust doesn’t know which you -->
<!-- want unless you specify. For the type parameters for the key and value types, -->
<!-- however, we use underscores, and Rust can infer the types that the hash map -->
<!-- contains based on the types of the data in the vectors. -->
<p>ここでは、<code>HashMap&lt;_, _&gt;</code>という型注釈が必要になります。なぜなら、いろんなデータ構造に<code>まとめ上げる</code>ことができ、
コンパイラは指定しない限り、どれがいるのかわからないからです。ところが、キーと値の型引数については、
アンダースコアを使用しており、コンパイラはベクタのデータ型に基づいてハッシュマップが含む型を推論することができるのです。</p>
<!-- ### Hash Maps and Ownership -->
<a class="header" href="print.html#aハッシュマップと所有権" id="aハッシュマップと所有権"><h3>ハッシュマップと所有権</h3></a>
<!-- For types that implement the `Copy` trait, like `i32`, the values are copied -->
<!-- into the hash map. For owned values like `String`, the values will be moved and -->
<!-- the hash map will be the owner of those values, as demonstrated in Listing 8-22. -->
<p><code>i32</code>のような<code>Copy</code>トレイトを実装する型について、値はハッシュマップにコピーされます。
<code>String</code>のような所有権のある値なら、値はムーブされ、リスト8-22でデモされているように、
ハッシュマップはそれらの値の所有者になるでしょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
// field_nameとfield_valueはこの時点で無効になる。試しに使ってみて
// どんなコンパイルエラーが出るか確認してみて！
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-22: Showing that keys and values are owned by -->
<!-- the hash map once they’re inserted</span> -->
<p><span class="caption">リスト8-22: 一旦挿入されたら、キーと値はハッシュマップに所有されることを示す</span></p>
<!-- We aren’t able to use the variables `field_name` and `field_value` after -->
<!-- they’ve been moved into the hash map with the call to `insert`. -->
<p><code>insert</code>を呼び出して<code>field_name</code>と<code>field_value</code>がハッシュマップにムーブされた後は、
これらの変数を使用することは叶いません。</p>
<!-- If we insert references to values into the hash map, the values won’t be moved -->
<!-- into the hash map. The values that the references point to must be valid for at -->
<!-- least as long as the hash map is valid. We’ll talk more about these issues in -->
<!-- the “Validating References with Lifetimes” section in Chapter 10. -->
<p>値への参照をハッシュマップに挿入したら、値はハッシュマップにムーブされません。参照が指している値は、
最低でもハッシュマップが有効な間は、有効でなければなりません。これらの問題について詳細には、
第10章の「ライフタイムで参照を有効化する」節で語ります。</p>
<!-- ### Accessing Values in a Hash Map -->
<a class="header" href="print.html#aハッシュマップの値にアクセスする" id="aハッシュマップの値にアクセスする"><h3>ハッシュマップの値にアクセスする</h3></a>
<!-- We can get a value out of the hash map by providing its key to the `get` -->
<!-- method, as shown in Listing 8-23. -->
<p>リスト8-23に示したように、キーを<code>get</code>メソッドに提供することで、ハッシュマップから値を取り出すことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-23: Accessing the score for the Blue team -->
<!-- stored in the hash map</span> -->
<p><span class="caption">リスト8-23: ハッシュマップに保持されたブルーチームのスコアにアクセスする</span></p>
<!-- Here, `score` will have the value that’s associated with the Blue team, and the -->
<!-- result will be `Some(&10)`. The result is wrapped in `Some` because `get` -->
<!-- returns an `Option<&V>`; if there’s no value for that key in the hash map, -->
<!-- `get` will return `None`. The program will need to handle the `Option` in one -->
<!-- of the ways that we covered in Chapter 6. -->
<p>ここで、<code>score</code>はブルーチームに紐づけられた値になり、結果は<code>Some(&amp;10)</code>となるでしょう。
結果は<code>Some</code>に包まれます。というのも、<code>get</code>は<code>Option&lt;&amp;V&gt;</code>を返すからです; キーに対応する値がハッシュマップになかったら、
<code>get</code>は<code>None</code>を返すでしょう。プログラムは、この<code>Option</code>を第6章で解説した方法のどれかで扱う必要があるでしょう。</p>
<!-- We can iterate over each key/value pair in a hash map in a similar manner as we -->
<!-- do with vectors, using a `for` loop: -->
<p>ベクタのように、<code>for</code>ループでハッシュマップのキーと値のペアを走査することができます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<!-- This code will print each pair in an arbitrary order: -->
<p>このコードは、各ペアを任意の順番で出力します:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<!-- ### Updating a Hash Map -->
<a class="header" href="print.html#aハッシュマップを更新する" id="aハッシュマップを更新する"><h3>ハッシュマップを更新する</h3></a>
<!-- Although the number of keys and values is growable, each key can only have one -->
<!-- value associated with it at a time. When we want to change the data in a hash -->
<!-- map, we have to decide how to handle the case when a key already has a value -->
<!-- assigned. We could replace the old value with the new value, completely -->
<!-- disregarding the old value. We could keep the old value and ignore the new -->
<!-- value, only adding the new value if the key *doesn’t* already have a value. Or -->
<!-- we could combine the old value and the new value. Let’s look at how to do each -->
<!-- of these! -->
<p>キーと値の数は伸長可能なものの、各キーには1回に1つの値しか紐づけることができません。
ハッシュマップ内のデータを変えたい時は、すでにキーに値が紐づいている場合の扱い方を決めなければなりません。
古い値を新しい値で置き換えて、古い値を完全に無視することもできます。古い値を保持して、
新しい値を無視し、キーにまだ値が<em>ない</em>場合に新しい値を追加するだけにすることもできます。
あるいは、古い値と新しい値を組み合わせることもできます。各方法について見ていきましょう！</p>
<!-- #### Overwriting a Value -->
<a class="header" href="print.html#a値を上書きする" id="a値を上書きする"><h4>値を上書きする</h4></a>
<!-- If we insert a key and a value into a hash map and then insert that same key -->
<!-- with a different value, the value associated with that key will be replaced. -->
<!-- Even though the code in Listing 8-24 calls `insert` twice, the hash map will -->
<!-- only contain one key/value pair because we’re inserting the value for the Blue -->
<!-- team’s key both times. -->
<p>キーと値をハッシュマップに挿入し、同じキーを異なる値で挿入したら、そのキーに紐づけられている値は置換されます。
リスト8-24のコードは、<code>insert</code>を二度呼んでいるものの、ハッシュマップには一つのキーと値の組しか含まれません。
なぜなら、ブルーチームキーに対する値を2回とも挿入しているからです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-24: Replacing a value stored with a particular -->
<!-- key</span> -->
<p><span class="caption">リスト8-24: 特定のキーで保持された値を置き換える</span></p>
<!-- This code will print `{"Blue": 25}`. The original value of `10` has been -->
<!-- overwritten. -->
<p>このコードは、<code>{&quot;Blue&quot;: 25}</code>と出力するでしょう。<code>10</code>という元の値は上書きされたのです。</p>
<!-- #### Only Inserting a Value If the Key Has No Value -->
<a class="header" href="print.html#aキーに値がなかった時のみ値を挿入する" id="aキーに値がなかった時のみ値を挿入する"><h4>キーに値がなかった時のみ値を挿入する</h4></a>
<!-- It’s common to check whether a particular key has a value andaaaaAaaaaaa if it doesn’t, -->
<!-- insert a value for it. Hash maps have a special API for this called `entry` -->
<!-- that takes the key we want to check as a parameter. The return value of the -->
<!-- `entry` method is an enum called `Entry` that represents a value that might or -->
<!-- might not exist. Let’s say we want to check whether the key for the Yellow team -->
<!-- has a value associated with it. If it doesn’t, we want to insert the value 50, -->
<!-- and the same for the Blue team. Using the `entry` API, the code looks like -->
<!-- Listing 8-25. -->
<p>特定のキーに値があるか確認することは一般的であり、存在しない時に値を挿入することも一般的です。
ハッシュマップには、これを行う<code>entry</code>と呼ばれる特別なAPIがあり、これは、引数としてチェックしたいキーを取ります。
この<code>entry</code>メソッドの戻り値は、<code>Entry</code>と呼ばれるenumであり、これは存在したりしなかったりするかもしれない値を表します。
イエローチームに対するキーに値が紐づけられているか否か確認したくなったとしましょう。存在しなかったら、
50という値を挿入したく、ブルーチームに対しても同様です。<code>entry</code>APIを使用すれば、コードはリスト8-25のようになります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-25: Using the `entry` method to only insert if -->
<!-- the key does not already have a value</span> -->
<p><span class="caption">リスト8-25: <code>entry</code>メソッドを使ってキーに値がない場合だけ挿入する</span></p>
<!-- The `or_insert` method on `Entry` is defined to return a mutable reference to -->
<!-- the value for the corresponding `Entry` key if that key exists, and if not, -->
<!-- inserts the parameter as the new value for this key and returns a mutable -->
<!-- reference to the new value. This technique is much cleaner than writing the -->
<!-- logic ourselves, and in addition, plays more nicely with the borrow checker. -->
<p><code>Entry</code>上の<code>or_insert</code>メソッドは、対応する<code>Entry</code>キーが存在した時にそのキーに対する値への可変参照を返すために定義されており、
もしなかったら、引数をこのキーの新しい値として挿入し、新しい値への可変参照を返します。このテクニックの方が、
そのロジックを自分で書くよりもはるかに綺麗な上に、borrow checkerとも親和性が高くなります。</p>
<!-- Running the code in Listing 8-25 will print `{"Yellow": 50, "Blue": 10}`. The -->
<!-- first call to `entry` will insert the key for the Yellow team with the value -->
<!-- 50 because the Yellow team doesn’t have a value already. The second call to -->
<!-- `entry` will not change the hash map because the Blue team already has the -->
<!-- value 10. -->
<p>リスト8-25のコードを実行すると、<code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>と出力するでしょう。
最初の<code>entry</code>呼び出しは、まだイエローチームに対する値がないので、値50でイエローチームのキーを挿入します。
<code>entry</code>の2回目の呼び出しはハッシュマップを変更しません。なぜなら、ブルーチームにはすでに10という値があるからです。</p>
<!-- #### Updating a Value Based on the Old Value -->
<a class="header" href="print.html#a古い値に基づいて値を更新する" id="a古い値に基づいて値を更新する"><h4>古い値に基づいて値を更新する</h4></a>
<!-- Another common use case for hash maps is to look up a key’s value and then -->
<!-- update it based on the old value. For instance, Listing 8-26 shows code that -->
<!-- counts how many times each word appears in some text. We use a hash map with -->
<!-- the words as keys and increment the value to keep track of how many times we’ve -->
<!-- seen that word. If it’s the first time we’ve seen a word, we’ll first insert -->
<!-- the value 0 -->
<p>ハッシュマップの別の一般的なユースケースは、キーの値を探し、古い値に基づいてそれを更新することです。
例えば、リスト8-26は、各単語があるテキストに何回出現するかを数え上げるコードを示しています。
キーに単語を入れたハッシュマップを使用し、その単語を何回見かけたか追いかけるために値を増やします。
ある単語を見かけたのが最初だったら、まず0という値を挿入します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-26: Counting occurrences of words using a hash -->
<!-- map that stores words and counts</span> -->
<p><span class="caption">リスト8-26: 単語とカウントを保持するハッシュマップを使って単語の出現数をカウントする</span></p>
<!-- This code will print `{"world": 2, "hello": 1, "wonderful": 1}`. The -->
<!-- `or_insert` method actually returns a mutable reference (`&mut V`) to the value -->
<!-- for this key. Here we store that mutable reference in the `count` variable, so -->
<!-- in order to assign to that value, we must first dereference `count` using the -->
<!-- asterisk (`*`). The mutable reference goes out of scope at the end of the `for` -->
<!-- loop, so all of these changes are safe and allowed by the borrowing rules. -->
<p>このコードは、<code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>と出力するでしょう。
<code>or_insert</code>関数は実際、このキーに対する値への可変参照(<code>&amp;mut V</code>)を返すのです。
ここでその可変参照を<code>count</code>変数に保持しているので、その値に代入するには、
まずアスタリスク(<code>*</code>)で<code>count</code>を参照外ししなければならないのです。この可変参照は、
<code>for</code>ループの終端でスコープを抜けるので、これらの変更は全て安全であり、借用規則により許可されるのです。</p>
<!-- ### Hashing Function -->
<a class="header" href="print.html#aハッシュ関数" id="aハッシュ関数"><h3>ハッシュ関数</h3></a>
<!-- By default, `HashMap` uses a cryptographically secure hashing function that can -->
<!-- provide resistance to Denial of Service (DoS) attacks. This is not the fastest -->
<!-- hashing algorithm available, but the trade-off for better security that comes -->
<!-- with the drop in performance is worth it. If you profile your code and find -->
<!-- that the default hash function is too slow for your purposes, you can switch to -->
<!-- another function by specifying a different *hasher*. A hasher is a type that -->
<!-- implements the `BuildHasher` trait. We’ll talk about traits and how to -->
<!-- implement them in Chapter 10. You don’t necessarily have to implement your own -->
<!-- hasher from scratch; [crates.io](https://crates.io) has libraries shared by -->
<!-- other Rust users that provide hashers implementing many common hashing -->
<!-- algorithms. -->
<p>標準では、<code>HashMap</code>はサービス拒否(DoS)アタックに対して抵抗を示す暗号学的に安全なハッシュ関数を使用します。
これは、利用可能な最速のハッシュアルゴリズムではありませんが、パフォーマンスの欠落と引き換えに安全性を得るというトレードオフは、
価値があります。自分のコードをプロファイリングして、自分の目的では標準のハッシュ関数は遅すぎると判明したら、
異なる<em>hasher</em>を指定することで別の関数に切り替えることができます。hasherとは、
<code>BuildeHasher</code>トレイトを実装する型のことです。トレイトについてとその実装方法については、第10章で語ります。
必ずしも独自のhasherを1から作り上げる必要はありません; <a href="https://crates.io">crates.io</a>には、
他のRustユーザによって共有された多くの一般的なハッシュアルゴリズムを実装したhasherを提供するライブラリがあります。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-7" id="aまとめ-7"><h2>まとめ</h2></a>
<!-- Vectors, strings, and hash maps will provide a large amount of functionality -->
<!-- necessary in programs when you need to store, access, and modify data. Here are-->
<!-- some exercises you should now be equipped to solve: -->
<p>ベクタ、文字列、ハッシュマップはデータを保持し、アクセスし、変更する必要のあるプログラムで必要になる、
多くの機能を提供してくれるでしょう。今なら解決可能なはずの練習問題を用意しました:</p>
<!-- * Given a list of integers, use a vector and return the mean (the average -->
<!--   value), median (when sorted, the value in the middle position), and mode (the -->
<!--   value that occurs most often; a hash map will be helpful here) of the list. -->
<!-- * Convert strings to pig latin. The first consonant of each word is moved to -->
<!--   the end of the word and “ay” is added, so “first” becomes “irst-fay.” Words -->
<!--   that start with a vowel have “hay” added to the end instead (“apple” becomes -->
<!--   “apple-hay”). Keep in mind the details about UTF-8 encoding! -->
<!-- * Using a hash map and vectors, create a text interface to allow a user to add -->
<!--   employee names to a department in a company. For example, “Add Sally to -->
<!--   Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all -->
<!--   people in a department or all people in the company by department, sorted -->
<!--   alphabetically. -->
<ul>
<li>整数のリストが与えられ、ベクタを使ってmean(平均値)、median(ソートされた時に真ん中に来る値)、
mode(最も頻繁に出現する値; ハッシュマップがここでは有効活用できるでしょう)を返してください。</li>
<li>文字列をピッグ・ラテン(<code>訳注</code>: 英語の言葉遊びの一つ)に変換してください。各単語の最初の子音は、
単語の終端に移り、&quot;ay&quot;が足されます。従って、&quot;first&quot;は&quot;irst-fay&quot;になります。ただし、
母音で始まる単語には、お尻に&quot;hay&quot;が付け足されます(&quot;apple&quot;は&quot;apple-hay&quot;になります)。
UTF-8エンコードに関する詳細を心に留めておいてください！</li>
<li>ハッシュマップとベクタを使用して、ユーザに会社の部署に雇用者の名前を追加させられるテキストインターフェイスを作ってください。
例えば、&quot;Add Sally to Engineering&quot;(開発部門にサリーを追加)や&quot;Add Amir to Sales&quot;(販売部門にアミールを追加)などです。
それからユーザにある部署にいる人間の一覧や部署ごとにアルファベット順で並べ替えられた会社の全人間の一覧を、
扱わせてあげてください。</li>
</ul>
<!-- The standard library API documentation describes methods that vectors, strings, -->
<!-- and hash maps have that will be helpful for these exercises! -->
<p>標準ライブラリのAPIドキュメントには、この練習問題に有用な、ベクタ、文字列、ハッシュマップのメソッドが解説されています。</p>
<!-- We’re getting into more complex programs in which operations can fail; so, it’s -->
<!-- a perfect time to discuss error handling. We'll do that next! -->
<p>処理が失敗する可能性のあるような、より複雑なプログラムに入り込んできています; ということは、
エラーの処理法について議論するのにぴったりということです。次にそれをします！</p>
<!-- # Error Handling -->
<a class="header" href="print.html#aエラー処理" id="aエラー処理"><h1>エラー処理</h1></a>
<!-- Rust’s commitment to reliability extends to error handling. Errors are a fact -->
<!-- of life in software, so Rust has a number of features for handling situations -->
<!-- in which something goes wrong. In many cases, Rust requires you to acknowledge -->
<!-- the possibility of an error and take some action before your code will compile. -->
<!-- This requirement makes your program more robust by ensuring that you'll -->
<!-- discover errors and handle them appropriately before you’ve deployed your code -->
<!-- to production! -->
<p>Rustの信頼性への傾倒は、エラー処理にも及びます。ソフトウェアにおいて、エラーは生きている証しです。
従って、Rustには何かがおかしくなる場面を扱う機能がたくさんあります。多くの場面で、
コンパイラは、エラーの可能性を知り、コードのコンパイルが通るまでに何かしら対応を行うことを要求してきます。
この要求により、エラーを発見し、コードを実用に供する前に適切に対処していることを確認することでプログラムを頑健なものにしてくれるのです！</p>
<!-- Rust groups errors into two major categories: *recoverable* and *unrecoverable* -->
<!-- errors. For a recoverable errors, such as a file not found error, it’s -->
<!-- reasonable to report the problem to the user and retry the operation. -->
<!-- Unrecoverable errors are always symptoms of bugs, like trying to access a -->
<!-- location beyond the end of an array. -->
<p>Rustでは、エラーは大きく二つに分類されます: <em>回復可能</em>と<em>回復不能</em>なエラーです。
ファイルが見つからないなどの回復可能なエラーには、問題をユーザに報告し、処理を再試行することが合理的になります。
回復不能なエラーは、常にバグの兆候です。例えば、配列の境界を超えた箇所にアクセスしようとすることなどです。</p>
<!-- Most languages don’t distinguish between these two kinds of errors and handle -->
<!-- both in the same way, using mechanisms like exceptions. Rust doesn’t have -->
<!-- exceptions. Instead, it has the value `Result<T, E>` for recoverable errors and -->
<!-- the `panic!` macro that stops execution when the program encounters an -->
<!-- unrecoverable error. This chapter covers calling `panic!` first and then talks -->
<!-- about returning `Result<T, E>` values. Additionally, we’ll explore -->
<!-- considerrations when deciding whether to try to recover from an error or to -->
<!-- stop execution. -->
<p>多くの言語では、この2種のエラーを区別することはなく、例外などの機構を使用して同様に扱います。
Rustには例外が存在しません。代わりに、回復可能なエラーには<code>Result&lt;T, E&gt;</code>値があり、
プログラムが回復不能なエラーに遭遇した時に、実行を中止する<code>panic!</code>マクロがあります。
この章では、まず<code>panic!</code>の呼び出しを講義し、それから<code>Result&lt;T, E&gt;</code>を戻り値にする話をします。
加えて、エラーからの回復を試みるか、実行を中止するか決定する際に考慮すべき事項についても、掘り下げましょう。</p>
<!-- ## Unrecoverable Errors with `panic!` -->
<a class="header" href="print.html#panicで回復不能なエラー" id="panicで回復不能なエラー"><h2><code>panic!</code>で回復不能なエラー</h2></a>
<!-- Sometimes, bad things happen in your code, and there’s nothing you can do about -->
<!-- it. In these cases, Rust has the `panic!` macro. When the `panic!` macro -->
<!-- executes, your program will print a failure message, unwind and clean up the -->
<!-- stack, and then quit. This most commonly occurs when a bug of some kind has -->
<!-- been detected, and it’s not clear to the programmer how to handle the error. -->
<p>時として、コードで悪いことが起きるものです。そして、それに対してできることは何もありません。
このような場面で、Rustには<code>panic!</code>マクロが用意されています。<code>panic!</code>マクロが実行されると、
プログラムは失敗のメッセージを表示し、スタックを巻き戻し掃除して、終了します。これが最もありふれて起こるのは、
何らかのバグが検出された時であり、プログラマには、どうエラーを処理すればいいか明確ではありません。</p>
<!-- > ### Unwinding the Stack or Aborting in Response to a Panic -->
<!-- > -->
<!-- > By default, when a panic occurs, the program starts *unwinding*, which -->
<!-- > means Rust walks back up the stack and cleans up the data from each function -->
<!-- > it encounters. But this walking back and cleanup is a lot of work. The -->
<!-- > alternative is to immediately *abort*, which ends the program without -->
<!-- > cleaning up. Memory that the program was using will then need to be cleaned -->
<!-- > up by the operating system. If in your project you need to make the resulting -->
<!-- > binary as small as possible, you can switch from unwinding to aborting upon a -->
<!-- > panic by adding `panic = 'abort'` to the appropriate `[profile]` sections in -->
<!-- > your *Cargo.toml* file. For example, if you want to abort on panic in release -->
<!-- > mode, add this: -->
<!-- > -->
<!-- > ```toml -->
<!-- > [profile.release] -->
<!-- > panic = 'abort' -->
<!-- > ``` -->
<blockquote>
<a class="header" href="print.html#aパニックに対してスタックを巻き戻すか異常終了するか" id="aパニックに対してスタックを巻き戻すか異常終了するか"><h3>パニックに対してスタックを巻き戻すか異常終了するか</h3></a>
<p>標準では、パニックが発生すると、プログラムは<em>巻き戻し</em>を始めます。つまり、言語がスタックを遡り、
遭遇した各関数のデータを片付けるということです。しかし、この遡りと片付けはすべきことが多くなります。
対立案は、即座に異常終了し、片付けをせずにプログラムを終了させることです。そうなると、プログラムが使用していたメモリは、
OSが片付ける必要があります。プロジェクトにおいて、実行可能ファイルを極力小さくする必要があれば、
<em>Cargo.toml</em>ファイルの適切な<code>[profile]</code>欄に<code>panic = 'abort'</code>を追記することで、
パニック時に巻き戻しから異常終了するように切り替えることができます。例として、
リリースモード時に異常終了するようにしたければ、以下を追記してください:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<!-- Let’s try calling `panic!` in a simple program: -->
<p>単純なプログラムで<code>panic!</code>の呼び出しを試してみましょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    panic!(&quot;crash and burn&quot;);  //クラッシュして炎上
}
</code></pre></pre>
<!-- When you run the program, you’ll see something like this: -->
<p>このプログラムを実行すると、以下のような出力を目の当たりにするでしょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:4
('main'スレッドはsrc/main.rs:2:4の「クラッシュして炎上」でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!-- The call to `panic!` causes the error message contained in the last two lines. -->
<!-- The first line shows our panic message and the place in our source code where -->
<!-- the panic occurred: *src/main.rs:2:4* indicates that it’s the second line, -->
<!-- fourth character of our *src/main.rs* file. -->
<p><code>panic!</code>の呼び出しが、最後の2行に含まれるエラーメッセージを発生させているのです。
1行目にパニックメッセージとソースコード中でパニックが発生した箇所を示唆しています:
<em>src/main.rs:2:4</em>は、<em>src/main.rs</em>ファイルの2行目4文字目であることを示しています。</p>
<!-- In this case, the line indicated is part of our code, and if we go to that -->
<!-- line, we see the `panic!` macro call. In other cases, the `panic!` call might -->
<!-- be in code that our code calls, and the filename and line number reported by -->
<!-- the error message will be someone else’s code where the `panic!` macro is -->
<!-- called, not the line of our code that eventually led to the `panic!` call. We -->
<!-- can use the backtrace of the functions the `panic!` call came from to figure -->
<!-- out the part of our code that is causing the problem. We’ll discuss what a  -->
<!-- backtrace is in more detail next. -->
<p>この場合、示唆される行は、自分のコードの一部で、その箇所を見に行けば、<code>panic!</code>マクロ呼び出しがあるわけです。
<code>panic!</code>呼び出しが、自分のコードが呼び出しているコードの一部になっている可能性もあるわけです。
エラーメッセージで報告されるファイル名と行番号が、結果的に<code>panic!</code>呼び出しに導いた自分のコードの行ではなく、
<code>panic!</code>マクロが呼び出されている他人のコードになるでしょう。<code>panic!</code>呼び出しの発生元である関数のバックトレースを使用して、
問題を起こしている自分のコードの箇所を割り出すことができます。バックトレースがどんなものか、次に議論しましょう。</p>
<!-- ### Using a `panic!` Backtrace -->
<a class="header" href="print.html#panicバックトレースを使用する" id="panicバックトレースを使用する"><h3><code>panic!</code>バックトレースを使用する</h3></a>
<!-- Let’s look at another example to see what it’s like when a `panic!` call comes -->
<!-- from a library because of a bug in our code instead of from our code calling -->
<!-- the macro directly. Listing 9-1 has some code that attempts to access an -->
<!-- element by index in a vector. -->
<p>別の例を眺めて、自分のコードでマクロを直接呼び出す代わりに、コードに存在するバグにより、
ライブラリで<code>panic!</code>呼び出しが発生するとどんな感じなのか確かめてみましょう。リスト9-1は、
添え字でベクタの要素にアクセスを試みるあるコードです。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<!-- <span class="caption">Listing 9-1: Attempting to access an element beyond the -->
<!-- end of a vector, which will cause a call to `panic!`</span> -->
<p><span class="caption">リスト9-1: ベクタの境界を超えて要素へのアクセスを試み、<code>panic!</code>の呼び出しを発生させる</span></p>
<!-- Here, we’re attempting to access the 100th element of our vector (which is at -->
<!-- index 99 because indexing starts at zero), but it has only 3 elements. In this -->
<!-- situation, Rust will panic. Using `[]` is supposed to return an element, but if -->
<!-- you pass an invalid index, there’s no element that Rust could return here that -->
<!-- would be correct. -->
<p>ここでは、ベクタの100番目の要素(添字は0始まりなので添字99)にアクセスを試みていますが、ベクタには3つしか要素がありません。
この場面では、Rustはパニックします。<code>[]</code>の使用は、要素を返すと想定されるものの、
無効な番号を渡せば、ここでRustが返せて正しいと思われる要素は何もないわけです。</p>
<!-- Other languages, like C, will attempt to give you exactly what you asked for in -->
<!-- this situation, even though it isn’t what you want: you’ll get whatever is at -->
<!-- the location in memory that would correspond to that element in the vector, -->
<!-- even though the memory doesn’t belong to the vector. This is called a *buffer -->
<!-- overread* and can lead to security vulnerabilities if an attacker is able to -->
<!-- manipulate the index in such a way as to read data they shouldn’t be allowed to -->
<!-- that is stored after the array. -->
<p>他の言語(Cなど)では、この場面で欲しいものではないにもかかわらず、まさしく要求したものを返そうとしてきます:
メモリがベクタに属していないにもかかわらず、ベクタ内のその要素に対応するメモリ上の箇所にあるものを何か返してくるのです。
これは、<em>バッファー外読み出し</em>(buffer overread; <code>訳注</code>: 初めて見かけた表現。バッファー読みすぎとも解釈できるか)と呼ばれ、
攻撃者が、配列の後に格納された読めるべきでないデータを読み出せるように添え字を操作できたら、
セキュリティ脆弱性につながる可能性があります。</p>
<!-- To protect your program from this sort of vulnerability, if you try to read an -->
<!-- element at an index that doesn’t exist, Rust will stop execution and refuse to -->
<!-- continue. Let’s try it and see: -->
<p>この種の脆弱性からプログラムを保護するために、存在しない番号の要素を読もうとしたら、
Rustは実行を中止し、継続を拒みます。試して確認してみましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
99', /checkout/src/liballoc/vec.rs:1555:10
('main'スレッドは、/checkout/src/liballoc/vec.rs:1555:10の
「境界外番号: 長さは3なのに、添え字は99です」でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!-- This error points at a file we didn’t write, *vec.rs*. That’s the -->
<!-- implementation of `Vec<T>` in the standard library. The code that gets run when -->
<!-- we use `[]` on our vector `v` is in *vec.rs*, and that is where the `panic!` is -->
<!-- actually happening. -->
<p>このエラーは、自分のファイルではない<em>vec.rs</em>ファイルを指しています。
標準ライブラリの<code>Vec&lt;T&gt;</code>の実装です。ベクタ<code>v</code>に対して<code>[]</code>を使った時に走るコードは、
<em>vec.rs</em>に存在し、ここで実際に<code>panic!</code>が発生しているのです。</p>
<!-- The next note line tells us that we can set the `RUST_BACKTRACE` environment -->
<!-- variable to get a backtrace of exactly what happened to cause the error. A -->
<!-- *backtrace* is a list of all the functions that have been called to get to this -->
<!-- point. Backtraces in Rust work like they do in other languages: the key to -->
<!-- reading the backtrace is to start from the top and read until you see files you -->
<!-- wrote. That’s the spot where the problem originated. The lines above the lines -->
<!-- mentioning your files are code that your code called; the lines below are code -->
<!-- that called your code. These lines might include core Rust code, standard -->
<!-- library code, or crates that you’re using. Let’s try getting a backtrace by -->
<!-- setting the `RUST_BACKTRACE` environment variable to any value except 0. -->
<!-- Listing 9-2 shows output similar to what you’ll see. -->
<p>その次の注釈行は、<code>RUST_BACKTRACE</code>環境変数をセットして、まさしく何が起き、
エラーが発生したのかのバックトレースを得られることを教えてくれています。
<em>バックトレース</em>とは、ここに至るまでに呼び出された全関数の一覧です。Rustのバックトレースも、
他の言語同様に動作します: バックトレースを読むコツは、頭からスタートして自分のファイルを見つけるまで読むことです。
そこが、問題の根源になるのです。自分のファイルを言及している箇所以前は、自分のコードで呼び出したコードになります;
以後は、自分のコードを呼び出しているコードになります。これらの行には、Rustの核となるコード、標準ライブラリのコード、
使用しているクレートなどが含まれるかもしれません。<code>RUST_BACKTRACE</code>環境変数を0以外の値にセットして、
バックトレースを出力してみましょう。リスト9-2のような出力が得られるでしょう。</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /checkout/src/liballoc/vec.rs:1555:10
stack backtrace:
   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace
             at /checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
   1: std::sys_common::backtrace::_print
             at /checkout/src/libstd/sys_common/backtrace.rs:71
   2: std::panicking::default_hook::{{closure}}
             at /checkout/src/libstd/sys_common/backtrace.rs:60
             at /checkout/src/libstd/panicking.rs:381
   3: std::panicking::default_hook
             at /checkout/src/libstd/panicking.rs:397
   4: std::panicking::rust_panic_with_hook
             at /checkout/src/libstd/panicking.rs:611
   5: std::panicking::begin_panic
             at /checkout/src/libstd/panicking.rs:572
   6: std::panicking::begin_panic_fmt
             at /checkout/src/libstd/panicking.rs:522
   7: rust_begin_unwind
             at /checkout/src/libstd/panicking.rs:498
   8: core::panicking::panic_fmt
             at /checkout/src/libcore/panicking.rs:71
   9: core::panicking::panic_bounds_check
             at /checkout/src/libcore/panicking.rs:58
  10: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;usize&gt;&gt;::index
             at /checkout/src/liballoc/vec.rs:1555
  11: panic::main
             at src/main.rs:4
  12: __rust_maybe_catch_panic
             at /checkout/src/libpanic_unwind/lib.rs:99
  13: std::rt::lang_start
             at /checkout/src/libstd/panicking.rs:459
             at /checkout/src/libstd/panic.rs:361
             at /checkout/src/libstd/rt.rs:61
  14: main
  15: __libc_start_main
  16: &lt;unknown&gt;
</code></pre>
<!-- <span class="caption">Listing 9-2: The backtrace generated by a call to -->
<!-- `panic!` displayed when the environment variable `RUST_BACKTRACE` is set</span> -->
<p><span class="caption">リスト9-2: <code>RUST_BACKTRACE</code>環境変数をセットした時に表示される、
<code>panic!</code>呼び出しが生成するバックトレース</span></p>
<!-- That’s a lot of output! The exact output you see might be different depending -->
<!-- on your operating system and Rust version. In order to get backtraces with this -->
<!-- information, debug symbols must be enabled. Debug symbols are enabled by -->
<!-- default when using `cargo build` or `cargo run` without the `--release` flag, -->
<!-- as we have here. -->
<p>出力が多いですね！OSやRustのバージョンによって、出力の詳細は変わる可能性があります。この情報とともに、
バックトレースを得るには、デバッグシンボルを有効にしなければなりません。デバッグシンボルは、
<code>--release</code>オプションなしで<code>cargo build</code>や<code>cargo run</code>を使用していれば、標準で有効になり、
ここではそうなっています。</p>
<!-- In the output in Listing 9-2, line 11 of the backtrace points to the line in -->
<!-- our project that’s causing the problem: line 4 of *src/main.rs*. If we don’t -->
<!-- want our program to panic, the location pointed to by the first line mentioning -->
<!-- a file we wrote is where we should start investigating to figure out how we got -->
<!-- to this location with values that caused the panic. In Listing 9-1, where -->
<!-- we deliberately wrote code that would panic in order to demonstrate how to use -->
<!-- backtraces, the way to fix the panic is to not request an element at index 99 -->
<!-- from a vector that only contains 3 items. When your code panics in the future, -->
<!-- you’ll need to figure out what action the code is taking with what values to -->
<!-- tcause the panic and what the code should do instead. -->
<p>リスト9-2の出力で、バックトレースの11行目が問題発生箇所を指し示しています: <em>src/main.rs</em>の4行目です。
プログラムにパニックしてほしくなければ、自分のファイルについて言及している最初の行で示されている箇所が、
どのようにパニックを引き起こす値でこの箇所にたどり着いたか割り出すために調査を開始すべき箇所になります。
バックトレースの使用法を模擬するためにわざとパニックするコードを書いたリスト9-1において、
パニックを解消する方法は、3つしか要素のないベクタの添字99の要素を要求しないことです。
将来コードがパニックしたら、パニックを引き起こすどんな値でコードがどんな動作をしているのかと、
代わりにコードは何をすべきなのかを算出する必要があるでしょう。</p>
<!-- We’ll come back to `panic!` and when we should and should not use `panic!` to -->
<!-- handle error conditions in “To `panic!` or Not to `panic!`” section later -->
<!-- in this chapter. Next, we’ll look at how to recover from an error using -->
<!-- `Result`. -->
<p>また、この章の後ほど、「<code>panic!</code>するか<code>panic!</code>するまいか」節で<code>panic!</code>とエラー状態を扱うのに<code>panic!</code>を使うべき時と使わぬべき時に戻ってきます。
次は、<code>Result</code>を使用してエラーから回復する方法を見ましょう。</p>
<!-- ## Recoverable Errors with `Result` -->
<a class="header" href="print.html#resultで回復可能なエラー" id="resultで回復可能なエラー"><h2><code>Result</code>で回復可能なエラー</h2></a>
<!-- Most errors aren’t serious enough to require the program to stop entirely. -->
<!-- Sometimes, when a function fails, it’s for a reason that we can easily -->
<!-- interpret and respond to. For example, if you try to open a file and that -->
<!-- operation fails because the file doesn’t exist, we might want to create the -->
<!-- file instead of terminating the process. -->
<p>多くのエラーは、プログラムを完全にストップさせるほど深刻ではありません。時々、関数が失敗すると、
容易に解釈し、対応できる理由によることがあります。例えば、ファイルを開こうとして、
ファイルが存在しないために処理が失敗したら、プロセスを殺すのではなく、ファイルを作成したいことがあります。</p>
<!-- Recall from “[Handling Potential Failure with the `Result` -->
<!-- Type][handle_failure]” in Chapter2 that the `Result` enum is -->
<!-- defined as having two variants, `Ok` and `Err`, as follows: -->
<p>第2章の<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">「<code>Result</code>型で失敗する可能性に対処する」</a>で<code>Result</code> enumが以下のように、
<code>Ok</code>と<code>Err</code>の2値からなるよう定義されていることを思い出してください:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<!-- The `T` and `E` are generic type parameters: we’ll discuss generics in more -->
<!-- detail in Chapter 10. What you need to know right now is that `T` represents -->
<!-- the type of the value that will be returned in a success case within the `Ok` -->
<!-- variant, and `E` represents the type of the error that will be returned in a -->
<!-- failure case within the `Err` variant. Because `Result` has these generic type -->
<!-- parameters, we can use the `Result` type and the functions that the standard -->
<!-- library has defined on it in many different situations where the successful -->
<!-- value and error value we want to return may differ. -->
<p><code>T</code>と<code>E</code>は、ジェネリックな型引数です: ジェネリクスについて詳しくは、第10章で議論します。
たった今知っておく必要があることは、<code>T</code>が成功した時に<code>Ok</code>バリアントに含まれて返される値の型を表すことと、
<code>E</code>が失敗した時に<code>Err</code>バリアントに含まれて返されるエラーの型を表すことです。<code>Result</code>はこのようなジェネリックな型引数を含むので、
標準ライブラリ上に定義されている<code>Result</code>型や関数などを、成功した時とエラーの値が異なるような様々な場面で使用できるのです。</p>
<!-- Let’s call a function that returns a `Result` value because the function could -->
<!-- fail. In Listing 9-3 we try to open a file. -->
<p>関数が失敗する可能性があるために<code>Result</code>値を返す関数を呼び出しましょう: リスト9-3では、
ファイルを開こうとしています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<!-- <span class="caption">Listing 9-3: Opening a file</span> -->
<p><span class="caption">リスト9-3: ファイルを開く</span></p>
<!-- How do we know `File::open` returns a `Result`? We could look at the standard -->
<!-- library API documentation, or we could ask the compiler! If we give `f` a type -->
<!-- annotation that we know is *not* the return type of the function and then try -->
<!-- to compile the code, the compiler will tell us that the types don’t match. The -->
<!-- error message will then tell us what the type of `f` *is*. Let’s try it! We -->
<!-- know that the return type of `File::open` isn’t of type `u32`, so let’s change -->
<!-- the `let f` statement to this: -->
<p><code>File::open</code>が<code>Result</code>を返すとどう知るのでしょうか？標準ライブラリのAPIドキュメントを参照することもできますし、
コンパイラに尋ねることもできます！<code>f</code>に関数の戻り値では<em>ない</em>と判明している型注釈を与えて、
コードのコンパイルを試みれば、コンパイラは型が合わないと教えてくれるでしょう。そして、エラーメッセージは、
<code>f</code>の<em>実際の</em>型を教えてくれるでしょう。試してみましょう！<code>File::open</code>の戻り値の型は<code>u32</code>ではないと判明しているので、
<code>let f</code>文を以下のように変更しましょう:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<!-- Attempting to compile now gives us the following output: -->
<p>コンパイルしようとすると、以下のような出力が得られます:</p>
<pre><code class="language-text">error[E0308]: mismatched types
(エラー: 型が合いません)
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
  (注釈: 予期した型は`u32`です)
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
  (実際の型は`std::result::Result&lt;std::fs::File, std::io::Error&gt;`です)
</code></pre>
<!-- This tells us the return type of the `File::open` function is a `Result<T, E>`. -->
<!-- The generic parameter `T` has been filled in here with the type of the success -->
<!-- value, `std::fs::File`, which is a file handle. The type of `E` used in the -->
<!-- error value is `std::io::Error`. -->
<p>これにより、<code>File::open</code>関数の戻り値の型は、<code>Result&lt;T, E&gt;</code>であることがわかります。ジェネリック引数の<code>T</code>は、
ここでは成功値の型<code>std::fs::File</code>で埋められていて、これはファイルハンドルです。
エラー値で使用されている<code>E</code>の型は、<code>std::io::Error</code>です。</p>
<!-- This return type means the call to `File::open` might succeed and return a file -->
<!-- handle that we can read from or write to. The function call also might fail: -->
<!-- for example, the file might not exist, or we might not have permission to -->
<!-- access the file. The `File::open` function needs to have a way to tell us -->
<!-- whether it succeeded or failed and at the same time give us either the file -->
<!-- handle or error information. This information is exactly what the `Result` enum -->
<!-- conveys. -->
<p>この戻り値型は、<code>File::open</code>の呼び出しが成功し、読み込みと書き込みを行えるファイルハンドルを返す可能性があることを意味します。
また、関数呼び出しは失敗もする可能性があります: 例えば、ファイルが存在しない可能性、ファイルへのアクセス権限がない可能性です。
<code>File::open</code>には成功したか失敗したかを知らせる方法とファイルハンドルまたは、エラー情報を与える方法が必要なのです。
この情報こそが<code>Result</code> enumが伝達するものなのです。</p>
<!-- In the case where `File::open` succeeds, the value in the variable `f` will be-->
<!-- an instance of `Ok` that contains a file handle. In the case where it fails, -->
<!-- the value in `f` will be an instance of `Err` that contains more information -->
<!-- about the kind of error that happened. -->
<p><code>File::open</code>が成功した場合、変数<code>f</code>の値はファイルハンドルを含む<code>Ok</code>インスタンスになります。
失敗した場合には、発生したエラーの種類に関する情報をより多く含む<code>Err</code>インスタンスが<code>f</code>の値になります。</p>
<!-- We need to add to the code in Listing 9-3 to take different actions depending -->
<!-- on the value `File::open` returns. Listing 9-4 shows one way to handle the -->
<!-- `Result` using a basic tool, the `match` expression that we discussed in -->
<!-- Chapter 6. -->
<p>リスト9-3のコードに追記をして<code>File::open</code>が返す値に応じて異なる動作をする必要があります。
リスト9-4に基礎的な道具を使って<code>Result</code>を扱う方法を一つ示しています。第6章で議論した<code>match</code>式です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            // ファイルを開く際に問題がありました
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<!-- <span class="caption">Listing 9-4: Using a `match` expression to handle the -->
<!-- `Result` variants that might be returned</span> -->
<p><span class="caption">リスト9-4: <code>match</code>式を使用して返却される可能性のある<code>Result</code>列挙子を処理する</span></p>
<!-- Note that, like the `Option` enum, the `Result` enum and its variants have been -->
<!-- imported in the prelude, so we don’t need to specify `Result::` before the `Ok` -->
<!-- and `Err` variants in the `match` arms. -->
<p><code>Option</code> enumのように、<code>Result</code> enumとそのバリアントは、初期化処理でインポートされているので、
<code>match</code>アーム内で<code>Ok</code>と<code>Err</code>バリアントの前に<code>Result::</code>を指定する必要がないことに注目してください。</p>
<!-- Here we tell Rust that when the result is `Ok`, return the inner `file` value -->
<!-- out of the `Ok` variant, and we then assign that file handle value to the -->
<!-- variable `f`. After the `match`, we can use the file handle for reading or -->
<!-- writing. -->
<p>ここでは、結果が<code>Ok</code>の時に、<code>Ok</code>列挙子から中身の<code>file</code>値を返すように指示し、
それからそのファイルハンドル値を変数<code>f</code>に代入しています。<code>match</code>の後には、
ファイルハンドルを使用して読み込んだり書き込むことができるわけです。</p>
<!-- The other arm of the `match` handles the case where we get an `Err` value from -->
<!-- `File::open`. In this example, we’ve chosen to call the `panic!` macro. If -->
<!-- there’s no file named *hello.txt* in our current directory and we run this -->
<!-- code, we’ll see the following output from the `panic!` macro: -->
<p><code>match</code>のもう一つのアームは、<code>File::open</code>から<code>Err</code>値が得られたケースを処理しています。
この例では、<code>panic!</code>マクロを呼び出すことを選択しています。カレントディレクトリに<em>hello.txt</em>というファイルがなく、
このコードを走らせたら、<code>panic!</code>マクロからの以下のような出力を目の当たりにするでしょう:</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12
('main'スレッドは、src/main.rs:9:12の「ファイルを開く際に問題がありました: Error{ repr:
Os { code: 2, message: &quot;そのような名前のファイルまたはディレクトリはありません&quot;}}」でパニックしました)
</code></pre>
<!-- As usual, this output tells us exactly what has gone wrong. -->
<p>通常通り、この出力は、一体何がおかしくなったのかを物語っています。</p>
<!-- ### Matching on Different Errors -->
<a class="header" href="print.html#a色々なエラーにマッチする" id="a色々なエラーにマッチする"><h3>色々なエラーにマッチする</h3></a>
<!-- The code in Listing 9-4 will `panic!` no matter why `File::open` failed. What -->
<!-- we want to do instead is take different actions for different failure reasons: -->
<!-- if `File::open` failed because the file doesn’t exist, we want to create the -->
<!-- file and return the handle to the new file. If `File::open` failed for any -->
<!-- other reason-for example, because we didn’t have permission to open the file-we-->
<!-- still want the code to `panic!` in the same way as it did in Listing 9-4. Look -->
<!-- at Listing 9-5, which adds another arm to the `match`. -->
<p>リスト9-4のコードは、<code>File::open</code>が失敗した理由にかかわらず<code>panic!</code>します。代わりにしたいことは、
失敗理由によって動作を変えることです: ファイルが存在しないために<code>File::open</code>が失敗したら、
ファイルを作成し、その新しいファイルへのハンドルを返したいです。他の理由(例えばファイルを開く権限がなかったなど)で、
<code>File::open</code>が失敗したら、リスト9-4のようにコードには<code>panic!</code>してほしいのです。
リスト9-5を眺めてください。ここでは<code>match</code>に別のアームを追加しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    //ファイルを作成しようとしましたが、問題がありました
                    panic!(
                        &quot;Tried to create file but there was a problem: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;There was a problem opening the file: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<!-- <span class="caption">Listing 9-5: Handling different kinds of errors in -->
<!-- different ways</span> -->
<p><span class="caption">リスト9-5: 色々な種類のエラーを異なる方法で扱う</span></p>
<!-- The type of the value that `File::open` returns inside the `Err` variant is -->
<!-- `io::Error`, which is a struct provided by the standard library. This struct -->
<!-- has a method `kind` that we can call to get an `io::ErrorKind` value. The enum-->
<!-- `io::ErrorKind` is provided by the standard library and has variants -->
<!-- representing the different kinds of errors that might result from an `io` -->
<!-- operation. The variant we want to use is `ErrorKind::NotFound`, which indicates -->
<!-- the file we’re trying to open doesn’t exist yet. -->
<p><code>File::open</code>が<code>Err</code>列挙子に含めて返す値の型は、<code>io::Error</code>であり、これは標準ライブラリで提供されている構造体です。
この構造体には、呼び出すと<code>io::ErrorKind</code>値が得られる<code>kind</code>メソッドがあります。<code>io::ErrorKind</code>というenumは、
標準ライブラリで提供されていて、<code>io</code>処理の結果発生する可能性のある色々な種類のエラーを表す列挙子があります。
使用したい列挙子は、<code>ErrorKind::NotFound</code>で、これは開こうとしているファイルがまだ存在しないことを示唆します。</p>
<!-- The condition `if error.kind() == ErrorKind::NotFound` is called a *match -->
<!-- guard*: it’s an extra condition on a `match` arm that further refines the arm’s -->
<!-- pattern. This condition must be true for that arm’s code to be run; otherwise, -->
<!-- the pattern matching will move on to consider the next arm in the `match`. The -->
<!-- `ref` in the pattern is needed so `error` is not moved into the guard condition -->
<!-- but is merely referenced by it. The reason you use `ref` to create a reference -->
<!-- in a pattern instead of `&` will be covered in detail in Chapter 18. In short, -->
<!-- in the context of a pattern, `&` matches a reference and gives you its value, -->
<!-- but `ref` matches a value and gives you a reference to it. -->
<p><code>if error.kind() == ErrorKind::Notfound</code>という条件式は、<em>マッチガード</em>と呼ばれます:
アームのパターンをさらに洗練する<code>match</code>アーム上のおまけの条件式です。この条件式は、
そのアームのコードが実行されるには真でなければいけないのです; そうでなければ、
パターンマッチングは継続し、<code>match</code>の次のアームを考慮します。パターンの<code>ref</code>は、
<code>error</code>がガード条件式にムーブされないように必要ですが、ただガード式に参照されます。
<code>ref</code>を使用して<code>&amp;</code>の代わりにパターン内で参照を作っている理由は、第18章で詳しく解説されるでしょう。
手短に言えば、パターンの文脈において、<code>&amp;</code>は参照にマッチし、その値を返すが、
<code>ref</code>は値にマッチし、それへの参照を返すということなのです。</p>
<!-- The condition we want to check in the match guard is whether the value returned -->
<!-- by `error.kind()` is the `NotFound` variant of the `ErrorKind` enum. If it is, -->
<!-- we try to create the file with `File::create`. However, because `File::create` -->
<!-- could also fail, we need to add an inner `match` expression as well. When the -->
<!-- file can’t be opened, a different error message will be printed. The last arm -->
<!-- of the outer `match` stays the same so the program panics on any error besides -->
<!-- the missing file error. -->
<p>マッチガードで精査したい条件は、<code>error.kind()</code>により返る値が、<code>ErrorKind</code> enumの<code>NotFound</code>列挙子であるかということです。
もしそうなら、<code>File::create</code>でファイル作成を試みます。ところが、<code>File::create</code>も失敗する可能性があるので、
内部にも<code>match</code>式を追加する必要があるのです。ファイルが開けないなら、異なるエラーメッセージが出力されるでしょう。
外側の<code>match</code>の最後のアームは同じままなので、ファイルが行方不明のエラー以外ならプログラムはパニックします。</p>
<!-- ### Shortcuts for Panic on Error: `unwrap` and `expect` -->
<a class="header" href="print.html#aエラー時にパニックするショートカット-unwrapとexpect" id="aエラー時にパニックするショートカット-unwrapとexpect"><h3>エラー時にパニックするショートカット: <code>unwrap</code>と<code>expect</code></h3></a>
<!-- Using `match` works well enough, but it can be a bit verbose and doesn’t always -->
<!-- communicate intent well. The `Result<T, E>` type has many helper methods -->
<!-- defined on it to do various tasks. One of those methods, called `unwrap`, is a -->
<!-- shortcut method that is implemented just like the `match` expression we wrote -->
<!-- in Listing 9-4. If the `Result` value is the `Ok` variant, `unwrap` will return -->
<!-- the value inside the `Ok`. If the `Result` is the `Err` variant, `unwrap` will -->
<!-- call the `panic!` macro for us. Here is an example of `unwrap` in action: -->
<p><code>match</code>の使用は、十分に仕事をしてくれますが、いささか冗長になり得る上、必ずしも意図をよく伝えるとは限りません。
<code>Result&lt;T, E&gt;</code>型には、色々な作業をするヘルパーメソッドが多く定義されています。それらの関数の一つは、
<code>unwrap</code>と呼ばれますが、リスト9-4で書いた<code>match</code>式と同じように実装された短絡メソッドです。
<code>Result</code>値が<code>Ok</code>列挙子なら、<code>unwrap</code>は<code>Ok</code>の中身を返します。<code>Result</code>が<code>Err</code>列挙子なら、
<code>unwrap</code>は<code>panic!</code>マクロを呼んでくれます。こちらが実際に動作している<code>unwrap</code>の例です:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<!-- If we run this code without a *hello.txt* file, we’ll see an error message from -->
<!-- the `panic!` call that the `unwrap` method makes: -->
<p>このコードを<em>hello.txt</em>ファイルなしで走らせたら、<code>unwrap</code>メソッドが行う<code>panic!</code>呼び出しからのエラーメッセージを目の当たりにするでしょう:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
('main'スレッドは、src/libcore/result.rs:906:4の
「`Err`値に対して`Result::unwrap()`が呼び出されました: Error{
repr: Os { code: 2, message: &quot;そのようなファイルまたはディレクトリはありません&quot; } }」でパニックしました)
</code></pre>
<!-- Another method, `expect`, which is similar to `unwrap`, lets us also choose the -->
<!-- `panic!` error message. Using `expect` instead of `unwrap` and providing good -->
<!-- error messages can convey your intent and make tracking down the source of a -->
<!-- panic easier. The syntax of `expect` looks like this: -->
<p>別のメソッド<code>expect</code>は、<code>unwrap</code>に似ていますが、<code>panic!</code>のエラーメッセージも選択させてくれます。
<code>unwrap</code>の代わりに<code>expect</code>を使用していいエラーメッセージを提供することは、意図を伝え、
パニックの原因をたどりやすくしてくれます。<code>expect</code>の表記はこんな感じです:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    // hello.txtを開くのに失敗しました
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<!-- We use `expect` in the same way as `unwrap`: to return the file handle or call -->
<!-- the `panic!` macro. The error message used by `expect` in its call to `panic!` -->
<!-- will be the parameter that we pass to `expect`, rather than the default -->
<!-- `panic!` message that `unwrap` uses. Here’s what it looks like: -->
<p><code>expect</code>を<code>unwrap</code>と同じように使用してます: ファイルハンドルを返したり、<code>panic!</code>マクロを呼び出しています。
<code>expect</code>が<code>panic!</code>呼び出しで使用するエラーメッセージは、<code>unwrap</code>が使用するデフォルトの<code>panic!</code>メッセージではなく、
<code>expect</code>に渡した引数になります。以下のようになります:</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<!-- Because this error message starts with the text we specified, `Failed to open -->
<!-- hello.txt`, it will be easier to find where in the code this error message is -->
<!-- coming from. If we use `unwrap` in multiple places, it can take more time to -->
<!-- figure out exactly which `unwrap` is causing the panic because all `unwrap` -->
<!-- calls that panic print the same message. -->
<p>このエラーメッセージは、指定したテキストの<code>hello.txtを開くのに失敗しました</code>で始まっているので、
コード内のどこでエラーメッセージが出力されたのかより見つけやすくなるでしょう。複数箇所で<code>unwrap</code>を使用していたら、
ズバリどの<code>unwrap</code>がパニックを引き起こしているのか算出するのは、より時間がかかる可能性があります。
パニックする<code>unwrap</code>呼び出しは全て、同じメッセージを出力するからです。</p>
<!-- ### Propagating Errors -->
<a class="header" href="print.html#aエラーを委譲する" id="aエラーを委譲する"><h3>エラーを委譲する</h3></a>
<!-- When you’re writing a function whose implementation calls something that might -->
<!-- fail, instead of handling the error within this function, you can return the -->
<!-- error to the calling code so that it can decide what to do. This is known as -->
<!-- *propagating* the error and gives more control to the calling code, where there -->
<!-- might be more information or logic that dictates how the error should be -->
<!-- handled than what you have available in the context of your code. -->
<p>失敗する可能性のある何かを呼び出す実装をした関数を書く際、関数内でエラーを処理する代わりに、
呼び出し元がどうするかを決められるようにエラーを返すことができます。これはエラーの<em>委譲</em>として認知され、
呼び出し元に自分のコードの文脈で利用可能なものよりも、
エラーの処理法を規定する情報やロジックがより多くある箇所を制御してもらいます。</p>
<!-- For example, Listing 9-6 shows a function that reads a username from a file. If -->
<!-- the file doesn’t exist or can’t be read, this function will return those errors -->
<!-- to the code that called this function. -->
<p>例えば、リスト9-6の関数は、ファイルからユーザ名を読み取ります。ファイルが存在しなかったり、読み込みできなければ、
この関数はそのようなエラーを呼び出し元のコードに返します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 9-6: A function that returns errors to the -->
<!-- calling code using `match`</span> -->
<p><span class="caption">リスト9-6: <code>match</code>でエラーを呼び出し元のコードに返す関数</span></p>
<!-- Look at the return type of the function first: `Result<String, io::Error>`. -->
<!-- This means the function is returning a value of the type `Result<T, E>` where -->
<!-- the generic parameter `T` has been filled in with the concrete type `String` -->
<!-- and the generic type `E` has been filled in with the concrete type `io::Error`. -->
<!-- If this function succeeds without any problems, the code that calls this -->
<!-- function will receive an `Ok` value that holds a `String`—the username that -->
<!-- this function read from the file. If this function encounters any problems, the -->
<!-- code that calls this function will receive an `Err` value that holds an -->
<!-- instance of `io::Error` that contains more information about what the problems -->
<!-- were. We chose `io::Error` as the return type of this function because that -->
<!-- happens to be the type of the error value returned from both of the operations -->
<!-- we’re calling in this function’s body that might fail: the `File::open` -->
<!-- function and the `read_to_string` method. -->
<p>まずは、関数の戻り値型に注目してください: <code>Result&lt;String, io::Error&gt;</code>です。つまり、この関数は、
<code>Result&lt;T, E&gt;</code>型の値を返しているということです。ここでジェネリック引数の<code>T</code>は、具体型<code>String</code>で埋められ、
ジェネリック引数の<code>E</code>は具体型<code>io::Error</code>で埋められています。この関数が何の問題もなく成功すれば、
この関数を呼び出したコードは、<code>String</code>(関数がファイルから読み取ったユーザ名)を保持する<code>Ok</code>値を受け取ります。
この関数が何か問題に行き当たったら、呼び出し元のコードは<code>io::Error</code>のインスタンスを保持する<code>Err</code>値を受け取り、
この<code>io::Error</code>は問題の内容に関する情報をより多く含んでいます。関数の戻り値の型に<code>io::Error</code>を選んだのは、
この関数本体で呼び出している失敗する可能性のある処理が両方とも偶然この型をエラー値として返すからです:
<code>File::open</code>関数と<code>read_to_string</code>メソッドです。</p>
<!-- The body of the function starts by calling the `File::open` function. Then we -->
<!-- handle the `Result` value returned with a `match` similar to the `match` in -->
<!-- Listing 9-4, only instead of calling `panic!` in the `Err` case, we return -->
<!-- early from this function and pass the error value from `File::open` back to the -->
<!-- calling code as this function’s error value. If `File::open` succeeds, we store -->
<!-- the file handle in the variable `f` and continue. -->
<p>関数の本体は、<code>File::open</code>関数を呼び出すところから始まります。そして、リスト9-4の<code>match</code>に似た<code>match</code>で返ってくる<code>Result</code>値を扱い、
<code>Err</code>ケースに<code>panic!</code>を呼び出す代わりだけですが、この関数から早期リターンしてこの関数のエラー値として、
<code>File::open</code>から得たエラー値を呼び出し元に渡し返します。<code>File::open</code>が成功すれば、
ファイルハンドルを変数<code>f</code>に保管して継続します。</p>
<!-- Then we create a new `String` in variable `s` and call the `read_to_string` -->
<!-- method on the file handle in `f` to read the contents of the file into `s`. The -->
<!-- `read_to_string` method also returns a `Result` because it might fail, even -->
<!-- though `File::open` succeeded. So we need another `match` to handle that -->
<!-- `Result`: if `read_to_string` succeeds, then our function has succeeded, and we -->
<!-- return the username from the file that’s now in `s` wrapped in an `Ok`. If -->
<!-- `read_to_string` fails, we return the error value in the same way that we -->
<!-- returned the error value in the `match` that handled the return value of -->
<!-- `File::open`. However, we don’t need to explicitly say `return`, because this -->
<!-- is the last expression in the function. -->
<p>さらに、変数<code>s</code>に新規<code>String</code>を生成し、<code>f</code>のファイルハンドルに対して<code>read_to_string</code>を呼び出して、
ファイルの中身を<code>s</code>に読み出します。<code>File::open</code>が成功しても、失敗する可能性があるので、<code>read_to_string</code>メソッドも、
<code>Result</code>を返却します。その<code>Result</code>を処理するために別の<code>match</code>が必要になります: <code>read_to_string</code>が成功したら、
関数は成功し、今は<code>Ok</code>に包まれた<code>s</code>に入っているファイルのユーザ名を返却します。<code>read_to_string</code>が失敗したら、
<code>File::open</code>の戻り値を扱った<code>match</code>でエラー値を返したように、エラー値を返します。
しかし、明示的に<code>return</code>を述べる必要はありません。これが関数の最後の式だからです。</p>
<!-- The code that calls this code will then handle getting either an `Ok` value -->
<!-- that contains a username or an `Err` value that contains an `io::Error`. We -->
<!-- don’t know what the calling code will do with those values. If the calling code -->
<!-- gets an `Err` value, it could call `panic!` and crash the program, use a -->
<!-- default username, or look up the username from somewhere other than a file, for -->
<!-- example. We don’t have enough information on what the calling code is actually -->
<!-- trying to do, so we propagate all the success or error information upwards for -->
<!-- it to handle appropriately. -->
<p>そうしたら、呼び出し元のコードは、ユーザ名を含む<code>Ok</code>値か、<code>io::Error</code>を含む<code>Err</code>値を得て扱います。
呼び出し元のコードがそれらの値をどうするかはわかりません。呼び出しコードが<code>Err</code>値を得たら、
例えば、<code>panic!</code>を呼び出してプログラムをクラッシュさせたり、デフォルトのユーザ名を使ったり、
ファイル以外の場所からユーザ名を検索したりできるでしょう。呼び出し元のコードが実際に何をしようとするかについて、
十分な情報がないので、成功や失敗情報を全て委譲して適切に扱えるようにするのです。</p>
<!-- This pattern of propagating errors is so common in Rust that Rust provides the -->
<!-- question mark operator `?` to make this easier. -->
<p>Rustにおいて、この種のエラー委譲は非常に一般的なので、Rustにはこれをしやすくする<code>?</code>演算子が用意されています。</p>
<!-- #### A Shortcut for Propagating Errors: the `?` operator -->
<a class="header" href="print.html#aエラー委譲のショートカット-演算子" id="aエラー委譲のショートカット-演算子"><h4>エラー委譲のショートカット: <code>?</code>演算子</h4></a>
<!-- Listing 9-7 shows an implementation of `read_username_from_file` that has the -->
<!-- same functionality as it had in Listing 9-6, but this implementation uses the -->
<!-- `?` operator: -->
<p>リスト9-7もリスト9-6と同じ機能を有する<code>read_username_from_file</code>の実装ですが、
こちらは<code>?</code>演算子を使用しています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 9-7: A function that returns errors to the -->
<!-- calling code using the `?` operator</span> -->
<p><span class="caption">リスト9-7: <code>?</code>演算子でエラーを呼び出し元に返す関数</span></p>
<!-- The `?` placed after a `Result` value is defined to work in almost the same way -->
<!-- as the `match` expressions we defined to handle the `Result` values in Listing -->
<!-- 9-6. If the value of the `Result` is an `Ok`, the value inside the `Ok` will -->
<!-- get returned from this expression, and the program will continue. If the value -->
<!-- is an `Err`, the value inside the `Err` will be returned from the whole -->
<!-- function as if we had used the `return` keyword so the error value gets -->
<!-- propagated to the calling code. -->
<p><code>Result</code>値の直後に置かれた<code>?</code>は、リスト9-6で<code>Result</code>値を処理するために定義した<code>match</code>式とほぼ同じように動作します。
<code>Result</code>の値が<code>Ok</code>なら、<code>Ok</code>の中身がこの式から返ってきて、プログラムは継続します。値が<code>Err</code>なら、
<code>return</code>キーワードを使ったかのように関数全体から<code>Err</code>の中身が返ってくるので、
エラー値は呼び出し元のコードに委譲されます。</p>
<!-- There is a difference between what the `match` expression from Listing 9-6 and -->
<!-- the `?` operator do: error values used with `?` go through the `from` function, -->
<!-- defined in the `From` trait in the standard library, which is used to convert -->
<!-- errors from one type into another. When the `?` operator calls the `from` -->
<!-- function, the error type received is converted into the error type defined in -->
<!-- the return type of the current function. This is useful when a function returns -->
<!-- one error type to represent all the ways a function might fail, even if parts -->
<!-- might fail for many different reasons. As long as each error type implements -->
<!-- the `from` function to define how to convert itself to the returned error type, -->
<!-- the `?` operator takes care of the conversion automatically. -->
<p>リスト9-6の<code>match</code>式と<code>?</code>演算子には違いがあります: <code>?</code>を使ったエラー値は、
標準ライブラリの<code>From</code>トレイトで定義され、エラーの型を別のものに変換する<code>from</code>関数を通ることです。
<code>?</code>演算子が<code>from</code>関数を呼び出すと、受け取ったエラー型が現在の関数の戻り値型で定義されているエラー型に変換されます。これは、
個々がいろんな理由で失敗する可能性があるのにも関わらず、関数が失敗する可能性を全て一つのエラー型で表現して返す時に有用です。
各エラー型が<code>from</code>関数を実装して返り値のエラー型への変換を定義している限り、
<code>?</code>演算子が変換の面倒を自動的に見てくれます。</p>
<!-- In the context of Listing 9-7, the `?` at the end of the `File::open` call will -->
<!-- return the value inside an `Ok` to the variable `f`. If an error occurs, the -->
<!-- `?` operator will return early out of the whole function and give any `Err` -->
<!-- value to the calling code. The same thing applies to the `?` at the end of the -->
<!-- `read_to_string` call. -->
<p>リスト9-7の文脈では、<code>File::open</code>呼び出し末尾の<code>?</code>は<code>Ok</code>の中身を変数<code>f</code>に返します。
エラーが発生したら、<code>?</code>演算子により関数全体から早期リターンし、あらゆる<code>Err</code>値を呼び出し元に与えます。
同じ法則が<code>read_to_string</code>呼び出し末尾の<code>?</code>にも適用されます。</p>
<!-- The `?` operator eliminates a lot of boilerplate and makes this function’s -->
<!-- implementation simpler. We could even shorten this code further by chaining -->
<!-- method calls immediately after the `?`, as shown in Listing 9-8. -->
<p><code>?</code>演算子により定型コードの多くが排除され、この関数の実装を単純にしてくれます。
リスト9-8で示したように、<code>?</code>の直後のメソッド呼び出しを連結することでさらにこのコードを短くすることさえもできます。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 9-8: Chaining method calls after the `?` -->
<!-- operator</span> -->
<p><span class="caption">リスト9-8: <code>?</code>演算子の後のメソッド呼び出しを連結する</span></p>
<!-- We’ve moved the creation of the new `String` in `s` to the beginning of the -->
<!-- function; that part hasn’t changed. Instead of creating a variable `f`, we’ve -->
<!-- chained the call to `read_to_string` directly onto the result of -->
<!-- `File::open("hello.txt")?`. We still have a `?` at the end of the -->
<!-- `read_to_string` call, and we still return an `Ok` value containing the -->
<!-- username in `s` when both `File::open` and `read_to_string` succeed rather than -->
<!-- returning errors. The functionality is again the same as in Listing 9-6 and -->
<!-- Listing 9-7; this is just a different, more ergonomic way to write it. -->
<p><code>s</code>の新規<code>String</code>の生成を関数の冒頭に移動しました; その部分は変化していません。変数<code>f</code>を生成する代わりに、
<code>read_to_string</code>の呼び出しを直接<code>File::open(&quot;hello.txt&quot;)?</code>の結果に連結させました。
それでも、<code>read_to_string</code>呼び出しの末尾には<code>?</code>があり、<code>File::open</code>と<code>read_to_string</code>両方が成功したら、
エラーを返すというよりもまだ<code>s</code>にユーザ名を含む<code>Ok</code>値を返します。機能もまたリスト9-6及び、9-7と同じです;
ただ単に異なるバージョンのよりプログラマフレンドリーな書き方なのです。</p>
<!-- #### `?` Operator Can Only Be Used in Functions That Return `Result` -->
<a class="header" href="print.html#a演算子はresultを返す関数でしか使用できない" id="a演算子はresultを返す関数でしか使用できない"><h4><code>?</code>演算子は、<code>Result</code>を返す関数でしか使用できない</h4></a>
<!-- The `?` operator can only be used in functions that have a return type of -->
<!-- `Result`, because it is defined to work in the same way as the `match` -->
<!-- expression we defined in Listing 9-6. The part of the `match` that requires a -->
<!-- return type of `Result` is `return Err(e)`, so the return type of the function -->
<!-- must be a `Result` to be compatible with this `return`. -->
<p><code>?</code>演算子は戻り値に<code>Result</code>を持つ関数でしか使用できません。というのも、リスト9-6で定義した<code>match</code>式と同様に動作するよう、
定義されているからです。<code>Result</code>の戻り値型を要求する<code>match</code>の部品は、<code>return Err(e)</code>なので、
関数の戻り値はこの<code>return</code>と互換性を保つために<code>Result</code>でなければならないのです。</p>
<!-- Let’s look at what happens if we use the `?` operator in the `main` function, -->
<!-- which you’ll recall has a return type of `()`: -->
<p><code>main</code>関数で<code>?</code>演算子を使用したらどうなるか見てみましょう。<code>main</code>関数は、戻り値が<code>()</code>でしたね:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<!-- When we compile this code, we get the following error message: -->
<p>このコードをコンパイルすると、以下のようなエラーメッセージが得られます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `(): std::ops::Try` is not satisfied
(エラー: `(): std::ops::Try`というトレイト境界が満たされていません)
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ------------------------
  |             |
  |             the `?` operator can only be used in a function that returns
  `Result` (or another type that implements `std::ops::Try`)
  |             in this macro invocation
  |             (このマクロ呼び出しの`Result`(かまたは`std::ops::Try`を実装する他の型)を返す関数でしか`?`演算子は使用できません)
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  (助言: `std::ops::Try`トレイトは`()`には実装されていません)
  = note: required by `std::ops::Try::from_error`
  (注釈: `std::ops::Try::from_error`で要求されています)
</code></pre>
<!-- This error points out that we’re only allowed to use the `?` operator in a -->
<!-- function that returns `Result`. In functions that don’t return `Result`, when -->
<!-- you call other functions that return `Result`, you’ll need to use a `match` or -->
<!-- one of the `Result` methods to handle the `Result` instead of using the `?` -->
<!-- operator to potentially propagate the error to the calling code. -->
<p>このエラーは、<code>?</code>演算子は<code>Result</code>を返す関数でしか使用が許可されないと指摘しています。
<code>Result</code>を返さない関数では、<code>Result</code>を返す別の関数を呼び出した時、
<code>?</code>演算子を使用してエラーを呼び出し元に委譲する可能性を生み出す代わりに、<code>match</code>か<code>Result</code>のメソッドのどれかを使う必要があるでしょう。</p>
<!-- Now that we’ve discussed the details of calling `panic!` or returning `Result`, -->
<!-- let’s return to the topic of how to decide which is appropriate to use in which -->
<!-- cases. -->
<p>さて、<code>panic!</code>呼び出しや<code>Result</code>を返す詳細について議論し終えたので、
どんな場合にどちらを使うのが適切か決める方法についての話に戻りましょう。</p>
<!-- ## To `panic!` or Not to `panic!` -->
<a class="header" href="print.html#panicすべきかするまいか" id="panicすべきかするまいか"><h2><code>panic!</code>すべきかするまいか</h2></a>
<!-- So how do you decide when you should `panic!` and when you should return -->
<!-- `Result`? When code panics, there’s no way to recover. You could call `panic!` -->
<!-- for any error situation, whether there’s a possible way to recover or not, but -->
<!-- then you’re making the decision on behalf of the code calling your code that a -->
<!-- situation is unrecoverable. When you choose to return a `Result` value, you -->
<!-- give the calling code options rather than making the decision for it. The -->
<!-- calling code could choose to attempt to recover in a way that’s appropriate for -->
<!-- its situation, or it could decide that an `Err` value in this case is -->
<!-- unrecoverable, so it can call `panic!` and turn your recoverable error into an -->
<!-- unrecoverable one. Therefore, returning `Result` is a good default choice when -->
<!-- you’re defining a function that might fail. -->
<p>では、<code>panic!</code>すべき時と<code>Result</code>を返すべき時はどう決定すればいいのでしょうか？コードがパニックしたら、
回復する手段はありません。回復する可能性のある手段の有る無しに関わらず、どんなエラー場面でも<code>panic!</code>を呼ぶことはできますが、
そうすると、呼び出す側のコードの立場に立ってこの場面は回復不能だという決定を下すことになります。
<code>Result</code>値を返す決定をすると、決断を下すのではなく、呼び出し側に選択肢を与えることになります。
呼び出し側は、場面に合わせて回復を試みることを決定したり、この場合の<code>Err</code>値は回復不能と断定して、
<code>panic!</code>を呼び出し、回復可能だったエラーを回復不能に変換することもできます。故に、<code>Result</code>を返却することは、
失敗する可能性のある関数を定義する際には、いい第1選択肢になります。</p>
<!-- In rare situations, it’s more appropriate to write code that panics instead of -->
<!-- returning a `Result` Let’s explore why it’s appropriate to panic in examples, -->
<!-- prototype code, and tests. Then we'll discuss situations in which the compiler -->
<!-- can’t tell that failure is impossible, but you as a human can. The chpater will -->
<!-- conclude with some general guidelines on how to decide whether to panic in -->
<!-- library code. -->
<p>稀な場面では、<code>Result</code>を返すよりもパニックするコードを書く方がより適切になることもあります。
例やプロトタイプコード、テストでパニックするのが適切な理由を探求しましょう。
それからコンパイラは失敗することはないとわからないけれど、人間はできる場面を議論しましょう。
そして、ライブラリコードでパニックするか決定する方法についての一般的なガイドラインで結論づけましょう。</p>
<!-- ### Examples, Prototype Code, and Tests -->
<a class="header" href="print.html#a例プロトタイプコードテスト" id="a例プロトタイプコードテスト"><h3>例、プロトタイプコード、テスト</h3></a>
<!-- When you’re writing an example to illustrate some concept, having robust -->
<!-- error-handling code in the example as well can make the example less clear. In -->
<!-- examples, it’s understood that a call to a method like `unwrap` that could -->
<!-- panic is meant as a placeholder for the way that you’d want your application to -->
<!-- handle errors, which can differ based on what the rest of your code is doing. -->
<p>例を記述して何らかの概念を具体化している時、頑健なエラー処理コードも例に含むことは、例の明瞭さを欠くことになりかねません。
例において、<code>unwrap</code>などのパニックする可能性のあるメソッド呼び出しは、
アプリケーションにエラーを処理してほしい方法へのプレースホルダーを意味していると理解され、
これは残りのコードがしていることによって異なる可能性があります。</p>
<!-- Similarly, the `unwrap` and `expect` methods are very handy when prototyping, -->
<!-- before you’re ready to decide how to handle errors. They leave clear markers in -->
<!-- your code for when you’re ready to make your program more robust. -->
<p>同様に、<code>unwrap</code>や<code>expect</code>メソッドは、エラーの処理法を決定する準備ができる前、プロトタイプの段階では、
非常に便利です。それらにより、コードにプログラムをより頑健にする時の明らかなマーカーが残されるわけです。</p>
<!-- If a method call fails in a test, we’d want the whole test to fail, even if -->
<!-- that method isn’t the functionality under test. Because `panic!` is how a test -->
<!-- is marked as a failure, calling `unwrap` or `expect` is exactly what should -->
<!-- happen. -->
<p>メソッド呼び出しがテスト内で失敗したら、そのメソッドがテスト下に置かれた機能ではなかったとしても、
テスト全体が失敗してほしいでしょう。<code>panic!</code>が、テストが失敗と印づけられる手段なので、
<code>unwrap</code>や<code>expect</code>の呼び出しはスバリ起こるべきことです。</p>
<!-- ### Cases in Which You Have More Information Than the Compiler -->
<a class="header" href="print.html#aコンパイラよりもプログラマがより情報を持っている場合" id="aコンパイラよりもプログラマがより情報を持っている場合"><h3>コンパイラよりもプログラマがより情報を持っている場合</h3></a>
<!-- It would also be appropriate to call `unwrap` when you have some other logic -->
<!-- that ensures the `Result` will have an `Ok` value, but the logic isn’t -->
<!-- something the compiler understands. You’ll still have a `Result` value that you -->
<!-- need to handle: whatever operation you’re calling still has the possibility of -->
<!-- failing in general, even though it’s logically impossible in your particular -->
<!-- situation. If you can ensure by manually inspecting the code that you’ll never -->
<!-- have an `Err` variant, it’s perfectly acceptable to call `unwrap`. Here’s an -->
<!-- example: -->
<p><code>Result</code>が<code>Ok</code>値であると確認する何らかの別のロジックがある場合、<code>unwrap</code>を呼び出すことは適切でしょうが、
コンパイラは、そのロジックを理解はしません。それでも、処理する必要のある<code>Result</code>は存在するでしょう:
呼び出している処理が何であれ、自分の特定の場面では論理的に起こり得なくても、一般的にまだ失敗する可能性はあるわけです。
手動でコードを調査して<code>Err</code>列挙子は存在しないと確認できたら、<code>unwrap</code>を呼び出すことは完全に受容できることです。
こちらが例です:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
#}</code></pre></pre>
<!-- We’re creating an `IpAddr` instance by parsing a hardcoded string. We can see -->
<!-- that `127.0.0.1` is a valid IP address, so it’s acceptable to use `unwrap` -->
<!-- here. However, having a hardcoded, valid string doesn’t change the return type -->
<!-- of the `parse` method: we still get a `Result` value, and the compiler will -->
<!-- still make us handle the `Result` as if the `Err` variant is still a possibility -->
<!-- because the compiler isn’t smart enough to see that this string is always a -->
<!-- valid IP address. If the IP address string came from a user rather than being -->
<!-- hardcoded into the program, and therefore *did* have a possibility of failure, -->
<!-- we’d definitely want to handle the `Result` in a more robust way instead. -->
<p>ハードコードされた文字列を構文解析することで<code>IpAddr</code>インスタンスを生成しています。
プログラマには<code>127.0.0.1</code>が有効なIPアドレスであることがわかるので、ここで<code>unwrap</code>を使用することは、
受容可能なことです。しかしながら、ハードコードされた有効な文字列が存在することは、
<code>parse</code>メソッドの戻り値型を変えることにはなりません: それでも得られるのは、<code>Result</code>値であり、
コンパイラはまだ<code>Err</code>列挙子になる可能性があるかのように<code>Result</code>を処理することを強制してきます。
コンパイラは、この文字列が常に有効なIPアドレスであると把握できるほど利口ではないからです。
プログラムにハードコードされるのではなく、IPアドレス文字列がユーザ起源でそれ故に<em>確かに</em>失敗する可能性がある場合、
絶対に<code>Result</code>をもっと頑健な方法で代わりに処理する必要があるでしょう。</p>
<!-- ### Guidelines for Error Handling -->
<a class="header" href="print.html#aエラー処理のガイドライン" id="aエラー処理のガイドライン"><h3>エラー処理のガイドライン</h3></a>
<!-- It’s advisable to have your code panic when it’s possible that your code -->
<!-- could end up in a bad state. In this context, a *bad state* is when some -->
<!-- assumption, guarantee, contract, or invariant has been broken, such as when -->
<!-- invalid values, contradictory values, or missing values are passed to your -->
<!-- code—plus one or more of the following: -->
<p>コードが悪い状態に陥る可能性があるときにパニックさせるのは、アドバイスされることです。この文脈において、
<em>悪い状態</em>とは、何らかの前提、保証、契約、不変性が破られたことを言い、例を挙げれば、無効な値、
矛盾する値、行方不明な値がコードに渡されることと、さらに以下のいずれか一つ以上の状態であります:</p>
<!-- * The bad state is not something that’s *expected* to happen occasionally. -->
<!-- * Your code after this point needs to rely on not being in this bad state. -->
<!-- * There’s not a good way to encode this information in the types you use. -->
<ul>
<li>悪い状態がときに起こるとは<em>想定</em>されないとき</li>
<li>この時点以降、この悪い状態にないことを頼りにコードが書かれている場合</li>
<li>使用している型にこの情報をコード化するいい手段がないとき</li>
</ul>
<!-- If someone calls your code and passes in values that don’t make sense, the best -->
<!-- choice might be to `panic!` and alert the person using your library to the -->
<!-- bug in their code so they can fix it during development. Similarly, `panic!` is -->
<!-- often appropriate if you’re calling external code that is out of your control -->
<!-- and it returns an invalid state that you have no way of fixing. -->
<p>誰かが自分のコードを呼び出して筋の通らない値を渡してきたら、最善の選択肢は<code>panic!</code>し、
開発段階で修正できるように自分たちのコードにバグがあることをライブラリ使用者に通知することかもしれません。
同様に自分の制御下にない外部コードを呼び出し、修正しようのない無効な状態を返すときに<code>panic!</code>はしばしば適切です。</p>
<!-- When a bad state is reached, but it’s expected to happen no matter how well you -->
<!-- write your code, it’s still more appropriate to return a `Result` rather than -->
<!-- making a `panic!` call. Examples include a parser being given malformed data -->
<!-- or an HTTP request returning a status that indicates you have hit a rate limit. -->
<!-- In these cases, you should indicate that failure is an expected possibility by -->
<!-- returning a `Result` to propagate these bad states upwards so the calling code -->
<!-- can decide how to handle the problem. To call `panic!` wouldn’t be the best way -->
<!-- to handle these cases. -->
<p>悪い状態に達すると、どんなにコードをうまく書いても起こると予想されるが、<code>panic!</code>呼び出しをするよりもまだ、
<code>Result</code>を返すほうがより適切です。例には、不正なデータを渡されたパーサーとか、
訪問制限に引っかかったことを示唆するステータスを返すHTTPリクエストなどが挙げられます。
このような場合には、呼び出し側が問題の処理方法を決定できるように<code>Result</code>を返してこの悪い状態を委譲して、
失敗が予想される可能性であることを示唆するべきです。<code>panic!</code>呼び出すことは、
これらのケースでは最善策ではないでしょう。</p>
<!-- When your code performs operations on values, your code should verify the -->
<!-- values are valid first and panic if the values aren’t valid. This is mostly for -->
<!-- safety reasons: attempting to operate on invalid data can expose your code to -->
<!-- vulnerabilities. This is the main reason the standard library will call -->
<!-- `panic!` if you attempt an out-of-bounds memory access: trying to access memory -->
<!-- that doesn’t belong to the current data structure is a common security problem. -->
<!-- Functions often have *contracts*: their behavior is only guaranteed if the -->
<!-- inputs meet particular requirements. Panicking when the contract is violated -->
<!-- makes sense because a contract violation always indicates a caller-side bug, -->
<!-- and it’s not a kind of error you want the calling code to have to explicitly -->
<!-- handle. In fact, there’s no reasonable way for calling code to recover; the -->
<!-- calling *programmers* need to fix the code. Contracts for a function, -->
<!-- especially when a violation will cause a panic, should be explained in the API -->
<!-- documentation for the function. -->
<p>コードが値に対して処理を行う場合、コードはまず値が有効であることを確認し、
値が有効でなければパニックするべきです。これはほぼ安全性上の理由によるものです: 不正なデータの処理を試みると、
コードを脆弱性に晒す可能性があります。これが、境界外へのメモリアクセスを試みたときに標準ライブラリが<code>panic!</code>を呼び出す主な理由です:
現在のデータ構造に属しないメモリにアクセスを試みることは、ありふれたセキュリティ問題なのです。
関数にはしばしば<em>契約</em>が伴います: 入力が特定の条件を満たすときのみ、振る舞いが保証されるのです。
契約が侵されたときにパニックすることは、道理が通っています。なぜなら、契約侵害は常に呼び出し側のバグを示唆し、
呼び出し側に明示的に処理してもらう必要のある種類のエラーではないからです。実際に、
呼び出し側が回復する合理的な手段はありません; 呼び出し側の<em>プログラマ</em>がコードを修正する必要があるのです。
関数の契約は、特に侵害がパニックを引き起こす際には、関数のAPIドキュメント内で説明されているべきです。</p>
<!-- However, having lots of error checks in all of your functions would be verbose -->
<!-- and annoying. Fortunately, you can use Rust’s type system (and thus the type -->
<!-- checking the compiler does) to do many of the checks for you. If your function -->
<!-- has a particular type as a parameter, you can proceed with your code’s logic -->
<!-- knowing that the compiler has already ensured you have a valid value. For -->
<!-- example, if you have a type rather than an `Option`, your program expects to -->
<!-- have *something* rather than *nothing*. Your code then doesn’t have to handle -->
<!-- two cases for the `Some` and `None` variants: it will only have one case for -->
<!-- definitely having a value. Code trying to pass nothing to your function won’t -->
<!-- even compile, so your function doesn’t have to check for that case at runtime. -->
<!-- Another example is using an unsigned integer type like `u32`, which ensures -->
<!-- the parameter is never negative. -->
<p>ですが、全ての関数でたくさんのエラーチェックを行うことは冗長で煩わしいことでしょう。幸運にも、
Rustの型システム(故にコンパイラが行う型精査)を使用して多くの精査を行ってもらうことができます。
関数の引数に特定の型があるなら、有効な値があるとコンパイラがすでに確認していることを把握して、
コードのロジックに進むことができます。例えば、<code>Option</code>以外の型がある場合、プログラムは、
<em>何もない</em>ではなく<em>何かある</em>と想定します。そうしたらコードは、
<code>Some</code>と<code>None</code>列挙子の2つの場合を処理する必要がなくなるわけです:
確実に値があるという可能性しかありません。関数に何もないことを渡そうとしてくるコードは、
コンパイルが通りもしませんので、その場合を実行時に精査する必要はないわけです。
別の例は、<code>u32</code>のような符号なし整数を使うことであり、この場合、引数は負には絶対にならないことが確認されます。</p>
<!-- ### Creating Custom Types for Validation -->
<a class="header" href="print.html#a有効化のために独自の型を作る" id="a有効化のために独自の型を作る"><h3>有効化のために独自の型を作る</h3></a>
<!-- Let’s take the idea of using Rust’s type system to ensure we have a valid value -->
<!-- one step further and look at creating a custom type for validation. Recall the -->
<!-- guessing game in Chapter 2 in which our code asked the user to guess a number -->
<!-- between 1 and 100. We never validated that the user’s guess was between those -->
<!-- numbers before checking it against our secret number; we only validated that -->
<!-- the guess was positive. In this case, the consequences were not very dire: our -->
<!-- output of “Too high” or “Too low” would still be correct. It would be a -->
<!-- useful enhancement to guide the user toward valid guesses and have different -->
<!-- behavior when a user guesses a number that’s out of range versus when a user -->
<!-- types, for example, letters instead. -->
<p>Rustの型システムを使用して有効な値があると確認するというアイディアを一歩先に進め、
有効化のために独自の型を作ることに目を向けましょう。第2章の数当てゲームで、
コードがユーザに1から100までの数字を推測するよう求めたことを思い出してください。
秘密の数字と照合する前にユーザの推測がそれらの値の範囲にあることを全く確認しませんでした;
推測が正であることしか確認しませんでした。この場合、結果はそれほど悲惨なものではありませんでした:
「大きすぎ」、「小さすぎ」という出力は、それでも正しかったでしょう。ユーザを有効な推測に導き、
ユーザが範囲外の数字を推測したり、例えばユーザが文字を代わりに入力したりしたときに別の挙動をするようにしたら、
有益な改善になるでしょう。</p>
<!-- One way to do this would be to parse the guess as an `i32` instead of only a -->
<!-- `u32` to allow potentially negative numbers, and then add a check for the -->
<!-- number being in range, like so: -->
<p>これをする一つの方法は、ただの<code>u32</code>の代わりに<code>i32</code>として推測をパースし、負の数になる可能性を許可し、
それから数字が範囲に収まっているというチェックを追加することでしょう。そう、以下のように:</p>
<pre><code class="language-rust ignore">loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if guess &lt; 1 || guess &gt; 100 {
        println!(&quot;The secret number will be between 1 and 100.&quot;);
        continue;
    }

    match guess.cmp(&amp;secret_number) {
    // --snip--
}
</code></pre>
<!-- The `if` expression checks whether our value is out of range, tells the user -->
<!-- about the problem, and calls `continue` to start the next iteration of the loop -->
<!-- and ask for another guess. After the `if` expression, we can proceed with the -->
<!-- comparisons between `guess` and the secret number knowing that `guess` is -->
<!-- between 1 and 100. -->
<p>この<code>if</code>式が、値が範囲外かどうかをチェックし、ユーザに問題を告知し、<code>continue</code>を呼び出してループの次の繰り返しを始め、
別の推測を求めます。<code>if</code>式の後、<code>guess</code>は1から100の範囲にあると把握して、<code>guess</code>と秘密の数字の比較に進むことができます。</p>
<!-- However, this is not an ideal solution: if it was absolutely critical that the -->
<!-- program only operated on values between 1 and 100, and it had many functions -->
<!-- with this requirement, having a check like this in every function would be -->
<!-- tedious (and might impact performance). -->
<p>ところが、これは理想的な解決策ではありません: プログラムが1から100の範囲の値しか処理しないことが間違いなく、
肝要であり、この要求がある関数の数が多ければ、このようなチェックを全関数で行うことは、
面倒でパフォーマンスにも影響を及ぼす可能性があるでしょう。</p>
<!-- Instead, we can make a new type and put the validations in a function to create -->
<!-- an instance of the type rather than repeating the validations everywhere. That -->
<!-- way, it’s safe for functions to use the new type in their signatures and -->
<!-- confidently use the values they receive. Listing 9-9 shows one way to define a -->
<!-- `Guess` type that will only create an instance of `Guess` if the `new` function -->
<!-- receives a value between 1 and 100. -->
<p>代わりに、新しい型を作ってバリデーションを関数内に閉じ込め、バリデーションを全箇所で繰り返すのではなく、
その型のインスタンスを生成することができます。そうすれば、関数がその新しい型をシグニチャに用い、
受け取った値を自信を持って使用することは安全になります。リスト9-9に、<code>new</code>関数が1から100までの値を受け取った時のみ、
<code>Guess</code>のインスタンスを生成する<code>Guess</code>型を定義する一つの方法を示しました。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }

    pub fn value(&amp;self) -&gt; u32 {
        self.value
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 9-9: A `Guess` type that will only continue with -->
<!-- values between 1 and 100</span> -->
<p><span class="caption">リスト9-9: 値が1から100の場合のみ処理を継続する<code>Guess</code>型</span></p>
<!-- First, we define a struct named `Guess` that has a field named `value` that -->
<!-- holds a `u32`. This is where the number will be stored. -->
<p>まず、<code>u32</code>型の<code>value</code>をフィールドに持つ<code>Guess</code>という名前の構造体を定義しています。
ここに数値が保管されます。</p>
<!-- Then we implement an associated function named `new` on `Guess` that creates -->
<!-- instances of `Guess` values. The `new` function is defined to have one -->
<!-- parameter named `value` of type `u32` and to return a `Guess`. The code in the -->
<!-- body of the `new` function tests `value` to make sure it’s between 1 and 100. -->
<!-- If `value` doesn’t pass this test, we make a `panic!` call, which will alert -->
<!-- the programmer who is writing the calling code that they have a bug they need -->
<!-- to fix, because creating a `Guess` with a `value` outside this range would -->
<!-- violate the contract that `Guess::new` is relying on. The conditions in which -->
<!-- `Guess::new` might panic should be discussed in its public-facing API -->
<!-- documentation; we’ll cover documentation conventions indicating the possibility -->
<!-- of a `panic!` in the API documentation that you create in Chapter 14. If -->
<!-- `value` does pass the test, we create a new `Guess` with its `value` field set -->
<!-- to the `value` parameter and return the `Guess`. -->
<p>それから<code>Guess</code>に<code>Guess</code>値のインスタンスを生成する<code>new</code>という名前の関連関数を実装しています。
<code>new</code>関数は、<code>u32</code>型の<code>value</code>という引数を取り、<code>Guess</code>を返すように定義されています。
<code>new</code>関数の本体のコードは、<code>value</code>をふるいにかけ、1から100の範囲であることを確かめます。
<code>value</code>がふるいに引っかかったら、<code>panic!</code>呼び出しを行います。これにより、呼び出しコードを書いているプログラマに、
修正すべきバグがあると警告します。というのも、この範囲外の<code>value</code>で<code>Guess</code>を生成することは、
<code>Guess::new</code>が頼りにしている契約を侵害するからです。<code>Guess::new</code>がパニックするかもしれない条件は、
公開されているAPIドキュメントで議論されるべきでしょう; あなたが作成するAPIドキュメントで<code>panic!</code>の可能性を示唆する、
ドキュメントの規約は、第14章で解説します。<code>value</code>が確かにふるいを通ったら、
<code>value</code>フィールドが<code>value</code>引数にセットされた新しい<code>Guess</code>を作成して返します。</p>
<!-- Next, we implement a method named `value` that borrows `self`, doesn’t have any -->
<!-- other parameters, and returns a `u32`. This kind of method is sometimes called -->
<!-- a *getter*, because its purpose is to get some data from its fields and return -->
<!-- it. This public method is necessary because the `value` field of the `Guess` -->
<!-- struct is private. It’s important that the `value` field is private so code -->
<!-- using the `Guess` struct is not allowed to set `value` directly: code outside -->
<!-- the module *must* use the `Guess::new` function to create an instance of -->
<!-- `Guess`, thereby ensuring there’s no way for a `Guess` to have a `value` that -->
<!-- hasn’t been checked by the conditions in the `Guess::new` function. -->
<p>次に、<code>self</code>を借用し、他に引数はなく、<code>u32</code>を返す<code>value</code>というメソッドを実装します。
この類のメソッドは時に<em>ゲッター</em>と呼ばれます。目的がフィールドから何らかのデータを得て返すことだからです。
この公開メソッドは、<code>Guess</code>構造体の<code>value</code>フィールドが非公開なので、必要になります。
<code>value</code>フィールドが非公開なことは重要であり、そのために<code>Guess</code>構造体を使用するコードは、
直接<code>value</code>をセットすることが叶わないのです: モジュール外のコードは、
<code>Guess::new</code>関数を使用して<code>Guess</code>のインスタンスを生成し<em>なければならず</em>、
それにより、<code>Guess::new</code>関数の条件式でチェックされていない<code>value</code>が<code>Guess</code>に存在する手段はないことが保証されるわけです。</p>
<!-- A function that has a parameter or returns only numbers between 1 and 100 could -->
<!-- then declare in its signature that it takes or returns a `Guess` rather than a -->
<!-- `u32` and wouldn’t need to do any additional checks in its body. -->
<p>そうしたら、引数を一つ持つか、1から100の範囲の数値のみを返す関数は、シグニチャで<code>u32</code>ではなく、
<code>Guess</code>を取るか返し、本体内で追加の確認を行う必要はなくなると宣言できるでしょう。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-8" id="aまとめ-8"><h2>まとめ</h2></a>
<!-- Rust’s error handling features are designed to help you write more robust code. -->
<!-- The `panic!` macro signals that your program is in a state it can’t handle and -->
<!-- lets you tell the process to stop instead of trying to proceed with invalid or -->
<!-- incorrect values. The `Result` enum uses Rust’s type system to indicate that -->
<!-- operations might fail in a way that your code could recover from. You can use -->
<!-- `Result` to tell code that calls your code that it needs to handle potential -->
<!-- success or failure as well. Using `panic!` and `Result` in the appropriate -->
<!-- situations will make your code more reliable in the face of inevitable problems. -->
<p>Rustのエラー処理機能は、プログラマがより頑健なコードを書く手助けをするように設計されています。
<code>panic!</code>マクロは、プログラムが処理できない状態にあり、無効だったり不正な値で処理を継続するのではなく、
プロセスに処理を中止するよう指示することを通知します。<code>Result</code> enumは、Rustの型システムを使用して、
コードが回復可能な方法で処理が失敗するかもしれないことを示唆します。<code>Result</code>を使用して、
呼び出し側のコードに成功や失敗する可能性を処理する必要があることも教えます。
適切な場面で<code>panic!</code>や<code>Result</code>を使用することで、必然的な問題の眼前でコードの信頼性を上げてくれます。</p>
<!-- Now that you’ve seen useful ways that the standard library uses generics with -->
<!-- the `Option` and `Result` enums, we’ll talk about how generics work and how you -->
<!-- can use them in your code. -->
<p>今や、標準ライブラリが<code>Option</code>や<code>Result</code> enumなどでジェネリクスを有効活用するところを目の当たりにしたので、
ジェネリクスの動作法と自分のコードでの使用方法について語りましょう。</p>
<!-- # Generic Types, Traits, and Lifetimes -->
<a class="header" href="print.html#aジェネリック型トレイトライフタイム" id="aジェネリック型トレイトライフタイム"><h1>ジェネリック型、トレイト、ライフタイム</h1></a>
<!-- Every programming language has tools for effectively handling the duplication -->
<!-- of concepts. In Rust, one such tool is *generics*. Generics are abstract -->
<!-- stand-ins for concrete types or other properties. When we’re writing code, we -->
<!-- can express the behavior of generics or how they relate to other generics -->
<!-- without knowing what will be in their place when compiling and running the code. -->
<p>全てのプログラミング言語には、概念の重複を効率的に扱う道具があります。Rustにおいて、そのような道具の一つが<em>ジェネリクス</em>です。
ジェネリクスは、具体型や他のプロパティの抽象的な代役です。コード記述の際、コンパイルやコード実行時に、
ジェネリクスの位置に何が入るかを知ることなく、ジェネリクスの振る舞いや他のジェネリクスとの関係を表現できるのです。</p>
<!-- Similar to the way a function takes parameters with unknown values to run the -->
<!-- same code on multiple concrete values, functions can take parameters of some -->
<!-- generic type instead of a concrete type, like `i32` or `String`. In fact, we’ve -->
<!-- already used generics in Chapter 6 with `Option<T>`, Chapter 8 with `Vec<T>` -->
<!-- and `HashMap<K, V>`, and Chapter 9 with `Result<T, E>`. In this chapter, you’ll -->
<!-- explore how to define your own types, functions, and methods with generics! -->
<p>関数が未知の値の引数を取り、同じコードを複数の具体的な値に対して走らせるように、
<code>i32</code>や<code>String</code>などの具体的な型の代わりに何かジェネリックな型の引数を取ることができます。
実際、第6章で<code>Option&lt;T&gt;</code>、第8章で<code>Vec&lt;T&gt;</code>と<code>HashMap&lt;K, V&gt;</code>、第9章で<code>Result&lt;T, E&gt;</code>を既に使用しました。
この章では、独自の型、関数、メソッドをジェネリクスとともに定義する方法を探求します！</p>
<!-- First, we’ll review how to extract a function to reduce code duplication. Next, -->
<!-- we’ll use the same technique to make a generic function from two functions that -->
<!-- differ only in the types of their parameters. We’ll also explain how to use -->
<!-- generic types in struct and enum definitions. -->
<p>まず、関数を抽出して、コードの重複を減らす方法を確認しましょう。次に同じテクニックを活用して、
引数の型のみが異なる2つの関数からジェネリックな関数を生成します。また、
ジェネリックな型を構造体やenum定義で使用する方法も説明します。</p>
<!-- Then you’ll learn how to use *traits* to define behavior in a generic way. You -->
<!-- can combine traits with generic types to constrain a generic type to only -->
<!-- those types that have a particular behavior, as opposed to just any type. -->
<p>それから、トレイトを使用して、ジェネリックな方法で振る舞いを定義する方法を学びます。
ジェネリックな型のあるトレイトを組み合わせてただ単にどんな型に対してもとは対照的に、
ジェネリックな型を特定の振る舞いのある型のみに制限することができます。</p>
<!-- Finally, we’ll discuss *lifetimes*, a variety of generics that give the -->
<!-- compiler information about how references relate to each other. Lifetimes allow -->
<!-- us to borrow values in many situations while still enabling the compiler to -->
<!-- check that the references are valid. -->
<p>最後に、ライフタイムを議論します。ライフタイムとは、コンパイラに参照がお互いにどう関係しているかの情報を与える1種のジェネリクスです。
ライフタイムのおかげでコンパイラに参照が有効であることを確認してもらうことを可能にしつつ、多くの場面で値を借用できます。</p>
<!-- ## Removing Duplication by Extracting a Function -->
<a class="header" href="print.html#a関数を抽出することで重複を取り除く" id="a関数を抽出することで重複を取り除く"><h2>関数を抽出することで重複を取り除く</h2></a>
<!-- Before diving into generics syntax, let’s first look at how to remove -->
<!-- duplication that doesn’t involve generic types by extracting a function. Then -->
<!-- we’ll apply this technique to extract a generic function! In the same way that -->
<!-- you recognize duplicated code to extract into a function, you’ll start to -->
<!-- recognize duplicated code that can use generics. -->
<p>ジェネリクスの記法に飛び込む前にまずは、関数を抽出することでジェネリックな型が関わらない重複を取り除く方法を見ましょう。
そして、このテクニックを適用してジェネリックな関数を抽出するのです！重複したコードを認識して関数に抽出できるのと同じように、
ジェネリクスを使用できる重複コードも認識し始めるでしょう。</p>
<!-- Consider a short program that finds the largest number in a list, as shown in -->
<!-- Listing 10-1. -->
<p>リスト10-1に示したように、リスト内の最大値を求める短いプログラムを考えてください。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    // 最大値は{}です
    println!(&quot;The largest number is {}&quot;, largest);
#  assert_eq!(largest, 100);
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-1: Code to find the largest number in a list -->
<!-- of numbers</span> -->
<p><span class="caption">リスト10-1: 数字のリストから最大値を求めるコード</span></p>
<!-- This code stores a list of integers in the variable `number_list` and places -->
<!-- the first number in the list in a variable named `largest`. Then it iterates -->
<!-- through all the numbers in the list, and if the current number is greater than -->
<!-- the number stored in `largest`, it replaces the number in that variable. -->
<!-- However, if the current number is less than the largest number seen so far, the -->
<!-- variable doesn’t change, and the code moves on to the next number in the list. -->
<!-- After considering all the numbers in the list, `largest` should hold the -->
<!-- largest number, which in this case is 100. -->
<p>このコードは、整数のリストを変数<code>number_list</code>に格納し、リストの最初の数字を<code>largest</code>という変数に配置しています。
それからリストの数字全部を走査し、現在の数字が<code>largest</code>に格納された数値よりも大きければ、
その変数の値を置き換えます。ですが、現在の数値が今まで見た最大値よりも小さければ、
変数は変わらず、コードはリストの次の数値に移っていきます。リストの数値全てを吟味した後、
<code>largest</code>は最大値を保持しているはずで、今回は100になります。</p>
<!-- To find the largest number in two different lists of numbers, we can duplicate -->
<!-- the code in Listing 10-1 and use the same logic at two different places in the -->
<!-- program, as shown in Listing 10-2. -->
<p>2つの異なる数値のリストから最大値を発見するには、リスト10-1のコードを複製し、
プログラムの異なる2箇所で同じロジックを使用できます。リスト10-2のようにですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-2: Code to find the largest number in *two* -->
<!-- lists of numbers</span> -->
<p><span class="caption">リスト10-2: <em>2</em>つの数値のリストから最大値を探すコード</span></p>
<!-- Although this code works, duplicating code is tedious and error prone. We also -->
<!-- have to update the code in multiple places whe we want to change it. -->
<p>このコードは動くものの、コードを複製することは退屈ですし、間違いも起きやすいです。また、
複数箇所のコードを変更したい時に更新しなければなりません。</p>
<!-- To eliminate this duplication, we can create an abstraction by defining a -->
<!-- function that operates on any list of integers given to it in a parameter. This -->
<!-- solution makes our code clearer and lets us express the concept of finding the -->
<!-- largest number in a list abstractly. -->
<p>この重複を排除するには、引数で与えられた整数のどんなリストに対しても処理が行える関数を定義して抽象化できます。
この解決策によりコードがより明確になり、リストの最大値を探すという概念を抽象的に表現させてくれます。</p>
<!-- In Listing 10-3, we extracted the code that finds the largest number into a -->
<!-- function named `largest`. Unlike the code in Listing 10-1, which can find the -->
<!-- largest number in only one particular list, this program can find the largest -->
<!-- number in two different lists. -->
<p>リスト10-3では、最大値を探すコードを<code>largest</code>という関数に抽出しました。リスト10-1のコードは、
たった1つの特定のリストからだけ最大値を探せますが、それとは異なり、このプログラムは2つの異なるリストから最大値を探せます。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 6000);
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-3: Abstracted code to find the largest number -->
<!-- in two lists</span> -->
<p><span class="caption">リスト10-3: 2つのリストから最大値を探す抽象化されたコード</span></p>
<!-- The `largest` function has a parameter called `list`, which represents any -->
<!-- concrete slice of `i32` values that we might pass into the function. As a -->
<!-- result, when we call the function, the code runs on the specific values that we -->
<!-- pass in. -->
<p><code>largest</code>関数には<code>list</code>と呼ばれる引数があり、これは、関数に渡す可能性のあるあらゆる<code>i32</code>値の具体的なスライスを示します。
結果的に、関数呼び出しの際、コードは渡した特定の値に対して走るのです。</p>
<!-- In sum, here are the steps we took to change the code from Listing 10-2 to -->
<!-- Listing 10-3: -->
<p>まとめとして、こちらがリスト10-2のコードからリスト10-3に変更するのに要したステップです:</p>
<!-- 1. Identify duplicate code. -->
<!-- 2. Extract the duplicate code into the body of the function and specify the -->
<!--    inputs and return values of that code in the function signature. -->
<!-- 3. Update the two instances of duplicated code to call the function instead. -->
<ol>
<li>重複したコードを認識する。</li>
<li>重複コードを関数本体に抽出し、コードの入力と戻り値を関数シグニチャで指定する。</li>
<li>重複したコードの2つの実体を代わりに関数を呼び出すように更新する。</li>
</ol>
<!-- Next, we’ll use these same steps with generics to reduce code duplication in -->
<!-- different ways. In the same way that the function body can operate on an -->
<!-- abstract `list` instead of specific values, generics allow code to operate on -->
<!-- abstract types. -->
<p>次は、この同じ手順をジェネリクスでも踏んで異なる方法でコードの重複を減らします。
関数本体が特定の値ではなく抽象的な<code>list</code>に対して処理できたのと同様に、
ジェネリクスは抽象的な型に対して処理するコードを可能にしてくれます。</p>
<!-- For example, say we had two functions: one that finds the largest item in a -->
<!-- slice of `i32` values and one that finds the largest item in a slice of `char` -->
<!-- values. How would we eliminate that duplication? Let’s find out! -->
<p>例えば、関数が2つあるとしましょう: 1つは<code>i32</code>値のスライスから最大の要素を探し、1つは<code>char</code>値のスライスから最大要素を探します。
この重複はどう排除するのでしょうか？答えを見つけましょう！</p>
<!-- ## Generic Data Types -->
<a class="header" href="print.html#aジェネリックなデータ型" id="aジェネリックなデータ型"><h2>ジェネリックなデータ型</h2></a>
<!-- We can use generics to create definitions for items like function signatures or -->
<!-- structs, which we can then use with many different concrete data types. Let’s -->
<!-- first look at how to define functions, structs, enums, and methods using -->
<!-- generics. Then we’ll discuss how generics affect code performance. -->
<p>関数シグニチャや構造体などの要素の定義を生成するのにジェネリクスを使用することができ、
それはさらに他の多くの具体的なデータ型と使用することもできます。まずは、
ジェネリクスで関数、構造体、enum、メソッドを定義する方法を見ましょう。それから、
ジェネリクスがコードのパフォーマンスに与える影響を議論します。</p>
<!-- ### In Function Definitions -->
<a class="header" href="print.html#a関数定義では" id="a関数定義では"><h3>関数定義では</h3></a>
<!-- When defining a function that uses generics, we place the generics in the -->
<!-- signature of the function where we would usually specify the data types of the -->
<!-- parameters and return value. Doing so makes our code more flexible and provides -->
<!-- more functionality to callers of our function while preventing code duplication. -->
<p>ジェネリクスを使用する関数を定義する時、通常、引数や戻り値のデータ型を指定する関数のシグニチャにジェネリクスを配置します。
そうすることでコードがより柔軟になり、コードの重複を阻止しつつ、関数の呼び出し元により多くの機能を提供します。</p>
<!-- Continuing with our `largest` function, Listing 10-4 shows two functions that -->
<!-- both find the largest value in a slice. -->
<p><code>largest</code>関数を続けます。リスト10-4はどちらもスライスから最大値を探す2つの関数を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
#    assert_eq!(result, 'y');
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-4: Two functions that differ only in their -->
<!-- names and the types in their signatures</span> -->
<p><span class="caption">リスト10-4: 名前とシグニチャの型のみが異なる2つの関数</span></p>
<!-- The `largest_i32` function is the one we extracted in Listing 10-3 that finds -->
<!-- the largest `i32` in a slice. The `largest_char` function finds the largest -->
<!-- `char` in a slice. The function bodies have the same code, so let’s eliminate -->
<!-- the duplication by introducing a generic type parameter in a single function. -->
<p><code>largest_i32</code>関数は、リスト10-3で抽出したスライスから最大の<code>i32</code>を探す関数です。
<code>largest_char</code>関数は、スライスから最大の<code>char</code>を探します。関数本体には同じコードがあるので、
単独の関数にジェネリックな型引数を導入してこの重複を排除しましょう。</p>
<!-- To parameterize the types in the new function we’ll define, we need to name the -->
<!-- type parameter, just as we do for the value parameters to a function. You can -->
<!-- use any identifier as a type parameter name. But we’ll use `T` because, by -->
<!-- convention, parameter names in Rust are short, often just a letter, and Rust’s -->
<!-- type-naming convention is CamelCase. Short for “type,” `T` is the default -->
<!-- choice of most Rust programmers. -->
<p>これから定義する新しい関数の型を引数にするには、ちょうど関数の値引数のように型引数に名前をつける必要があります。
型引数の名前にはどんな識別子も使用できますが、<code>T</code>を使用します。というのも、慣習では、
Rustの引数名は短く(しばしばたった1文字になります)、Rustの型の命名規則がキャメルケースだからです。
&quot;type&quot;の省略形なので、<code>T</code>が多くのRustプログラマの規定の選択なのです。</p>
<!-- When we use a parameter in the body of the function, we have to declare the -->
<!-- parameter name in the signature so the compiler knows what that name means. -->
<!-- Similarly, when we use a type parameter name in a function signature, we have -->
<!-- to declare the type parameter name before we use it. To define the generic -->
<!-- `largest` function, place type name declarations inside angle brackets, `<>`, -->
<!-- between the name of the function and the parameter list, like this: -->
<p>関数の本体で引数を使用すると、コンパイラがその名前の意味を知れるようにシグニチャでその引数名を宣言しなければなりません。
同様に、型引数名を関数シグニチャで使用する際には、使用する前に型引数名を宣言しなければなりません。
ジェネリックな<code>largest</code>関数を定義するために、型名宣言を山カッコ(<code>&lt;&gt;</code>)内、関数名と引数リストの間に配置してください。
こんな感じに:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<!-- We read this definition as: the function `largest` is generic over some type -->
<!-- `T`. This function has one parameter named `list`, which is a slice of values -->
<!-- of type `T`. The `largest` function will return a value of the same type `T`. -->
<p>この定義は以下のように解読します: 関数<code>largest</code>は、なんらかの型<code>T</code>に関してジェネリックであると。
この関数には<code>list</code>という引数が1つあり、これは型<code>T</code>の値のスライスです。
<code>largest</code>関数は同じ<code>T</code>型の値を返します。</p>
<!-- Listing 10-5 shows the combined `largest` function definition using the generic -->
<!-- data type in its signature. The listing also shows how we can call the function -->
<!-- with either a slice of `i32` values or `char` values. Note that this code won’t -->
<!-- compile yet, but we’ll fix it later in this chapter. -->
<p>リスト10-5は、シグニチャにジェネリックなデータ型を使用して<code>largest</code>関数定義を組み合わせたものを示しています。
このリストはさらに、この関数を<code>i32</code>値か<code>char</code>値のどちらかで呼べる方法も表示しています。
このコードはまだコンパイルできないことに注意してください。ですが、この章の後ほど修正します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<!-- <span class="caption">Listing 10-5: A definition of the `largest` function that -->
<!-- uses generic type parameters but doesn’t compile yet</span> -->
<p><span class="caption">リスト10-5: ジェネリックな型引数を使用するものの、まだコンパイルできない<code>largest</code>関数の定義</span></p>
<!-- If we compile this code right now, we’ll get this error: -->
<p>直ちにこのコードをコンパイルしたら、以下のようなエラーが出ます:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
(エラー: 2項演算`&gt;`は、型`T`に適用できません)
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
  (注釈: `std::cmp&quot;&quot;PartialOrd`の実装が`T`に対して不足しています)
</code></pre>
<!-- The note mentions `std::cmp::PartialOrd`, which is a *trait*. We’ll talk about -->
<!-- traits in the next section. For now, this error states that the body of -->
<!-- `largest` won’t work for all possible types that `T` could be. Because we want -->
<!-- to compare values of type `T` in the body, we can only use types whose values -->
<!-- can be ordered. To enable comparisons, the standard library has the -->
<!-- `std::cmp::PartialOrd` trait that you can implement on types (see Appendix C -->
<!-- for more on this trait). You’ll learn how to specify that a generic type has a -->
<!-- particular trait in the “Trait Bounds” section, but let’s first explore other -->
<!-- ways of using generic type parameters. -->
<p>注釈が<code>std::cmp::PartialOrd</code>に触れていて、これは、<em>トレイト</em>です。トレイトについては、次の節で語ります。
とりあえず、このエラーは、<code>largest</code>の本体は、<code>T</code>がなりうる全ての可能性のある型に対して動作しないと述べています。
本体で型<code>T</code>の値を比較したいので、値が順序付け可能な型のみしか使用できないのです。比較を可能にするために、
標準ライブラリには型に実装できる<code>std::cmp::PartialOrd</code>トレイトがあります(このトレイトについて詳しくは付録Cを参照されたし)。
ジェネリックな型が特定のトレイトを持つと指定する方法は「トレイト境界」節で習うでしょうが、
先にジェネリックな型引数を使用する他の方法を探求しましょう。</p>
<!-- ### In Struct Definitions -->
<a class="header" href="print.html#a構造体定義では" id="a構造体定義では"><h3>構造体定義では</h3></a>
<!-- We can also define structs to use a generic type parameter in one or more -->
<!-- fields using the `<>` syntax. Listing 10-6 shows how to define a `Point<T>` -->
<!-- struct to hold `x` and `y` coordinate values of any type. -->
<p>また、構造体を定義して<code>&lt;&gt;</code>記法で1つ以上のフィールドにジェネリックな型引数を使用することもできます。
リスト10-6は、<code>Point&lt;T&gt;</code>構造体を定義してあらゆる型の<code>x</code>と<code>y</code>座標を保持する方法を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-6: A `Point<T>` struct that holds `x` and `y` -->
<!-- values of type `T`</span> -->
<p><span class="caption">リスト10-6: 型<code>T</code>の<code>x</code>と<code>y</code>値を保持する<code>Point&lt;T&gt;</code>構造体</span></p>
<!-- The syntax for using generics in struct definitions is similar to that used in -->
<!-- function definitions. First, we declare the name of the type parameter inside -->
<!-- angle brackets just after the name of the struct. Then we can use the generic -->
<!-- type in the struct definition where we would otherwise specify concrete data -->
<!-- types. -->
<p>構造体定義でジェネリクスを使用する記法は、関数定義のものと似ています。まず、山カッコ内に型引数の名前を構造体名の直後に宣言します。
そして、そうしていなければ具体的なデータ型を記述する構造体定義の箇所にジェネリックな型を使用できます。</p>
<!-- Note that because we’ve used only one generic type to define `Point<T>`, this -->
<!-- definition says that the `Point<T>` struct is generic over some type `T`, and -->
<!-- the fields `x` and `y` are *both* that same type, whatever that type may be. If -->
<!-- we create an instance of a `Point<T>` that has values of different types, as in -->
<!-- Listing 10-7, our code won’t compile. -->
<p>1つのジェネリックな型だけを使用して<code>Point&lt;T&gt;</code>を定義したので、この定義は、<code>Point&lt;T&gt;</code>構造体がなんらかの型<code>T</code>に関して、
ジェネリックであると述べていてその型がなんであれ、<code>x</code>と<code>y</code>のフィールドは<em>両方</em>その同じ型になっていることに注意してください。
リスト10-7のように、異なる型の値のある<code>Point&lt;T&gt;</code>のインスタンスを生成すれば、コードはコンパイルできません。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<!-- <span class="caption">Listing 10-7: The fields `x` and `y` must be the same -->
<!-- type because both have the same generic data type `T`.</span> -->
<p><span class="caption">リスト10-7: どちらも同じジェネリックなデータ型<code>T</code>なので、<code>x</code>と<code>y</code>というフィールドは同じ型でなければならない</span></p>
<!-- In this example, when we assign the integer value 5 to `x`, we let the -->
<!-- compiler know that the generic type `T` will be an integer for this instance of -->
<!-- `Point<T>`. Then when we specify 4.0 for `y`, which we’ve defined to have the -->
<!-- same type as `x`, we’ll get a type mismatch error like this: -->
<p>この例で、<code>x</code>に整数値5を代入すると、この<code>Point&lt;T&gt;</code>のインスタンスに対するジェネリックな型<code>T</code>は整数になるとコンパイラに知らせます。
それから<code>y</code>に4.0を指定する時に、このフィールドは<code>x</code>と同じ型と定義したはずなので、このように型不一致エラーが出ます:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
floating-point variable
  |
  = note: expected type `{integer}`
             found type `{float}`
</code></pre>
<!-- To define a `Point` struct where `x` and `y` are both generics but could have -->
<!-- different types, we can use multiple generic type parameters. For example, in -->
<!-- Listing 10-8, we can change the definition of `Point` to be generic over types -->
<!-- `T` and `U` where `x` is of type `T` and `y` is of type `U`. -->
<p><code>x</code>と<code>y</code>が両方ジェネリックだけれども、異なる型になり得る<code>Point</code>構造体を定義するには、
複数のジェネリックな型引数を使用できます。例えば、リスト10-8では、<code>Point</code>の定義を変更して、
型<code>T</code>と<code>U</code>に関してジェネリックにし、<code>x</code>が型<code>T</code>で、<code>y</code>が型<code>U</code>になります。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-8: A `Point<T, U>` generic over two types so -->
<!-- that `x` and `y` can be values of different types</span> -->
<p><span class="caption">リスト10-8: <code>Point&lt;T, U&gt;</code>は2つの型に関してジェネリックなので、<code>x</code>と<code>y</code>は異なる型の値になり得る</span></p>
<!-- Now all the instances of `Point` shown are allowed! You can use as many generic -->
<!-- type parameters in a definition as you want, but using more than a few makes -->
<!-- your code hard to read. When you need lots of generic types in your code, it -->
<!-- could indicate that your code needs restructuring into smaller pieces. -->
<p>もう、示された<code>Point</code>インスタンスは全部許可されます！所望の数だけ定義でジェネリックな型引数を使用できますが、
数個以上使用すると、コードが読みづらくなります。コードで多くのジェネリックな型が必要な時は、
コードの小分けが必要なサインかもしれません。</p>
<!-- ### In Enum Definitions -->
<a class="header" href="print.html#enum定義では" id="enum定義では"><h3>enum定義では</h3></a>
<!-- As we did with structs, we can define enums to hold generic data types in their -->
<!-- variants. Let’s take another look at the `Option<T>` enum that the standard -->
<!-- library provides, which we used in Chapter 6: -->
<p>構造体のように、列挙子にジェネリックなデータ型を保持するenumを定義することができます。
標準ライブラリが提供している<code>Option&lt;T&gt;</code> enumに別の見方をしましょう。このenumは第6章で使用しました:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<!-- This definition should now make more sense to you. As you can see, `Option<T>` -->
<!-- is an enum that is generic over type `T` and has two variants: `Some`, which -->
<!-- holds one value of type `T`, and a `None` variant that doesn’t hold any value. -->
<!-- By using the `Option<T>` enum, we can express the abstract concept of having an -->
<!-- optional value, and because `Option<T>` is generic, we can use this abstraction -->
<!-- no matter what the type of the optional value is. -->
<p>この定義はもう、あなたにとって道理が通っているはずです。ご覧の通り、<code>Option&lt;T&gt;</code>は、
型<code>T</code>に関してジェネリックで2つの列挙子を持つenumです: その列挙子は、型<code>T</code>の値を保持する<code>Some</code>と、
値を何も保持しない<code>None</code>です。<code>Option&lt;T&gt;</code> enumを使用することで、オプショナルな値があるという抽象的な概念を表現でき、
<code>Option&lt;T&gt;</code>はジェネリックなので、オプショナルな値の型に関わらず、この抽象を使用できます。</p>
<!-- Enums can use multiple generic types as well. The definition of the `Result` -->
<!-- enum that we used in Chapter 9 is one example: -->
<p>enumも複数のジェネリックな型を使用できます。第9章で使用した<code>Result</code> enumの定義が一例です:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<!-- The `Result` enum is generic over two types, `T` and `E`, and has two variants: -->
<!-- `Ok`, which holds a value of type `T`, and `Err`, which holds a value of type -->
<!-- `E`. This definition makes it convenient to use the `Result` enum anywhere we -->
<!-- have an operation that might succeed (return a value of some type `T`) or fail -->
<!-- (return an error of some type `E`). In fact, this is what we used to open a -->
<!-- file in Listing 9-3, where `T` was filled in with the type `std::fs::File` when -->
<!-- the file was opened successfully and `E` was filled in with the type -->
<!-- `std::io::Error` when there were problems opening the file. -->
<p><code>Result</code> enumは2つの型<code>T</code>、<code>E</code>に関してジェネリックで、2つの列挙子があります: 型<code>T</code>の値を保持する<code>Ok</code>と、
型<code>E</code>の値を保持する<code>Err</code>です。この定義により、<code>Result</code> enumを成功する(なんらかの型<code>T</code>の値を返す)か、
失敗する(なんらかの型<code>E</code>のエラーを返す)可能性のある処理があるあらゆる箇所に使用するのが便利になります。
事実、ファイルを開くのに成功した時に<code>T</code>に型<code>std::fs::File</code>が入り、ファイルを開く際に問題があった時に<code>E</code>に型<code>std::io::Error</code>が入ったものが、
リスト9-3でファイルを開くのに使用したものです。</p>
<!-- When you recognize situations in your code with multiple struct or enum -->
<!-- definitions that differ only in the types of the values they hold, you can -->
<!-- avoid duplication by using generic types instead. -->
<p>自分のコード内で保持している値の型のみが異なる構造体やenum定義の場面を認識したら、
代わりにジェネリックな型を使用することで重複を避けることができます。</p>
<!-- ### In Method Definitions -->
<a class="header" href="print.html#aメソッド定義では" id="aメソッド定義では"><h3>メソッド定義では</h3></a>
<!-- We can implement methods on structs and enums (as we did in Chapter 5) and use -->
<!-- generic types in their definitions, too. Listing 10-9 shows the `Point<T>` -->
<!-- struct we defined in Listing 10-6 with a method named `x` implemented on it. -->
<p>(第5章のように、)定義にジェネリックな型を使うメソッドを構造体やenumに実装することもできます。リスト10-9は、
リスト10-6で定義した<code>Point&lt;T&gt;</code>構造体に<code>x</code>というメソッドを実装したものを示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-9: Implementing a method named `x` on the -->
<!-- `Point<T>` struct that will return a reference to the `x` field of type -->
<!-- `T`</span> -->
<p><span class="caption">リスト10-9: 型<code>T</code>の<code>x</code>フィールドへの参照を返す<code>x</code>というメソッドを<code>Point&lt;T&gt;</code>構造体に実装する</span></p>
<!-- Here, we’ve defined a method named `x` on `Point<T>` that returns a reference -->
<!-- to the data in the field `x`. -->
<p>ここで、フィールド<code>x</code>のデータへの参照を返す<code>x</code>というメソッドを<code>Point&lt;T&gt;</code>に定義しました。</p>
<!-- Note that we have to declare `T` just after `impl` so we can use it to specify -->
<!-- that we’re implementing methods on the type `Point<T>`.  By declaring `T` as a -->
<!-- generic type after `impl`, Rust can identify that the type in the angle -->
<!-- brackets in `Point` is a generic type rather than a concrete type. -->
<p>型<code>Point&lt;T&gt;</code>にメソッドを実装していると指定するために<code>T</code>を使用できるよう<code>impl</code>の直後に宣言しなければならないことに注意してください。
<code>impl</code>の後に<code>T</code>をジェネリックな型として宣言することで、コンパイラは、<code>Point</code>の山カッコ内の型が、
具体的な型ではなくジェネリックな型であることを認識できるのです。</p>
<!-- We could, for example, implement methods only on `Point<f32>` instances rather -->
<!-- than on `Point<T>` instances with any generic type. In Listing 10-10 we use the -->
<!-- concrete type `f32`, meaning we don’t declare any types after `impl`. -->
<p>例えば、あらゆるジェネリックな型とともに<code>Point&lt;T&gt;</code>インスタンスではなく、<code>Point&lt;f32&gt;</code>だけにメソッドを実装することもできるでしょう。
リスト10-10では、具体的な型<code>f32</code>を使用しています。つまり、<code>impl</code>の後に型を宣言しません。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point&lt;T&gt; {
#     x: T,
#     y: T,
# }
#
impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 10-10: An `impl` block that only applies to a -->
<!-- struct with a particular concrete type for the generic type parameter `T`</span> -->
<p><span class="caption">リスト10-10: ジェネリックな型引数<code>T</code>に対して特定の具体的な型がある構造体にのみ適用される<code>impl</code>ブロック</span></p>
<!-- This code means the type `Point<f32>` will have a method named -->
<!-- `distance_from_origin` and other instances of `Point<T>` where `T` is not of -->
<!-- type `f32` will not have this method defined. The method measures how far our -->
<!-- point is from the point at coordinates (0.0, 0.0) and uses mathematical -->
<!-- operations that are vailable only for floating point types. -->
<p>このコードは、<code>Point&lt;f32&gt;</code>には<code>distance_from_origin</code>というメソッドが存在するが、
<code>T</code>が<code>f32</code>ではない<code>Point&lt;T&gt;</code>の他のインスタンスにはこのメソッドが定義されないことを意味します。
このメソッドは、この点が座標(0.0, 0.0)の点からどれだけ離れているかを測定し、
浮動小数点数にのみ利用可能な数学的処理を使用します。</p>
<!-- Generic type parameters in a struct definition aren’t always the same as those -->
<!-- you use in that struct’s method signatures. For example, Listing 10-11 defines -->
<!-- the method `mixup` on the `Point<T, U>` struct from Listing 10-8. The method -->
<!-- takes another `Point` as a parameter, which might have different types than the -->
<!-- `self` `Point` we’re calling `mixup` on. The method creates a new `Point` -->
<!-- instance with the `x` value from the `self` `Point` (of type `T`) and the `y` -->
<!-- value from the passed-in `Point` (of type `W`). -->
<p>構造体定義のジェネリックな型引数は、必ずしもその構造体のメソッドシグニチャで使用するものと同じにはなりません。
例を挙げれば、リスト10-11は、リスト10-8の<code>Point&lt;T, U&gt;</code>にメソッド<code>mixup</code>を定義しています。
このメソッドは、他の<code>Point</code>を引数として取り、この引数は<code>mixup</code>を呼び出している<code>self</code>の<code>Point</code>とは異なる型の可能性があります。
このメソッドは、(型<code>T</code>の)<code>self</code>の<code>Point</code>の<code>x</code>値と渡した(型<code>W</code>の)<code>Point</code>の<code>y</code>値から新しい<code>Point</code>インスタンスを生成します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-11: A method that uses different generic types -->
<!-- than its struct’s definition</span> -->
<p><span class="caption">リスト10-11: 構造体定義とは異なるジェネリックな型を使用するメソッド</span></p>
<!-- In `main`, we’ve defined a `Point` that has an `i32` for `x` (with value `5`) -->
<!-- and an `f64` for `y` (with value `10.4`). The `p2` variable is a `Point` struct -->
<!-- that has a string slice for `x` (with value `"Hello"`) and a `char` for `y` -->
<!-- (with value `c`). Calling `mixup` on `p1` with the argument `p2` gives us `p3`, -->
<!-- which will have an `i32` for `x`, because `x` came from `p1`. The `p3` variable -->
<!-- will have a `char` for `y`, because `y` came from `p2`. The `println!` macro -->
<!-- call will print `p3.x = 5, p3.y = c`. -->
<p><code>main</code>で、<code>x</code>(値は<code>5</code>)に<code>i32</code>、<code>y</code>(値は<code>10.4</code>)に<code>f64</code>を持つ<code>Point</code>を定義しました。<code>p2</code>変数は、
<code>x</code>(値は<code>&quot;Hello&quot;</code>)に文字列スライス、<code>y</code>(値は<code>c</code>)に<code>char</code>を持つ<code>Point</code>構造体です。
引数<code>p2</code>で<code>p1</code>に<code>mixup</code>を呼び出すと、<code>p3</code>が得られ、<code>x</code>は<code>i32</code>になります。<code>x</code>は<code>p1</code>由来だからです。
<code>p3</code>変数は、<code>y</code>に<code>char</code>になります。<code>y</code>は<code>p2</code>由来だからです。<code>println!</code>マクロの呼び出しは、
<code>p3.x = 5, p3.y = c</code>と出力するでしょう。</p>
<!-- The purpose of this example is to demonstrate a situation in which some generic -->
<!-- parameters are declared with `impl` and some are declared with the method -->
<!-- definition. Here, the generic parameters `T` and `U` are declared after `impl`, -->
<!-- because they go with the struct definition. The generic parameters `V` and `W` -->
<!-- are declared after `fn mixup`, because they’re only relevant to the method. -->
<p>この例の目的は、一部のジェネリックな引数は<code>impl</code>で宣言され、他の一部はメソッド定義で宣言される場面をデモすることです。
ここで、ジェネリックな引数<code>T</code>と<code>U</code>は<code>impl</code>の後に宣言されています。構造体定義にはまるからです。
ジェネリックな引数<code>V</code>と<code>W</code>は<code>fn mixup</code>の後に宣言されています。何故なら、このメソッドにしか関係ないからです。</p>
<!-- ### Performance of Code Using Generics -->
<a class="header" href="print.html#aジェネリクスを使用したコードのパフォーマンス" id="aジェネリクスを使用したコードのパフォーマンス"><h3>ジェネリクスを使用したコードのパフォーマンス</h3></a>
<!-- You might be wondering whether there is a runtime cost when you’re using -->
<!-- generic type parameters. The good news is that Rust implements generics in such -->
<!-- a way that your code doesn’t run any slower using generic types than it would -->
<!-- with concrete types. -->
<p>ジェネリックな型引数を使用すると、実行時にコストが発生するかあなたは不思議に思っている可能性があります。
コンパイラが、ジェネリクスを具体的な型がある時よりもジェネリックな型を使用したコードを実行するのが遅くならないように実装しているのは、
嬉しいお知らせです。</p>
<!-- Rust accomplishes this by performing monomorphization of the code that is using -->
<!-- generics at compile time. *Monomorphization* is the process of turning generic -->
<!-- code into specific code by filling in the concrete types that are used when -->
<!-- compiled. -->
<p>コンパイラはこれをジェネリクスを使用しているコードの単相化をコンパイル時に行うことで達成しています。
<em>単相化</em>(monomorphization)は、コンパイル時に使用されている具体的な型を入れることで、
ジェネリックなコードを特定のコードに変換する過程のことです。</p>
<!-- In this process, the compiler does the opposite of the steps we used to create -->
<!-- the generic function in Listing 10-5: the compiler looks at all the places -->
<!-- where generic code is called and generates code for the concrete types the -->
<!-- generic code is called with. -->
<p>この過程において、コンパイラは、リスト10-5でジェネリックな関数を生成するために使用した手順と真逆のことをしています:
コンパイラは、ジェネリックなコードが呼び出されている箇所全部を見て、
ジェネリックなコードが呼び出されている具体的な型のコードを生成するのです。</p>
<!-- Let’s look at how this works with an example that uses the standard library’s -->
<!-- `Option<T>` enum: -->
<p>標準ライブラリの<code>Option&lt;T&gt;</code> enumを使用する例でこれが動作する方法を見ましょう:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let integer = Some(5);
let float = Some(5.0);
#}</code></pre></pre>
<!-- When Rust compiles this code, it performs monomorphization. During that -->
<!-- process, the compiler reads the values that have been used in `Option<T>` -->
<!-- instances and identifies two kinds of `Option<T>`: one is `i32` and the other -->
<!-- is `f64`. As such, it expands the generic definition of `Option<T>` into -->
<!-- `Option_i32` and `Option_f64`, thereby replacing the generic definition with -->
<!-- the specific ones. -->
<p>コンパイラがこのコードをコンパイルすると、単相化を行います。その過程で、コンパイラは<code>Option&lt;T&gt;</code>のインスタンスに使用された値を読み取り、
2種類の<code>Option&lt;T&gt;</code>を識別します: 一方は<code>i32</code>で、もう片方は<code>f64</code>です。そのように、
コンパイラは、<code>Option&lt;T&gt;</code>のジェネリックな定義を<code>Option_i32</code>と<code>Option_f64</code>に展開し、
それにより、ジェネリックな定義を特定の定義と置き換えます。</p>
<!-- The monomorphized version of the code looks like the following. The generic -->
<!-- `Option<T>` is replaced with the specific definitions created by the compiler: -->
<p>単相化されたバージョンのコードは、以下のようになります。ジェネリックな<code>Option&lt;T&gt;</code>が、
コンパイラが生成した特定の定義に置き換えられています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<!-- Because Rust compiles generic code into code that specifies the type in each -->
<!-- instance, we pay no runtime cost for using generics. When the code runs, it -->
<!-- performs just as it would if we had duplicated each definition by hand. The -->
<!-- process of monomorphization makes Rust’s generics extremely efficient at -->
<!-- runtime. -->
<p>Rustでは、ジェネリックなコードを各インスタンスで型を指定したコードにコンパイルするので、
ジェネリクスを使用することに対して実行時コストを払うことはありません。コードを実行すると、
それぞれの定義を手作業で複製した時のように振る舞います。単相化の過程により、
Rustのジェネリクスは実行時に究極的に効率的になるのです。</p>
<!-- ## Traits: Defining Shared Behavior -->
<a class="header" href="print.html#aトレイト-共通の振る舞いを定義する" id="aトレイト-共通の振る舞いを定義する"><h2>トレイト: 共通の振る舞いを定義する</h2></a>
<!-- A *trait* tells the Rust compiler about functionality a particular type has and -->
<!-- can share with other types. We can use traits to define shared behavior in an -->
<!-- abstract way. We can use trait bounds to specify that a generic can be any type -->
<!-- that has certain behavior. -->
<p><em>トレイト</em>により、Rustコンパイラに特定の型に存在し、他の型と共有できる機能について知らせます。
トレイトを使用して共通の振る舞いを抽象的に定義できます。トレイト境界を使用して、
あるジェネリックが特定の振る舞いのあるあらゆる型になり得ることを指定できます。</p>
<!-- > Note: Traits are similar to a feature often called *interfaces* in other -->
<!-- > languages, although with some differences. -->
<blockquote>
<p>注釈: 違いはあるものの、トレイトは他の言語でよくインターフェイスと呼ばれる機能に類似しています。</p>
</blockquote>
<!-- ### Defining a Trait -->
<a class="header" href="print.html#aトレイトを定義する" id="aトレイトを定義する"><h3>トレイトを定義する</h3></a>
<!-- A type’s behavior consists of the methods we can call on that type. Different -->
<!-- types share the same behavior if we can call the same methods on all of those -->
<!-- types. Trait definitions are a way to group method signatures together to -->
<!-- define a set of behaviors necessary to accomplish some purpose. -->
<p>型の振る舞いは、その型に対して呼び出せるメソッドから構成されます。異なる型は、それらの型全部に対して同じメソッドを呼び出せたら、
同じ振る舞いを共有します。トレイト定義は、メソッドシグニチャを一緒くたにしてなんらかの目的を達成するのに必要な一連の振る舞いを定義する手段です。</p>
<!-- For example, let’s say we have multiple structs that hold various kinds and -->
<!-- amounts of text: a `NewsArticle` struct that holds a news story filed in a -->
<!-- particular location and a `Tweet` that can have at most 280 characters along -->
<!-- with metadata that indicates whether it was a new tweet, a retweet, or a reply -->
<!-- to another tweet. -->
<p>例えば、いろんな種類や量のテキストを保持する複数の構造体があるとしましょう: 特定の場所で送られる新しいニュースを保持する<code>NewsArticle</code>と、
新規ツイートか、リツイートか、はたまた他のツイートへのリプライなのかを示すメタデータを伴う最大で280文字までの<code>Tweet</code>です。</p>
<!-- We want to make a media aggregator library that can display summaries of data -->
<!-- that might be stored in a `NewsArticle` or `Tweet` instance. To do this, we -->
<!-- need a summary from each type, and we need to request that summary by calling a -->
<!-- `summarize` method on an instance. Listing 10-12 shows the definition of a -->
<!-- `Summary` trait that expresses this behavior. -->
<p><code>NewsArticle</code>や<code>Tweet</code>インスタンスに格納される可能性のあるデータの総括を表示するメディア総括ライブラリを作成したいです。
このために、各型からまとめが必要で、インスタンスに対して<code>summarize</code>メソッドを呼び出すことでそのまとめを要求する必要があります。
リスト10-12は、この振る舞いを表現する<code>Summary</code>トレイトの定義を表示しています。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 10-12: A `Summary` trait that consists of the -->
<!-- behavior provided by a `summarize` method</span> -->
<p><span class="caption">リスト10-12: <code>summarize</code>メソッドで提供される振る舞いからなる<code>Summary</code>トレイト</span></p>
<!-- Here, we declare a trait using the `trait` keyword and then the trait’s name, -->
<!-- which is `Summary` in this case. Inside the curly brackets, we declare the -->
<!-- method signatures that describe the behaviors of the types that implement this -->
<!-- trait, which in this case is `fn summarize(&self) -> String`. -->
<p>ここでは、<code>trait</code>キーワード、それからトレイト名を使用してトレイトを定義していて、その名前は今回の場合、
<code>Summary</code>です。波括弧の中にこのトレイトを実装する型の振る舞いを記述するメソッドシグニチャを定義し、
今回の場合は、<code>fn summarize(&amp;self) -&gt; String</code>です。</p>
<!-- After the method signature, instead of providing an implementation within curly -->
<!-- brackets, we use a semicolon. Each type implementing this trait must provide -->
<!-- its own custom behavior for the body of the method. The compiler will enforce -->
<!-- that any type that has the `Summary` trait will have the method `summarize` -->
<!-- defined with this signature exactly. -->
<p>メソッドシグニチャの後に、波括弧内に実装を提供する代わりに、セミコロンを使用しています。
このトレイトを実装する型はそれぞれ、メソッドの本体に独自の振る舞いを提供しなければなりません。
コンパイラにより、<code>Summary</code>トレイトを保持するあらゆる型に、このシグニチャと全く同じメソッド<code>summarize</code>が定義されていることが、
強制されます。</p>
<!-- A trait can have multiple methods in its body: the method signatures are listed -->
<!-- one per line and each line ends in a semicolon. -->
<p>トレイトには、本体に複数のメソッドを含むことができます: メソッドシグニチャは行ごとに列挙され、
各行はセミコロンで終止します。</p>
<!-- ### Implementing a Trait on a Type -->
<a class="header" href="print.html#aトレイトを型に実装する" id="aトレイトを型に実装する"><h3>トレイトを型に実装する</h3></a>
<!-- Now that we’ve defined the desired behavior using the `Summary` trait, we can -->
<!-- implement it on the types in our media aggregator. Listing 10-13 shows an -->
<!-- implementation of the `Summary` trait on the `NewsArticle` struct that uses the -->
<!-- headline, the author, and the location to create the return value of -->
<!-- `summarize`. For the `Tweet` struct, we define `summarize` as the username -->
<!-- followed by the entire text of the tweet, assuming that tweet content is -->
<!-- already limited to 280 characters. -->
<p>今や<code>Summary</code>トレイトで欲しい振る舞いを定義したので、メディア総括機で型に実装することができます。
リスト10-13は見出し、著者、場所を使用して<code>summarize</code>の戻り値を生成する<code>NewsArticle</code>構造体の<code>Summary</code>トレイト実装を示しています。
<code>Tweet</code>構造体に関しては、ツイートの内容が既に280文字に限定されていることを想定して、
<code>summarize</code>をユーザ名にツイート全体のテキストが続く形で定義します。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Summary {
#     fn summarize(&amp;self) -&gt; String;
# }
#
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 10-13: Implementing the `Summary` trait on the -->
<!-- `NewsArticle` and `Tweet` types</span> -->
<p><span class="caption">リスト10-13: <code>Summary</code>トレイトを<code>NewsArticle</code>と<code>Tweet</code>型に実装する</span></p>
<!-- Implementing a trait on a type is similar to implementing regular methods. The -->
<!-- difference is that after `impl`, we put the trait name that we want to -->
<!-- implement, then use the `for` keyword, and then specify the name of the type we -->
<!-- want to implement the trait for. Within the `impl` block, we put the method -->
<!-- signatures that the trait definition has defined. Instead of adding a semicolon -->
<!-- after each signature, we use curly brackets and fill in the method body with -->
<!-- the specific behavior that we want the methods of the trait to have for the -->
<!-- particular type. -->
<p>型にトレイトを実装することは、普通のメソッドを実装することに似ています。違いは、<code>impl</code>の後に、
実装したいトレイトの名前を置き、それから<code>for</code>キーワード、さらにトレイトの実装対象の型の名前を指定することです。
<code>impl</code>ブロック内に、トレイト定義で定義したメソッドシグニチャを置きます。各シグニチャの後にセミコロンを追記するのではなく、
波括弧を使用し、メソッド本体に特定の型のトレイトのメソッドに欲しい特定の振る舞いを入れます。</p>
<!-- After implementing the trait, we can call the methods on instances of -->
<!-- `NewsArticle` and `Tweet` in the same way we call regular methods, like this: -->
<p>トレイトを実装後、普通の関数同様に<code>NewsArticle</code>や<code>Tweet</code>のインスタンスに対してメソッドを呼び出せます。
こんな感じで:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    // もちろん、ご存知かもしれないようにね、みなさん
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<!-- This code prints `1 new tweet: horse_ebooks: of course, as you probably already -->
<!-- know, people`. -->
<p>このコードは、<code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>と出力します。</p>
<!-- Note that because we defined the `Summary` trait and the `NewsArticle` and -->
<!-- `Tweet` types in the same *lib.rs* in Listing 10-13, they’re all in the same -->
<!-- scope. Let’s say this *lib.rs* is for a crate we’ve called `aggregator` and -->
<!-- someone else wants to use our crate’s functionality to implement the `Summary` -->
<!-- trait on a struct defined within their library’s scope. They would need to -->
<!-- import the trait into their scope first. They would do so by specifying `use -->
<!-- aggregator::Summary;`, which then would enable them to implement `Summary` for -->
<!-- their type. The `Summary` trait would also need to be a public trait for -->
<!-- another crate to implement it, which it is because we put the `pub` keyword -->
<!-- before `trait` in Listing 10-12. -->
<p>リスト10-13で<code>Summary</code>トレイトと<code>NewArticle</code>、<code>Tweet</code>型を同じ<em>lib.rs</em>に定義したので、
全部同じスコープにあることに注目してください。この<em>lib.rs</em>を<code>aggregator</code>と呼ばれるクレート専用にして、
誰か他の人が私たちのクレートの機能を活用して自分のライブラリのスコープに定義された構造体に<code>Summary</code>トレイトを実装したいとしましょう。
まず、トレイトをスコープにインポートする必要があるでしょう。<code>use aggregator::Summary;</code>と指定してそれを行い、
これにより、自分の型に<code>Summary</code>を実装することが可能になるでしょう。<code>Summary</code>トレイトは、
他のクレートが実装するためには、公開トレイトである必要があり、ここでは、リスト10-12の<code>trait</code>の前に、
<code>pub</code>キーワードを置いたのでそうなっています。</p>
<!-- One restriction to note with trait implementations is that we can implement a -->
<!-- trait on a type only if either the trait or the type is local to our crate. -->
<!-- For example, we can implement standard library traits like `Display` on a -->
<!-- custom type like `Tweet` as part of our `aggregator` crate functionality, -->
<!-- because the type `Tweet` is local to our `aggregator` crate. We can also -->
<!-- implement `Summary` on `Vec<T>` in our `aggregator` crate, because the -->
<!-- trait `Summary` is local to our `aggregator` crate. -->
<p>トレイト実装で注意すべき制限の1つは、トレイトか対象の型が自分のクレートにローカルである時のみ、
型に対してトレイトを実装できるということです。例えば、<code>Display</code>のような標準ライブラリのトレイトを<code>aggregator</code>クレートの機能の一部として、
<code>Tweet</code>のような独自の型に実装できます。型<code>Tweet</code>が<code>aggregator</code>クレートにローカルだからです。
また、<code>Summary</code>を<code>aggregator</code>クレートで<code>Vec&lt;T&gt;</code>に対して実装することもできます。
トレイト<code>Summary</code>は、<code>aggregator</code>クレートにローカルだからです。</p>
<!-- But we can’t implement external traits on external types. For example, we can’t -->
<!-- implement the `Display` trait on `Vec<T>` within our `aggregator` crate, -->
<!-- because `Display` and `Vec<T>` are defined in the standard library and aren’t -->
<!-- local to our `aggregator` crate. This restriction is part of a property of -->
<!-- programs called *coherence*, and more specifically the *orphan rule*, so named -->
<!-- because the parent type is not present. This rule ensures that other people’s -->
<!-- code can’t break your code and vice versa. Without the rule, two crates could -->
<!-- implement the same trait for the same type, and Rust wouldn’t know which -->
<!-- implementation to use. -->
<p>しかし、外部のトレイトを外部の型に対して実装することはできません。例として、
<code>aggregator</code>クレート内で<code>Vec&lt;T&gt;</code>に対して<code>Display</code>トレイトを実装することはできません。
<code>Display</code>と<code>Vec&lt;T&gt;</code>は標準ライブラリで定義され、<code>aggregator</code>クレートにローカルではないからです。
この制限は、<em>コヒーレンス</em>(coherence)あるいは、具体的に<em>オーファンルール</em>(orphan rule)と呼ばれるプログラムの特性の一部で、
親の型が存在しないためにそう命名されました。この規則により、他の人のコードが自分のコードを壊したり、
その逆が起きないことを保証してくれます。この規則がなければ、2つのクレートが同じ型に対して同じトレイトを実装できてしまい、
コンパイラはどちらの実装を使うべきかわからなくなってしまうでしょう。</p>
<!-- ### Default Implementations -->
<a class="header" href="print.html#aデフォルト実装" id="aデフォルト実装"><h3>デフォルト実装</h3></a>
<!-- Sometimes it’s useful to have default behavior for some or all of the methods -->
<!-- in a trait instead of requiring implementations for all methods on every type. -->
<!-- Then, as we implement the trait on a particular type, we can keep or override -->
<!-- each method’s default behavior. -->
<p>時として、全ての型の全メソッドに対して実装を必要とするのではなく、トレイトの全てあるいは一部のメソッドに対してデフォルトの振る舞いがあると有用です。
そうすれば、特定の型にトレイトを実装する際、各メソッドのデフォルト実装を保持するかオーバーライドできるわけです。</p>
<!-- Listing 10-14 shows how to specify a default string for the `summarize` method -->
<!-- of the `Summary` trait instead of only defining the method signature, as we did -->
<!-- in Listing 10-12: -->
<p>リスト10-14は、リスト10-12のように、メソッドシグニチャだけを定義するのではなく、
<code>Summary</code>トレイトの<code>summarize</code>メソッドにデフォルトの文字列を指定する方法を示しています:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        // (もっと読む)
        String::from(&quot;(Read more...)&quot;)
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 10-14: Definition of a `Summary` trait with a -->
<!-- default implementation of the `summarize` method</span> -->
<p><span class="caption">リスト10-14: <code>summarize</code>メソッドのデフォルト実装がある<code>Summary</code>トレイトの定義</span></p>
<!-- To use a default implementation to summarize instances of `NewsArticle` instead -->
<!-- of defining a custom implementation, we specify an empty `impl` block with -->
<!-- `impl Summary for NewsArticle {}`. -->
<p>デフォルト実装を使用して独自の実装を定義するのではなく、<code>NewsArticle</code>のインスタンスをまとめるには、
<code>impl Summary for NewsArticle {}</code>と空の<code>impl</code>ブロックを指定します。</p>
<!-- Even though we’re no longer defining the `summarize` method on `NewsArticle` -->
<!-- directly, we’ve provided a default implementation and specified that -->
<!-- `NewsArticle` implements the `Summary` trait. As a result, we can still call -->
<!-- the `summarize` method on an instance of `NewsArticle`, like this: -->
<p>たとえ、最早<code>NewsArticle</code>に直接<code>summarize</code>メソッドを定義することはなくても、デフォルト実装を提供し、
<code>NewsArticle</code>は<code>Summary</code>トレイトを実装すると指定しました。結果的に、それでも、
<code>NewsArticle</code>のインスタンスに対して<code>summarize</code>メソッドを呼び出すことができます。
このように:</p>
<pre><code class="language-rust ignore">let article = NewsArticle {
    // ペンギンチームがスタンレーカップチャンピオンシップを勝ち取る！
    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Pittsburgh, PA, USA&quot;),
    author: String::from(&quot;Iceburgh&quot;),
    // ピッツバーグ・ペンギンが再度NHLで最強のホッケーチームになった
    content: String::from(&quot;The Pittsburgh Penguins once again are the best
    hockey team in the NHL.&quot;),
};

// 新しい記事が利用可能です！ {}
println!(&quot;New article available! {}&quot;, article.summarize());
</code></pre>
<!-- This code prints `New article available! (Read more...)`. -->
<p>このコードは、<code>New article available! (Read more...)</code>と出力します。</p>
<!-- Creating a default implementation for `summarize` doesn’t require us to change -->
<!-- anything about the implementation of `Summary` on `Tweet` in Listing 10-13. The -->
<!-- reason is that the syntax for overriding a default implementation is the same -->
<!-- as the syntax for implementing a trait method that doesn’t have a default -->
<!-- implementation. -->
<p><code>summarize</code>にデフォルト実装を作っても、リスト10-13の<code>Tweet</code>の<code>Summary</code>実装を変える必要はありません。
理由は、デフォルト実装をオーバーライドする記法がデフォルト実装のないトレイトメソッドを実装する記法と同じだからです。</p>
<!-- Default implementations can call other methods in the same trait, even if those -->
<!-- other methods don’t have a default implementation. In this way, a trait can -->
<!-- provide a lot of useful functionality and only require implementors to specify -->
<!-- a small part of it. For example, we could define the `Summary` trait to have a -->
<!-- `summarize_author` method whose implementation is required, and then define a -->
<!-- `summarize` method that has a default implementation that calls the -->
<!-- `summarize_author` method: -->
<p>デフォルト実装は、他のデフォルト実装がないメソッドでも呼び出すことができます。
このように、トレイトは多くの有用な機能を提供しつつ、実装者に僅かな部分だけ指定してもらう必要しかないのです。
例えば、<code>Summary</code>トレイトを実装が必須の<code>summarize_author</code>メソッドを持つように定義し、
それから<code>summarize_author</code>メソッドを呼び出すデフォルト実装のある<code>summarize</code>メソッドを定義することもできます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        // {}からもっと読む
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
#}</code></pre></pre>
<!-- To use this version of `Summary`, we only need to define `summarize_author` -->
<!-- when we implement the trait on a type: -->
<p>このバージョンの<code>Summary</code>を使用するには、型にトレイトを実装する際に<code>summarize_author</code>を定義する必要だけあります:</p>
<pre><code class="language-rust ignore">impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<!-- After we define `summarize_author`, we can call `summarize` on instances of the -->
<!-- `Tweet` struct, and the default implementation of `summarize` will call the -->
<!-- definition of `summarize_author` that we’ve provided. Because we’ve implemented -->
<!-- `summarize_author`, the `Summary` trait has given us the behavior of the -->
<!-- `summarize` method without requiring us to write any more code. -->
<p><code>summarize_author</code>定義後、<code>Tweet</code>構造体のインスタンスに対して<code>summarize</code>を呼び出せ、
<code>summarize</code>のデフォルト実装は、提供済みの<code>summarize_author</code>の定義を呼び出すでしょう。
<code>summarize_author</code>を実装したので、追加のコードを書く必要なく、<code>Summary</code>トレイトは、
<code>summarize</code>メソッドの振る舞いを与えてくれました。</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<!-- This code prints `1 new tweet: (Read more from @horse_ebooks...)`. -->
<p>このコードは、<code>1 new tweet: (Read more from @horse_ebooks...)</code>と出力します。</p>
<!-- Note that it isn’t possible to call the default implementation from an -->
<!-- overriding implementation of that same method. -->
<p>同じメソッドのオーバーライドした実装からは、デフォルト実装を呼び出すことができないことに注意してください。</p>
<!-- ### Trait Bounds -->
<a class="header" href="print.html#aトレイト境界" id="aトレイト境界"><h3>トレイト境界</h3></a>
<!-- Now that you know how to define traits and implement those traits on types, we -->
<!-- can explore how to use traits with generic type parameters. We can use *trait -->
<!-- bounds* to constrain generic types to ensure the type will be limited to those -->
<!-- that implement a particular trait and behavior. -->
<p>これでトレイトの定義とトレイトを型に実装する方法を知ったので、ジェネリックな型引数でトレイトを使用する方法を探求できます。
<em>トレイト境界</em>を使用してジェネリックな型を制限し、型が特定のトレイトや振る舞いを実装するものに制限されることを保証できます。</p>
<!-- For example, in Listing 10-13, we implemented the `Summary` trait on the types -->
<!-- `NewsArticle` and `Tweet`. We can define a function `notify` that calls the -->
<!-- `summarize` method on its parameter `item`, which is of the generic type `T`. -->
<!-- To be able to call `summarize` on `item` without getting an error telling us -->
<!-- that the generic type `T` doesn’t implement the method `summarize`, we can use -->
<!-- trait bounds on `T` to specify that `item` must be of a type that implements -->
<!-- the `Summary` trait: -->
<p>例として、リスト10-13で、<code>Summary</code>トレイトを型<code>NewsArticle</code>と<code>Tweet</code>に実装しました。
引数<code>item</code>に対して<code>summarize</code>メソッドを呼び出す関数<code>notify</code>を定義でき、この引数はジェネリックな型<code>T</code>です。
ジェネリックな型<code>T</code>がメソッド<code>summarize</code>を実装しないというエラーを出さずに<code>item</code>に<code>summarize</code>を呼び出せるために、
<code>T</code>に対してトレイト境界を使用して<code>item</code>は、<code>Summary</code>トレイトを実装する型でなければならないと指定できます:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: T) {
    // 衝撃的なニュース！ {}
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<!-- We place trait bounds with the declaration of the generic type parameter, after -->
<!-- a colon and inside angle brackets. Because of the trait bound on `T`, we can -->
<!-- call `notify` and pass in any instance of `NewsArticle` or `Tweet`. Code that -->
<!-- calls the function with any other type, like a `String` or an `i32`, won’t -->
<!-- compile, because those types don’t implement `Summary`. -->
<p>トレイト境界をジェネリックな型引数宣言とともにコロンの後、山カッコ内に配置しています。<code>T</code>に対するトレイト境界のため、
<code>notify</code>を呼び出して<code>NewsArticle</code>か<code>Tweet</code>のどんなインスタンスも渡すことができます。
あらゆる他の型、<code>String</code>や<code>i32</code>などでこの関数を呼び出すコードは、型が<code>Summary</code>を実装しないので、
コンパイルできません。</p>
<!-- We can specify multiple trait bounds on a generic type using the `+` syntax. -->
<!-- For example, to use display formatting on the type `T` in a function as well as -->
<!-- the `summarize` method, we can use `T: Summary + Display` to say `T` can be any -->
<!-- type that implements `Summary` and `Display`. -->
<p><code>+</code>記法でジェネリックな型に対して複数のトレイト境界を指定できます。例えば、関数で<code>T</code>に対してフォーマット表示と、
<code>summarize</code>メソッドを使用するには、<code>T: Summary + Display</code>を使用して、<code>T</code>は<code>Summary</code>と<code>Display</code>を実装するどんな型にもなると宣言できます。</p>
<!-- However, there are downsides to using too many trait bounds. Each generic has -->
<!-- its own trait bounds, so functions with multiple generic type parameters can -->
<!-- have lots of trait bound information between a function’s name and its -->
<!-- parameter list, making the function signature hard to read. For this reason, -->
<!-- Rust has alternate syntax for specifying trait bounds inside a `where` clause -->
<!-- after the function signature. So instead of writing this: -->
<p>しかしながら、トレイト境界が多すぎると欠点もあります。各ジェネリックには、特有のトレイト境界があるので、
複数のジェネリックな型引数がある関数には、関数名と引数リストの間に多くのトレイト境界の情報が付くこともあり、
関数シグニチャが読みづらくなる原因になります。このため、Rustには関数シグニチャの後、
<code>where</code>節内にトレイト境界を指定する対立的な記法があります。従って、こう書く代わりに:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<!-- we can use a `where` clause, like this: -->
<p>こんな感じに<code>where</code>節を活用できます:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<!-- This function’s signature is less cluttered in that the function name, -->
<!-- parameter list, and return type are close together, similar to a function -->
<!-- without lots of trait bounds. -->
<p>この関数シグニチャは、多くのトレイト境界のない関数のように、関数名、引数リスト、戻り値の型が一緒になって近いという点でごちゃごちゃしていません。</p>
<!-- ### Fixing the `largest` Function with Trait Bounds -->
<a class="header" href="print.html#aトレイト境界でlargest関数を修正する" id="aトレイト境界でlargest関数を修正する"><h3>トレイト境界で<code>largest</code>関数を修正する</h3></a>
<!-- Now that you know how to specify the behavior you want to use using the generic -->
<!-- type parameter’s bounds, let’s return to Listing 10-5 to fix the definition of -->
<!-- the `largest` function that uses a generic type parameter! Last time we tried -->
<!-- to run that code, we received this error: -->
<p>ジェネリックな型引数の境界で使用したい振る舞いを指定する方法を知ったので、リスト10-5に戻って、
ジェネリックな型引数を使用する<code>largest</code>関数の定義を修正しましょう！最後にそのコードを実行しようとしたら、
こんなエラーが出ました:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<!-- In the body of `largest` we wanted to compare two values of type `T` using the -->
<!-- greater than (`>`) operator. Because that operator is defined as a default -->
<!-- method on the standard library trait `std::cmp::PartialOrd`, we need to specify -->
<!-- `PartialOrd` in the trait bounds for `T` so the `largest` function can work on -->
<!-- slices of any type that we can compare. We don’t need to bring `PartialOrd` -->
<!-- into scope because it’s in the prelude. Change the signature of `largest` to -->
<!-- look like this: -->
<p><code>largest</code>の本体で、大なり演算子(<code>&gt;</code>)を使用して型<code>T</code>の2つの値を比較したかったのです。その演算子は、
標準ライブラリトレイトの<code>std::cmp::PartialOrd</code>でデフォルトメソッドとして定義されているので、
<code>largest</code>関数が、比較できるあらゆる型のスライスに対して動くように<code>T</code>のトレイト境界に<code>PartialOrd</code>を指定する必要があります。
初期化処理に含まれているので、<code>PartialOrd</code>をスコープに導入する必要はありません。
<code>largest</code>のシグニチャを以下のような見た目に変えてください:</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<!-- This time when we compile the code, we get a different set of errors: -->
<p>今度コードをコンパイルすると、異なる一連のエラーが出ます:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy slice
(エラー: `[T]`、コピーでないスライスからムーブできません。)
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&amp;list[0]`
                         (助言: 代わりに参照の使用を考慮してください: `&amp;list[0]`)

error[E0507]: cannot move out of borrowed content
(エラー: 借用された内容からムーブできません)
 --&gt; src/main.rs:4:9
  |
4 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
            (ヒント: ムーブを避けるには、`ref item`か`ref mut item`を使用してください)
</code></pre>
<!-- The key line in this error is `cannot move out of type [T], a non-copy slice`. -->
<!-- With our non-generic versions of the `largest` function, we were only trying to -->
<!-- find the largest `i32` or `char`. As discussed in the “Stack-Only Data: Copy” -->
<!-- section in Chapter 4, types like `i32` and `char` that have a known size can be -->
<!-- stored on the stack, so they implement the `Copy` trait. But when we made the -->
<!-- `largest` function generic, it became possible for the `list` parameter to have -->
<!-- types in it that don’t implement the `Copy` trait. Consequently, we wouldn’t be -->
<!-- able to move the value out of `list[0]` and into the `largest` variable, -->
<!-- resulting in this error. -->
<p>このエラーの鍵となる行は、<code>cannot move out of type [T], a non-copy slice</code>です。
ジェネリックでないバージョンの<code>largest</code>関数では、最大の<code>i32</code>か<code>char</code>を探そうとするだけでした。
第4章の「スタックだけのデータ: コピー」節で議論したように、<code>i32</code>や<code>char</code>のような既知のサイズの型は、
スタックに格納できるので、<code>Copy</code>トレイトを実装しています。しかし、<code>largest</code>関数をジェネリックにすると、
<code>list</code>引数が<code>Copy</code>トレイトを実装しない型を含む可能性も出てきたのです。結果として、
<code>list[0]</code>から値をムーブできず、<code>largest</code>にムーブできず、このエラーに落ち着いたのです。</p>
<!-- To call this code with only those types that implement the `Copy` trait, we can -->
<!-- add `Copy` to the trait bounds of `T`! Listing 10-15 shows the complete code of -->
<!-- a generic `largest` function that will compile as long as the types of the -->
<!-- values in the slice that we pass into the function implement the `PartialOrd` -->
<!-- *and* `Copy` traits, like `i32` and `char` do. -->
<p>このコードを<code>Copy</code>トレイトを実装する型とだけで呼び出すには、<code>T</code>のトレイト境界に<code>Copy</code>を追加できます！
リスト10-15は、関数に渡したスライスの値の型が<code>i32</code>や<code>char</code>などのように、<code>PartialOrd</code><em>と</em><code>Copy</code>を実装する限り、
コンパイルできるジェネリックな<code>largest</code>関数の完全なコードを示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-15: A working definition of the `largest` -->
<!-- function that works on any generic type that implements the `PartialOrd` and -->
<!-- `Copy` traits</span> -->
<p><span class="caption">リスト10-15: <code>PartialOrd</code>と<code>Copy</code>トレイトを実装するあらゆるジェネリックな型に対して動く、
<code>largest</code>関数の動く定義</span></p>
<!-- If we don’t want to restrict the `largest` function to the types that implement -->
<!-- the `Copy` trait, we could specify that `T` has the trait bound `Clone` instead -->
<!-- of `Copy`. Then we could clone each value in the slice when we want the -->
<!-- `largest` function to have ownership. Using the `clone` function means we’re -->
<!-- potentially making more heap allocations in the case of types that own heap -->
<!-- data like `String`, and heap allocations can be slow if we’re working with -->
<!-- large amounts of data. -->
<p>もし<code>largest</code>関数を<code>Copy</code>を実装する型だけに制限したくなかったら、<code>Copy</code>ではなく、
Tが<code>Clone</code>というトレイト境界を含むと指定することもできます。そうしたら、
<code>largest</code>関数に所有権が欲しい時にスライスの各値をクローンできます。<code>clone</code>関数を使用するということは、
<code>String</code>のようなヒープデータを所有する型の場合にもっとヒープ確保が発生する可能性があることを意味し、
大きなデータを取り扱っていたら、ヒープ確保は遅いこともあります。</p>
<!-- Another way we could implement `largest` is for the function to return a -->
<!-- reference to a `T` value in the slice. If we change the return type to `&T` -->
<!-- instead of `T`, thereby changing the body of the function to return a -->
<!-- reference, we wouldn’t need the `Clone` or `Copy` trait bounds and we could -->
<!-- avoid heap allocations. Try implementing these alternate solutions on your own! -->
<p><code>largest</code>の別の実装方法は、関数がスライスの<code>T</code>値への参照を返すようにすることです。
戻り値の型を<code>T</code>ではなく<code>&amp;T</code>に変え、それにより関数の本体を参照を返すように変更したら、
<code>Clone</code>か<code>Copy</code>トレイト境界は必要なくなり、ヒープ確保も避けられるでしょう。
試しにこれらの対立的な解決策もご自身で実装してみてください！</p>
<!-- ### Using Trait Bounds to Conditionally Implement Methods -->
<a class="header" href="print.html#aトレイト境界を使用してメソッド実装を条件分けする" id="aトレイト境界を使用してメソッド実装を条件分けする"><h3>トレイト境界を使用して、メソッド実装を条件分けする</h3></a>
<!-- By using a trait bound with an `impl` block that uses generic type parameters, -->
<!-- we can implement methods conditionally for types that implement the specified -->
<!-- traits. For example, the type `Pair<T>` in Listing 10-16 always implements the -->
<!-- `new` function. But `Pair<T>` only implements the `cmp_display` method if its -->
<!-- inner type `T` implements the `PartialOrd` trait that enables comparison *and* -->
<!-- the `Display` trait that enables printing. -->
<p><code>impl</code>ブロックでジェネリックな型引数を使用するトレイト境界を活用することで、
特定のトレイトを実装する型に対するメソッド実装を条件分けできます。例えば、
リスト10-16の型<code>Pair&lt;T&gt;</code>は、常に<code>new</code>関数を実装します。しかし、<code>Pair&lt;T&gt;</code>は、
内部の型<code>T</code>が比較を可能にする<code>PartialOrd</code>トレイト<em>と</em>出力を可能にする<code>Display</code>トレイトを実装している時のみ、
<code>cmp_display</code>メソッドを実装します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 10-16: Conditionally implement methods on a -->
<!-- generic type depending on trait bounds</span> -->
<p><span class="caption">リスト10-16: トレイト境界によってジェネリックな型に対するメソッド実装を条件分けする</span></p>
<!-- We can also conditionally implement a trait for any type that implements -->
<!-- another trait. Implementations of a trait on any type that satisfies the trait -->
<!-- bounds are called *blanket implementations* and are extensively used in the -->
<!-- Rust standard library. For example, the standard library implements the -->
<!-- `ToString` trait on any type that implements the `Display` trait. The `impl` -->
<!-- block in the standard library looks similar to this code: -->
<p>また、別のトレイトを実装するあらゆる型に対するトレイト実装を条件分けすることもできます。
トレイト境界を満たすあらゆる型にトレイトを実装することは、<em>ブランケット実装</em>(blanket implementation)と呼ばれ、
Rustの標準ライブラリで広く使用されています。例を挙げれば、標準ライブラリは、
<code>Display</code>トレイトを実装するあらゆる型に<code>ToString</code>トレイトを実装しています。
標準ライブラリの<code>impl</code>ブロックは以下のような見た目です:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<!-- Because the standard library has this blanket implementation, we can call the -->
<!-- `to_string` method defined by the `ToString` trait on any type that implements -->
<!-- the `Display` trait. For example, we can turn integers into their corresponding -->
<!-- `String` values like this because integers implement `Display`: -->
<p>標準ライブラリにはこのブランケット実装があるので、<code>Display</code>トレイトを実装する任意の型に対して、
<code>ToString</code>トレイトで定義された<code>to_string</code>メソッドを呼び出せるのです。
例えば、整数は<code>Display</code>を実装するので、このように整数値を対応する<code>String</code>値に変換できます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = 3.to_string();
#}</code></pre></pre>
<!-- Blanket implementations appear in the documentation for the trait in the -->
<!-- “Implementors” section. -->
<p>ブランケット実装は、「実装したもの」節のトレイトのドキュメンテーションに出現します。</p>
<!-- Traits and trait bounds let us write code that uses generic type parameters to -->
<!-- reduce duplication but also specify to the compiler that we want the generic -->
<!-- type to have particular behavior. The compiler can then use the trait bound -->
<!-- information to check that all the concrete types used with our code provide the -->
<!-- correct behavior. In dynamically typed languages, we would get an error at -->
<!-- runtime if we called a method on a type that the type didn’t implement. But -->
<!-- Rust moves these errors to compile time so we’re forced to fix the problems -->
<!-- before our code is even able to run. Additionally, we don’t have to write code -->
<!-- that checks for behavior at runtime because we’ve already checked at compile -->
<!-- time. Doing so improves performance without having to give up the flexibility -->
<!-- of generics. -->
<p>トレイトとトレイト境界により、ジェネリックな型引数を使用して重複を減らしつつ、コンパイラに対して、
そのジェネリックな型に特定の振る舞いが欲しいことを指定するコードを書くことができます。
それからコンパイラは、トレイト境界の情報を活用してコードに使用された具体的な型が正しい振る舞いを提供しているか確認できます。
動的型付け言語では、型が実装しない型のメソッドを呼び出せば、実行時にエラーが出るでしょう。
しかし、Rustはこの種のエラーをコンパイル時に移したので、コードが動かせるようにさえなる以前に問題を修正することを強制されるのです。
加えて、コンパイル時に既に確認したので、実行時に振る舞いがあるかどう確認するコードを書かなくても済みます。
そうすることでジェネリクスの柔軟性を諦める必要なく、パフォーマンスを向上させます。</p>
<!-- Another kind of generic that we’ve already been using is called *lifetimes*. -->
<!-- Rather than ensuring that a type has the behavior we want, lifetimes ensure -->
<!-- that references are valid as long as we need them to be. Let’s look at how -->
<!-- lifetimes do that. -->
<p>もう使用したことのある別の種のジェネリクスは、ライフタイムと呼ばれます。
型が欲しい振る舞いを保持していることを保証するのではなく、必要な間だけ参照が有効であることをライフタイムは保証します。
ライフタイムがどうやってそれを行うかを見ましょう。</p>
<!-- ## Validating References with Lifetimes -->
<a class="header" href="print.html#aライフタイムで参照を有効化する" id="aライフタイムで参照を有効化する"><h2>ライフタイムで参照を有効化する</h2></a>
<!-- One detail we didn’t discuss in the “References and Borrowing” section in -->
<!-- Chapter 4 is that every reference in Rust has a *lifetime*, which is the scope -->
<!-- for which that reference is valid. Most of the time, lifetimes are implicit and -->
<!-- inferred, just like most of the time, types are inferred. We must annotate types -->
<!-- when multiple types are possible. In a similar way, we must annotate lifetimes -->
<!-- when the lifetimes of references could be related in a few different ways. Rust -->
<!-- requires us to annotate the relationships using generic lifetime parameters to -->
<!-- ensure the actual references used at runtime will definitely be valid. -->
<p>第4章の「参照と借用」節で議論しなかった詳細の1つは、Rustにおいて参照は全てライフタイムを保持することであり、
ライフタイムとは、その参照が有効になるスコープのことです。多くの場合、型が推論されるように、
多くの場合、ライフタイムも暗黙的に推論されます。複数の型の可能性があるときには、型を注釈しなければなりません。
同様に、参照のライフタイムがいくつか異なる方法で関係することがある場合には注釈しなければなりません。
コンパイラは、ジェネリックライフタイム引数を使用して関係を注釈し、実行時に実際の参照が確かに有効であることを保証することを要求するのです。</p>
<!-- 4行目頭、ways you might encouter...はways that you might encounterで訳している(つまり同格) -->
<!-- The concept of lifetimes is somewhat different from tools in other programming -->
<!-- languages, arguably making lifetimes Rust’s most distinctive feature. Although -->
<!-- we won’t cover lifetimes in their entirety in this chapter, we’ll discuss -->
<!-- common ways you might encounter lifetime syntax so you can become familiar with -->
<!-- the concepts. See the “Advanced Lifetimes” section in Chapter 19 for more -->
<!-- detailed information. -->
<p>ライフタイムの概念は、ほかのプログラミング言語の道具とはどこか異なり、議論はあるでしょうが、
ライフタイムがRustで一番際立った機能になっています。この章では、ライフタイムの全てを講義しないものの、
ライフタイム記法と遭遇する可能性のある一般的な手段を議論するので、概念に馴染めます。
もっと詳しく知るには、第19章の「高度なライフタイム」節を参照されたし。</p>
<!-- ### Preventing Dangling References with Lifetimes -->
<a class="header" href="print.html#aライフタイムでダングリング参照を回避する" id="aライフタイムでダングリング参照を回避する"><h3>ライフタイムでダングリング参照を回避する</h3></a>
<!-- The main aim of lifetimes is to prevent dangling references, which cause a -->
<!-- program to reference data other than the data it’s intended to reference. -->
<!-- Consider the program in Listing 10-17, which has an outer scope and an inner -->
<!-- scope. -->
<p>ライフタイムの主な目的は、ダングリング参照を回避することであり、ダングリング参照によりプログラムは、
参照することを意図したデータ以外のデータを参照してしまいます。リスト10-17のプログラムを考えてください。
これには、外側のスコープと内側のスコープが含まれています。</p>
<pre><code class="language-rust ignore">{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<!-- <span class="caption">Listing 10-17: An attempt to use a reference whose value -->
<!-- has gone out of scope</span> -->
<p><span class="caption">リスト10-17: 値がスコープを抜けてしまった参照を使用しようとする</span></p>
<!-- > Note: The example in Listing 10-17, 10-18, and 10-24 declare variables -->
<!-- > without giving them an initial value, so the variable name exists in the -->
<!-- > outer scope. At first glance, this might appear to be in conflict with Rust's -->
<!-- > having no null values. However, if we try to use a variable before giving it -->
<!-- > a value, we’ll get a compile-time error, which shows that Rust indeed does -->
<!-- > not allow null values. -->
<blockquote>
<p>注釈: リスト10-17や10-18、10-24では、変数に初期値を与えずに宣言しているので、変数名は外側のスコープに存在します。
初見では、これはRustにはnull値が存在しないということと衝突しているように見える可能性があります。
しかしながら、値を与える前に変数を使用しようとすれば、コンパイルエラーになり、
確かにRustではnull値は許可されないことを示します。</p>
</blockquote>
<!-- The outer scope declares a variable named `r` with no initial value, and the -->
<!-- inner scope declares a variable named `x` with the initial value of 5. Inside -->
<!-- the inner scope, we attempt to set the value of `r` as a reference to `x`. Then -->
<!-- the inner scope ends, and we attempt to print the value in `r`. This code won’t -->
<!-- compile because the value `r` is referring to has gone out of scope before we -->
<!-- try to use it. Here is the error message: -->
<p>外側のスコープで初期値なしの<code>r</code>という変数を宣言し、内側のスコープで初期値5の<code>x</code>という変数を宣言しています。
内側のスコープ内で、<code>r</code>の値を<code>x</code>への参照にセットしようとしています。それから内側のスコープが終わり、
<code>r</code>の値を出力しようとしています。<code>r</code>が参照している値が使おうとする前にスコープを抜けるので、
このコードはコンパイルできません。こちらがエラーメッセージです:</p>
<pre><code class="language-text">error[E0597]: `x` does not live long enough
(エラー: `x`の生存期間が短すぎます)
  --&gt; src/main.rs:7:5
   |
6  |         r = &amp;x;
   |              - borrow occurs here
   |              (借用はここで起きています)
7  |     }
   |     ^ `x` dropped here while still borrowed
   |     (`x`は借用されている間にここでドロップされました)
...
10 | }
   | - borrowed value needs to live until here
   | (借用された値はここまで生きる必要があります)
</code></pre>
<!-- The variable `x` doesn’t “live long enough.” The reason is that `x` will be out -->
<!-- of scope when the inner scope ends on line 7. But `r` is still valid for the -->
<!-- outer scope; because its scope is larger, we say that it “lives longer.” If -->
<!-- Rust allowed this code to work, `r` would be referencing memory that was -->
<!-- deallocated when `x` went out of scope, and anything we tried to do with `r` -->
<!-- wouldn’t work correctly. So how does Rust determine that this code is invalid? -->
<!-- It uses a borrow checker. -->
<p>変数<code>x</code>の「生存期間が短すぎます。」原因は内側のスコープが7行目で終わった時点で<code>x</code>がスコープを抜けるからです。
ですが、<code>r</code>はまだ、外側のスコープに対して有効です; スコープが大きいので、「長生きする」と言います。
Rustで、このコードが動くことを許可していたら、<code>r</code>は<code>x</code>がスコープを抜けた時に解放されるメモリを参照していることになり、
<code>r</code>で行おうとするいかなることもちゃんと動かないでしょう。では、どうやってコンパイラはこのコードが無効であると決定しているのでしょうか？
借用精査機(borrow checker)を使用しています。</p>
<!-- ### The Borrow Checker -->
<a class="header" href="print.html#a借用精査機" id="a借用精査機"><h3>借用精査機</h3></a>
<!-- The Rust compiler has a *borrow checker* that compares scopes to determine -->
<!-- whether all borrows are valid. Listing 10-18 shows the same code as Listing -->
<!-- 10-17 but with annotations showing the lifetimes of the variables: -->
<p>Rustコンパイラには、スコープを比較して全ての借用が有効であるかを決定する<em>借用精査機</em>があります。
リスト10-18は、リスト10-17と同じコードを示していますが、変数のライフタイムを表示する注釈が付いています:</p>
<pre><code class="language-rust ignore">{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
</code></pre>
<!-- <span class="caption">Listing 10-18: Annotations of the lifetimes of `r` and -->
<!-- `x`, named `'a` and `'b`, respectively</span> -->
<p><span class="caption">リスト10-18: それぞれ<code>'a</code>と<code>'b</code>と名付けられた<code>r</code>と<code>x</code>のライフタイムの注釈</span></p>
<!-- Here, we’ve annotated the lifetime of `r` with `'a` and the lifetime of `x` -->
<!-- with `'b`. As you can see, the inner `'b` block is much smaller than the outer -->
<!-- `'a` lifetime block. At compile time, Rust compares the size of the two -->
<!-- lifetimes and sees that `r` has a lifetime of `'a` but that it refers to memory -->
<!-- with a lifetime of `'b`. The program is rejected because `'b` is shorter than -->
<!-- `'a`: the subject of the reference doesn’t live as long as the reference. -->
<p>ここで、<code>r</code>のライフタイムは<code>'a</code>、<code>x</code>のライフタイムは<code>'b</code>で注釈しました。ご覧の通り、
内側の<code>'b</code>ブロックの方が、外側の<code>'a</code>ライフタイムブロックよりはるかに小さいです。
コンパイル時に、コンパイラは2つのライフタイムのサイズを比較し、<code>r</code>は<code>'a</code>のライフタイムだけれども、
<code>'b</code>のライフタイムのメモリを参照していると確認します。<code>'b</code>は<code>'a</code>よりも短いので、プログラムは拒否されます:
参照の被写体が参照ほど長生きしないのです。</p>
<!-- Listing 10-19 fixes the code so it doesn’t have a dangling reference and -->
<!-- compiles without any errors. -->
<p>リスト10-19でコードを修正したので、ダングリング参照はなくなり、エラーなくコンパイルできます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
#}</code></pre></pre>
<!-- <span class="caption">Listing 10-19: A valid reference because the data has a -->
<!-- longer lifetime than the reference</span> -->
<p><span class="caption">リスト10-19: データのライフタイムが参照より長いので、有効な参照</span></p>
<!-- Here, `x` has the lifetime `'b`, which in this case is larger than `'a`. This -->
<!-- means `r` can reference `x` because Rust knows that the reference in `r` will -->
<!-- always be valid while `x` is valid. -->
<p>ここで<code>x</code>のライフタイムは<code>'b</code>になり、今回の場合<code>'a</code>よりも大きいです。つまり、
コンパイラは<code>x</code>が有効な間、<code>r</code>の参照も常に有効になることを把握しているので、<code>r</code>は<code>x</code>を参照できます。</p>
<!-- Now that you know where the lifetimes of references are and how Rust analyzes -->
<!-- lifetimes to ensure references will always be valid, let’s explore generic -->
<!-- lifetimes of parameters and return values in the context of functions. -->
<p>今や、参照のライフタイムがどこにあり、コンパイラがライフタイムを解析して参照が常に有効であることを保証する仕組みがわかったので、
関数の文脈でジェネリックな引数と戻り値のライフタイムを探求しましょう。</p>
<!-- ### Generic Lifetimes in Functions -->
<a class="header" href="print.html#a関数のジェネリックなライフタイム" id="a関数のジェネリックなライフタイム"><h3>関数のジェネリックなライフタイム</h3></a>
<!-- Let’s write a function that returns the longer of two string slices. This -->
<!-- function will take two string slices and return a string slice. After we’ve -->
<!-- implemented the `longest` function, the code in Listing 10-20 should print `The -->
<!-- longest string is abcd`. -->
<p>2つの文字列スライスのうち、長い方を返す関数を書きましょう。この関数は、
2つの文字列スライスを取り、1つの文字列スライスを返します。<code>longest</code>関数の実装完了後、
リスト10-20のコードは、<code>The logest string is abcd</code>と出力するはずです。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    // 最長の文字列は、{}です
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<!-- <span class="caption">Listing 10-20: A `main` function that calls the `longest` -->
<!-- function to find the longer of two string slices</span> -->
<p><span class="caption">リスト10-20: <code>longest</code>関数を呼び出して2つの文字列スライスのうち長い方を探す<code>main</code>関数</span></p>
<!-- Note that we want the function to take string slices, which are references, -->
<!-- because we don’t want the `longest` function to take ownership of its -->
<!-- parameters. We want to allow the function to accept slices of a `String` (the -->
<!-- type stored in the variable `string1`) as well as string literals (which is -->
<!-- what variable `string2` contains). -->
<p>関数に取ってほしい引数が文字列スライス、つまり参照であることに注意してください。
何故なら、<code>longest</code>関数に引数の所有権を奪ってほしくないからです。
この関数に<code>String</code>のスライス(変数<code>string1</code>に格納されている型)と文字列リテラル(変数<code>string2</code>が含むもの)を受け取らせたいのです。</p>
<!-- Refer to the “String Slices as Parameters” section in Chapter 4 for more -->
<!-- discussion about why the parameters we use in Listing 10-20 are the ones we -->
<!-- want. -->
<p>リスト10-20で使用している引数が求めているものである理由についてもっと詳しい議論は、
第4章の「引数としての文字列スライス」節をご参照ください。</p>
<!-- If we try to implement the `longest` function as shown in Listing 10-21, it -->
<!-- won’t compile. -->
<p>リスト10-21に示したように<code>longetst</code>関数を実装しようとしたら、コンパイルできないでしょう。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<!-- <span class="caption">Listing 10-21: An implementation of the `longest` -->
<!-- function that returns the longer of two string slices but does not yet -->
<!-- compile</span> -->
<p><span class="caption">リスト10-21: 2つの文字列スライスのうち長い方を返すけれども、コンパイルできない<code>longest</code>関数の実装</span></p>
<!-- Instead, we get the following error that talks about lifetimes: -->
<p>代わりに、以下のようなライフタイムに言及するエラーが出ます:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
(エラー: ライフタイム指定子が不足しています)
 --&gt; src/main.rs:1:33
  |
1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
  (助言: この関数の戻り値型は借用された値を含んでいますが、
シグニチャは、それが`x`か`y`由来のものなのか宣言していません)
</code></pre>
<!-- The help text reveals that the return type needs a generic lifetime parameter -->
<!-- on it because Rust can’t tell whether the reference being returned refers to -->
<!-- `x` or `y`. Actually, we don’t know either, because the `if` block in the body -->
<!-- of this function returns a reference to `x` and the `else` block returns a -->
<!-- reference to `y`! -->
<p>助言テキストが戻り値の型はジェネリックなライフタイム引数である必要があると明かしています。
というのも、返している参照が<code>x</code>か<code>y</code>を参照しているかコンパイラにはわからないからです。
この関数の本体の<code>if</code>ブロックは<code>x</code>への参照を返し、<code>else</code>ブロックは<code>y</code>への参照を返すので、
実際、どちらか私たちにもわかりません！</p>
<!-- When we’re defining this function, we don’t know the concrete values that will -->
<!-- be passed into this function, so we don’t know whether the `if` case or the -->
<!-- `else` case will execute. We also don’t know the concrete lifetimes of the -->
<!-- references that will be passed in, so we can’t look at the scopes as we did in -->
<!-- Listings 10-18 and 10-19 to determine whether the reference we return will -->
<!-- always be valid. The borrow checker can’t determine this either, because it -->
<!-- doesn’t know how the lifetimes of `x` and `y` relate to the lifetime of the -->
<!-- return value. To fix this error, we’ll add generic lifetime parameters that -->
<!-- define the relationship between the references so the borrow checker can -->
<!-- perform its analysis. -->
<p>この関数を定義する際、この関数に渡される具体的な値がわからないので、<code>if</code>ケースか、<code>else</code>ケースが実行されるか、わからないのです。
また、渡される参照の具体的なライフタイムもわからないので、リスト10-18と10-19で、
返す参照が常に有効であるかを決定したようにスコープを見ることもできないのです。
借用精査機もこれを決定することはできません。<code>x</code>と<code>y</code>のライフタイムがどう戻り値のライフタイムと関係するかわからないからです。
このエラーを修正するには、借用精査機が解析を実行できるように、参照間の関係を定義するジェネリックなライフタイム引数を追加します。</p>
<!-- ### Lifetime Annotation Syntax -->
<a class="header" href="print.html#aライフタイム注釈記法" id="aライフタイム注釈記法"><h3>ライフタイム注釈記法</h3></a>
<!-- Lifetime annotations don’t change how long any of the references live. Just -->
<!-- as functions can accept any type when the signature specifies a generic type -->
<!-- parameter, functions can accept references with any lifetime by specifying a -->
<!-- generic lifetime parameter. Lifetime annotations describe the relationships of -->
<!-- the lifetimes of multiple references to each other without affecting the -->
<!-- lifetimes. -->
<p>ライフタイム注釈は、いかなる参照の生存期間も変えることはありません。シグニチャがジェネリックな型引数を指定している時に、
関数があらゆる型を受け入れるのと全く同様に、ジェネリックなライフタイム引数を指定することで関数は、
あらゆるライフタイムの参照を受け入れるのです。ライフタイム注釈は、ライフタイムに影響することなく、
複数の参照のライフタイムのお互いの関係を記述します。</p>
<!-- Lifetime annotations have a slightly unusual syntax: the names of lifetime -->
<!-- parameters must start with an apostrophe (`'`) and are usually all lowercase and -->
<!-- very short, like generic types. Most people use the name `'a`. We place -->
<!-- lifetime parameter annotations after the `&` of a reference, using a space to -->
<!-- separate the annotation from the reference’s type. -->
<p>ライフタイム注釈は、少しだけ不自然な記法です: ライフタイム引数の名前はアポストロフィー(<code>'</code>)で始まらなければならず、
通常全部小文字で、ジェネリック型のようにとても短いです。多くの人は、<code>'a</code>という名前を使います。
ライフタイム引数注釈は、参照の<code>&amp;</code>の後に配置し、注釈と参照の型を区別するために空白を1つ使用します。</p>
<!-- Here are some examples: a reference to an `i32` without a lifetime parameter, a -->
<!-- reference to an `i32` that has a lifetime parameter named `'a`, and a mutable -->
<!-- reference to an `i32` that also has the lifetime `'a`. -->
<p>例を挙げましょう: ライフタイム引数なしの<code>i32</code>への参照、<code>'a</code>というライフタイム引数付きの<code>i32</code>への参照、
これもライフタイム<code>'a</code>付き<code>i32</code>への可変参照です。</p>
<pre><code class="language-rust ignore">            // (ただの)参照
&amp;i32        // a reference
            // 明示的なライフタイム付きの参照
&amp;'a i32     // a reference with an explicit lifetime
            // 明示的なライフタイム付きの可変参照
&amp;'a mut i32 // a mutable reference with an explicit lifetime
</code></pre>
<!-- One lifetime annotation by itself doesn’t have much meaning, because the -->
<!-- annotations are meant to tell Rust how generic lifetime parameters of multiple -->
<!-- references relate to each other. For example, let’s say we have a function with -->
<!-- the parameter `first` that is a reference to an `i32` with lifetime `'a`. The -->
<!-- function also has another parameter named `second` that is another reference to -->
<!-- an `i32` that also has the lifetime `'a`. The lifetime annotations indicate -->
<!-- that the references `first` and `second` must both live as long as that generic -->
<!-- lifetime. -->
<p>1つのライフタイム注釈それだけでは、大して意味はありません。注釈は、複数の参照のジェネリックなライフタイム引数が、
お互いにどう関係するかをコンパイラに指示することを意図しているからです。例えば、
ライフタイム<code>'a</code>付きの<code>i32</code>への参照となる引数<code>first</code>のある関数があるとしましょう。
この関数にはさらに、<code>'a</code>のライフタイム付きの<code>i32</code>への別の参照となる<code>second</code>という別の引数もあります。
ライフタイム注釈は、<code>first</code>と<code>second</code>の参照がどちらもジェネリックなライフタイムと同じだけ生きることを示唆します。</p>
<!-- ### Lifetime Annotations in Function Signatures -->
<a class="header" href="print.html#a関数シグニチャにおけるライフタイム注釈" id="a関数シグニチャにおけるライフタイム注釈"><h3>関数シグニチャにおけるライフタイム注釈</h3></a>
<!-- Now let’s examine lifetime annotations in the context of the `longest` -->
<!-- function. As with generic type parameters, we need to declare generic lifetime -->
<!-- parameters inside angle brackets between the function name and the parameter -->
<!-- list. The constraint we want to express in this signature is that all the -->
<!-- references in the parameters and the return value must have the same lifetime. -->
<!-- We’ll name the lifetime `'a` and then add it to each reference, as shown in -->
<!-- Listing 10-22. -->
<p>さて、<code>longest</code>関数の文脈でライフタイム注釈を調査しましょう。ジェネリックな型引数同様、
関数名と引数リストの間、山カッコの中にジェネリックなライフタイム引数を宣言する必要があります。
このシグニチャで表現したい制約は、引数の全参照と戻り値が同じライフタイムになることです。
ライフタイムを<code>'a</code>と名付け、それから各参照に追記します。リスト10-22に示したように。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 10-22: The `longest` function definition -->
<!-- specifying that all the references in the signature must have the same lifetime -->
<!-- `'a`</span> -->
<p><span class="caption">リスト10-22: シグニチャの全参照が同じライフタイム<code>'a</code>になると指定した<code>longest</code>関数の定義</span></p>
<!-- This code should compile and produce the result we want when we use it with the -->
<!-- `main` function in Listing 10-20. -->
<p>このコードはコンパイルでき、リスト10-20の<code>main</code>関数とともに使用したら、欲しい結果になるはずです。</p>
<!-- The function signature now tells Rust that for some lifetime `'a`, the function -->
<!-- takes two parameters, both of which are string slices that live at least as -->
<!-- long as lifetime `'a`. The function signature also tells Rust that the string -->
<!-- slice returned from the function will live at least as long as lifetime `'a`. -->
<!-- These constraints are what we want Rust to enforce. Remember, when we specify -->
<!-- the lifetime parameters in this function signature, we’re not changing the -->
<!-- lifetimes of any values passed in or returned. Rather, we’re specifying that -->
<!-- the borrow checker should reject any values that don’t adhere to these -->
<!-- constraints. Note that the `longest` function doesn’t need to know exactly how -->
<!-- long `x` and `y` will live, only that some scope can be substituted for `'a` -->
<!-- that will satisfy this signature. -->
<p>これで関数シグニチャは、なんらかのライフタイム<code>'a</code>に対して、関数は2つの引数を取り、
どちらも少なくともライフタイム<code>'a</code>と同じだけ生きる文字列スライスであるとコンパイラに教えています。
また、この関数シグニチャは、関数から返る文字列スライスも少なくともライフタイム<code>'a</code>と同じだけ生きると、
コンパイラに教えています。これらの制約は、コンパイラに強制してほしいものです。
この関数シグニチャでライフタイム引数を指定する時、渡されたり、返したりしたいかなる値のライフタイムも変更していないことを思い出してください。
むしろ、借用精査機は、これらの制約を支持しない値全てを拒否するべきと指定しています。
<code>longest</code>関数は、正確に<code>x</code>と<code>y</code>の生存期間を知る必要はなく、何かのスコープが<code>'a</code>に代替され、
このシグニチャを満足することだけ知っている必要があることに注意してください。</p>
<!-- When annotating lifetimes in functions, the annotations go in the function -->
<!-- signature, not in the function body. Rust can analyze the code within the -->
<!-- function without any help. However, when a function has references to or from -->
<!-- code outside that function, it becomes almost impossible for Rust to figure out -->
<!-- the lifetimes of the parameters or return values on its own. The lifetimes -->
<!-- might be different each time the function is called. This is why we need to -->
<!-- annotate the lifetimes manually. -->
<p>関数でライフタイムを注釈する際、注釈は関数シグニチャに<ruby>嵌<rp>(</rp><rt>はま</rt><rp>)</rp></ruby>り、
関数本体には嵌りません。コンパイラは、なんの助けもなく、関数内のコードを解析できます。しかしながら、
関数に関数外やからの参照がある場合、コンパイラは引数や戻り値のライフタイムをそれだけではじき出すことはほとんど不可能になります。
ライフタイムは、関数が呼び出される度に異なる可能性があります。このために、手動でライフタイムを注釈する必要があるのです。</p>
<!-- When we pass concrete references to `longest`, the concrete lifetime that is -->
<!-- substituted for `'a` is the part of the scope of `x` that overlaps with the -->
<!-- scope of `y`. In other words, the generic lifetime `'a` will get the concrete -->
<!-- lifetime that is equal to the smaller of the lifetimes of `x` and `y`. Because -->
<!-- we’ve annotated the returned reference with the same lifetime parameter `'a`, -->
<!-- the returned reference will also be valid for the length of the smaller of the -->
<!-- lifetimes of `x` and `y`. -->
<p>具体的な参照を<code>longest</code>に渡すと、<code>'a</code>を代替する具体的なライフタイムは、<code>y</code>のスコープと被さる<code>x</code>のスコープの一部になります。
言い換えると、ジェネリックなライフタイム<code>'a</code>は、<code>x</code>と<code>y</code>のライフタイムのうち、小さい方に等しい具体的なライフタイムになるのです。
返却される参照を同じライフタイム引数<code>'a</code>で注釈したので、返却される参照も<code>x</code>か<code>y</code>のライフタイムの小さい方と同じだけ有効になるでしょう。</p>
<!-- Let’s look at how the lifetime annotations restrict the `longest` function by -->
<!-- passing in references that have different concrete lifetimes. Listing 10-23 is -->
<!-- a straightforward example. -->
<p>ライフタイム注釈が異なる具体的なライフタイムになる参照を渡すことで<code>longest</code>関数を制限する方法を見ましょう。
リスト10-23は、率直な例です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    // 長い文字列は長い
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-23: Using the `longest` function with -->
<!-- references to `String` values that have different concrete lifetimes</span> -->
<p><span class="caption">リスト10-23: 異なる具体的なライフタイムの<code>String</code>値への参照で<code>longest</code>関数を使用する</span></p>
<!-- In this example, `string1` is valid until the end of the outer scope, `string2` -->
<!-- is valid until the end of the inner scope, and `result` references something -->
<!-- that is valid until the end of the inner scope. Run this code, and you’ll see -->
<!-- that the borrow checker approves of this code; it will compile and print `The -->
<!-- longest string is long string is long`. -->
<p>この例において、<code>string1</code>は外側のスコープの終わりまで有効で、<code>string2</code>は内側のスコープの終わりまで有効、
そして<code>result</code>は内側のスコープの終わりまで有効な何かを参照しています。このコードを実行すると、
借用精査機がこのコードに賛成するのがわかるでしょう。要するに、コンパイルでき、
<code>The longest string is long string is long</code>と出力するのです。</p>
<!-- Next, let’s try an example that shows that the lifetime of the reference in -->
<!-- `result` must be the smaller lifetime of the two arguments. We’ll move the -->
<!-- declaration of the `result` variable outside the inner scope but leave the -->
<!-- assignment of the value to the `result` variable inside the scope with -->
<!-- `string2`. Then we’ll move the `println!` that uses `result` outside the inner -->
<!-- scope, after the inner scope has ended. The code in Listing 10-24 will not -->
<!-- compile. -->
<p>次に、<code>result</code>の参照のライフタイムが2つの引数の小さい方のライフタイムになることを示す例を試しましょう。
<code>result</code>変数の宣言を内側のスコープの外に移すものの、<code>result</code>変数への代入は<code>string2</code>のスコープ内に残したままにします。
それから<code>result</code>を使用する<code>println!</code>を内側のスコープの外、内側のスコープが終わった後に移動します。
リスト10-24のコードはコンパイルできません。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<!-- <span class="caption">Listing 10-24: Attempting to use `result` after `string2` -->
<!-- has gone out of scope</span> -->
<p><span class="caption">リスト10-24: <code>string2</code>がスコープを抜けてから<code>result</code>を使用しようとする</span></p>
<!-- When we try to compile this code, we’ll get this error: -->
<p>このコードのコンパイルを試みると、こんなエラーになります:</p>
<pre><code class="language-text">error[E0597]: `string2` does not live long enough
  --&gt; src/main.rs:15:5
   |
14 |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
15 |     }
   |     ^ `string2` dropped here while still borrowed
16 |     println!(&quot;The longest string is {}&quot;, result);
17 | }
   | - borrowed value needs to live until here
</code></pre>
<!-- The error shows that for `result` to be valid for the `println!` statement, -->
<!-- `string2` would need to be valid until the end of the outer scope. Rust knows -->
<!-- this because we annotated the lifetimes of the function parameters and return -->
<!-- values using the same lifetime parameter `'a`. -->
<p>このエラーは、<code>result</code>が<code>println!</code>文に対して有効になるために、<code>string2</code>が外側のスコープの終わりまで有効である必要があることを示しています。
関数引数と戻り値のライフタイムを同じライフタイム引数<code>'a</code>で注釈したので、コンパイラはこのことを知っています。</p>
<!-- As humans, we can look at this code and see that `string1` is longer than -->
<!-- `string2` and therefore `result` will contain a reference to `string1`. -->
<!-- Because `string1` has not gone out of scope yet, a reference to `string1` will -->
<!-- still be valid for the `println!` statement. However, the compiler can’t see -->
<!-- that the reference is valid in this case. We’ve told Rust that the lifetime of -->
<!-- the reference returned by the `longest` function is the same as the smaller of -->
<!-- the lifetimes of the references passed in. Therefore, the borrow checker -->
<!-- disallows the code in Listing 10-24 as possibly having an invalid reference. -->
<p>人間からしたら、このコードを見て<code>string1</code>は<code>string2</code>よりも長いことが確認でき、
故に<code>result</code>は<code>string1</code>への参照を含んでいます。まだ<code>string1</code>はスコープを抜けていないので、
それでも<code>string1</code>への参照は<code>println!</code>にとって有効でしょう。ですが、コンパイラはこの場合、
参照が有効であると見なせません。<code>longest</code>関数から返ってくる参照のライフタイムは、
渡した参照のうちの小さい方と同じだとコンパイラに指示しました。それ故に、
借用精査機は、リスト10-24のコードを無効な参照がある可能性があるとして許可しないのです。</p>
<!-- Try designing more experiments that vary the values and lifetimes of the -->
<!-- references passed in to the `longest` function and how the returned reference -->
<!-- is used. Make hypotheses about whether or not your experiments will pass the -->
<!-- borrow checker before you compile; then check to see if you’re right! -->
<p>試しに値や<code>longest</code>関数に渡される参照のライフタイムや返される参照の使用法が異なる実験をもっと企ててみてください。
自分の実験がコンパイル前に借用精査機を通るかどうか仮説を立ててください; そして、正しいか確かめてください！</p>
<!-- ### Thinking in Terms of Lifetimes -->
<a class="header" href="print.html#aライフタイムの観点で思考する" id="aライフタイムの観点で思考する"><h3>ライフタイムの観点で思考する</h3></a>
<!-- The way in which you need to specify lifetime parameters depends on what your -->
<!-- function is doing. For example, if we changed the implementation of the -->
<!-- `longest` function to always return the first parameter rather than the longest -->
<!-- string slice, we wouldn’t need to specify a lifetime on the `y` parameter. The -->
<!-- following code will compile: -->
<p>ライフタイム引数を指定する必要のある手段は、関数が行っていることによります。例えば、
<code>longest</code>関数の実装を最長の文字列スライスではなく、常に最初の引数を返すように変更したら、
<code>y</code>引数に対してライフタイムを指定する必要はなくなるでしょう。以下のコードはコンパイルできます:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<!-- In this example, we’ve specified a lifetime parameter `'a` for the parameter -->
<!-- `x` and the return type, but not for the parameter `y`, because the lifetime of -->
<!-- `y` does not have any relationship with the lifetime of `x` or the return value. -->
<p>この例では、引数<code>x</code>と戻り値に対してライフタイム引数<code>'a</code>を指定しましたが、引数<code>y</code>には指定していません。
<code>y</code>のライフタイムは<code>x</code>や戻り値のライフタイムとは何の関係もないからです。</p>
<!-- When returning a reference from a function, the lifetime parameter for the -->
<!-- return type needs to match the lifetime parameter for one of the parameters. If -->
<!-- the reference returned does *not* refer to one of the parameters, it must refer -->
<!-- to a value created within this function, which would be a dangling reference -->
<!-- because the value will go out of scope at the end of the function. Consider -->
<!-- this attempted implementation of the `longest` function that won’t compile: -->
<p>関数から参照を返す際、戻り値型のライフタイム引数は、引数のうちどれかのライフタイム引数と一致する必要があります。
返される参照が引数のどれかを参照してい<em>なけれ</em>ば、この関数内で生成された値を参照しているに違いなく、
これは、その値が関数の末端でスコープを抜けるので、ダングリング参照になるでしょう。
コンパイルできないこの<code>longest</code>関数の未遂の実装を考えてください:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    // 本当に長い文字列
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<!-- Here, even though we’ve specified a lifetime parameter `'a` for the return -->
<!-- type, this implementation will fail to compile because the return value -->
<!-- lifetime is not related to the lifetime of the parameters at all. Here is the -->
<!-- error message we get: -->
<p>ここでは、たとえ、戻り値型にライフタイム引数<code>'a</code>を指定していても、戻り値のライフタイムは、
引数のライフタイムと全く関係がないので、この実装はコンパイルできないでしょう。
こちらが、得られるエラーメッセージです:</p>
<pre><code class="language-text">error[E0597]: `result` does not live long enough
 --&gt; src/main.rs:3:5
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the
function body at 1:1...
(注釈: 借用された値は、関数本体1行目1文字目で定義されているようにライフタイム'aに対して有効でなければなりません)
 --&gt; src/main.rs:1:1
  |
1 | / fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
2 | |     let result = String::from(&quot;really long string&quot;);
3 | |     result.as_str()
4 | | }
  | |_^
</code></pre>
<!-- The problem is that `result` goes out of scope and gets cleaned up at the end -->
<!-- of the `longest` function. We’re also trying to return a reference to `result` -->
<!-- from the function. There is no way we can specify lifetime parameters that -->
<!-- would change the dangling reference, and Rust won’t let us create a dangling -->
<!-- reference. In this case, the best fix would be to return an owned data type -->
<!-- rather than a reference so the calling function is then responsible for -->
<!-- cleaning up the value. -->
<p>問題は、<code>result</code>が<code>longest</code>関数の末端でスコープを抜け、片付けられてしまうことです。
また、関数から<code>result</code>を返そうともしています。ダングリング参照を変えるであろうライフタイム引数を指定する手段はなく、
コンパイラは、ダングリング参照を生成させてくれません。今回の場合、最善の修正案は、
呼び出し元の関数が値の片付けに責任を持てるよう、参照ではなく所有されたデータ型を返すことでしょう。</p>
<!-- Ultimately, lifetime syntax is about connecting the lifetimes of various -->
<!-- parameters and return values of functions. Once they’re connected, Rust has -->
<!-- enough information to allow memory-safe operations and disallow operations that -->
<!-- would create dangling pointers or otherwise violate memory safety. -->
<p>究極的にライフタイム記法は、関数のいろんな引数と戻り値のライフタイムを接続することに関するのです。
一旦、繋がりができたら、メモリ安全な処理を許可するのに十分な情報がコンパイラにはあり、
ダングリングポインタを生成するであろう処理を不認可し、さもなくばメモリ安全性を侵害するのです。</p>
<!-- ### Lifetime Annotations in Struct Definitions -->
<a class="header" href="print.html#a構造体定義のライフタイム注釈" id="a構造体定義のライフタイム注釈"><h3>構造体定義のライフタイム注釈</h3></a>
<!-- So far, we’ve only defined structs to hold owned types. It’s possible for -->
<!-- structs to hold references, but in that case we would need to add a lifetime -->
<!-- annotation on every reference in the struct’s definition. Listing 10-25 has a -->
<!-- struct named `ImportantExcerpt` that holds a string slice. -->
<p>ここまで、所有された型を保持する構造体だけを定義してきました。構造体に参照を保持させることもできますが、
その場合、構造体定義の全参照にライフタイム注釈を付け加える必要があるでしょう。
リスト10-25には、文字列スライスを保持する<code>ImportantExcerpt</code>という構造体があります。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    // 僕をイシュマエルとお呼び。何年か前・・・
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.')
        .next()
        .expect(&quot;Could not find a '.'&quot;);  // '.'が見つかりませんでした
    let i = ImportantExcerpt { part: first_sentence };
}
</code></pre></pre>
<!-- <span class="caption">Listing 10-25: A struct that holds a reference, so its -->
<!-- definition needs a lifetime annotation</span> -->
<p><span class="caption">リスト10-25: 参照を含む構造体なので、定義にライフタイム注釈が必要</span></p>
<!-- This struct has one field, `part`, that holds a string slice, which is a -->
<!-- reference. As with generic data types, we declare the name of the generic -->
<!-- lifetime parameter inside angle brackets after the name of the struct so we can -->
<!-- use the lifetime parameter in the body of the struct definition. This -->
<!-- annotation means an instance of `ImportantExcerpt` can’t outlive the reference -->
<!-- it holds in its `part` field. -->
<p>この構造体には文字列スライスを保持する1つのフィールド、<code>part</code>があり、これは参照です。
ジェネリックなデータ型同様、構造体名の後、山カッコの中にジェネリックなライフタイム引数の名前を宣言するので、
構造体定義の本体でライフタイム引数を使用できます。この注釈は、<code>ImportantExcerpt</code>のインスタンスが、
<code>part</code>フィールドに保持している参照よりも長生きしないことを意味します。</p>
<!-- The `main` function here creates an instance of the `ImportantExcerpt` struct -->
<!-- that holds a reference to the first sentence of the `String` owned by the -->
<!-- variable `novel`. The data in `novel` exists before the `ImportantExcerpt` -->
<!-- instance is created. In addition, `novel` doesn’t go out of scope until after -->
<!-- the `ImportantExcerpt` goes out of scope, so the reference in the -->
<!-- `ImportantExcerpt` instance is valid. -->
<p>ここの<code>main</code>関数は、変数<code>novel</code>に所有される<code>String</code>の最初の文への参照を保持する<code>ImportantExcerpt</code>インスタンスを生成しています。
<code>novel</code>のデータは、<code>ImportantExcerpt</code>インスタンスが作られる前に存在しています。
加えて、<code>ImportantExcerpt</code>がスコープを抜けるまで<code>novel</code>はスコープを抜けないので、
<code>ImportantExcerpt</code>インスタンスの参照は有効なのです。</p>
<!-- ### Lifetime Elision -->
<a class="header" href="print.html#aライフタイム省略" id="aライフタイム省略"><h3>ライフタイム省略</h3></a>
<!-- You’ve learned that every reference has a lifetime and that you need to specify -->
<!-- lifetime parameters for functions or structs that use references. However, in -->
<!-- Chapter 4 we had a function in Listing 4-9, which is shown again in Listing -->
<!-- 10-26, that compiled without lifetime annotations. -->
<p>全参照にはライフタイムがあり、参照を使用する関数や構造体にはライフタイム引数を指定する必要があることを学びました。
ですが、リスト4-9にとある関数があり、リスト10-26に再度示しましたが、
これは、ライフタイム注釈なしでコンパイルできました。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 10-26: A function we defined in Listing 4-9 that -->
<!-- compiled without lifetime annotations, even though the parameter and return -->
<!-- type are references</span> -->
<p><span class="caption">リスト10-26: 引数と戻り値型が参照であるにも関わらず、ライフタイム注釈なしでコンパイルできた
リスト4-9で定義した関数</span></p>
<!-- The reason this function compiles without lifetime annotations is historical: -->
<!-- in early versions (pre-1.0) of Rust, this code wouldn’t have compiled because -->
<!-- every reference needed an explicit lifetime. At that time, the function -->
<!-- signature would have been written like this: -->
<p>この関数がライフタイム注釈なしでコンパイルできた理由は、歴史的なものです: 昔のバージョンのRust(1.0以前)では、
全参照に明示的なライフタイムが必要だったので、このコードはコンパイルできませんでした。
その頃、関数シグニチャはこのように記述されていたのです:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!-- After writing a lot of Rust code, the Rust team found that Rust programmers -->
<!-- were entering the same lifetime annotations over and over in particular -->
<!-- situations. These situations were predictable and followed a few deterministic -->
<!-- patterns. The developers programmed these patterns into the compiler’s code so -->
<!-- the borrow checker could infer the lifetimes in these situations and wouldn't -->
<!-- need explicit annotations. -->
<p>多くのRustコードを書いた後、Rustチームは、Rustプログラマが特定の場面では、
何度も何度も同じライフタイム注釈に入ることを発見しました。これらの場面は予測可能で、
いくつかの決定的なパターンに従っていました。開発者はこのパターンをコンパイラのコードに落とし込んだので、
このような場面には借用精査機がライフタイムを推論できるようになり、明示的な注釈を必要としなくなったのです。</p>
<!-- This piece of Rust history is relevant because it’s possible that more -->
<!-- deterministic patterns will emerge and be added to the compiler. In the future, -->
<!-- even fewer lifetime annotations might be required. -->
<p>他の決定的なパターンが出現し、コンパイラに追加されることもあり得るので、このRustの歴史は関係があります。
将来的に、さらに少数のライフタイム注釈しか必要にならない可能性もあります。</p>
<!-- The patterns programmed into Rust’s analysis of references are called the -->
<!-- *lifetime elision rules*. These aren’t rules for programmers to follow; they’re -->
<!-- a set of particular cases that the compiler will consider, and if your code -->
<!-- fits these cases, you don’t need to write the lifetimes explicitly. -->
<p>コンパイラの参照解析に落とし込まれたパターンは、<em>ライフタイム省略規則</em>と呼ばれます。
これらはプログラマが従う規則ではありません; コンパイラが考慮する一連の特定のケースであり、
自分のコードがこのケースに当てはまれば、ライフタイムを明示的に書く必要はなくなります。</p>
<!-- The elision rules don’t provide full inference. If Rust deterministically -->
<!-- applies the rules but there is still ambiguity as to what lifetimes the -->
<!-- references have, the compiler won’t guess what the lifetime of the remaining -->
<!-- references should be. In this case, instead of guessing, the compiler will give -->
<!-- you an error that you can resolve by adding the lifetime annotations that -->
<!-- specify how the references relate to each other. -->
<p>省略規則は、完全な推論を提供しません。コンパイラが決定的に規則を適用できるけれども、
参照がなるライフタイムに関してそれでも曖昧性があるなら、コンパイラは、残りの参照がなるべきライフタイムを推論しません。
この場合、推論ではなく、コンパイラは、参照がお互いにどう関係するかを指定するライフタイム注釈を追記することで、
解決できるエラーを与えます。</p>
<!-- Lifetimes on function or method parameters are called *input lifetimes*, and -->
<!-- lifetimes on return values are called *output lifetimes*. -->
<p>関数やメソッドの引数のライフタイムは、<em>入力ライフタイム</em>と呼ばれ、
戻り値のライフタイムは<em>出力ライフタイム</em>と称されます。</p>
<!-- The compiler uses three rules to figure out what lifetimes references have when -->
<!-- there aren’t explicit annotations. The first rule applies to input lifetimes, -->
<!-- and the second and third rules apply to output lifetimes. If the compiler gets -->
<!-- to the end of the three rules and there are still references for which it can’t -->
<!-- figure out lifetimes, the compiler will stop with an error. -->
<p>コンパイラは3つの規則を活用し、明示的な注釈がない時に、参照がどんなライフタイムになるかを計算します。
最初の規則は入力ライフタイムに適用され、2番目と3番目の規則は出力ライフタイムに適用されます。
コンパイラが3つの規則の最後まで到達し、それでもライフタイムを割り出せない参照があったら、
コンパイラはエラーで停止します。</p>
<!-- The first rule is that each parameter that is a reference gets its own lifetime -->
<!-- parameter. In other words, a function with one parameter gets one lifetime -->
<!-- parameter: `fn foo<'a>(x: &'a i32)`; a function with two parameters gets two -->
<!-- separate lifetime parameters: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; and so -->
<!-- on. -->
<p>最初の規則は、参照である各引数は、独自のライフタイム引数を得るというものです。換言すれば、
1引数の関数は、1つのライフタイム引数を得るということです: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>;
2つ引数のある関数は、2つの個別のライフタイム引数を得ます: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>;
以下同様。</p>
<!-- The second rule is if there is exactly one input lifetime parameter, that -->
<!-- lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: &'a i32) -->
<!-- -> &'a i32`. -->
<p>2番目の規則は、1つだけ入力ライフタイム引数があるなら、そのライフタイムが全ての出力ライフタイム引数に代入されるというものです:
<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</p>
<!-- The third rule is if there are multiple input lifetime parameters, but one of -->
<!-- them is `&self` or `&mut self` because this is a method, the lifetime of `self` -->
<!-- is assigned to all output lifetime parameters. This third rule makes methods -->
<!-- much nicer to read and write because fewer symbols are necessary. -->
<p>3番目の規則は、複数の入力ライフタイム引数があるけれども、メソッドなのでそのうちの一つが<code>&amp;self</code>や<code>&amp;mut self</code>だったら、
<code>self</code>のライフタイムが全出力ライフタイム引数に代入されるというものです。
この3番目の規則により、必要なシンボルの数が減るので、メソッドが遥かに読み書きしやすくなります。</p>
<!-- Let’s pretend we’re the compiler. We’ll apply these rules to figure out what -->
<!-- the lifetimes of the references in the signature of the `first_word` function -->
<!-- in Listing 10-26 are. The signature starts without any lifetimes associated -->
<!-- with the references: -->
<p>コンパイラになってみましょう。これらの規則を適用して、リスト10-26の<code>first_word</code>関数のシグニチャの参照のライフタイムが何か計算します。
シグニチャは、参照に紐付けられるライフタイムがない状態から始まります:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<!-- Then the compiler applies the first rule, which specifies that each parameter -->
<!-- gets its own lifetime. We’ll call it `'a` as usual, so now the signature is -->
<!-- this: -->
<p>そうして、コンパイラは最初の規則を適用し、各引数が独自のライフタイムを得ると指定します。
それを通常通り<code>'a</code>と呼ぶので、シグニチャはこうなります:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<!-- The second rule applies because there is exactly one input lifetime. The second -->
<!-- rule specifies that the lifetime of the one input parameter gets assigned to -->
<!-- the output lifetime, so the signature is now this: -->
<p>1つだけ入力ライフタイムがあるので、2番目の規則を適用します。2番目の規則は、1つの入力引数のライフタイムが、
出力引数に代入されると指定するので、シグニチャはこうなります:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!-- Now all the references in this function signature have lifetimes, and the -->
<!-- compiler can continue its analysis without needing the programmer to annotate -->
<!-- the lifetimes in this function signature. -->
<p>もうこの関数シグニチャの全ての参照にライフタイムが付いたので、コンパイラは、
プログラマにこの関数シグニチャのライフタムを注釈してもらう必要なく、解析を続行できます。</p>
<!-- Let’s look at another example, this time using the `longest` function that had -->
<!-- no lifetime parameters when we started working with it in Listing 10-21: -->
<p>別の例に目を向けましょう。今回は、リスト10-21で取り掛かったときにはライフタイム引数はなかった<code>longest</code>関数です:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<!-- Let’s apply the first rule: each parameter gets its own lifetime. This time we -->
<!-- have two parameters instead of one, so we have two lifetimes: -->
<p>最初の規則を適用しましょう: 各引数が独自のライフタイムを得るのです。今回は、
1つではなく2つ引数があるので、ライフタイムも2つです:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<!-- You can see that the second rule doesn’t apply because there is more than one -->
<!-- input lifetime. The third rule doesn’t apply either, because `longest` is a -->
<!-- function rather than a method, so none of the parameters are `self`. After -->
<!-- working through all three rules, we still haven’t figured out what the return -->
<!-- type’s lifetime is. This is why we got an error trying to compile the code in -->
<!-- Listing 10-21: the compiler worked through the lifetime elision rules but still -->
<!-- couldn’t figure out all the lifetimes of the references in the signature. -->
<p>2つ以上入力ライフタイムがあるので、2番目の規則は適用されないとわかります。また3番目の規則も適用されません。
<code>longest</code>はメソッドではなく関数なので、どの引数も<code>self</code>ではないのです。3つの規則全部を適用した後、
まだ戻り値型のライフタイムが判明していません。このために、リスト10-21でこのコードをコンパイルしようとしてエラーになったのです:
コンパイラは、ライフタイム省略規則全てを適用したけれども、シグニチャの参照全部のライフタイムを計算できなかったのです。</p>
<!-- Because the third rule really only applies in method signatures, we’ll look at -->
<!-- lifetimes in that context next to see why the third rule means we don’t have to -->
<!-- annotate lifetimes in method signatures very often. -->
<p>3番目の規則は本当にメソッドシグニチャでしか適用されないので、次にその文脈でライフタイムを観察し、
3番目の規則が、メソッドシグニチャであまり頻繁にライフタイムを注釈しなくても済むことを意味する理由を確認します。</p>
<!-- ### Lifetime Annotations in Method Definitions -->
<a class="header" href="print.html#aメソッド定義におけるライフタイム注釈" id="aメソッド定義におけるライフタイム注釈"><h3>メソッド定義におけるライフタイム注釈</h3></a>
<!-- When we implement methods on a struct with lifetimes, we use the same syntax as -->
<!-- that of generic type parameters shown in Listing 10-11. Where we declare and -->
<!-- use the lifetime parameters depends on whether they’re related to the struct -->
<!-- fields or the method parameters and return values. -->
<p>構造体にライフタイムのあるメソッドを実装する際、リスト10-11で示したジェネリックな型引数と同じ記法を使用します。
ライフタイム引数を宣言し使用する場所は、構造体フィールドかメソッド引数と戻り値に関係するかによります。</p>
<!-- Lifetime names for struct fields always need to be declared after the `impl` -->
<!-- keyword and then used after the struct’s name, because those lifetimes are part -->
<!-- of the struct’s type. -->
<p>構造体のフィールド用のライフタイム名は、<code>impl</code>キーワードの後に宣言する必要があり、
それから構造体名の後に使用されます。そのようなライフタイムは構造体の型の一部になるからです。</p>
<!-- In method signatures inside the `impl` block, references might be tied to the -->
<!-- lifetime of references in the struct’s fields, or they might be independent. In -->
<!-- addition, the lifetime elision rules often make it so that lifetime annotations -->
<!-- aren’t necessary in method signatures. Let’s look at some examples using the -->
<!-- struct named `ImportantExcerpt` that we defined in Listing 10-25. -->
<p><code>impl</code>ブロック内のメソッドシグニチャでは、参照は構造体のフィールドの参照のライフタイムに紐づくか、
独立している可能性があります。加えて、ライフタイム省略規則により、メソッドシグニチャでライフタイム注釈が必要なくなることがよくあります。
リスト10-25で定義した<code>ImportantExcerpt</code>という構造体を使用して、何か例を眺めましょう。</p>
<!-- First, we’ll use a method named `level` whose only parameter is a reference to -->
<!-- `self` and whose return value is an `i32`, which is not a reference to anything: -->
<p>まず、唯一の引数が<code>self</code>への参照で戻り値が<code>i32</code>という何かへの参照ではない<code>level</code>というメソッドを使用します:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
#}</code></pre></pre>
<!-- The lifetime parameter declaration after `impl` and use after the type name is -->
<!-- required, but we’re not required to annotate the lifetime of the reference to -->
<!-- `self` because of the first elision rule. -->
<p><code>impl</code>後のライフタイム引数宣言と型名の後に使用するのは必須ですが、最初の省略規則のため、
<code>self</code>への参照のライフタイムを注釈する必要はありません。</p>
<!-- Here is an example where the third lifetime elision rule applies: -->
<p>3番目のライフタイム省略規則が適用される例はこちらです:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
#}</code></pre></pre>
<!-- There are two input lifetimes, so Rust applies the first lifetime elision rule -->
<!-- and gives both `&self` and `announcement` their own lifetimes. Then, because -->
<!-- one of the parameters is `&self`, the return type gets the lifetime of `&self`, -->
<!-- and all lifetimes have been accounted for. -->
<p>2つ入力ライフタイムがあるので、コンパイラは最初のライフタイム省略規則を適用し、
<code>&amp;self</code>と<code>announcement</code>に独自のライフタイムを与えます。それから、
引数の1つが<code>&amp;self</code>なので、戻り値型は<code>&amp;self</code>のライフタイムを得て、
全てのライフタイムが説明されました。</p>
<!-- ### The Static Lifetime -->
<a class="header" href="print.html#a静的ライフタイム" id="a静的ライフタイム"><h3>静的ライフタイム</h3></a>
<!-- One special lifetime we need to discuss is `'static`, which denotes the entire -->
<!-- duration of the program. All string literals have the `'static` lifetime, which -->
<!-- we can annotate as follows: -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
#}</code></pre></pre>
<p>議論する必要のある1種の特殊なライフタイムが、<code>'static</code>であり、これはプログラム全体の期間を示します。
文字列リテラルは全て<code>'static</code>ライフタイムになり、次のように注釈できます:</p>
<!-- The text of this string is stored directly in the binary of your program, which -->
<!-- is always available. Therefore, the lifetime of all string literals is -->
<!-- `'static`. -->
<p>この文字列のテキストは、プログラムのバイナリに直接格納され、常に利用可能です。故に、全文字列リテラルのライフタイムは、
<code>'static</code>なのです。</p>
<!-- You might see suggestions to use the `'static` lifetime in error messages. But -->
<!-- before specifying `'static` as the lifetime for a reference, think about -->
<!-- whether the reference you have actually lives the entire lifetime of your -->
<!-- program or not. You might consider whether you want it to live that long, even -->
<!-- if it could. Most of the time, the problem results from attempting to create a -->
<!-- dangling reference or a mismatch of the available lifetimes. In such cases, the -->
<!-- solution is fixing those problems, not specifying the `'static` lifetime. -->
<p>エラーメッセージで<code>'static</code>ライフタイムを使用することを勧められることがある可能性があります。
ですが、参照に対してライフタイムとして<code>'static</code>を指定する前に、今ある参照が本当にプログラムの全期間生きるかどうか考えてください。
可能であっても、参照がそれだけの期間生きるかどうか考慮する可能性があります。
ほとんどの場合、問題は、ダングリング参照を生成しようとしているか、利用可能なライフタイムの不一致が原因です。
そのような場合、解決策はその問題を修正することであり、<code>'static</code>ライフタイムを指定することではありません。</p>
<!-- ## Generic Type Parameters, Trait Bounds, and Lifetimes Together -->
<a class="header" href="print.html#aジェネリックな型引数トレイト境界ライフタイムを一度に" id="aジェネリックな型引数トレイト境界ライフタイムを一度に"><h2>ジェネリックな型引数、トレイト境界、ライフタイムを一度に</h2></a>
<!-- Let’s briefly look at the syntax of specifying generic type parameters, trait -->
<!-- bounds, and lifetimes all in one function! -->
<p>ジェネリックな型引数、トレイト境界、ライフタイムを指定する記法を全て1関数でちょっと眺めましょう！</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<!-- This is the `longest` function from Listing 10-22 that returns the longer of -->
<!-- two string slices. But now it has an extra parameter named `ann` of the generic -->
<!-- type `T`, which can be filled in by any type that implements the `Display` -->
<!-- trait as specified by the `where` clause. This extra parameter will be printed -->
<!-- before the function compares the lengths of the string slices, which is why the -->
<!-- `Display` trait bound is necessary. Because lifetimes are a type of generic, -->
<!-- the declarations of the lifetime parameter `'a` and the generic type parameter -->
<!-- `T` go in the same list inside the angle brackets after the function name. -->
<p>これがリスト10-22からの2つの文字列のうち長い方を返す<code>longest</code>関数ですが、
ジェネリックな型<code>T</code>の<code>ann</code>という追加の引数があり、これは<code>where</code>節で指定されているように、
<code>Display</code>トレイトを実装するあらゆる型で埋めることができます。
この追加の引数は、関数が文字列スライスの長さを比較する前に出力されるので、
<code>Display</code>トレイト境界が必要なのです。ライフタイムは1種のジェネリックなので、
ライフタイム引数<code>'a</code>とジェネリックな型引数<code>T</code>が関数名の後、山カッコ内の同じリストに収まっています。</p>
<!-- ## Summary -->
<a class="header" href="print.html#a総括" id="a総括"><h2>総括</h2></a>
<!-- We covered a lot in this chapter! Now that you know about generic type -->
<!-- parameters, traits and trait bounds, and generic lifetime parameters, you’re -->
<!-- ready to write code without repetition that works in many different situations. -->
<!-- Generic type parameters let you apply the code to different types. Traits and -->
<!-- trait bounds ensure that even though the types are generic, they’ll have the -->
<!-- behavior the code needs. You learned how to use lifetime annotations to ensure -->
<!-- that this flexible code won’t have any dangling references. And all of this -->
<!-- analysis happens at compile time, which doesn’t affect runtime performance! -->
<p>いろんなことをこの章では講義しましたね！今やジェネリックな型引数、トレイトとトレイト境界、そしてジェネリックなライフタイム引数を知ったので、
多くの異なる場面で動くコードを繰り返しなく書く準備ができました。ジェネリックな型引数により、
コードを異なる型に適用させてくれます。トレイトとトレイト境界は、型がジェネリックであっても、
コードが必要とする振る舞いを持つことを保証します。ライフタイム注釈を活用して、
この柔軟なコードにダングリング参照が存在しないことを保証する方法を学びました。
さらにこの解析は全てコンパイル時に起こり、実行時のパフォーマンスには影響しません！</p>
<!-- Believe it or not, there is much more to learn on the topics we discussed in -->
<!-- this chapter: Chapter 17 discusses trait objects, which are another way to use -->
<!-- traits. Chapter 19 covers more complex scenarios involving lifetime annotations -->
<!-- as well as some advanced type system features. But next, you’ll learn how to -->
<!-- write tests in Rust so you can make sure your code is working the way it should. -->
<p>信じるかどうかは自由ですが、この章で議論した話題にはもっともっと学ぶべきことがあります:
第17章ではトレイトオブジェクトを議論し、これはトレイトを使用する別の手段です。
第19章では、ライフタイム注釈が関わるもっと複雑な筋書きと何か高度な型システムの機能を講義します。
ですが次は、Rustでテストを書く方法を学ぶので、コードがあるべき通りに動いていることを確かめられます。</p>
<!-- # Writing Automated Tests -->
<a class="header" href="print.html#a自動テストを書く" id="a自動テストを書く"><h1>自動テストを書く</h1></a>
<!-- In his 1972 essay “The Humble Programmer,” Edsger W. Dijkstra said that -->
<!-- “Program testing can be a very effective way to show the presence of bugs, but -->
<!-- it is hopelessly inadequate for showing their absence.” That doesn’t mean we -->
<!-- shouldn’t try to test as much as we can! -->
<p>1972年のエッセイ「謙虚なプログラマ」でエドガー・W・ダイクストラは以下のように述べている。
「プログラムのテストは、バグの存在を示すには非常に効率的な手法であるが、
バグの不在を示すには望み薄く不適切である」と。これは、できるだけテストを試みるべきではないということではありません。</p>
<!-- Correctness in our programs is the extent to which our code does what we intend -->
<!-- it to do. Rust is designed with a high degree of concern about the correctness -->
<!-- of programs, but correctness is complex and not easy to prove. Rust’s type -->
<!-- system shoulders a huge part of this burden, but the type system cannot catch -->
<!-- every kind of incorrectness. As such, Rust includes support for writing -->
<!-- automated software tests within the language. -->
<p>プログラムの正当性は、どこまで自分のコードが意図していることをしているかなのです。
Rustは、プログラムの正当性に重きを置いて設計されていますが、
正当性は複雑で、単純に証明することはありません。Rustの型システムは、
この重荷の多くの部分を肩代わりしてくれますが、型システムはあらゆる種類の不当性を捕捉してはくれません。
ゆえに、Rustでは、言語内で自動化されたソフトウェアテストを書くことをサポートしているのです。</p>
<!-- As an example, say we write a function called `add_two` that adds 2 to whatever -->
<!-- number is passed to it. This function’s signature accepts an integer as a -->
<!-- parameter and returns an integer as a result. When we implement and compile -->
<!-- that function, Rust does all the type checking and borrow checking that you've -->
<!-- learned so far to ensure that, for instance, we aren’t passing a `String` value -->
<!-- or an invalid reference to this function. But Rust *can’t* check that this -->
<!-- function will do precisely what we intend, which is return the parameter plus 2 -->
<!-- rather than, say, the parameter plus 10 or the parameter minus 50! That's where -->
<!-- tests come in. -->
<p>例として、渡された何かの数値に2を足す<code>add_two</code>という関数を書くとしましょう。
この関数のシグニチャは、引数に整数を取り、結果として整数を返します。
この関数を実装してコンパイルすると、コンパイラはこれまでに学んできた型チェックと借用チェックを全て行い、
例えば、<code>String</code>の値や無効な参照をこの関数に渡していないかなどを確かめるのです。
ところが、コンパイラはプログラマがまさしく意図したことを関数が実行しているかどうかは確かめ<em>られません</em>。
つまり、そうですね、引数に10を足したり、50を引いたりするのではなく、引数に2を足していることです。
そんな時にテストは、必要になるのです。</p>
<!-- We can write tests that assert, for example, that when we pass `3` to the -->
<!-- `add_two` function, the returned value is `5`. We can run these tests whenever -->
<!-- we make changes to our code to make sure any existing correct behavior has not -->
<!-- changed. -->
<p>例えば、<code>add_two</code>関数に<code>3</code>を渡した時に、戻り値は5であることをアサーションするようなテストを書くことができます。
コードに変更を加えた際にこれらのテストを走らせ、既存の正当な振る舞いが変わっていないことを確認できます。</p>
<!-- Testing is a complex skill: although we can’t cover every detail about how to -->
<!-- write good tests in one chapter, we’ll discuss the mechanics of Rust’s testing -->
<!-- facilities. We’ll talk about the annotations and macros available to you when -->
<!-- writing your tests, the default behavior and options provided for running your -->
<!-- tests, and how to organize tests into unit tests and integration tests. -->
<p>テストは、煩雑なスキルです: いいテストの書き方をあらゆる方面から解説することは1章だけではできないのですが、
Rustのテスト機構のメカニズムについて議論します。テストを書く際に利用可能になるアノテーションとマクロについて、
テストを実行するのに提供されているオプションと標準の動作、さらにテストをユニットテストや統合テストに体系化する方法について語ります。</p>
<!-- ## How to Write Tests -->
<a class="header" href="print.html#aテストの記述法" id="aテストの記述法"><h2>テストの記述法</h2></a>
<!-- Tests are Rust functions that verify that the non-test code is functioning in -->
<!-- the expected manner. The bodies of test functions typically perform these three -->
<!-- actions: -->
<p>テストは、非テストコードが想定された手段で機能していることを実証するRustの関数です。
テスト関数の本体は、典型的には以下の3つの動作を行います:</p>
<!-- 1. Set up any needed data or state. -->
<!-- 2. Run the code we want to test. -->
<!-- 3. Assert the results are what we expect. -->
<ol>
<li>必要なデータや状態をセットアップする。</li>
<li>テスト対象のコードを走らせる。</li>
<li>結果が想定通りかアサーションする。</li>
</ol>
<!-- Let’s look at the features Rust provides specifically for writing tests that -->
<!-- take these actions, which include the `test` attribute, a few macros, and the -->
<!-- `should_panic` attribute. -->
<p>Rustが、特にこれらの動作を行うテストを書くために用意している機能を見ていきましょう。
これには、<code>test</code>アトリビュート、いくつかのマクロ、<code>should_panic</code>アトリビュートが含まれます。</p>
<!-- ### The Anatomy of a Test Function -->
<a class="header" href="print.html#aテスト関数の解剖" id="aテスト関数の解剖"><h2>テスト関数の解剖</h2></a>
<!-- At its simplest, a test in Rust is a function that’s annotated with the `test` -->
<!-- attribute. Attributes are metadata about pieces of Rust code; one example is -->
<!-- the `derive` attribute we used with structs in Chapter 5. To change a function -->
<!-- into a test function, we add `#[test]` on the line before `fn`. When we run our -->
<!-- tests with the `cargo test` command, Rust builds a test runner binary that runs -->
<!-- the functions annotated with the `test` attribute and reports on whether each -->
<!-- test function passes or fails. -->
<p>最も単純には、Rustにおけるテストは<code>test</code>アトリビュートで注釈された関数のことです。アトリビュートとは、
Rustコードの欠片に関するメタデータです; 一例を挙げれば、構造体とともに第5章で使用した<code>derive</code>アトリビュートです。
関数をテスト関数に変えるには、<code>fn</code>の前に<code>#[test]</code>を付け加えるのです。
<code>cargo test</code>コマンドでテストを実行したら、コンパイラは<code>test</code>アトリビュートで注釈された関数を走らせるテスト用バイナリをビルドし、
各テスト関数が通過したか失敗したかを報告します。</p>
<!-- In Chapter 7, we saw that when we make a new library project with Cargo, a test -->
<!-- module with a test function in it is automatically generated for us. This -->
<!-- module helps us start writing our tests so you don’t have to look up the -->
<!-- exact structure and syntax of test functions every time you start a new -->
<!-- project. You can add as many additional test functions and as many test modules -->
<!-- as you want! -->
<p>第7章で、Cargoで新規ライブラリプロジェクトを作成した時に、テスト関数が含まれるテストモジュールが自動で生成されたことを見かけました。
このモジュールのおかげでテストを書き始めることができるので、新しいプロジェクトを立ち上げる度に、
テスト関数の正確な構造と記法を調べる必要がなくなるわけです。必要なだけテスト関数とテストモジュールは追加することができます。</p>
<!-- We’ll explore some aspects of how tests work by experimenting with the template -->
<!-- test generated for us without actually testing any code. Then we’ll write some -->
<!-- real-world tests that call some code that we’ve written and assert that its -->
<!-- behavior is correct. -->
<p>実際にテストすることなしにテンプレートのテストが生成されるのを実験することでテストの動作法の一部を探求しましょう。
それから、自分で書いた何らかのコードを呼び出し、振る舞いが正しいかアサーションする現実世界のテストを書きましょう。</p>
<!-- Let’s create a new library project called `adder`: -->
<p><code>adder</code>という新しいライブラリプロジェクトを生成しましょう:</p>
<pre><code class="language-text">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<!-- The contents of the *src/lib.rs* file in your `adder` library should look like -->
<!-- Listing 11-1. -->
<p><code>adder</code>ライブラリの<em>src/lib.rs</em>ファイルの中身はリスト11-1のような見た目のはずです。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 11-1: The test module and function generated -->
<!-- automatically by `cargo new`</span> -->
<p><span class="caption">リスト11-1: <code>cargo new</code>で自動生成されたテストモジュールと関数</span></p>
<!-- For now, let’s ignore the top two lines and focus on the function to see how it -->
<!-- works. Note the `#[test]` annotation before the `fn` line: this attribute -->
<!-- indicates this is a test function, so the test runner knows to treat this -->
<!-- function as a test. We could also have non-test functions in the `tests` module -->
<!-- to help set up common scenarios or perform common operations, so we need to -->
<!-- indicate which functions are tests by using the `#[test]` attribute. -->
<p>とりあえず、最初の2行は無視し、関数に集中してその動作法を見ましょう。
<code>fn</code>行の<code>#[test]</code>アノテーションに注目してください: このアトリビュートは、これがテスト関数であることを示唆しますので、
テスト実行機はこの関数をテストとして扱うとわかるのです。さらに、<code>tests</code>モジュール内には非テスト関数を入れ込み、
一般的なシナリオをセットアップしたり、共通の処理を行う手助けをしたりもできるので、
<code>#[test]</code>アトリビュートでどの関数がテストかを示唆する必要があるのです。</p>
<!-- The function body uses the `assert_eq!` macro to assert that 2 + 2 equals 4. -->
<!-- This assertion serves as an example of the format for a typical test. Let’s run -->
<!-- it to see that this test passes. -->
<p>関数本体は、<code>assert_eq!</code>マクロを使用して、2 + 2が4に等しいことをアサーションしています。
このアサーションは、典型的なテストのフォーマット例をなしているわけです。走らせてこのテストが通ることを確かめましょう。</p>
<!-- The `cargo test` command runs all tests in our project, as shown in Listing -->
<!-- 11-2. -->
<p><code>cargo test</code>コマンドでプロジェクトにあるテストが全て実行されます。リスト11-2に示したようにですね。</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- <span class="caption">Listing 11-2: The output from running the automatically -->
<!-- generated test</span> -->
<p><span class="caption">リスト11-2: 自動生成されたテストを走らせた出力</span></p>
<!-- Cargo compiled and ran the test. After the `Compiling`, `Finished`, and -->
<!-- `Running` lines is the line `running 1 test`. The next line shows the name -->
<!-- of the generated test function, called `it_works`, and the result of running -->
<!-- that test, `ok`. The overall summary of running the tests appears next. The -->
<!-- text `test result: ok.` means that all the tests passed, and the portion that -->
<!-- reads `1 passed; 0 failed` totals the number of tests that passed or failed. -->
<p>Cargoがテストをコンパイルし、走らせました。<code>Compiling</code>, <code>Finished</code>, <code>Running</code>の行の後に<code>running 1 test</code>の行があります。
次行が、生成されたテスト関数の<code>it_works</code>という名前とこのテストの実行結果、<code>ok</code>を示しています。
テスト実行の総合的なまとめが次に出現します。<code>test result:ok.</code>というテキストは、
全テストが通ったことを意味し、<code>1 passed; 0 failed</code>と読める部分は、通過または失敗したテストの数を合計しているのです。</p>
<!-- Because we don’t have any tests we’ve marked as ignored, the summary shows `0 -->
<!-- ignored`. We also haven’t filtered the tests being run, so the end of the -->
<!-- summary shows `0 filtered out`. We’ll talk about ignoring and filtering out -->
<!-- tests in the next section, “Controlling How Tests Are Run.” -->
<p>無視すると指定したテストは何もなかったため、まとめは<code>0 ignored</code>と示しています。
また、実行するテストにフィルタをかけもしなかったので、まとめの最後に<code>0 filtered out</code>と表示されています。
テストを無視することとフィルタすることに関しては次の節、「テストの実行され方を制御する」で語ります。</p>
<!-- The `0 measured` statistic is for benchmark tests that measure performance. -->
<!-- Benchmark tests are, as of this writing, only available in nightly Rust. See -->
<!-- [the documentation about benchmark tests][bench] to learn more. -->
<p><code>0 measured</code>という統計は、パフォーマンスを測定するベンチマークテスト用です。
ベンチマークテストは、本書記述の時点では、ナイトリー版のRustでのみ利用可能です。
詳しくは、<a href="../../unstable-book/library-features/test.html">ベンチマークテストのドキュメンテーション</a>を参照されたし。</p>
<!-- The next part of the test output, which starts with `Doc-tests adder`, is for -->
<!-- the results of any documentation tests. We don’t have any documentation tests -->
<!-- yet, but Rust can compile any code examples that appear in our API -->
<!-- documentation. This feature helps us keep our docs and our code in sync! We’ll -->
<!-- discuss how to write documentation tests in the “Documentation Comments As -->
<!-- Tests” section of Chapter 14. For now, we’ll ignore the `Doc-tests` output. -->
<p>テスト出力の次の部分、つまり<code>Doc-tests adder</code>で始まる部分は、ドキュメンテーションテストの結果用のものです。
まだドキュメンテーションテストは何もないものの、コンパイラは、APIドキュメントに現れたどんなコード例もコンパイルできます。
この機能により、ドキュメントとコードを同期することができるわけです。ドキュメンテーションテストの書き方については、
第14章の「テストとしてのドキュメンテーションコメント」節で議論しましょう。今は、<code>Doc-tests</code>出力は無視します。</p>
<!-- Let’s change the name of our test to see how that changes the test output. -->
<!-- Change the `it_works` function to a different name, such as `exploration`, like -->
<!-- so: -->
<p>テストの名前を変更してどうテスト出力が変わるか確かめましょう。<code>it_works</code>関数を違う名前、<code>exploration</code>などに変えてください。
そう、以下のように:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre></pre>
<!-- Then run `cargo test` again. The output now shows `exploration` instead of -->
<!-- `it_works`: -->
<p>そして、<code>cargo test</code>を再度走らせます。これで出力が<code>it_works</code>の代わりに<code>exploration</code>と表示しています:</p>
<pre><code class="language-text">running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- Let’s add another test, but this time we’ll make a test that fails! Tests fail -->
<!-- when something in the test function panics. Each test is run in a new thread, -->
<!-- and when the main thread sees that a test thread has died, the test is marked -->
<!-- as failed. We talked about the simplest way to cause a panic in Chapter 9, -->
<!-- which is to call the `panic!` macro. Enter the new test, `another`, so your -->
<!-- *src/lib.rs* file looks like Listing 11-3. -->
<p>別のテストを追加しますが、今回は失敗するテストにしましょう！テスト関数内の何かがパニックすると、
テストは失敗します。各テストは、新規スレッドで実行され、メインスレッドが、テストスレッドが死んだと確認した時、
テストは失敗と印づけられます。第9章でパニックを引き起こす最も単純な方法について語りました。
要するに、<code>panic!</code>マクロを呼び出すことです。<em>src/lib.rs</em>ファイルがリスト11-3のような見た目になるよう、
新しいテスト<code>another</code>を入力してください。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        //このテストを失敗させる
        panic!(&quot;Make this test fail&quot;);
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 11-3: Adding a second test that will fail because -->
<!-- we call the `panic!` macro</span> -->
<p><span class="caption">リスト11-3: <code>panic!</code>マクロを呼び出したために失敗する2番目のテストを追加する</span></p>
<!-- Run the tests again using `cargo test`. The output should look like Listing -->
<!-- 11-4, which shows that our `exploration` test passed and `another` failed. -->
<p><code>cargo test</code>で再度テストを走らせてください。出力はリスト11-4のようになるはずであり、
<code>exploration</code>テストは通り、<code>another</code>は失敗したと表示されます。</p>
<pre><code class="language-text">running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
    thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:10:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed
</code></pre>
<!-- <span class="caption">Listing 11-4: Test results when one test passes and one -->
<!-- test fails</span> -->
<p><span class="caption">リスト11-4: 1つのテストが通り、失敗するときのテスト結果</span></p>
<!-- Instead of `ok`, the line `test tests::another` shows `FAILED`. Two new -->
<!-- sections appear between the individual results and the summary: the first -->
<!-- section displays the detailed reason for each test failure. In this case, -->
<!-- `another` failed because it `panicked at 'Make this test fail'`, which happened -->
<!-- on line 10 in the *src/lib.rs* file. The next section lists just the names of -->
<!-- all the failing tests, which is useful when there are lots of tests and lots of -->
<!-- detailed failing test output. We can use the name of a failing test to run just -->
<!-- that test to more easily debug it; we’ll talk more about ways to run tests in -->
<!-- the “Controlling How Tests Are Run” section. -->
<p><code>ok</code>の代わりに<code>test test::another</code>の行は、<code>FAILED</code>を表示しています。個々の結果とまとめの間に、
2つ新たな区域ができました: 最初の区域は、失敗したテスト各々の具体的な理由を表示しています。
今回の場合、<code>another</code>は<code>'Make this test fail'でパニックした</code>ために失敗し、
これは、<em>src/lib.rs</em>ファイルの10行で起きました。次の区域は失敗したテストの名前だけを列挙し、
テストがたくさんあり、失敗したテストの詳細がたくさん表示されるときに有用になります。
失敗したテストの名前を使用してそのテストだけを実行し、より簡単にデバッグすることができます。
ただし、テストの実行方法については、「テストの実行され方を制御する」節でもっと語りましょう。</p>
<!-- The summary line displays at the end: overall, our test result is `FAILED`. -->
<!-- We had one test pass and one test fail. -->
<p>総括の行が最後に出力されています: 総合的に言うと、テスト結果は<code>失敗</code>でした。
一つのテストが通り、一つが失敗したわけです。</p>
<!-- Now that you’ve seen what the test results look like in different scenarios, -->
<!-- let’s look at some macros other than `panic!` that are useful in tests. -->
<p>異なるシナリオでのテスト結果がどんな風になるか見てきたので、テストを行う際に有用になる<code>panic!</code>以外のマクロに目を向けましょう。</p>
<!-- ### Checking Results with the `assert!` Macro -->
<a class="header" href="print.html#assertマクロで結果を確認する" id="assertマクロで結果を確認する"><h3><code>assert!</code>マクロで結果を確認する</h3></a>
<!-- The `assert!` macro, provided by the standard library, is useful when you want -->
<!-- to ensure that some condition in a test evaluates to `true`. We give the -->
<!-- `assert!` macro an argument that evaluates to a Boolean. If the value is -->
<!-- `true`, `assert!` does nothing and the test passes. If the value is `false`, -->
<!-- the `assert!` macro calls the `panic!` macro, which causes the test to fail. -->
<!-- Using the `assert!` macro helps us check that our code is functioning in the -->
<!-- way we intend. -->
<p><code>assert!</code>マクロは、標準ライブラリで提供されていますが、テスト内の何らかの条件が<code>true</code>と評価されることを確かめたいときに有効です。
<code>assert!</code>マクロには、論理値に評価される引数を与えます。その値が<code>true</code>なら、
<code>assert!</code>は何もせず、テストは通ります。その値が<code>false</code>なら、<code>assert!</code>マクロは<code>panic!</code>マクロを呼び出し、
テストは失敗します。<code>assert!</code>マクロを使用することで、コードが意図した通りに機能していることを確認する助けになるわけです。</p>
<!-- In Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold` -->
<!-- method, which are repeated here in Listing 11-5. Let’s put this code in the -->
<!-- *src/lib.rs* file and write some tests for it using the `assert!` macro. -->
<p>第5章のリスト5-15で、<code>Rectangle</code>構造体と<code>can_hold</code>メソッドを使用しました。リスト11-5でもそれを繰り返しています。
このコードを<em>src/lib.rs</em>ファイルに放り込み、<code>assert!</code>マクロでそれ用のテストを何か書いてみましょう。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 11-5: Using the `Rectangle` struct and its -->
<!-- `can_hold` method from Chapter 5</span> -->
<p><span class="caption">リスト11-5: 第5章から<code>Rectangle</code>構造体とその<code>can_hold</code>メソッドを使用する</span></p>
<!-- The `can_hold` method returns a Boolean, which means it’s a perfect use case -->
<!-- for the `assert!` macro. In Listing 11-6, we write a test that exercises the -->
<!-- `can_hold` method by creating a `Rectangle` instance that has a length of 8 and -->
<!-- a width of 7 and asserting that it can hold another `Rectangle` instance that -->
<!-- has a length of 5 and a width of 1. -->
<p><code>can_hold</code>メソッドは論理値を返すので、<code>assert!</code>マクロの完璧なユースケースになるわけです。
リスト11-6で、長さが8、幅が7の<code>Rectangle</code>インスタンスを生成し、これが長さ5、
幅1の別の<code>Rectangle</code>インスタンスを保持できるとアサーションすることで<code>can_hold</code>を用いるテストを書きます。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 11-6: A test for `can_hold` that checks whether a -->
<!-- larger rectangle can indeed hold a smaller rectangle</span> -->
<p><span class="caption">リスト11-6: より大きな四角形がより小さな四角形を確かに保持できるかを確認する<code>can_hold</code>用のテスト</span></p>
<!-- Note that we’ve added a new line inside the `tests` module: the `use super::*;`. -->
<!-- The `tests` module is a regular module that follows the usual visibility rules -->
<!-- we covered in Chapter 7 in the “Privacy Rules” section. Because the `tests` -->
<!-- module is an inner module, we need to bring the code under test in the outer -->
<!-- module into the scope of the inner module. We use a glob here so anything we -->
<!-- define in the outer module is available to this `tests` module. -->
<p><code>tests</code>モジュール内に新しい行を加えたことに注目してください: <code>use super::*</code>です。
<code>tests</code>モジュールは、第7章の「プライバシー規則」節で解説した通常の公開ルールに従う普通のモジュールです。
<code>tests</code>モジュールは、内部モジュールなので、外部モジュール内のテスト配下にあるコードを内部モジュールのスコープに持っていく必要があります。
ここではglobを使用して、外部モジュールで定義したもの全てがこの<code>tests</code>モジュールでも使用可能になるようにしています。</p>
<!-- We’ve named our test `larger_can_hold_smaller`, and we’ve created the two -->
<!-- `Rectangle` instances that we need. Then we called the `assert!` macro and -->
<!-- passed it the result of calling `larger.can_hold(&smaller)`. This expression -->
<!-- is supposed to return `true`, so our test should pass. Let’s find out! -->
<p>テストは<code>larger_can_hold_smaller</code>と名付け、必要な<code>Rectangle</code>インスタンスを2つ生成しています。
そして、<code>assert!</code>マクロを呼び出し、<code>larger.can_hold(&amp;smaller)</code>の呼び出し結果を渡しました。
この式は、<code>true</code>を返すと考えられるので、テストは通るはずです。確かめましょう！</p>
<pre><code class="language-text">running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- It does pass! Let’s add another test, this time asserting that a smaller -->
<!-- rectangle cannot hold a larger rectangle: -->
<p>確かに！別のテストを追加しましょう。今回は、小さい四角形は、より大きな四角形を保持できないことをアサーションします。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
</code></pre></pre>
<!-- Because the correct result of the `can_hold` function in this case is `false`, -->
<!-- we need to negate that result before we pass it to the `assert!` macro. As a -->
<!-- result, our test will pass if `can_hold` returns `false`: -->
<p>今回の場合、<code>can_hold</code>関数の正しい結果は<code>false</code>なので、その結果を<code>assert!</code>マクロに渡す前に反転させる必要があります。
結果として、<code>can_hold</code>が<code>false</code>を返せば、テストは通ります。</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- Two tests that pass! Now let’s see what happens to our test results when we -->
<!-- introduce a bug in our code. Let’s change the implementation of the `can_hold` -->
<!-- method by replacing the greater than sign with a less than sign when it -->
<!-- compares the lengths: -->
<p>通るテストが2つ！さて、コードにバグを導入したらテスト結果がどうなるか確認してみましょう。
長さを比較する大なり記号を小なり記号で置き換えて<code>can_hold</code>メソッドの実装を変更しましょう:</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
# #[derive(Debug)]
# pub struct Rectangle {
#     length: u32,
#     width: u32,
# }
// --snip--

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &lt; other.length &amp;&amp; self.width &gt; other.width
    }
}
</code></pre></pre>
<!-- Running the tests now produces the following: -->
<p>テストを実行すると、以下のような出力をします:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... FAILED

failures:

---- tests::larger_can_hold_smaller stdout ----
    thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
    larger.can_hold(&amp;smaller)', src/lib.rs:22:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- Our tests caught the bug! Because `larger.length` is 8 and `smaller.length` is -->
<!-- 5, the comparison of the lengths in `can_hold` now returns `false`: 8 is not -->
<!-- less than 5. -->
<p>テストによりバグが捕捉されました！<code>larger.length</code>が8、<code>smaller.length</code>が5なので、
<code>can_hold</code>内の長さの比較が今は<code>false</code>を返すようになったのです: 8は5より小さくないですからね。</p>
<!-- ### Testing Equality with the `assert_eq!` and `assert_ne!` Macros -->
<a class="header" href="print.html#assert_eqとassert_neマクロで等値性をテストする" id="assert_eqとassert_neマクロで等値性をテストする"><h3><code>assert_eq!</code>と<code>assert_ne!</code>マクロで等値性をテストする</h3></a>
<!-- A common way to test functionality is to compare the result of the code under -->
<!-- test to the value we expect the code to return to make sure they’re equal. We -->
<!-- could do this using the `assert!` macro and passing it an expression using the -->
<!-- `==` operator. However, this is such a common test that the standard library -->
<!-- provides a pair of macros—`assert_eq!` and `assert_ne!`—to perform this test -->
<!-- more conveniently. These macros compare two arguments for equality or -->
<!-- inequality, respectively. They’ll also print the two values if the assertion -->
<!-- fails, which makes it easier to see *why* the test failed; conversely, the -->
<!-- `assert!` macro only indicates that it got a `false` value for the `==` -->
<!-- expression, not the values that lead to the `false` value. -->
<p>機能をテストする一般的な方法は、テスト下にあるコードの結果をコードが返すと期待される値と比較して、
等しいと確かめることです。これを<code>assert</code>マクロを使用して<code>==</code>演算子を使用した式を渡すことで行うこともできます。
しかしながら、これはありふれたテストなので、標準ライブラリには1組のマクロ(<code>assert_eq!</code>と<code>assert_ne!</code>)が提供され、
このテストをより便利に行うことができます。これらのマクロはそれぞれ、二つの引数を等値性と非等値性のために比較します。
また、アサーションが失敗したら二つの値の出力もし、テストが失敗した<em>原因</em>を確認しやすくなります。
一方で<code>assert!</code>マクロは、<code>==</code>式の値が<code>false</code>値になったことしか示唆せず、<code>false</code>値に導いた値は出力しません。</p>
<!-- In Listing 11-7, we write a function named `add_two` that adds `2` to its -->
<!-- parameter and returns the result. Then we test this function using the -->
<!-- `assert_eq!` macro. -->
<p>リスト11-7において、引数に<code>2</code>を加えて結果を返す<code>add_two</code>という名前の関数を書いています。
そして、<code>assert_eq!</code>マクロでこの関数をテストしています。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 11-7: Testing the function `add_two` using the -->
<!-- `assert_eq!` macro</span> -->
<p><span class="caption">リスト11-7: <code>assert_eq!</code>マクロで<code>add_two</code>関数をテストする</span></p>
<!-- Let’s check that it passes! -->
<p>テストが通ることを確認しましょう！</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- The first argument we gave to the `assert_eq!` macro, `4`, is equal to the -->
<!-- result of calling `add_two(2)`. The line for this test is `test -->
<!-- tests::it_adds_two ... ok`, and the `ok` text indicates that our test passed! -->
<p><code>assert_eq!</code>マクロに与えた第1引数の<code>4</code>は、<code>add_two(2)</code>の呼び出し結果と等しいです。
このテストの行は<code>test tests::it_adds_two ... ok</code>であり、<code>ok</code>というテキストはテストが通ったことを示しています！</p>
<!-- Let’s introduce a bug into our code to see what it looks like when a test that -->
<!-- uses `assert_eq!` fails. Change the implementation of the `add_two` function to -->
<!-- instead add `3`: -->
<p>コードにバグを仕込んで、<code>assert_eq!</code>を使ったテストが失敗した時にどんな見た目になるのか確認してみましょう。
<code>add_two</code>関数の実装を代わりに<code>3</code>を足すように変えてください:</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
</code></pre></pre>
<!-- Run the tests again: -->
<p>テストを再度実行します:</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
        thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- Our test caught the bug! The `it_adds_two` test failed, displaying the message -->
<!-- `` assertion failed: `(left == right)` `` and showing that `left` was `4` and -->
<!-- `right` was `5`. This message is useful and helps us start debugging: it means -->
<!-- the `left` argument to `assert_eq!` was `4` but the `right` argument, where we -->
<!-- had `add_two(2)`, was `5`. -->
<p>テストがバグを捕捉しました！<code>it_adds_two</code>のテストは失敗し、<code>assertion failed: `(left == right)`</code>というメッセージを表示し、
<code>left</code>は<code>4</code>で、<code>right</code>は<code>5</code>だったと示しています。このメッセージは有用で、デバッグを開始する助けになります:
<code>assert_eq!</code>の<code>left</code>引数は<code>4</code>だったが、<code>add_two(2)</code>がある<code>right</code>引数は<code>5</code>だったことを意味しています。</p>
<!-- Note that in some languages and test frameworks, the parameters to the -->
<!-- functions that assert two values are equal are called `expected` and `actual`, -->
<!-- and the order in which we specify the arguments matters. However, in Rust, -->
<!-- they’re called `left` and `right`, and the order in which we specify the value -->
<!-- we expect and the value that the code under test produces doesn’t matter. We -->
<!-- could write the assertion in this test as `assert_eq!(add_two(2), 4)`, which -->
<!-- would result in a failure message that displays `` assertion failed: `(left == -->
<!-- right)` `` and that `left` was `5` and `right` was `4`. -->
<p>ある言語やテストフレームワークでは、二つの値が等しいとアサーションを行う関数の引数は、
<code>expected</code>と<code>actual</code>と呼ばれ、引数を指定する順序が問題になることに注意してください。
ですがRustでは、<code>left</code>と<code>right</code>と呼ばれ、期待する値とテスト下のコードが生成する値を指定する順序は、
問題になりません。<code>assert_eq!(add_two(2), 4)</code>と今回のテストのアサーションを書くこともでき、
そうすると失敗メッセージは、<code>assertion failed: `(left == right)`</code>と、
<code>left</code>が<code>5</code>で<code>right</code>が<code>4</code>と表示されるわけです。</p>
<!-- The `assert_ne!` macro will pass if the two values we give it are not equal and -->
<!-- fail if they’re equal. This macro is most useful for cases when we’re not sure -->
<!-- what a value *will* be, but we know what the value definitely *won’t* be if our -->
<!-- code is functioning as we intend. For example, if we’re testing a function that -->
<!-- is guaranteed to change its input in some way, but the way in which the input -->
<!-- is changed depends on the day of the week that we run our tests, the best thing -->
<!-- to assert might be that the output of the function is not equal to the input. -->
<p><code>assert_ne!</code>マクロは、与えた2つの値が等しくなければ通り、等しければ失敗します。
このマクロは、値が何になる<em>だろう</em>か確信が持てないけれども、コードが意図した通りに動いていれば、
確実にこの値にはならない<em>だろう</em>とわかっているような場合に最も有用になります。例えば、
入力を何らかの手段で変えることが保障されているけれども、入力が変更される方法がテストを実行する曜日に依存する関数をテストしているなら、
アサーションすべき最善の事柄は、関数の出力が入力と等しくないことかもしれません。</p>
<!-- Under the surface, the `assert_eq!` and `assert_ne!` macros use the operators -->
<!-- `==` and `!=`, respectively. When the assertions fail, these macros print their -->
<!-- arguments using debug formatting, which means the values being compared must -->
<!-- implement the `PartialEq` and `Debug` traits. All the primitive types and most -->
<!-- of the standard library types implement these traits. For structs and enums -->
<!-- that you define, you’ll need to implement `PartialEq` to assert that values of -->
<!-- those types are equal or not equal. You’ll need to implement `Debug` to print -->
<!-- out the values when the assertion fails. Because both traits are derivable traits, -->
<!-- as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward -->
<!-- as adding the `#[derive(PartialEq, Debug)]` annotation to your struct or enum -->
<!-- definition. See Appendix C for more details about these and other derivable -->
<!-- traits. -->
<p>表面下では、<code>assert_eq!</code>と<code>assert_ne!</code>マクロはそれぞれ、<code>==</code>と<code>!=</code>演算子を使用しています。
アサーションが失敗すると、これらのマクロは引数をデバッグフォーマットを使用して出力するので、
比較対象の値は<code>PartialEq</code>と<code>Debug</code>トレイトを実装していなければなりません。
組み込み型の全部と、標準ライブラリの型はほぼ全てこれらのトレイトを実装しています。
自分で定義した構造体とenumについては、<code>PartialEq</code>を実装して、
その型の値が等しいか等しくないかアサーションする必要があるでしょう。<code>Debug</code>を実装して、
アサーションが失敗した時に値を出力する必要もあるでしょう。
第5章のリスト5-12で触れたように、どちらのトレイトも継承可能トレイトなので、
これは通常、構造体やenum定義に<code>#[derive(PartialEq, Debug)]</code>というアノテーションを追加するくらい率直になります。
これらや他の継承可能トレイトに関する詳細については、付録Cをご覧ください。</p>
<!-- ### Adding Custom Failure Messages -->
<a class="header" href="print.html#aカスタムの失敗メッセージを追加する" id="aカスタムの失敗メッセージを追加する"><h3>カスタムの失敗メッセージを追加する</h3></a>
<!-- We can also add a custom message to be printed with the failure message as -->
<!-- optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. Any -->
<!-- arguments specified after the one required argument to `assert!` or the two -->
<!-- required arguments to `assert_eq!` and `assert_ne!` are passed along to the -->
<!-- `format!` macro (discussed in Chapter 8 in the “Concatenation with the `+` -->
<!-- Operator or the `format!` Macro” section), so you can pass a format string that -->
<!-- contains `{}` placeholders and values to go in those placeholders. Custom -->
<!-- messages are useful to document what an assertion means; when a test fails, -->
<!-- we’ll have a better idea of what the problem is with the code. -->
<p>さらに、<code>assert!</code>、<code>assert_eq!</code>、<code>assert_ne!</code>の追加引数として、失敗メッセージと共にカスタムのメッセージが表示されるよう、
追加することもできます。<code>assert!</code>の1つの必須引数、
あるいは<code>assert_eq!</code>と<code>assert_ne!</code>の2つの必須引数の後に指定された引数はどれも<code>format!</code>マクロに明け渡されるので、
(format!マクロについては第8章の「<code>+</code>演算子または、<code>format!</code>マクロで連結する」節で議論しました)、
<code>{}</code>プレースホルダーを含むフォーマット文字列とこのプレースホルダーに置き換えられる値を渡すことができます。
カスタムメッセージは、アサーションがどんな意味を持つかドキュメント化するのに役に立ちます;
テストが失敗した時、問題が何なのかコードと共により良い考えを持てるでしょう。</p>
<!-- For example, let’s say we have a function that greets people by name, and we -->
<!-- want to test that the name we pass into the function appears in the output: -->
<p>例として、人々に名前で挨拶をする関数があり、関数に渡した名前が出力に出現することをテストしたいとしましょう:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
</code></pre></pre>
<!-- The requirements for this program haven’t been agreed upon yet, and we’re -->
<!-- pretty sure the `Hello` text at the beginning of the greeting will change. We -->
<!-- decided we don’t want to have to update the test when the requirements change, -->
<!-- so instead of checking for exact equality to the value returned from the -->
<!-- `greeting` function, we’ll just assert that the output contains the text of the -->
<!-- input parameter. -->
<p>このプログラムの必要事項はまだ合意が得られておらず、挨拶の先頭の<code>Hello</code>というテキストは変わるだろうということは確かです。
要件が変わった時にテストを更新しなくてもよいようにしたいと決定したので、
<code>greeting</code>関数から返る値と正確な等値性を確認するのではなく、出力が入力引数のテキストを含むことをアサーションするだけにします。</p>
<!-- Let’s introduce a bug into this code by changing `greeting` to not include -->
<!-- `name` to see what this test failure looks like: -->
<p><code>greeting</code>が<code>name</code>を含まないように変更してこのコードにバグを仕込み、このテストの失敗がどんな見た目になるのか確かめましょう:</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
</code></pre></pre>
<!-- Running this test produces the following: -->
<p>このテストを実行すると、以下のように出力されます:</p>
<pre><code class="language-text">running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
        thread 'tests::greeting_contains_name' panicked at 'assertion failed:
result.contains(&quot;Carol&quot;)', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name
</code></pre>
<!-- This result just indicates that the assertion failed and which line the -->
<!-- assertion is on. A more useful failure message in this case would print the -->
<!-- value we got from the `greeting` function. Let’s change the test function, -->
<!-- giving it a custom failure message made from a format string with a placeholder -->
<!-- filled in with the actual value we got from the `greeting` function: -->
<p>この結果は、アサーションが失敗し、どの行にアサーションがあるかを示しているだけです。
より有用な失敗メッセージは今回の場合、<code>greeting</code>関数から得た値を出力することでしょう。
<code>greeting</code>関数から得た実際の値で埋められるプレースホルダーを含むフォーマット文字列からなるカスタムの失敗メッセージを与え、
テスト関数を変更しましょう:</p>
<pre><code class="language-rust ignore">#[test]
fn greeting_contains_name() {
    let result = greeting(&quot;Carol&quot;);
    //挨拶は名前を含んでいません。値は`{}`でした
    assert!(
        result.contains(&quot;Carol&quot;),
        &quot;Greeting did not contain name, value was `{}`&quot;, result
    );
}
</code></pre>
<!-- Now when we run the test, we’ll get a more informative error message: -->
<p>これでテストを実行したら、より有益なエラーメッセージが得られるでしょう:</p>
<pre><code class="language-text">---- tests::greeting_contains_name stdout ----
        thread 'tests::greeting_contains_name' panicked at 'Greeting did not
contain name, value was `Hello!`', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!-- We can see the value we actually got in the test output, which would help us -->
<!-- debug what happened instead of what we were expecting to happen. -->
<p>実際に得られた値がテスト出力に見られ、起こると想定していたものではなく、
起こったものをデバッグするのに役に立ちます。</p>
<!-- ### Checking for Panics with `should_panic` -->
<a class="header" href="print.html#should_panicでパニックを確認する" id="should_panicでパニックを確認する"><h3><code>should_panic</code>でパニックを確認する</h3></a>
<!-- In addition to checking that our code returns the correct values we expect, -->
<!-- it’s also important to check that our code handles error conditions as we -->
<!-- expect. For example, consider the `Guess` type that we created in Chapter 9, -->
<!-- Listing 9-9. Other code that uses `Guess` depends on the guarantee that `Guess` -->
<!-- instances will only contain values between 1 and 100. We can write a test that -->
<!-- ensures that attempting to create a `Guess` instance with a value outside that -->
<!-- range panics. -->
<p>期待する正しい値をコードが返すことを確認することに加えて、想定通りにコードがエラー状態を扱っていることを確認するのも重要です。
例えば、第9章のリスト9-9で生成した<code>Guess</code>型を考えてください。<code>Guess</code>を使用する他のコードは、
<code>Guess</code>のインスタンスは1から100の範囲の値しか含まないという保証に依存しています。
その範囲外の値で<code>Guess</code>インスタンスを生成しようとするとパニックすることを保証するテストを書くことができます。</p>
<!-- We do this by adding another attribute, `should_panic`, to our test function. -->
<!-- This attribute makes a test pass if the code inside the function panics; the -->
<!-- test will fail if the code inside the function doesn’t panic. -->
<p>これは、テスト関数に<code>should_panic</code>という別のアトリビュートを追加することで達成できます。
このアトリビュートは、関数内のコードがパニックしたら、テストを通過させます。つまり、
関数内のコードがパニックしなかったら、テストは失敗するわけです。</p>
<!-- Listing 11-8 shows a test that checks that the error conditions of `Guess::new` -->
<!-- happen when we expect them to. -->
<p>リスト11-8は、想定した時に<code>Guess::new</code>のエラー状態が発生していることを確認するテストを示しています。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            //予想値は1から100の間でなければなりません
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 11-8: Testing that a condition will cause a -->
<!-- `panic!`</span> -->
<p><span class="caption">リスト11-8: 状況が<code>panic!</code>を引き起こすとテストする</span></p>
<!-- We place the `#[should_panic]` attribute after the `#[test]` attribute and -->
<!-- before the test function it applies to. Let’s look at the result when this test -->
<!-- passes: -->
<p><code>#[test]</code>アトリビュートの後、適用するテスト関数の前に<code>#[should_panic]</code>アトリビュートを配置しています。
このテストが通るときの結果を見ましょう:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- Looks good! Now let’s introduce a bug in our code by removing the condition -->
<!-- that the `new` function will panic if the value is greater than 100: -->
<p>よさそうですね！では、値が100より大きいときに<code>new</code>関数がパニックするという条件を除去することでコードにバグを導入しましょう:</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
# pub struct Guess {
#     value: u32,
# }
#
// --snip--

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1  {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}
</code></pre></pre>
<!-- When we run the test in Listing 11-8, it will fail: -->
<p>リスト11-8のテストを実行すると、失敗するでしょう:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- We don’t get a very helpful message in this case, but when we look at the test -->
<!-- function, we see that it’s annotated with `#[should_panic]`. The failure we got -->
<!-- means that the code in the test function did not cause a panic. -->
<p>この場合、それほど役に立つメッセージは得られませんが、テスト関数に目を向ければ、
<code>#[should_panic]</code>で注釈されていることがわかります。得られた失敗は、
テスト関数のコードがパニックを引き起こさなかったことを意味するのです。</p>
<!-- Tests that use `should_panic` can be imprecise because they only indicate that -->
<!-- the code has caused some panic. A `should_panic` test would pass even if the -->
<!-- test panics for a different reason than the one we were expecting to happen. To -->
<!-- make `should_panic` tests more precise, we can add an optional `expected` -->
<!-- parameter to the `should_panic` attribute. The test harness will make sure that -->
<!-- the failure message contains the provided text. For example, consider the -->
<!-- modified code for `Guess` in Listing 11-9 where the `new` function panics with -->
<!-- different messages depending on whether the value is too small or too large. -->
<p><code>should_panic</code>を使用するテストは不正確なこともあります。なぜなら、コードが何らかのパニックを起こしたことしか示さないからです。
<code>should_panic</code>のテストは、起きると想定していたもの以外の理由でテストがパニックしても通ってしまうのです。
<code>should_panic</code>のテストの正確を期すために、<code>should_panic</code>アトリビュートの省略可能な<code>expected</code>引数を追加できます。
このテストの拘束具が、失敗メッセージに与えられたテキストが含まれていることを確かめてくれるでしょう。
例えば、リスト11-9の<code>Guess</code>の変更されたコードを考えてください。ここでは、
<code>new</code>関数は、値の大小によって異なるメッセージでパニックします。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
# pub struct Guess {
#     value: u32,
# }
#
// --snip--

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 {
            //予想値は、1以上でなければなりません
            panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                   value);
        } else if value &gt; 100 {
            //予想値は100以下でなければなりません
            panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;,
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    // 予想値は100以下でなければなりません
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 11-9: Testing that a condition will cause a -->
<!-- `panic!` with a particular panic message</span> -->
<p><span class="caption">リスト11-9: 状況が特定のパニックメッセージで<code>panic!</code>を引き起こすことをテストする</span></p>
<!-- This test will pass because the value we put in the `should_panic` attribute’s -->
<!-- `expected` parameter is a substring of the message that the `Guess::new` -->
<!-- function panics with. We could have specified the entire panic message that we -->
<!-- expect, which in this case would be `Guess value must be less than or equal to -->
<!-- 100, got 200.` What you choose to specify in the expected parameter for -->
<!-- `should_panic` depends on how much of the panic message is unique or dynamic -->
<!-- and how precise you want your test to be. In this case, a substring of the -->
<!-- panic message is enough to ensure that the code in the test function executes -->
<!-- the `else if value > 100` case. -->
<p><code>should_panic</code>アトリビュートの<code>expected</code>引数に置いた値が<code>Guess::new</code>関数がパニックしたメッセージの一部になっているので、
このテストは通ります。予想されるパニックメッセージ全体を指定することもでき、そうすれば今回の場合、
<code>Guess value must be less than or equal to 100, got 200.</code>となります。
<code>should_panic</code>の予想される引数に指定すると決めたものは、パニックメッセージの固有性や活動性、
テストの正確性によります。今回の場合、パニックメッセージの一部でも、テスト関数内のコードが、
<code>else if value &gt; 100</code>ケースを実行していると確認するのに事足りるのです。</p>
<!-- To see what happens when a `should_panic` test with an `expected` message -->
<!-- fails, let’s again introduce a bug into our code by swapping the bodies of the -->
<!-- `if value < 1` and the `else if value > 100` blocks: -->
<p><code>expected</code>メッセージありの<code>should_panic</code>テストが失敗すると何が起きるのが確かめるために、
<code>if value &lt; 1</code>と<code>else if value &gt; 100</code>ブロックの本体を入れ替えることで再度コードにバグを仕込みましょう:</p>
<pre><code class="language-rust ignore">if value &lt; 1 {
    panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;, value);
} else if value &gt; 100 {
    panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;, value);
}
</code></pre>
<!-- This time when we run the `should_panic` test, it will fail: -->
<p><code>should_panic</code>テストを実行すると、今回は失敗するでしょう:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
        thread 'tests::greater_than_100' panicked at 'Guess value must be
greater than or equal to 1, got 200.', src/lib.rs:11:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string 'Guess value must be less than or
equal to 100'

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- The failure message indicates that this test did indeed panic as we expected, -->
<!-- but the panic message did not include the expected string `'Guess value must be -->
<!-- less than or equal to 100'`. The panic message that we did get in this case was -->
<!-- `Guess value must be greater than or equal to 1, got 200.` Now we can start -->
<!-- figuring out where our bug is! -->
<p>この失敗メッセージは、このテストが確かにまさしく予想通りパニックしたことを示唆していますが、
パニックメッセージは、予想される文字列の<code>'Guess value must be less than or equal to 100'</code>を含んでいませんでした。
実際に得られたパニックメッセージは今回の場合、<code>Guess value must be greater than or equal to 1, got 200</code>でした。
そうしてバグの所在地を割り出し始めることができるわけです！</p>
<!-- Now that you know several ways to write tests, let’s look at what is happening -->
<!-- when we run our tests and explore the different options we can use with `cargo -->
<!-- test`. -->
<p>今やテスト記法を複数知ったので、テストを走らせる際に起きていることに目を向け、
<code>cargo test</code>で使用できる色んなオプションを探求しましょう。</p>
<!-- ## Controlling How Tests Are Run -->
<a class="header" href="print.html#aテストの実行され方を制御する" id="aテストの実行され方を制御する"><h2>テストの実行され方を制御する</h2></a>
<!-- Just as `cargo run` compiles your code and then runs the resulting binary, -->
<!-- `cargo test` compiles your code in test mode and runs the resulting test -->
<!-- binary. You can specify command line options to change the default behavior of -->
<!-- `cargo test`. For example, the default behavior of the binary produced by -->
<!-- `cargo test` is to run all the tests in parallel and capture output generated -->
<!-- during test runs, preventing the output from being displayed and making it -->
<!-- easier to read the output related to the test results. -->
<p><code>cargo run</code>がコードをコンパイルし、出来上がったバイナリを走らせるのと全く同様に、
<code>cargo test</code>はコードをテストモードでコンパイルし、出来上がったテストバイナリを実行します。
コマンドラインオプションを指定して<code>cargo test</code>の規定動作を変更することができます。
例えば、<code>cargo test</code>で生成されるバイナリの規定動作は、テストを全て並行に実行し、
テスト実行中に生成された出力をキャプチャして出力が表示されるのを防ぎ、
テスト結果に関係する出力を読みやすくすることです。</p>
<!-- Some command line options go to `cargo test` and some go to the resulting test -->
<!-- binary. To separate these two types of arguments, you list the arguments that -->
<!-- go to `cargo test` followed by the separator `--` and then the ones that go to -->
<!-- the test binary. Running `cargo test --help` displays the options you can use -->
<!-- with `cargo test`, and running `cargo test -- --help` displays the options you -->
<!-- can use after the separator `--`. -->
<p>コマンドラインオプションの中には<code>cargo test</code>にかかるものや、出来上がったテストバイナリにかかるものがあります。
この2種の引数を区別するために、<code>cargo test</code>にかかる引数を<code>--</code>という区分記号の後に列挙し、
それからテストバイナリにかかる引数を列挙します。<code>cargo test --help</code>を走らせると、<code>cargo test</code>で使用できるオプションが表示され、
<code>cargo test -- --help</code>を走らせると、<code>--</code>という区分記号の後に使えるオプションが表示されます。</p>
<!-- ### Running Tests in Parallel or Consecutively -->
<a class="header" href="print.html#aテストを並行または連続して実行する" id="aテストを並行または連続して実行する"><h3>テストを並行または連続して実行する</h3></a>
<!-- When you run multiple tests, by default they run in parallel using threads. -->
<!-- This means the tests will finish running faster so you can get feedback quicker -->
<!-- on whether or not your code is working. Because the tests are running at the -->
<!-- same time, make sure your tests don’t depend on each other or on any shared -->
<!-- state, including a shared environment, such as the current working directory or -->
<!-- environment variables. -->
<p>複数のテストを実行するとき、標準では、スレッドを使用して並行に走ります。これはつまり、
テストが早く実行し終わり、コードが機能しているいかんにかかわらず、反応をより早く得られることを意味します。
テストは同時に実行されているので、テストが相互や共有された環境を含む他の共通の状態に依存してないことを確かめてください。
現在の作業対象ディレクトリや環境変数などですね。</p>
<!-- For example, say each of your tests runs some code that creates a file on disk -->
<!-- named *test-output.txt* and writes some data to that file. Then each test reads -->
<!-- the data in that file and asserts that the file contains a particular value, -->
<!-- which is different in each test. Because the tests run at the same time, one -->
<!-- test might overwrite the file between when another test writes and reads the -->
<!-- file. The second test will then fail, not because the code is incorrect but -->
<!-- because the tests have interfered with each other while running in parallel. -->
<!-- One solution is to make sure each test writes to a different file; another -->
<!-- solution is to run the tests one at a time. -->
<p>例えば、各テストがディスクに<em>test_output.txt</em>というファイルを作成し、何らかのデータを書き込むコードを走らせるとしてください。
そして、各テストはそのファイルのデータを読み取り、ファイルが特定の値を含んでいるとアサーションし、
その値は各テストで異なります。テストが同時に走るので、あるテストが、
他のテストが書き込んだり読み込んだりする間隙にファイルを上書きするかもしれません。
それから2番目のテストが失敗します。コードが不正だからではなく、
並行に実行されている間にテストがお互いに邪魔をしてしまったせいです。
各テストが異なるファイルに書き込むことを確かめるのが一つの解決策です; 別の解決策では、
一度に一つのテストを実行します。</p>
<!-- If you don’t want to run the tests in parallel or if you want more fine-grained -->
<!-- control over the number of threads used, you can send the `--test-threads` flag -->
<!-- and the number of threads you want to use to the test binary. Take a look at -->
<!-- the following example: -->
<p>並行にテストを実行したくなかったり、使用されるスレッド数をよりきめ細かく制御したい場合、
<code>--test-threads</code>フラグと使用したいスレッド数をテストバイナリに送ることができます。
以下の例に目を向けてください:</p>
<pre><code class="language-text">$ cargo test -- --test-threads=1
</code></pre>
<!-- We set the number of test threads to `1`, telling the program not to use any -->
<!-- parallelism. Running the tests using one thread will take longer than running -->
<!-- them in parallel, but the tests won’t interfere with each other if they share -->
<!-- state. -->
<p>テストスレッドの数を<code>1</code>にセットし、並行性を使用しないようにプログラムに指示しています。
1スレッドのみを使用してテストを実行すると、並行に実行するより時間がかかりますが、
状態を共有していても、お互いに邪魔をすることはありません。</p>
<!-- ### Showing Function Output -->
<a class="header" href="print.html#a関数の出力を表示する" id="a関数の出力を表示する"><h3>関数の出力を表示する</h3></a>
<!-- By default, if a test passes, Rust’s test library captures anything printed to -->
<!-- standard output. For example, if we call `println!` in a test and the test -->
<!-- passes, we won’t see the `println!` output in the terminal; we’ll only see the -->
<!-- line that indicates the test passed. If a test fails, we’ll see whatever was -->
<!-- printed to standard output with the rest of the failure message. -->
<p>標準では、テストが通ると、Rustのテストライブラリは標準出力に出力されたものを全てキャプチャします。例えば、
テストで<code>println!</code>を呼び出してテストが通ると、<code>println!</code>の出力は、ターミナルに表示されません;
テストが通ったことを示す行しか見れないでしょう。テストが失敗すれば、
残りの失敗メッセージと共に、標準出力に出力されたものが全て見えるでしょう。</p>
<!-- As an example, Listing 11-10 has a silly function that prints the value of its -->
<!-- parameter and returns 10, as well as a test that passes and a test that fails. -->
<p>例として、リスト11-10は引数の値を出力し、10を返す馬鹿げた関数と通過するテスト1つ、失敗するテスト1つです。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn prints_and_returns_10(a: i32) -&gt; i32 {
    //{}という値を得た
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 11-10: Tests for a function that calls -->
<!-- `println!`</span> -->
<p><span class="caption">リスト11-10: <code>println!</code>を呼び出す関数用のテスト</span></p>
<!-- When we run these tests with `cargo test`, we’ll see the following output: -->
<p>これらのテストを<code>cargo test</code>で実行すると、以下のような出力を目の当たりにするでしょう:</p>
<pre><code class="language-text">running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
        I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- Note that nowhere in this output do we see `I got the value 4`, which is what -->
<!-- is printed when the test that passes runs. That output has been captured. The -->
<!-- output from the test that failed, `I got the value 8`, appears in the section -->
<!-- of the test summary output, which also shows the cause of the test failure. -->
<p>この出力のどこにも<code>I got the value 4</code>という出力が見られないことに注意してください。
この出力は、通るテストが走る際に出力されるものです。この出力はキャプチャされてしまったのです。
失敗したテストからの出力である<code>I got the value 8</code>はテスト総括出力の区域に出現し、
ここには、テスト失敗の原因も表示されています。</p>
<!-- If we want to see printed values for passing tests as well, we can disable the -->
<!-- output capture behavior by using the `--nocapture` flag: -->
<p>通過するテストについても出力される値が見たかったら、出力キャプチャ機能を<code>--nocapture</code>フラグで無効化することができます:</p>
<pre><code class="language-text">$ cargo test -- --nocapture
</code></pre>
<!-- When we run the tests in Listing 11-10 again with the `--nocapture` flag, we -->
<!-- see the following output: -->
<p>リスト11-10のテストを<code>--nocapture</code>フラグと共に再度実行したら、以下のような出力を目の当たりにします:</p>
<pre><code class="language-text">running 2 tests
I got the value 4
I got the value 8
test tests::this_test_will_pass ... ok
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- Note that the output for the tests and the test results are interleaved; the -->
<!-- reason is that the tests are running in parallel, as we talked about in the -->
<!-- previous section. Try using the `--test-threads=1` option and the `--nocapture` -->
<!-- flag, and see what the output looks like then! -->
<p>テスト用の出力とテスト結果の出力がまぜこぜになっていることに注意してください;
その理由は、前節で語ったようにテストが並行に実行されているからです。
<code>-test-threads=1</code>オプションと<code>--nocapture</code>フラグを使ってみて、
出力がどうなるか確かめてください！</p>
<!-- ### Running a Subset of Tests by Name -->
<a class="header" href="print.html#a名前でテストの一部を実行する" id="a名前でテストの一部を実行する"><h3>名前でテストの一部を実行する</h3></a>
<!-- Sometimes, running a full test suite can take a long time. If you’re working on -->
<!-- code in a particular area, you might want to run only the tests pertaining to -->
<!-- that code. You can choose which tests to run by passing `cargo test` the name -->
<!-- or names of the test(s) you want to run as an argument. -->
<p>時々、全テストを実行すると時間がかかってしまうことがあります。特定の部分のコードしか対象にしていない場合、
そのコードに関わるテストのみを走らせたいかもしれません。<code>cargo test</code>に走らせたいテストの名前を引数として渡すことで、
実行するテストを選ぶことができます。</p>
<!-- To demonstrate how to run a subset of tests, we’ll create three tests for our -->
<!-- `add_two` function, as shown in Listing 11-11, and choose which ones to run. -->
<p>テストの一部を走らせる方法を模擬するために、リスト11-11に示したように、
<code>add_two</code>関数用に3つテストを作成し、走らせるテストを選択します。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 11-11: Three tests with three different -->
<!-- names</span> -->
<p><span class="caption">リスト11-11: 3つの異なる名前の3つのテスト</span></p>
<!-- If we run the tests without passing any arguments, as we saw earlier, all the -->
<!-- tests will run in parallel: -->
<p>以前見かけたように、引数なしでテストを走らせたら、全テストが並行に走ります:</p>
<pre><code class="language-text">running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- #### Running Single Tests -->
<a class="header" href="print.html#a単独のテストを走らせる" id="a単独のテストを走らせる"><h4>単独のテストを走らせる</h4></a>
<!-- We can pass the name of any test function to `cargo test` to run only that test: -->
<p>あらゆるテスト関数の名前を<code>cargo test</code>に渡して、そのテストのみを実行することができます:</p>
<pre><code class="language-text">$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<!-- Only the test with the name `one_hundred` ran; the other two tests didn't match -->
<!-- that name. The test output lets us know we had more tests than what this -->
<!-- command ran by displaying `2 filtered out` at the end of the summary line. -->
<p><code>one_hundred</code>という名前のテストだけが走りました; 他の2つのテストはその名前に合致しなかったのです。
まとめ行の最後に<code>2 filtered out</code>と表示することでテスト出力は、このコマンドが走らせた以上のテストがあることを知らせてくれています。</p>
<!-- We can’t specify the names of multiple tests in this way; only the first value -->
<!-- given to `cargo test` will be used. But there is a way to run multiple tests. -->
<p>この方法では、複数のテストの名前を指定することはできません; <code>cargo test</code>に与えられた最初の値のみが使われるのです。
ですが、複数のテストを走らせる方法もあります。</p>
<!-- #### Filtering to Run Multiple Tests -->
<a class="header" href="print.html#a複数のテストを実行するようフィルターをかける" id="a複数のテストを実行するようフィルターをかける"><h4>複数のテストを実行するようフィルターをかける</h4></a>
<!-- We can specify part of a test name, and any test whose name matches that value -->
<!-- will be run. For example, because two of our tests’ names contain `add`, we can -->
<!-- run those two by running `cargo test add`: -->
<p>テスト名の一部を指定でき、その値に合致するあらゆるテストが走ります。例えば、
我々のテストの2つが<code>add</code>という名前を含むので、<code>cargo test add</code>を実行することで、その二つを走らせることができます:</p>
<pre><code class="language-text">$ cargo test add
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<!-- This command ran all tests with `add` in the name and filtered out the test -->
<!-- named `one_hundred`. Also note that the module in which tests appear becomes -->
<!-- part of the test’s name, so we can run all the tests in a module by filtering -->
<!-- on the module’s name. -->
<p>このコマンドは名前に<code>add</code>を含むテストを全て実行し、<code>one_hundred</code>という名前のテストを除外しました。
また、テストが出現するモジュールがテスト名の一部になっていて、
モジュール名でフィルターをかけることで、あるモジュール内のテスト全てを実行できることに注目してください。</p>
<!-- ### Ignoring Some Tests Unless Specifically Requested -->
<a class="header" href="print.html#a特に希望のない限りテストを無視する" id="a特に希望のない限りテストを無視する"><h3>特に希望のない限りテストを無視する</h3></a>
<!-- Sometimes a few specific tests can be very time-consuming to execute, so you -->
<!-- might want to exclude them during most runs of `cargo test`. Rather than -->
<!-- listing as arguments all tests you do want to run, you can instead annotate the -->
<!-- time-consuming tests using the `ignore` attribute to exclude them, as shown -->
<!-- here: -->
<p>時として、いくつかの特定のテストが実行するのに非常に時間がかかることがあり、
<code>cargo test</code>の実行のほとんどで除外したくなるかもしれません。引数として確かに実行したいテストを全て列挙するのではなく、
ここに示したように代わりに時間のかかるテストを<code>ignore</code>アトリビュートで除外すると注釈することができます。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // 実行に1時間かかるコード
    // code that takes an hour to run
}
#}</code></pre></pre>
<!-- After `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now -->
<!-- when we run our tests, `it_works` runs, but `expensive_test` doesn’t: -->
<p><code>#[test]</code>の後の除外したいテストに<code>#[ignore]</code>行を追加しています。これで、
テストを実行したら、<code>it_works</code>は実行されるものの、<code>expensive_test</code>は実行されません:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- The `expensive_test` function is listed as `ignored`. If we want to run only -->
<!-- the ignored tests, we can use `cargo test -- --ignored`: -->
<p><code>expensive_test</code>関数は、<code>ignored</code>と列挙されています。無視されるテストのみを実行したかったら、
<code>cargo test -- --ignored</code>を使うことができます:</p>
<pre><code class="language-text">$ cargo test -- --ignored
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<!-- 1行目後半、"make sure ..."のところを「結果が早く出る」と訳しているが、この書き方では「結果が早い」としか読めない。どうしたものか -->
<!-- By controlling which tests run, you can make sure your `cargo test` results -->
<!-- will be fast. When you’re at a point where it makes sense to check the results -->
<!-- of the `ignored` tests and you have time to wait for the results, you can run -->
<!-- `cargo test -- --ignored` instead. -->
<p>どのテストを走らせるか制御することで、結果が早く出ることを確かめることができるのです。
<code>ignored</code>テストの結果を確認することが道理に合い、結果を待つだけの時間ができたときに、
代わりに<code>cargo test -- --ignored</code>を走らせることができます。</p>
<!-- ## Test Organization -->
<a class="header" href="print.html#aテストの体系化" id="aテストの体系化"><h2>テストの体系化</h2></a>
<!-- As mentioned at the start of the chapter, testing is a complex discipline, and -->
<!-- different people use different terminology and organization. The Rust community -->
<!-- thinks about tests in terms of two main categories: *unit tests* and -->
<!-- *integration tests*. Unit tests are small and more focused, testing one module -->
<!-- in isolation at a time, and can test private interfaces. Integration tests are -->
<!-- entirely external to your library and use your code in the same way any other -->
<!-- external code would, using only the public interface and potentially exercising -->
<!-- multiple modules per test. -->
<p>章の初めで触れたように、テストは複雑な鍛錬であり、人によって専門用語や体系化が異なります。
Rustのコミュニティでは、テストを2つの大きなカテゴリで捉えています: <em>単体テスト</em>と<em>結合テスト</em>です。
単体テストは小規模でより集中していて、個別に1回に1モジュールをテストし、非公開のインターフェイスもテストする可能性があります。
結合テストは、完全にライブラリ外になり、他の外部コード同様に自分のコードを使用し、公開インターフェイスのみ使用し、
1テストにつき複数のモジュールを用いることもあります。</p>
<!-- Writing both kinds of tests is important to ensure that the pieces of your -->
<!-- library are doing what you expect them to, separately and together. -->
<p>どちらのテストを書くのも、ライブラリの一部が個別かつ共同でしてほしいことをしていることを確認するのに重要なのです。</p>
<!-- ### Unit Tests -->
<a class="header" href="print.html#a単体テスト" id="a単体テスト"><h3>単体テスト</h3></a>
<!-- The purpose of unit tests is to test each unit of code in isolation from the -->
<!-- rest of the code to quickly pinpoint where code is and isn’t working as -->
<!-- expected. We put unit tests in the *src* directory in each file with the -->
<!-- code that they’re testing. The convention is to create a module named `tests` -->
<!-- in each file to contain the test functions and to annotate the module with -->
<!-- `cfg(test)`. -->
<p>単体テストの目的は、残りのコードから切り離して各単位のコードをテストし、
コードが想定通り、動いたり動いていなかったりする箇所を急速に特定することです。
単体テストは、テスト対象となるコードと共に、<em>src</em>ディレクトリの各ファイルに置きます。
慣習は、各ファイルに<code>tests</code>という名前のモジュールを作り、テスト関数を含ませ、
そのモジュールを<code>cfg(test)</code>で注釈することです。</p>
<!-- #### The Tests Module and `#[cfg(test)]` -->
<a class="header" href="print.html#aテストモジュールとcfgtest" id="aテストモジュールとcfgtest"><h4>テストモジュールと<code>#[cfg(test)]</code></h4></a>
<!-- The `#[cfg(test)]` annotation on the tests module tells Rust to compile and run -->
<!-- the test code only when we run `cargo test`, but not when we run `cargo build`. -->
<!-- This saves compile time when we only want to build the library and saves space -->
<!-- in the resulting compiled artifact because the tests are not included. You’ll -->
<!-- see that because integration tests go in a different directory, they don’t need -->
<!-- the `#[cfg(test)]` annotation. However, because unit tests go in the same files -->
<!-- as the code, we use `#[cfg(test)]` to specify that they shouldn’t be -->
<!-- included in the compiled result. -->
<p>testsモジュールの<code>#[cfg(test)]</code>という注釈は、コンパイラに<code>cargo build</code>を走らせた時ではなく、<code>cargo test</code>を走らせた時にだけ、
テストコードをコンパイルし走らせるよう指示します。これにより、ライブラリをビルドしたいだけの時にコンパイルタイムを節約し、
テストが含まれないので、コンパイル後の成果物のサイズも節約します。結合テストは別のディレクトリに存在することになるので、
<code>#[cfg(test)]</code>注釈は必要ないとわかるでしょう。しかしながら、単体テストはコードと同じファイルに存在するので、
<code>#[cfg(test)]</code>を使用してコンパイル結果に含まれないよう指定するのです。</p>
<!-- Recall that when we generated the new `adder` project in the first section of -->
<!-- this chapter, Cargo generated this code for us: -->
<p>この章の最初の節で新しい<code>adder</code>プロジェクトを生成した時に、Cargoがこのコードも生成してくれたことを思い出してください:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<!-- This code is the automatically generated test module. The attribute `cfg` -->
<!-- stands for *configuration* and tells Rust that the following item should only -->
<!-- be included given a certain configuration option. In this case, the -->
<!-- configuration option is `test`, which is provided by Rust for compiling and -->
<!-- running tests. By using the `cfg` attribute, Cargo compiles our test code only -->
<!-- if we actively run the tests with `cargo test`. This includes any helper -->
<!-- functions that might be within this module, in addition to the functions -->
<!-- annotated with `#[test]`. -->
<p>このコードが自動生成されたテストモジュールです。<code>cfg</code>というアトリビュートは、<em>configuration</em>を表していて、
コンパイラに続く要素が、ある特定の設定オプションを与えて含まれるように指示します。
今回の場合、設定オプションは、<code>test</code>であり、言語によって提供されているテストをコンパイルし、
走らせるためのものです。<code>cfg</code>アトリビュートを使用することで、<code>cargo test</code>で積極的にテストを実行した場合のみ、
Cargoがテストコードをコンパイルします。これには、このモジュールに含まれるかもしれないヘルパー関数全ても含まれ、
<code>#[test]</code>で注釈された関数だけにはなりません。</p>
<!-- #### Testing Private Functions -->
<a class="header" href="print.html#a非公開関数をテストする" id="a非公開関数をテストする"><h4>非公開関数をテストする</h4></a>
<!-- There’s debate within the testing community about whether or not private -->
<!-- functions should be tested directly, and other languages make it difficult or -->
<!-- impossible to test private functions. Regardless of which testing ideology you -->
<!-- adhere to, Rust’s privacy rules do allow you to test private functions. -->
<!-- Consider the code in Listing 11-12 with the private function `internal_adder`. -->
<p>テストコミュニティ内で非公開関数を直接テストするべきかについては議論があり、
他の言語では非公開関数をテストするのは困難だったり、不可能だったりします。
あなたがどちらのテストイデオロギーを支持しているかに関わらず、Rustの公開性規則により、
非公開関数をテストすることが確かに可能です。リスト11-12の非公開関数<code>internal_adder</code>を含むコードを考えてください。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 11-12: Testing a private function</span> -->
<p><span class="caption">リスト11-12: 非公開関数をテストする</span></p>
<!-- Note that the `internal_adder` function is not marked as `pub`, but because -->
<!-- tests are just Rust code and the `tests` module is just another module, you can -->
<!-- import and call `internal_adder` in a test just fine. If you don’t think -->
<!-- private functions should be tested, there’s nothing in Rust that will compel -->
<!-- you to do so. -->
<p><code>internal_adder</code>関数は<code>pub</code>とマークされていないものの、テストも単なるRustのコードであり、
<code>tests</code>モジュールもただのモジュールでしかないので、テスト内で<code>internal_adder</code>を普通にインポートし呼び出すことができます。
非公開関数はテストするべきではないとお考えなら、Rustにはそれを強制するものは何もありません。</p>
<!-- ### Integration Tests -->
<a class="header" href="print.html#a結合テスト" id="a結合テスト"><h3>結合テスト</h3></a>
<!-- In Rust, integration tests are entirely external to your library. They use your -->
<!-- library in the same way any other code would, which means they can only call -->
<!-- functions that are part of your library’s public API. Their purpose is to test -->
<!-- whether many parts of your library work together correctly. Units of code that -->
<!-- work correctly on their own could have problems when integrated, so test -->
<!-- coverage of the integrated code is important as well. To create integration -->
<!-- tests, you first need a *tests* directory. -->
<p>Rustにおいて、結合テストは完全にライブラリ外のものです。他のコードがするのと全く同様にあなたのライブラリを使用するので、
ライブラリの公開APIの一部である関数しか呼び出すことはできません。その目的は、
ライブラリのいろんな部分が共同で正常に動作しているかをテストすることです。
単体では正常に動くコードも、結合した状態だと問題を孕む可能性もあるので、
結合したコードのテストの範囲も同様に重要になるのです。結合テストを作成するには、
まず<em>tests</em>ディレクトリが必要になります。</p>
<!-- #### The *tests* Directory -->
<a class="header" href="print.html#testsディレクトリ" id="testsディレクトリ"><h4><em>tests</em>ディレクトリ</h4></a>
<!-- We create a *tests* directory at the top level of our project directory, next -->
<!-- to *src*. Cargo knows to look for integration test files in this directory. We -->
<!-- can then make as many test files as we want to in this directory, and Cargo -->
<!-- will compile each of the files as an individual crate. -->
<p>プロジェクトディレクトリのトップ階層、<em>src</em>の隣に<em>tests</em>ディレクトリを作成します。
Cargoは、このディレクトリに結合テストのファイルを探すことを把握しています。
そして、このディレクトリ内にいくらでもテストファイルを作成することができ、
Cargoはそれぞれのファイルを個別のクレートとしてコンパイルします。</p>
<!-- Let’s create an integration test. With the code in Listing 11-12 still in the -->
<!-- *src/lib.rs* file, make a *tests* directory, create a new file named -->
<!-- *tests/integration_test.rs*, and enter the code in Listing 11-13. -->
<p>結合テストを作成しましょう。リスト11-12のコードが<em>src/lib.rs</em>ファイルにあるまま、
<em>tests</em>ディレクトリを作成し、<em>tests/integration_test.rs</em>という名前の新しいファイルを生成し、
リスト11-13のコードを入力してください。</p>
<!-- <span class="filename">Filename: tests/integration_test.rs</span> -->
<p><span class="filename">ファイル名: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<!-- <span class="caption">Listing 11-13: An integration test of a function in the -->
<!-- `adder` crate</span> -->
<p><span class="caption">リスト11-13: <code>adder</code>クレートの関数の結合テスト</span></p>
<!-- We’ve added `extern crate adder` at the top of the code, which we didn’t need -->
<!-- in the unit tests. The reason is that each test in the `tests` directory is a -->
<!-- separate crate, so we need to import our library into each of them. -->
<p>コードの頂点に<code>extern crate adder</code>を追記しましたが、これは単体テストでは必要なかったものです。
理由は、<code>tests</code>ディレクトリのテストはそれぞれ個別のクレートであるため、
各々ライブラリをインポートする必要があるためです。</p>
<!-- We don’t need to annotate any code in *tests/integration_test.rs* with -->
<!-- `#[cfg(test)]`. Cargo treats the `tests` directory specially and compiles files -->
<!-- in this directory only when we run `cargo test`. Run `cargo test` now: -->
<p><em>tests/integration_test.rs</em>のどんなコードも<code>#[cfg(test)]</code>で注釈する必要はありません。
Cargoは<code>tests</code>ディレクトリを特別に扱い、<code>cargo test</code>を走らせた時にのみこのディレクトリのファイルをコンパイルするのです。
さあ、<code>cargo test</code>を実行してください:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- The three sections of output include the unit tests, the integration test, and -->
<!-- the doc tests. The first section for the unit tests is the same as we’ve been -->
<!-- seeing: one line for each unit test (one named `internal` that we added in -->
<!-- Listing 11-12) and then a summary line for the unit tests. -->
<p>3つの区域の出力が単体テスト、結合テスト、ドックテストを含んでいます。単体テスト用の最初の区域は、
今まで見てきたものと同じです: 各単体テストに1行(リスト11-12で追加した<code>internal</code>という名前のもの)と、
単体テストの総括行です。</p>
<!-- The integration tests section starts with the line `Running -->
<!-- target/debug/deps/integration-test-ce99bcc2479f4607` (the hash at the end of -->
<!-- your output will be different). Next, there is a line for each test function in -->
<!-- that integration test and a summary line for the results of the integration -->
<!-- test just before the `Doc-tests adder` section starts. -->
<p>結合テストの区域は、
<code>Running target/debug/deps/integration-test-ce99bcc2479f4607</code>という行で始まっています(最後のハッシュは違うでしょう)。
次に、この結合テストの各テスト関数用の行があり、<code>Doc-tests adder</code>区域が始まる直前に、
結合テストの結果用の総括行があります。</p>
<!-- Similarly to how adding more unit test functions adds more result lines to the -->
<!-- unit tests section, adding more test functions to the integration test file -->
<!-- adds more result lines to this integration test file’s section. Each -->
<!-- integration test file has its own section, so if we add more files in the -->
<!-- *tests* directory, there will be more integration test sections. -->
<p>単体テスト関数を追加すると、単体テスト区域のテスト結果の行が増えることに似て、
作成した結合テストファイルにもっとテスト関数を追加すると、そのファイルの区域に行が増えることになります。
結合テストファイルはそれぞれ独自の区域があるため、<em>tests</em>ディレクトリにさらにファイルを追加すれば、
結合テストの区域が増えることになるでしょう。</p>
<!-- We can still run a particular integration test function by specifying the test -->
<!-- function’s name as an argument to `cargo test`. To run all the tests in a -->
<!-- particular integration test file, use the `--test` argument of `cargo test` -->
<!-- followed by the name of the file: -->
<p>それでも、テスト関数の名前を引数として<code>cargo test</code>に指定することで、特定の結合テスト関数を走らせることができます。
特定の結合テストファイルにあるテストを全て走らせるには、<code>cargo test</code>に<code>--test</code>引数、
その後にファイル名を続けて使用してください:</p>
<pre><code class="language-text">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- This command runs only the tests in the *tests/integration_test.rs* file. -->
<p>このコマンドは、<em>tests/integration_test.rs</em>ファイルにあるテストのみを実行します。</p>
<!-- #### Submodules in Integration Tests -->
<a class="header" href="print.html#a結合テスト内のサブモジュール" id="a結合テスト内のサブモジュール"><h4>結合テスト内のサブモジュール</h4></a>
<!-- As you add more integration tests, you might want to make more than one file in -->
<!-- the *tests* directory to help organize them; for example, you can group the -->
<!-- test functions by the functionality they’re testing. As mentioned earlier, each -->
<!-- file in the *tests* directory is compiled as its own separate crate. -->
<p>結合テストを追加するにつれて、<em>tests</em>ディレクトリに2つ以上のファイルを作成して体系化したくなるかもしれません;
例えば、テスト対象となる機能でテスト関数をグループ化することができます。前記したように、
<em>tests</em>ディレクトリの各ファイルは、個別のクレートとしてコンパイルされます。</p>
<!-- Treating each integration test file as its own crate is useful to create -->
<!-- separate scopes that are more like the way end users will be using your crate. -->
<!-- However, this means files in the *tests* directory don’t share the same -->
<!-- behavior as files in *src* do, as you learned in Chapter 7 regarding how to -->
<!-- separate code into modules and files. -->
<p>各結合テストファイルをそれ自身のクレートとして扱うと、
エンドユーザが読者のクレートを使用するかのような個別のスコープを生成するのに役立ちます。
ですが、これは<em>tests</em>ディレクトリのファイルが、コードをモジュールとファイルに分ける方法に関して第7章で学んだように、
<em>src</em>のファイルとは同じ振る舞いを共有しないことを意味します。</p>
<!-- The different behavior of files in the *tests* directory is most noticeable -->
<!-- when you have a set of helper functions that would be useful in multiple -->
<!-- integration test files and you try to follow the steps in the “Moving Modules -->
<!-- to Other Files” section of Chapter 7 to extract them into a common module. For -->
<!-- example, if we create *tests/common.rs* and place a function named `setup` in -->
<!-- it, we can add some code to `setup` that we want to call from multiple test -->
<!-- functions in multiple test files: -->
<p><em>tests</em>ディレクトリのファイルの異なる振る舞いは、複数の結合テストファイルで役に立ちそうなヘルパー関数ができ、
第7章の「モジュールを別のファイルに移動する」節の手順に従って共通モジュールに抽出しようとした時に最も気付きやすくなります。
例えば、<em>tests/common.rs</em>を作成し、そこに<code>setup</code>という名前の関数を配置したら、
複数のテストファイルの複数のテスト関数から呼び出したい<code>setup</code>に何らかのコードを追加することができます:</p>
<!-- <span class="filename">Filename: tests/common.rs</span> -->
<p><span class="filename">ファイル名: tests/common.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn setup() {
    // ここにライブラリテスト固有のコードが来る
    // setup code specific to your library's tests would go here
}
#}</code></pre></pre>
<!-- When we run the tests again, we’ll see a new section in the test output for the -->
<!-- *common.rs* file, even though this file doesn’t contain any test functions nor -->
<!-- did we call the `setup` function from anywhere: -->
<p>再度テストを実行すると、<em>common.rs</em>ファイルは何もテスト関数を含んだり、<code>setup</code>関数をどこかから呼んだりしてないのに、
テスト出力に<em>common.rs</em>用の区域が見えるでしょう。</p>
<pre><code class="language-text">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- Having `common` appear in the test results with `running 0 tests` displayed for -->
<!-- it is not what we wanted. We just wanted to share some code with the other -->
<!-- integration test files. -->
<p><code>common</code>が<code>running 0 tests</code>とテスト結果に表示されるのは、望んだ結果ではありません。
ただ単に他の結合テストファイルと何らかのコードを共有したかっただけです。</p>
<!-- To avoid having `common` appear in the test output, instead of creating -->
<!-- *tests/common.rs*, we’ll create *tests/common/mod.rs*. In the “Rules of Module -->
<!-- Filesystems” section of Chapter 7, we used the naming convention -->
<!-- *module_name/mod.rs* for files of modules that have submodules. We don’t have -->
<!-- submodules for `common` here, but naming the file this way tells Rust not to -->
<!-- treat the `common` module as an integration test file. When we move the `setup` -->
<!-- function code into *tests/common/mod.rs* and delete the *tests/common.rs* file, -->
<!-- the section in the test output will no longer appear. Files in subdirectories -->
<!-- of the *tests* directory don’t get compiled as separate crates or have sections -->
<!-- in the test output. -->
<p><code>common</code>がテスト出力に出現するのを防ぐには、<em>tests/common.rs</em>を作成する代わりに、
<em>tests/common/mod.rs</em>を作成します。第7章の「モジュールファイルシステムの規則」節において、
<em>module_name/mod.rs</em>という命名規則をサブモジュールのあるモジュールのファイルに使用しました。
ここでは<code>common</code>にサブモジュールはありませんが、
このように命名することでコンパイラに<code>common</code>モジュールを結合テストファイルとして扱わないように指示します。
<code>setup</code>関数のコードを<em>tests/common/mod.rs</em>に移動し、<em>tests/common.rs</em>ファイルを削除すると、
テスト出力に区域はもう表示されなくなります。<em>tests</em>ディレクトリのサブディレクトリ内のファイルは個別クレートとしてコンパイルされたり、
テスト出力に区域が表示されることがないのです。</p>
<!-- After we’ve created *tests/common/mod.rs*, we can use it from any of the -->
<!-- integration test files as a module. Here’s an example of calling the `setup` -->
<!-- function from the `it_adds_two` test in *tests/integration_test.rs*: -->
<p><em>tests/common.mod.rs</em>を作成した後、それをどの結合テストファイルからもモジュールとして使用することができます。
こちらは、<em>tests/integration_test.rs</em>内の<code>it_adds_two</code>テストから<code>setup</code>関数を呼び出す例です:</p>
<!-- <span class="filename">Filename: tests/integration_test.rs</span> -->
<p><span class="filename">ファイル名: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<!-- Note that the `mod common;` declaration is the same as the module declarations -->
<!-- we demonstrated in Listing 7-4. Then in the test function, we can call the -->
<!-- `common::setup()` function. -->
<p><code>mod common;</code>という宣言は、リスト7-4で模擬したモジュール宣言と同じであることに注意してください。
それから、テスト関数内で<code>common::setup()</code>関数を呼び出すことができます。</p>
<!-- #### Integration Tests for Binary Crates -->
<a class="header" href="print.html#aバイナリクレート用の結合テスト" id="aバイナリクレート用の結合テスト"><h4>バイナリクレート用の結合テスト</h4></a>
<!-- If our project is a binary crate that only contains a *src/main.rs* file and -->
<!-- doesn’t have a *src/lib.rs* file, we can’t create integration tests in the -->
<!-- *tests* directory and use `extern crate` to import functions defined in the -->
<!-- *src/main.rs* file. Only library crates expose functions that other crates can -->
<!-- call and use; binary crates are meant to be run on their own. -->
<p>もしもプロジェクトが<em>src/main.rs</em>ファイルのみを含み、<em>src/lib.rs</em>ファイルを持たないバイナリクレートだったら、
<em>tests</em>ディレクトリに結合テストを作成し、
<code>extern crate</code>を使用して<em>src/main.rs</em>ファイルに定義された関数をインポートすることはできません。
ライブラリクレートのみが、他のクレートが呼び出して使用できる関数を晒け出せるのです;
バイナリクレートはそれ単体で実行するという意味を持っています。</p>
<!-- This is one of the reasons Rust projects that provide a binary have a -->
<!-- straightforward *src/main.rs* file that calls logic that lives in the -->
<!-- *src/lib.rs* file. Using that structure, integration tests *can* test the -->
<!-- library crate by using `extern crate` to exercise the important functionality. -->
<!-- If the important functionality works, the small amount of code in the -->
<!-- *src/main.rs* file will work as well, and that small amount of code doesn’t -->
<!-- need to be tested. -->
<p>これは、バイナリを提供するRustのプロジェクトに、
<em>src/lib.rs</em>ファイルに存在するロジックを呼び出す素直な<em>src/main.rs</em>ファイルがある一因になっています。
この構造を使用して結合テストは、<code>extern crate</code>を使用して重要な機能を用いることでライブラリクレートをテストすることが<em>できます</em>。
この重要な機能が動作すれば、<em>src/main.rs</em>ファイルの少量のコードも動作し、その少量のコードはテストする必要がないわけです。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-9" id="aまとめ-9"><h2>まとめ</h2></a>
<!-- Rust’s testing features provide a way to specify how code should function to -->
<!-- ensure it continues to work as we expect, even as we make changes. Unit tests -->
<!-- exercise different parts of a library separately and can test private -->
<!-- implementation details. Integration tests check that many parts of the library -->
<!-- work together correctly, and they use the library’s public API to test the code -->
<!-- in the same way external code will use it. Even though Rust’s type system and -->
<!-- ownership rules help prevent some kinds of bugs, tests are still important to -->
<!-- help reduce logic bugs having to do with how your code is expected to behave. -->
<p>Rustのテスト機能は、変更を加えた後でさえ想定通りにコードが機能し続けることを保証して、
コードが機能すべき方法を指定する手段を提供します。単体テストはライブラリの異なる部分を個別に用い、
非公開の実装詳細をテストすることができます。結合テストは、ライブラリのいろんな部分が共同で正常に動作することを確認し、
ライブラリの公開APIを使用して外部コードが使用するのと同じ方法でコードをテストします。
Rustの型システムと所有権ルールにより防がれるバグの種類もあるものの、それでもテストは、
コードの振る舞い方に関するロジックのバグを減らすのに重要なのです。</p>
<!-- Let’s combine the knowledge you learned in this chapter and in previous -->
<!-- chapters and work on a project! -->
<p>この章と以前の章で学んだ知識を結集して、とあるプロジェクトに取り掛かりましょう！</p>
<!-- # An I/O Project: Building a Command Line Program -->
<a class="header" href="print.html#a入出力プロジェクト-コマンドラインプログラムを構築する" id="a入出力プロジェクト-コマンドラインプログラムを構築する"><h1>入出力プロジェクト: コマンドラインプログラムを構築する</h1></a>
<!-- This chapter is a recap of the many skills you’ve learned so far and an -->
<!-- exploration of a few more standard library features. We’ll build a command line -->
<!-- tool that interacts with file and command line input/output to practice some of -->
<!-- the Rust concepts you now have under your belt. -->
<p>この章は、ここまでに学んできた多くのスキルを思い出すきっかけであり、もういくつか標準ライブラリの機能も探求します。
ファイルやコマンドラインの入出力と相互作用するコマンドラインツールを構築し、
今やあなたの支配下にあるRustの概念の一部を練習していきます。</p>
<!-- Rust’s speed, safety, single binary output, and cross-platform support make it -->
<!-- an ideal language for creating command line tools, so for our project, we’ll -->
<!-- make our own version of the classic command line tool `grep` (**g**lobally -->
<!-- search a **r**egular **e**xpression and **p**rint). In the simplest use case, -->
<!-- `grep` searches a specified file for a specified string. To do so, `grep` takes -->
<!-- as its arguments a filename and a string. Then it reads the file, finds lines -->
<!-- in that file that contain the string argument, and prints those lines. -->
<p>Rustの速度、安全性、単バイナリ出力、クロスプラットフォームサポートにより、コマンドラインツールを作るのにふさわしい言語なので、
このプロジェクトでは、独自の伝統的なコマンドラインツールの<code>grep</code>(<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression
and <strong>p</strong>rint: 正規表現をグローバルで検索し表示する)を作成していきます。最も単純な使用法では、
<code>grep</code>は指定したファイルから指定した文字列を検索します。そうするには、
<code>grep</code>は引数としてファイル名と文字列を受け取ります。それからファイルを読み込んでそのファイル内で文字列引数を含む行を探し、
検索した行を出力するのです。</p>
<!-- Along the way, we’ll show how to make our command line tool use features of the -->
<!-- terminal that many command line tools use. We’ll read the value of an -->
<!-- environment variable to allow the user to configure the behavior of our tool. -->
<!-- We’ll also print to the standard error console stream (`stderr`) instead of -->
<!-- standard output (`stdout`), so, for example, the user can redirect successful -->
<!-- output to a file while still seeing error messages onscreen. -->
<p>その過程で、多くのコマンドラインツールが使用している端末の機能を使用させる方法を示します。
環境変数の値を読み取ってユーザがこのツールの振る舞いを設定できるようにします。また、
標準出力(<code>stdout</code>)の代わりに、標準エラー出力(<code>stderr</code>)するので、例えば、
ユーザはエラーメッセージはスクリーン上で確認しつつ、成功した出力はファイルにリダイレクトできます。</p>
<!-- One Rust community member, Andrew Gallant, has already created a fully -->
<!-- featured, very fast version of `grep`, called `ripgrep`. By comparison, our -->
<!-- version of `grep` will be fairly simple, but this chapter will give you some of -->
<!-- the background knowledge you need to understand a real-world project like -->
<!-- `ripgrep`. -->
<p>あるRustコミュニティのメンバであるアンドリュー・ガラント(Andrew Gallant)が既に全機能装備の非常に高速な<code>grep</code>、
<code>ripgrep</code>と呼ばれるものを作成しました。比較対象として、我々の<code>grep</code>はとても単純ですが、
この章により、<code>ripgrep</code>のような現実世界のプロジェクトを理解するのに必要な背景知識の一部を身に付けられるでしょう。</p>
<!-- Our `grep` project will combine a number of concepts you’ve learned so far: -->
<p>この<code>grep</code>プロジェクトは、ここまでに学んできた多くの概念を集結させます:</p>
<!-- * Organizing code (using what you learned in modules, Chapter 7) -->
<!-- * Using vectors and strings (collections, Chapter 8) -->
<!-- * Handling errors (Chapter 9) -->
<!-- * Using traits and lifetimes where appropriate (Chapter 10) -->
<!-- * Writing tests (Chapter 11) -->
<ul>
<li>コードを体系化する(モジュール、第7章で学んだことを使用)</li>
<li>ベクタ型と文字列を使用する(コレクション、第8章)</li>
<li>エラーを処理する(第9章)</li>
<li>適切な箇所でトレイトとライフタイムを使用する(第10章)</li>
<li>テストを記述する(第11章)</li>
</ul>
<!-- We’ll also briefly introduce closures, iterators, and trait objects, which -->
<!-- Chapters 13 and 17 will cover in detail. -->
<p>さらに、クロージャ、イテレータ、トレイトオブジェクトなど、第13章、17章で詳しく解説するものもちょっとだけ紹介します。</p>
<!-- ## Accepting Command Line Arguments -->
<a class="header" href="print.html#aコマンドライン引数を受け付ける" id="aコマンドライン引数を受け付ける"><h2>コマンドライン引数を受け付ける</h2></a>
<!-- Let’s create a new project with, as always, `cargo new`. We’ll call our project -->
<!-- `minigrep` to distinguish it from the `grep` tool that you might already have -->
<!-- on your system. -->
<p>いつものように、<code>cargo new</code>で新しいプロジェクトを作りましょう。プロジェクトを<code>minigrep</code>と名付けて、
既に自分のシステムに存在するかもしれない<code>grep</code>ツールと区別しましょう。</p>
<pre><code class="language-text">$ cargo new --bin minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<!-- The first task is to make `minigrep` accept its two command line arguments: the -->
<!-- filename and a string to search for. That is, we want to be able to run our -->
<!-- program with `cargo run`, a string to search for, and a path to a file to -->
<!-- search in, like so: -->
<p>最初の仕事は、<code>minigrep</code>を二つの引数を受け付けるようにすることです: ファイル名と検索する文字列ですね。
つまり、<code>cargo run</code>で検索文字列と検索を行うファイルへのパスと共にプログラムを実行できるようになりたいということです。
こんな感じにね:</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<!-- Right now, the program generated by `cargo new` cannot process arguments we -->
<!-- give it. Some existing libraries on [Crates.io](https://crates.io/) can help -->
<!-- with writing a program that accepts command line arguments, but because you're -->
<!-- just learning this concept, let’s implement this capability ourselves. -->
<p>今現在は、<code>cargo new</code>で生成されたプログラムは、与えた引数を処理できません。
<a href="https://crates.io/">Crates.io</a>に存在するある既存のライブラリは、
コマンドライン引数を受け付けるプログラムを書く手助けをしてくれますが、ちょうどこの概念を学んでいる最中なので、
この能力を自分で実装しましょう。</p>
<!-- ### Reading the Argument Values -->
<a class="header" href="print.html#a引数の値を読み取る" id="a引数の値を読み取る"><h3>引数の値を読み取る</h3></a>
<!-- To enable `minigrep` to read the values of command line arguments we pass to -->
<!-- it, we’ll need a function provided in Rust’s standard library, which is -->
<!-- `std::env::args`. This function returns an *iterator* of the command line -->
<!-- arguments that were given to `minigrep`. We haven’t discussed iterators yet -->
<!-- (we’ll cover them fully in Chapter 13), but for now, you only need to know two -->
<!-- details about iterators: iterators produce a series of values, and we can call -->
<!-- the `collect` function on an iterator to turn it into a collection, such as a -->
<!-- vector, containing all the elements the iterator produces. -->
<p><code>minigrep</code>が渡したコマンドライン引数の値を読み取れるようにするために、Rustの標準ライブラリで提供されている関数が必要になり、
それは、<code>std::env::args</code>です。この関数は、<code>minigrep</code>に与えられたコマンドライン引数の<em>イテレータ</em>を返します。
イテレータについてはまだ議論していません(完全には第13章で解説します)が、とりあえずイテレータに関しては、
2つの詳細のみ知っていればいいです: イテレータは一連の値を生成することと、イテレータに対して<code>collect</code>関数を呼び出し、
イテレータが生成する要素全部を含むベクタ型などのコレクションに変えられることです。</p>
<!-- Use the code in Listing 12-1 to allow your `minigrep` program to read any -->
<!-- command line arguments passed to it and then collect the values into a vector. -->
<p>リスト12-1のコードを使用して<code>minigrep</code>プログラムに渡されたあらゆるコマンドライン引数を読み取れるようにし、
それからその値をベクタ型として集結させてください。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<!-- <span class="caption">Listing 12-1: Collecting the command line arguments into -->
<!-- a vector and printing them</span> -->
<p><span class="caption">リスト12-1: コマンドライン引数をベクタ型に集結させ、出力する</span></p>
<!-- First, we bring the `std::env` module into scope with a `use` statement so we -->
<!-- can use its `args` function. Notice that the `std::env::args` function is -->
<!-- nested in two levels of modules. As we discussed in Chapter 7, in cases where -->
<!-- the desired function is nested in more than one module, it’s conventional to -->
<!-- bring the parent module into scope rather than the function. By doing so, we -->
<!-- can easily use other functions from `std::env`. It’s also less ambiguous than -->
<!-- adding `use std::env::args` and then calling the function with just `args` -->
<!-- because `args` might easily be mistaken for a function that’s defined in the -->
<!-- current module. -->
<p>まず、<code>std::env</code>モジュールを<code>use</code>文でスコープに導入したので、<code>args</code>関数が使用できます。
<code>std::env::args</code>関数は、2レベルモジュールがネストされていることに気付いてください。
第7章で議論したように、希望の関数が2モジュール以上ネストされている場合、
関数ではなく親モジュールをスコープに導入するのが因習的です。そうすることで、
<code>std::env</code>から別の関数も容易に使用することができます。また、
<code>use std::env::args</code>を追記し、関数を<code>args</code>とするだけで呼び出すのに比べて曖昧でもありません。
というのも、<code>args</code>は現在のモジュールに定義されている関数と容易に見間違えられるかもしれないからです。</p>
<!-- > ### The `args` Function and Invalid Unicode -->
<!-- > -->
<!-- > Note that `std::env::args` will panic if any argument contains invalid -->
<!-- > Unicode. If your program needs to accept arguments containing invalid -->
<!-- > Unicode, use `std::env::args_os` instead. That function returns an iterator -->
<!-- > that produces `OsString` values instead of `String` values. We’ve chosen -->
<!-- > use `std::env::args` here for simplicity because `OsString` values differ -->
<!-- > per platform and are more complex to work with than `String` values. -->
<blockquote>
<a class="header" href="print.html#args関数と不正なユニコード" id="args関数と不正なユニコード"><h3><code>args</code>関数と不正なユニコード</h3></a>
<p>引数のどれかが不正なユニコードを含んでいたら、<code>std::env::args</code>はパニックすることに注意してください。
プログラムが不正なユニコードを含む引数を受け付ける必要があるなら、代わりに<code>std::env::args_os</code>を使用してください。
この関数は、<code>String</code>値ではなく、<code>OsString</code>値を生成するイテレータを返します。ここでは、
簡潔性のために<code>std::env::args</code>を使うことを選択しました。
なぜなら、<code>OsString</code>値はプラットフォームごとに異なり、<code>String</code>値に比べて取り扱いが煩雑だからです。</p>
</blockquote>
<!-- On the first line of `main`, we call `env::args`, and we immediately use -->
<!-- `collect` to turn the iterator into a vector containing all the values produced -->
<!-- by the iterator. We can use the `collect` function to create many kinds of -->
<!-- collections, so we explicitly annotate the type of `args` to specify that we -->
<!-- want a vector of strings. Although we very rarely need to annotate types in -->
<!-- Rust, `collect` is one function you do often need to annotate because Rust -->
<!-- isn’t able to infer the kind of collection you want. -->
<p><code>main</code>の最初の行で<code>env::args</code>を呼び出し、そして即座に<code>collect</code>を使用して、
イテレータをイテレータが生成する値全てを含むベクタ型に変換しています。
<code>collect</code>関数を使用して多くの種類のコレクションを生成することができるので、
<code>args</code>の型を明示的に注釈して文字列のベクタが欲しいのだと指定しています。Rustにおいて、
型を注釈しなければならない頻度は非常に少ないのですが、<code>collect</code>はよく確かに注釈が必要になる一つの関数なのです。
コンパイラには、あなたが欲しているコレクションの種類が推論できないからです。</p>
<!-- Finally, we print the vector using the debug formatter, `:?`. Let’s try running -->
<!-- the code with no arguments and then with two arguments: -->
<p>最後に、デバッグ整形機の<code>:?</code>を使用してベクタを出力しています。引数なしでコードを走らせてみて、
それから引数二つで試してみましょう:</p>
<pre><code class="language-text">$ cargo run
--snip--
[&quot;target/debug/minigrep&quot;]

$ cargo run needle haystack
--snip--
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<!-- Notice that the first value in the vector is `"target/debug/minigrep"`, which -->
<!-- is the name of our binary. This matches the behavior of the arguments list in -->
<!-- C, letting programs use the name by which they were invoked in their execution. -->
<!-- It’s often convenient to have access to the program name in case you want to -->
<!-- print it in messages or change behavior of the program based on what command -->
<!-- line alias was used to invoke the program. But for the purposes of this -->
<!-- chapter, we’ll ignore it and save only the two arguments we need. -->
<p>ベクタの最初の値は<code>&quot;target/debug/minigrep&quot;</code>であり、これはバイナリの名前であることに気付いてください。
これはCの引数リストの振る舞いと合致し、実行時に呼び出された名前をプログラムに使わせてくれるわけです。
メッセージで出力したり、プログラムを起動するのに使用されたコマンドラインエイリアスによってプログラムの振る舞いを変えたい場合に、
プログラム名にアクセスするのにしばしば便利です。ですが、この章の目的には、これを無視し、必要な二つの引数のみを保存します。</p>
<!-- ### Saving the Argument Values in Variables -->
<a class="header" href="print.html#a引数の値を変数に保存する" id="a引数の値を変数に保存する"><h3>引数の値を変数に保存する</h3></a>
<!-- Printing the value of the vector of arguments illustrated that the program is -->
<!-- able to access the values specified as command line arguments. Now we need to -->
<!-- save the values of the two arguments in variables so we can use the values -->
<!-- throughout the rest of the program. We do that in Listing 12-2. -->
<p>引数のベクタの値を出力すると、プログラムはコマンドライン引数として指定された値にアクセスできることが具現化されました。
さて、プログラムの残りを通して使用できるように、二つの引数の値を変数に保存する必要があります。
それをしているのがリスト12-2です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    // {}を探しています
    println!(&quot;Searching for {}&quot;, query);
    // {}というファイルの中
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<!-- <span class="caption">Listing 12-2: Creating variables to hold the query -->
<!-- argument and filename argument</span> -->
<p><span class="caption">リスト12-2: クエリ引数とファイル名引数を保持する変数を生成</span></p>
<!-- As we saw when we printed the vector, the program’s name takes up the first -->
<!-- value in the vector at `args[0]`, so we’re starting at index `1`. The first -->
<!-- argument `minigrep` takes is the string we’re searching for, so we put a -->
<!-- reference to the first argument in the variable `query`. The second argument -->
<!-- will be the filename, so we put a reference to the second argument in the -->
<!-- variable `filename`. -->
<p>ベクタを出力した時に確認したように、プログラム名がベクタの最初の値、<code>args[0]</code>を占めているので、
添字<code>1</code>から始めます。<code>minigrep</code>が取る最初の引数は、検索する文字列なので、
最初の引数への参照を変数<code>query</code>に置きました。2番目の引数はファイル名でしょうから、
2番目の引数への参照は変数<code>filename</code>に置きました。</p>
<!-- We temporarily print the values of these variables to prove that the code is -->
<!-- working as we intend. Let’s run this program again with the arguments `test` -->
<!-- and `sample.txt`: -->
<p>一時的にこれら変数の値を出力して、コードが意図通りに動いていることを証明しています。
再度このプログラムを<code>test</code>と<code>sample.txt</code>という引数で実行しましょう:</p>
<pre><code class="language-text">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<!-- Great, the program is working! The values of the arguments we need are being -->
<!-- saved into the right variables. Later we’ll add some error handling to deal -->
<!-- with certain potential erroneous situations, such as when the user provides no -->
<!-- arguments; for now, we’ll ignore that situation and work on adding file-reading -->
<!-- capabilities instead. -->
<p>素晴らしい、プログラムは動作しています！必要な引数の値が、正しい変数に保存されています。後ほど、
何らかのエラー処理を加えて、特定の可能性のあるエラー状況に対処します。ユーザが引数を提供しなかった場合などです;
今は、そのような状況はないものとし、代わりにファイル読み取り能力を追加することに取り組みます。</p>
<!-- ## Reading a File -->
<a class="header" href="print.html#aファイルを読み込む" id="aファイルを読み込む"><h2>ファイルを読み込む</h2></a>
<!-- Now we’ll add functionality to read the file that is specified in the -->
<!-- `filename` command line argument. First, we need a sample file to test it with: -->
<!-- the best kind of file to use to make sure `minigrep` is working is one with a -->
<!-- small amount of text over multiple lines with some repeated words. Listing 12-3 -->
<!-- has an Emily Dickinson poem that will work well! Create a file called -->
<!-- *poem.txt* at the root level of your project, and enter the poem “I’m Nobody! -->
<!-- Who are you?” -->
<p>では、<code>filename</code>コマンドライン引数で指定されたファイルを読み込む機能を追加しましょう。
まず、テスト実行するためのサンプルファイルが必要ですね: <code>minigrep</code>が動作していることを確かめるために使用すべき好適なファイルは、
複数行にわたって同じ単語の繰り返しのある少量のテキストです。リスト12-3は、
うまくいくであろうエミリー・ディキンソン(Emily Dickinson)の詩です！
プロジェクトのルート階層に<em>poem.txt</em>というファイルを作成し、この詩「私は誰でもない！あなたは誰？」を入力してください。</p>
<!-- <span class="filename">Filename: poem.txt</span> -->
<p><span class="filename">ファイル名: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

私は誰でもない！あなたは誰？
あなたも誰でもないの？
なら、私たちは組だね、何も言わないで！
あの人たちは、私たちを追放するでしょう。わかりますよね？

誰かでいるなんて侘しいじゃない！
カエルみたいで公すぎるじゃない。
自分の名を長い1日に告げるのなんて。
感服するような沼地にね！
</code></pre>
<!-- <span class="caption">Listing 12-3: A poem by Emily Dickinson makes a good test -->
<!-- case</span> -->
<p><span class="caption">リスト12-3: エミリー・ディキンソンの詩は、いいテストケースになる</span></p>
<!-- With the text in place, edit *src/main.rs* and add code to open the file, as -->
<!-- shown in Listing 12-4. -->
<p>テキストを適当な場所に置いて、<em>src/main.rs</em>を編集し、ファイルを開くコードを追加してください。
リスト12-4に示したようにですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;
use std::fs::File;
use std::io::prelude::*;

fn main() {
#     let args: Vec&lt;String&gt; = env::args().collect();
#
#     let query = &amp;args[1];
#     let filename = &amp;args[2];
#
#     println!(&quot;Searching for {}&quot;, query);
    // --snip--
    println!(&quot;In file {}&quot;, filename);

    // ファイルが見つかりませんでした
    let mut f = File::open(filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    // ファイルの読み込み中に問題がありました
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    // テキストは\n{}です
    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<!-- <span class="caption">Listing 12-4: Reading the contents of the file specified -->
<!-- by the second argument</span> -->
<p><span class="caption">リスト12-4: 第2引数で指定されたファイルの中身を読み込む</span></p>
<!-- First, we add some more `use` statements to bring in relevant parts of the -->
<!-- standard library: we need `std::fs::File` to handle files, and -->
<!-- `std::io::prelude::*` contains various useful traits for doing I/O, including -->
<!-- file I/O. In the same way that Rust has a general prelude that brings certain -->
<!-- types and functions into scope automatically, the `std::io` module has its own -->
<!-- prelude of common types and functions you’ll need when working with I/O. Unlike -->
<!-- the default prelude, we must explicitly add a `use` statement for the -->
<!-- prelude from `std::io`. -->
<p>最初に、もう何個か<code>use</code>文を追記して、標準ライブラリの関係のある箇所を持ってきています:
ファイルを扱うのに<code>std::fs::File</code>が必要ですし、
<code>std::io::prelude::*</code>はファイル入出力を含む入出力処理をするのに有用なトレイトを色々含んでいます。
言語が一般的な初期化処理で特定の型や関数を自動的にスコープに導入するように、
<code>std::io</code>モジュールにはそれ独自の共通の型や関数の初期化処理があり、入出力を行う際に必要になるわけです。
標準の初期化処理とは異なり、<code>std::io</code>の初期化処理には明示的に<code>use</code>文を加えなければなりません。</p>
<!-- In `main`, we’ve added three statements: first, we get a mutable handle to the -->
<!-- file by calling the `File::open` function and passing it the value of the -->
<!-- `filename` variable. Second, we create a variable called `contents` and set it -->
<!-- to a mutable, empty `String`. This will hold the content of the file after we -->
<!-- read it in. Third, we call `read_to_string` on our file handle and pass a -->
<!-- mutable reference to `contents` as an argument. -->
<p><code>main</code>で3文を追記しました: 一つ目が、<code>File::open</code>関数を呼んで<code>filename</code>変数の値に渡して、
ファイルへの可変なハンドルを得る処理です。二つ目が、<code>contents</code>という名の変数を生成して、
可変で空の<code>String</code>を割り当てる処理です。この変数が、ファイル読み込み後に中身を保持します。
三つ目が、ファイルハンドルに対して<code>read_to_string</code>を呼び出し、引数として<code>contents</code>への可変参照を渡す処理です。</p>
<!-- After those lines, we’ve again added a temporary `println!` statement that -->
<!-- prints the value of `contents` after the file is read, so we can check that the -->
<!-- program is working so far. -->
<p>それらの処理の後に、今回もファイル読み込み後に<code>contents</code>の値を出力する一時的な<code>println!</code>文を追記したので、
ここまでプログラムがきちんと動作していることを確認できます。</p>
<!-- Let’s run this code with any string as the first command line argument (because -->
<!-- we haven’t implemented the searching part yet) and the *poem.txt* file as the -->
<!-- second argument: -->
<p>第1コマンドライン引数には適当な文字列(まだ検索する箇所は実装してませんからね)を、第2引数に<em>poem.txt</em>ファイルを入れて、
このコードを実行しましょう:</p>
<pre><code class="language-text">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<!-- 2行目最後の行は、末端のone ideaをあえて訳していない。こちらの方が日本語としては自然と思われる -->
<!-- Great! The code read and then printed the content of the file. But the code -->
<!-- has a few flaws. The `main` function has multiple responsibilities: generally, -->
<!-- functions are clearer and easier to maintain if each function is responsible -->
<!-- for only one idea. The other problem is that we’re not handling errors as well -->
<!-- as we could. The program is still small, so these flaws aren’t a big problem, -->
<!-- but as the program grows, it will be harder to fix them cleanly. It’s good -->
<!-- practice to begin refactoring early on when developing a program, because it’s -->
<!-- much easier to refactor smaller amounts of code. We’ll do that next. -->
<p>素晴らしい！コードがファイルの中身を読み込み、出力するようになりました。しかし、このコードにはいくつか欠陥があります。
<code>main</code>関数が複数の責任を受け持っています: 一般に、各関数がただ一つの責任だけを持つようになれば、
関数は明確に管理しやすくなります。もう一つの問題点は、できうる限りのエラー処理を怠っていることです。
まだプログラムが小規模なので、これらの欠陥は大きな問題にはなりませんが、プログラムが大規模になるにつれ、
それを綺麗に解消するのは困難になっていきます。プログラムを開発する際に早い段階でリファクタングを行うのは、
良い傾向です。リファクタリングするコードの量が少なければ、簡単になりますからね。次は、それを行いましょう。</p>
<!-- ## Refactoring to Improve Modularity and Error Handling -->
<a class="header" href="print.html#aリファクタリングしてモジュール性の向上とエラー処理" id="aリファクタリングしてモジュール性の向上とエラー処理"><h2>リファクタリングしてモジュール性の向上とエラー処理</h2></a>
<!-- To improve our program, we’ll fix four problems that have to do with the -->
<!-- program’s structure and how it’s handling potential errors. -->
<p>プログラムを改善するために、プログラムの構造と起こりうるエラーに対処する方法に関連する4つの問題を解消していきましょう。</p>
<!-- First, our `main` function now performs two tasks: it parses arguments and -->
<!-- opens files. For such a small function, this isn’t a major problem. However, if -->
<!-- we continue to grow our program inside `main`, the number of separate tasks the -->
<!-- `main` function handles will increase. As a function gains responsibilities, it -->
<!-- becomes more difficult to reason about, harder to test, and harder to change -->
<!-- without breaking one of its parts. It’s best to separate functionality so each -->
<!-- function is responsible for one task. -->
<p>1番目は、<code>main</code>関数が2つの仕事を受け持っていることです: 引数を解析し、ファイルを開いています。
このような小さな関数なら、これは、大した問題ではありませんが、<code>main</code>内でプログラムを巨大化させ続けたら、
<code>main</code>関数が扱う個別の仕事の数も増えていきます。関数が責任を受け持つごとに、
内容が把握しにくくなり、テストも行いづらくなり、機能を壊さずに変更するのも困難になっていきます。
機能を小分けして、各関数が1つの仕事のみに責任を持つようにするのが最善です。</p>
<!-- This issue also ties into the second problem: although `query` and `filename` -->
<!-- are configuration variables to our program, variables like `f` and `contents` -->
<!-- are used to perform the program’s logic. The longer `main` becomes, the more -->
<!-- variables we’ll need to bring into scope; the more variables we have in scope, -->
<!-- the harder it will be to keep track of the purpose of each. It’s best to group -->
<!-- the configuration variables into one structure to make their purpose clear. -->
<p>この問題は、2番目の問題にも紐付いています: <code>query</code>と<code>filename</code>はプログラムの設定用変数ですが、
<code>f</code>や<code>contents</code>といった変数は、プログラムのロジックを担っています。<code>main</code>が長くなるほど、
スコープに入れるべき変数も増えます。そして、スコープにある変数が増えれば、各々の目的を追うのも大変になるわけです。
設定用変数を一つの構造に押し込め、目的を明瞭化するのが最善です。</p>
<!-- The third problem is that we’ve used `expect` to print an error message when -->
<!-- opening the file fails, but the error message just prints `file not found`. -->
<!-- Opening a file can fail in a number of ways besides the file being missing: for -->
<!-- example, the file might exist, but we might not have permission to open it. -->
<!-- Right now, if we’re in that situation, we’d print the `file not found` error -->
<!-- message, which would give the user the wrong information! -->
<p>3番目の問題は、ファイルを開き損ねた時に<code>expect</code>を使ってエラーメッセージを出力しているのに、
エラーメッセージが<code>ファイルが見つかりませんでした</code>としか表示しないことです。
ファイルを開く行為は、ファイルが存在しない以外にもいろんな方法で失敗することがあります:
例えば、ファイルは存在するかもしれないけれど、開く権限がないかもしれないなどです。
現時点では、そのような状況になった時、「ファイルが見つかりませんでした」というエラーメッセージを出力し、
これはユーザに間違った情報を与えるのです。</p>
<!-- 1行目最後の方のandを順接の理由で訳している -->
<!-- Fourth, we use `expect` repeatedly to handle different errors, and if the user -->
<!-- runs our program without specifying enough arguments, they’ll get an `index out -->
<!-- of bounds` error from Rust that doesn’t clearly explain the problem. It would -->
<!-- be best if all the error-handling code was in one place so future maintainers -->
<!-- have only one place to consult in the code if the error-handling logic needs to -->
<!-- change. Having all the error-handling code in one place will also ensure that -->
<!-- we’re printing messages that will be meaningful to our end users. -->
<p>4番目は、異なるエラーを処理するのに<code>expect</code>を繰り返し使用しているので、ユーザが十分な数の引数を渡さずにプログラムを起動した時に、
問題を明確に説明しない「範囲外アクセス(index out of bounds)」というエラーがRustから得られることです。
エラー処理のコードが全て1箇所に存在し、将来エラー処理ロジックが変更になった時に、
メンテナンス者が1箇所のコードのみを考慮すればいいようにするのが最善でしょう。
エラー処理コードが1箇所にあれば、エンドユーザにとって意味のあるメッセージを出力していることを確認することにもつながります。</p>
<!-- Let’s address these four problems by refactoring our project. -->
<p>プロジェクトをリファクタリングして、これら4つの問題を扱いましょう。</p>
<!-- ### Separation of Concerns for Binary Projects -->
<a class="header" href="print.html#aバイナリプロジェクトの責任の分離" id="aバイナリプロジェクトの責任の分離"><h3>バイナリプロジェクトの責任の分離</h3></a>
<!-- The organizational problem of allocating responsibility for multiple tasks to -->
<!-- the `main` function is common to many binary projects. As a result, the Rust -->
<!-- community has developed a process to use as a guideline for splitting the -->
<!-- separate concerns of a binary program when `main` starts getting large. The -->
<!-- process has the following steps: -->
<p><code>main</code>関数に複数の仕事の責任を押し付けるという構造上の問題は、多くのバイナリプロジェクトでありふれています。
結果として、<code>main</code>が肥大化し始めた際にバイナリプログラムの個別の責任を分割するためにガイドラインとして活用できる工程をRustコミニュティは、
開発しました。この工程は、以下のような手順になっています:</p>
<!-- * Split your program into a *main.rs* and a *lib.rs* and move your program’s -->
<!--   logic to *lib.rs*. -->
<!-- * As long as your command line parsing logic is small, it can remain in -->
<!--   *main.rs*. -->
<!-- * When the command line parsing logic starts getting complicated, extract it -->
<!--   from *main.rs* and move it to *lib.rs*. -->
<ul>
<li>プログラムを<em>main.rs</em>と<em>lib.rs</em>に分け、ロジックを<em>lib.rs</em>に移動する。</li>
<li>コマンドライン引数の解析ロジックが小規模な限り、<em>main.rs</em>に置いても良い。</li>
<li>コマンドライン引数の解析ロジックが複雑化の様相を呈し始めたら、<em>main.rs</em>から抽出して<em>lib.rs</em>に移動する。</li>
</ul>
<!-- The responsibilities that remain in the `main` function after this process -->
<!-- should be limited to the following: -->
<p>この工程の後に<code>main</code>関数に残る責任は以下に限定される:</p>
<!-- * Calling the command line parsing logic with the argument values -->
<!-- * Setting up any other configuration -->
<!-- * Calling a `run` function in *lib.rs* -->
<!-- * Handling the error if `run` returns an error -->
<ul>
<li>引数の値でコマンドライン引数の解析ロジックを呼び出す</li>
<li>他のあらゆる設定を行う</li>
<li><em>lib.rs</em>の<code>run</code>関数を呼び出す</li>
<li><code>run</code>がエラーを返した時に処理する</li>
</ul>
<!-- This pattern is about separating concerns: *main.rs* handles running the -->
<!-- program, and *lib.rs* handles all the logic of the task at hand. Because we -->
<!-- can’t test the `main` function directly, this structure lets us test all of -->
<!-- your program’s logic by moving it into functions in *lib.rs*. The only code -->
<!-- that remains in *main.rs* will be small enough to verify its correctness by -->
<!-- reading it. Let’s rework our program by following this process. -->
<p>このパターンは、責任の分離についてです: <em>main.rs</em>はプログラムの実行を行い、
そして、<em>lib.rs</em>が手にある仕事のロジック全てを扱います。<code>main</code>関数を直接テストすることはできないので、
この構造により、プログラムのロジック全てを<em>lib.rs</em>の関数に移すことでテストできるようになります。
<em>main.rs</em>に残る唯一のコードは、読めばその正当性が評価できるだけ小規模になるでしょう。
この工程に従って、プログラムのやり直しをしましょう。</p>
<!-- #### Extracting the Argument Parser -->
<a class="header" href="print.html#a引数解析器を抽出する" id="a引数解析器を抽出する"><h4>引数解析器を抽出する</h4></a>
<!-- We’ll extract the functionality for parsing arguments into a function that -->
<!-- `main` will call to prepare for moving the command line parsing logic to -->
<!-- *src/lib.rs*. Listing 12-5 shows the new start of `main` that calls a new -->
<!-- function `parse_config`, which we’ll define in *src/main.rs* for the moment. -->
<p>引数解析の機能を<code>main</code>が呼び出す関数に抽出して、コマンドライン引数解析ロジックを<em>src/lib.rs</em>に移動する準備をします。
リスト12-5に新しい関数<code>parse_config</code>を呼び出す<code>main</code>の冒頭部を示し、
この新しい関数は今だけ<em>src/main.rs</em>に定義します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<!-- <span class="caption">Listing 12-5: Extracting a `parse_config` function from -->
<!-- `main`</span> -->
<p><span class="caption">リスト12-5: <code>main</code>から<code>parse_config</code>関数を抽出する</span></p>
<!-- We’re still collecting the command line arguments into a vector, but instead of -->
<!-- assigning the argument value at index 1 to the variable `query` and the -->
<!-- argument value at index 2 to the variable `filename` within the `main` -->
<!-- function, we pass the whole vector to the `parse_config` function. The -->
<!-- `parse_config` function then holds the logic that determines which argument -->
<!-- goes in which variable and passes the values back to `main`. We still create -->
<!-- the `query` and `filename` variables in `main`, but `main` no longer has the -->
<!-- responsibility of determining how the command line arguments and variables -->
<!-- correspond. -->
<p>それでもまだ、コマンドライン引数をベクタ型に集結させていますが、<code>main</code>関数内で引数の値のインデックス1を変数<code>query</code>に、
インデックス2を変数<code>filename</code>に代入する代わりに、ベクタ全体を<code>parse_config</code>関数に渡しています。
そして、<code>parse_config</code>関数にはどの引数がどの変数に入り、それらの値を<code>main</code>に返すというロジックが存在します。
まだ<code>main</code>内で<code>query</code>と<code>filename</code>という変数を生成していますが、もう<code>main</code>は、
コマンドライン引数と変数がどう対応するかを決定する責任は持ちません。</p>
<!-- This rework may seem like overkill for our small program, but we’re refactoring -->
<!-- in small, incremental steps. After making this change, run the program again to -->
<!-- verify that the argument parsing still works. It’s good to check your progress -->
<!-- often, to help you identify the cause of problems when they occur. -->
<p>This rework may seem like overkill for our small program, but we’re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It’s good to check your progress
often, to help identify the cause of problems when they occur.</p>
<p>このやり直しは、私たちの小規模なプログラムにはやりすぎに思えるかもしれませんが、
少しずつ段階的にリファクタリングしているのです。この変更後、プログラムを再度実行して、
引数解析がまだ動作していることを実証してください。問題が発生した時に原因を特定する助けにするために頻繁に進捗を確認するのはいいことです。</p>
<!-- #### Grouping Configuration Values -->
<a class="header" href="print.html#a設定値をまとめる" id="a設定値をまとめる"><h4>設定値をまとめる</h4></a>
<!-- We can take another small step to improve the `parse_config` function further. -->
<!-- At the moment, we’re returning a tuple, but then we immediately break that -->
<!-- tuple into individual parts again. This is a sign that perhaps we don’t have -->
<!-- the right abstraction yet. -->
<p>もう少し<code>parse_config</code>関数を改善することができます。現時点では、タプルを返していますが、
即座にタプルを分解して再度個別の値にしています。これは、正しい抽象化をまだできていないかもしれない兆候です。</p>
<!-- Another indicator that shows there’s room for improvement is the `config` part -->
<!-- of `parse_config`, which implies that the two values we return are related and -->
<!-- are both part of one configuration value. We’re not currently conveying this -->
<!-- meaning in the structure of the data other than grouping the two values into -->
<!-- a tuple; we could put the two values into one struct and give each of the -->
<!-- struct fields a meaningful name. Doing so will make it easier for future -->
<!-- maintainers of this code to understand how the different values relate to each -->
<!-- other and what their purpose is. -->
<p>まだ改善の余地があると示してくれる他の徴候は、<code>parse_config</code>の<code>config</code>の部分であり、
返却している二つの値は関係があり、一つの設定値の一部にどちらもなることを暗示しています。
現状では、一つのタプルにまとめていること以外、この意味をデータの構造に載せていません;
この二つの値を1構造体に置き換え、構造体のフィールドそれぞれに意味のある名前をつけることもできるでしょう。
そうすることで将来このコードのメンテナンス者が、異なる値が相互に関係する仕方や、目的を理解しやすくできるでしょう。</p>
<!--  Note: Some people call this anti-pattern of using primitive values when a -->
<!--  complex type would be more appropriate *primitive obsession*. -->
<blockquote>
<p>注釈: この複雑型(complex type)がより適切な時に組み込みの値を使うアンチパターンを、
<em>primitive obsession</em>(<code>訳注</code>: 初めて聞いた表現。<em>組み込み型強迫観念</em>といったところだろうか)と呼ぶ人もいます。</p>
</blockquote>
<!-- Listing 12-6 shows the improvements to the `parse_config` function. -->
<p>リスト12-6は、<code>parse_config</code>関数の改善を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
# use std::fs::File;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<!-- <span class="caption">Listing 12-6: Refactoring `parse_config` to return an -->
<!-- instance of a `Config` struct</span> -->
<p><span class="caption">リスト12-6: <code>parse_config</code>をリファクタリングして<code>Config</code>構造体のインスタンスを返すようにした</span></p>
<!-- We’ve added a struct named `Config` defined to have fields named `query` and -->
<!-- `filename`. The signature of `parse_config` now indicates that it returns a -->
<!-- `Config` value. In the body of `parse_config`, where we used to return string -->
<!-- slices that reference `String` values in `args`, we now define `Config` to -->
<!-- contain owned `String` values. The `args` variable in `main` is the owner of -->
<!-- the argument values and is only letting the `parse_config` function borrow -->
<!-- them, which means we’d violate Rust’s borrowing rules if `Config` tried to take -->
<!-- ownership of the values in `args`. -->
<p><code>query</code>と<code>filenmae</code>というフィールドを持つよう定義された<code>Config</code>という構造体を追加しました。
<code>parse_config</code>のシグニチャは、これで<code>Config</code>値を返すと示すようになりました。<code>parse_config</code>の本体では、
以前は<code>args</code>の<code>String</code>値を参照する文字列スライスを返していましたが、
今では所有する<code>String</code>値を含むように<code>Config</code>を定義しています。<code>main</code>の<code>args</code>変数は引数値の所有者であり、
<code>parse_config</code>関数だけに借用させていますが、これは<code>Config</code>が<code>args</code>の値の所有権を奪おうとしたら、
Rustの借用規則に違反してしまうことを意味します。</p>
<!-- We could manage the `String` data in a number of different ways, but the -->
<!-- easiest, though somewhat inefficient, route is to call the `clone` method on -->
<!-- the values. This will make a full copy of the data for the `Config` instance to -->
<!-- own, which takes more time and memory than storing a reference to the string -->
<!-- data. However, cloning the data also makes our code very straightforward -->
<!-- because we don’t have to manage the lifetimes of the references; in this -->
<!-- circumstance, giving up a little performance to gain simplicity is a worthwhile -->
<!-- trade-off. -->
<p><code>String</code>のデータは、多くの異なる手法で管理できますが、最も単純だけれどもどこか非効率的な手段は、
値に対して<code>clone</code>メソッドを呼び出すことです。これにより、<code>Config</code>インスタンスが所有するデータの総コピーが生成されるので、
文字列データへの参照を保持するよりも時間とメモリを消費します。ですが、データをクローンすることで、
コードがとても素直にもなります。というのも、参照のライフタイムを管理する必要がないからです。
つまり、この場面において、少々のパフォーマンスを犠牲にして単純性を得るのは、価値のある交換です。</p>
<!-- > ### The Trade-Offs of Using `clone` -->
<!-- > -->
<!-- > There’s a tendency among many Rustaceans to avoid using `clone` to fix -->
<!-- > ownership problems because of its runtime cost. In Chapter 13, you’ll learn -->
<!-- > how to use more efficient methods in this type of situation. But for now, -->
<!-- > it’s okay to copy a few strings to continue making progress because we’ll -->
<!-- > make these copies only once and your filename and query string are very -->
<!-- > small. It’s better to have a working program that’s a bit inefficient than to -->
<!-- > try to hyperoptimize code on your first pass. As you become more experienced -->
<!-- > with Rust, it’ll be easier to start with the most efficient solution, but for -->
<!-- > now, it’s perfectly acceptable to call `clone`. -->
<blockquote>
<a class="header" href="print.html#cloneを使用するトレードオフ" id="cloneを使用するトレードオフ"><h3><code>clone</code>を使用するトレードオフ</h3></a>
<p>実行時コストのために<code>clone</code>を使用して所有権問題を解消するのを避ける傾向が多くのRustaceanにあります。
第13章で、この種の状況においてより効率的なメソッドの使用法を学ぶでしょう。ですがとりあえずは、
これらのコピーをするのは1回だけですし、ファイル名とクエリ文字列は非常に小さなものなので、
いくつかの文字列をコピーして進捗するのは良しとしましょう。最初の通り道でコードを究極的に効率化しようとするよりも、
ちょっと非効率的でも動くプログラムを用意する方がいいでしょう。もっとRustの経験を積めば、
最も効率的な解決法から開始することも簡単になるでしょうが、今は、<code>clone</code>を呼び出すのは完璧に受け入れられることです。</p>
</blockquote>
<!-- We’ve updated `main` so it places the instance of `Config` returned by -->
<!-- `parse_config` into a variable named `config`, and we updated the code that -->
<!-- previously used the separate `query` and `filename` variables so it now uses -->
<!-- the fields on the `Config` struct instead. -->
<p><code>main</code>を更新したので、<code>parse_config</code>から返された<code>Config</code>のインスタンスを<code>config</code>という変数に置くようになり、
以前は個別の<code>query</code>と<code>filename</code>変数を使用していたコードを更新したので、代わりに<code>Config</code>構造体のフィールドを使用するようになりました。</p>
<!-- Now our code more clearly conveys that `query` and `filename` are related and -->
<!-- that their purpose is to configure how the program will work. Any code that -->
<!-- uses these values knows to find them in the `config` instance in the fields -->
<!-- named for their purpose. -->
<p>これでコードは<code>query</code>と<code>filename</code>が関連していることと、その目的がプログラムの振る舞い方を設定するということをより明確に伝えます。
これらの値を使用するあらゆるコードは、<code>config</code>インスタンスの目的の名前を冠したフィールドにそれらを発見することを把握しています。</p>
<!-- #### Creating a Constructor for `Config` -->
<a class="header" href="print.html#configのコンストラクタを作成する" id="configのコンストラクタを作成する"><h4><code>Config</code>のコンストラクタを作成する</h4></a>
<!-- So far, we’ve extracted the logic responsible for parsing the command line -->
<!-- arguments from `main` and placed it in the `parse_config` function. Doing so -->
<!-- helped us to see that the `query` and `filename` values were related and that -->
<!-- relationship should be conveyed in our code. We then added a `Config` struct to -->
<!-- name the related purpose of `query` and `filename` and to be able to return the -->
<!-- values’ names as struct field names from the `parse_config` function. -->
<p>ここまで、コマンドライン引数を解析する責任を負ったロジックを<code>main</code>から抽出し、<code>parse_config</code>関数に配置しました。
そうすることで<code>query</code>と<code>filename</code>の値が関連し、その関係性がコードに載っていることを確認する助けになりました。
それから<code>Config</code>構造体を追加して<code>query</code>と<code>filename</code>の関係する目的を名前付けし、
構造体のフィールド名として<code>parse_config</code>関数からその値の名前を返すことができています。</p>
<!-- So now that the purpose of the `parse_config` function is to create a `Config` -->
<!-- instance, we can change `parse_config` from a plain function to a function -->
<!-- named `new` that is associated with the `Config` struct. Making this change -->
<!-- will make the code more idiomatic. We can create instances of types in the -->
<!-- standard library, such as `String`, by calling `String::new`. Similarly, by -->
<!-- changing `parse_config` into a `new` function associated with `Config`, we’ll -->
<!-- be able to create instances of `Config` by calling `Config::new`. Listing 12-7 -->
<!-- shows the changes we need to make. -->
<p>したがって、今や<code>parse_config</code>関数の目的は<code>Config</code>インスタンスを生成することになったので、
<code>parse_config</code>をただの関数から<code>Config</code>構造体に紐付く<code>new</code>という関数に変えることができます。
この変更を行うことで、コードがより慣用的になります。<code>String</code>などの標準ライブラリの型のインスタンスを、
<code>String::new</code>を呼び出すことで生成できます。同様に、<code>parse_config</code>を<code>Config</code>に紐付く<code>new</code>関数に変えれば、
<code>Config::new</code>を呼び出すことで<code>Config</code>のインスタンスを生成できるようになります。リスト12-7が、
行う必要のある変更を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // --snip--
}

# struct Config {
#     query: String,
#     filename: String,
# }
#
// --snip--

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 12-7: Changing `parse_config` into -->
<!-- `Config::new`</span> -->
<p><span class="caption">リスト12-7: <code>parse_config</code>を<code>Config::new</code>に変える</span></p>
<!-- We’ve updated `main` where we were calling `parse_config` to instead call -->
<!-- `Config::new`. We’ve changed the name of `parse_config` to `new` and moved it -->
<!-- within an `impl` block, which associates the `new` function with `Config`. Try -->
<!-- compiling this code again to make sure it works. -->
<p><code>parse_config</code>を呼び出していた<code>main</code>を代わりに<code>Config::new</code>を呼び出すように更新しました。
<code>parse_config</code>の名前を<code>new</code>に変え、<code>impl</code>ブロックに入れ込んだので、<code>new</code>関数と<code>Config</code>が紐付くようになりました。
再度このコードをコンパイルしてみて、動作することを確かめてください。</p>
<!-- ### Fixing the Error Handling -->
<a class="header" href="print.html#aエラー処理を修正する" id="aエラー処理を修正する"><h3>エラー処理を修正する</h3></a>
<!-- Now we’ll work on fixing our error handling. Recall that attempting to access -->
<!-- the values in the `args` vector at index 1 or index 2 will cause the program to -->
<!-- panic if the vector contains fewer than three items. Try running the program -->
<!-- without any arguments; it will look like this: -->
<p>さて、エラー処理の修正に取り掛かりましょう。ベクタが2個以下の要素しか含んでいないときに<code>args</code>ベクタのインデックス1か2にアクセスしようとすると、
プログラムがパニックすることを思い出してください。試しに引数なしでプログラムを実行してください。すると、こんな感じになります:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', src/main.rs:29:21
(スレッド'main'は、「境界外アクセス: 長さは1なのにインデックスも1です」でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!-- The line `index out of bounds: the len is 1 but the index is 1` is an error -->
<!-- message intended for programmers. It won’t help our end users understand what -->
<!-- happened and what they should do instead. Let’s fix that now. -->
<p><code>境界外アクセス: 長さは1なのにインデックスも1です</code>という行は、プログラマ向けのエラーメッセージです。
エンドユーザが起きたことと代わりにすべきことを理解する手助けにはならないでしょう。これを今修正しましょう。</p>
<!-- #### Improving the Error Message -->
<a class="header" href="print.html#aエラーメッセージを改善する" id="aエラーメッセージを改善する"><h4>エラーメッセージを改善する</h4></a>
<!-- In Listing 12-8, we add a check in the `new` function that will verify that the -->
<!-- slice is long enough before accessing index 1 and 2. If the slice isn’t long -->
<!-- enough, the program panics and displays a better error message than the `index -->
<!-- out of bounds` message. -->
<p>リスト12-8で、<code>new</code>関数にインデックス1と2にアクセスする前にスライスが十分長いことを実証するチェックを追加しています。
スライスの長さが十分でなければ、プログラムはパニックし、<code>境界外インデックス</code>よりもいいエラーメッセージを表示します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        // 引数の数が足りません
        panic!(&quot;not enough arguments&quot;);
    }
    // --snip--
</code></pre>
<!-- <span class="caption">Listing 12-8: Adding a check for the number of -->
<!-- arguments</span> -->
<p><span class="caption">リスト12-8: 引数の数のチェックを追加する</span></p>
<!-- This code is similar to the `Guess::new` function we wrote in Listing 9-9, -->
<!-- where we called `panic!` when the `value` argument was out of the range of -->
<!-- valid values. Instead of checking for a range of values here, we’re checking -->
<!-- that the length of `args` is at least 3 and the rest of the function can -->
<!-- operate under the assumption that this condition has been met. If `args` has -->
<!-- fewer than three items, this condition will be true, and we call the `panic!` -->
<!-- macro to end the program immediately. -->
<p>このコードは、リスト9-9で記述した<code>value</code>引数が正常な値の範囲外だった時に<code>panic!</code>を呼び出した<code>Guess::new</code>関数と似ています。
ここでは、値の範囲を確かめる代わりに、<code>args</code>の長さが少なくとも3であることを確かめていて、
関数の残りの部分は、この条件が満たされているという前提のもとで処理を行うことができます。
<code>args</code>に2要素以下しかなければ、この条件は真になり、<code>panic!</code>マクロを呼び出して、即座にプログラムを終了させます。</p>
<!-- With these extra few lines of code in `new`, let’s run the program without any -->
<!-- arguments again to see what the error looks like now: -->
<p>では、<code>new</code>のこのおまけの数行がある状態で、再度引数なしでプログラムを走らせ、エラーがどんな見た目か確かめましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:30:12
(スレッド'main'は「引数が足りません」でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!-- This output is better: we now have a reasonable error message. However, we also -->
<!-- have extraneous information we don’t want to give to our users. Perhaps using -->
<!-- the technique we used in Listing 9-9 isn’t the best to use here: a call to -->
<!-- `panic!` is more appropriate for a programming problem than a usage problem, as -->
<!-- discussed in Chapter 9. Instead, we can use the other technique you learned -->
<!-- about in Chapter 9—returning a `Result` that indicates either success or an -->
<!-- error. -->
<p>この出力の方がマシです: これでエラーメッセージが合理的になりました。ですが、
ユーザに与えたくない追加の情報も含まれてしまっています。おそらく、
ここではリスト9-9で使用したテクニックを使用するのは最善ではありません:
<code>panic!</code>の呼び出しは、第9章で議論したように、使用の問題よりもプログラミング上の問題により適しています。
代わりに、第9章で学んだもう一つのテクニックを使用することができます。成功か失敗かを示唆する<code>Result</code>を返すことです。</p>
<!-- #### Returning a `Result` from `new` Instead of Calling `panic!` -->
<a class="header" href="print.html#panicを呼び出す代わりにnewからresultを返す" id="panicを呼び出す代わりにnewからresultを返す"><h4><code>panic!</code>を呼び出す代わりに<code>new</code>から<code>Result</code>を返す</h4></a>
<!-- We can instead return a `Result` value that will contain a `Config` instance in -->
<!-- the successful case and will describe the problem in the error case. When -->
<!-- `Config::new` is communicating to `main`, we can use the `Result` type to -->
<!-- signal there was a problem. Then we can change `main` to convert an `Err` -->
<!-- variant into a more practical error for our users without the surrounding text -->
<!-- about `thread 'main'` and `RUST_BACKTRACE` that a call to `panic!` causes. -->
<p>代わりに、成功時には<code>Config</code>インスタンスを含み、エラー時には問題に言及する<code>Result</code>値を返すことができます。
<code>Config::new</code>が<code>main</code>と対話する時、<code>Result</code>型を使用して問題があったとシグナルを送ることができます。
それから<code>main</code>を変更して、<code>panic!</code>呼び出しが引き起こしていた<code>thread 'main'</code>と<code>RUST_BACKTRACE</code>に関する周囲のテキストがない、
ユーザ向けのより実用的なエラーに<code>Err</code>バリアントを変換することができます。</p>
<!-- Listing 12-9 shows the changes we need to make to the return value of -->
<!-- `Config::new` and the body of the function needed to return a `Result`. Note -->
<!-- that this won’t compile until we update `main` as well, which we’ll do in the -->
<!-- next listing. -->
<p>リスト12-9は、<code>Config::new</code>の戻り値に必要な変更と<code>Result</code>を返すのに必要な関数の本体を示しています。
<code>main</code>も更新するまで、これはコンパイルできないことに注意してください。その更新は次のリストで行います。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<!-- <span class="caption">Listing 12-9: Returning a `Result` from -->
<!-- `Config::new`</span> -->
<p><span class="caption">リスト12-9: <code>Config::new</code>から<code>Result</code>を返却する</span></p>
<!-- Our `new` function now returns a `Result` with a `Config` instance in the -->
<!-- success case and a `&'static str` in the error case. Recall from “The Static -->
<!-- Lifetime” section in Chapter 10 that `&'static str` is the type of string -->
<!-- literals, which is our error message type for now. -->
<p><code>new</code>関数は、今や、成功時には<code>Config</code>インスタンスを、エラー時には<code>&amp;'static str</code>を伴う<code>Result</code>を返すようになりました。
第10章の「静的ライフタイム」節から<code>&amp;'static str</code>は文字列リテラルの型であることを思い出してください。
これは、今はエラーメッセージの型になっています。</p>
<!-- We’ve made two changes in the body of the `new` function: instead of calling -->
<!-- `panic!` when the user doesn’t pass enough arguments, we now return an `Err` -->
<!-- value, and we’ve wrapped the `Config` return value in an `Ok`. These changes -->
<!-- make the function conform to its new type signature. -->
<p><code>new</code>関数の本体で2つ変更を行いました: 十分な数の引数をユーザが渡さなかった場合に<code>panic!</code>を呼び出す代わりに、
今は<code>Err</code>値を返し、<code>Config</code>戻り値を<code>Ok</code>に包んでいます。これらの変更により、関数が新しい型シグニチャに適合するわけです。</p>
<!-- Returning an `Err` value from `Config::new` allows the `main` function to -->
<!-- handle the `Result` value returned from the `new` function and exit the process -->
<!-- more cleanly in the error case. -->
<p><code>Config::new</code>から<code>Err</code>値を返すことにより、<code>main</code>関数は、<code>new</code>関数から返ってくる<code>Result</code>値を処理し、
エラー時により綺麗にプロセスから抜け出すことができます。</p>
<!-- #### Calling `Config::new` and Handling Errors -->
<a class="header" href="print.html#confignewを呼び出しエラーを処理する" id="confignewを呼び出しエラーを処理する"><h4><code>Config::new</code>を呼び出し、エラーを処理する</h4></a>
<!-- To handle the error case and print a user-friendly message, we need to update -->
<!-- `main` to handle the `Result` being returned by `Config::new`, as shown in -->
<!-- Listing 12-10. We’ll also take the responsibility of exiting the command line -->
<!-- tool with a nonzero error code from `panic!` and implement it by hand. A -->
<!-- nonzero exit status is a convention to signal to the process that called our -->
<!-- program that the program exited with an error state. -->
<p>エラーケースを処理し、ユーザフレンドリーなメッセージを出力するために、<code>main</code>を更新して、
リスト12-10に示したように<code>Config::new</code>から返されている<code>Result</code>を処理する必要があります。
また、<code>panic!</code>からコマンドラインツールを0以外のエラーコードで抜け出す責任も奪い取り、
手作業でそれも実装します。0以外の終了コードは、
我々のプログラムを呼び出したプロセスにプログラムがエラー状態で終了したことを通知する慣習です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        // 引数解析時に問題
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
</code></pre>
<!-- <span class="caption">Listing 12-10: Exiting with an error code if creating a -->
<!-- new `Config` fails</span> -->
<p><span class="caption">リスト12-10: 新しい<code>Config</code>作成に失敗したら、エラーコードで終了する</span></p>
<!-- In this listing, we’ve used a method we haven’t covered before: -->
<!-- `unwrap_or_else`, which is defined on `Result<T, E>` by the standard library. -->
<!-- Using `unwrap_or_else` allows us to define some custom, non-`panic!` error -->
<!-- handling. If the `Result` is an `Ok` value, this method’s behavior is similar -->
<!-- to `unwrap`: it returns the inner value `Ok` is wrapping. However, if the value -->
<!-- is an `Err` value, this method calls the code in the *closure*, which is an -->
<!-- anonymous function we define and pass as an argument to `unwrap_or_else`. We’ll -->
<!-- cover closures in more detail in Chapter 13. For now, you just need to know -->
<!-- that `unwrap_or_else` will pass the inner value of the `Err`, which in this -->
<!-- case is the static string `not enough arguments` that we added in Listing 12-9, -->
<!-- to our closure in the argument `err` that appears between the vertical pipes. -->
<!-- The code in the closure can then use the `err` value when it runs. -->
<p>このリストにおいて、以前には講義していないメソッドを使用しました: <code>unwrap_or_else</code>です。
これは標準ライブラリで<code>Result&lt;T, E&gt;</code>に定義されています。<code>unwrap_or_else</code>を使うことで、
<code>panic!</code>ではない何らか独自のエラー処理を定義できるのです。この<code>Result</code>が<code>Ok</code>値だったら、
このメソッドの振る舞いは<code>unwrap</code>に似ています: <code>Ok</code>が包んでいる中身の値を返すのです。
しかし、値が<code>Err</code>値なら、このメソッドは、<em>クロージャ</em>内でコードを呼び出し、
クロージャは定義し、引数として<code>unwrap_or_else</code>に渡す匿名関数です。クロージャについては第13章で詳しく解説します。
とりあえず、<code>unwrap_or_else</code>は、今回リスト12-9で追加した<code>not enough arguments</code>という静的文字列の<code>Err</code>の中身を、
縦棒の間に出現する<code>err</code>引数のクロージャに渡していることだけ知っておく必要があります。
クロージャのコードはそれから、実行された時に<code>err</code>値を使用できます。</p>
<!-- We’ve added a new `use` line to import `process` from the standard library. The -->
<!-- code in the closure that will be run in the error case is only two lines: we -->
<!-- print the `err` value and then call `process::exit`. The `process::exit` -->
<!-- function will stop the program immediately and return the number that was -->
<!-- passed as the exit status code. This is similar to the `panic!`-based handling -->
<!-- we used in Listing 12-8, but we no longer get all the extra output. Let’s try -->
<!-- it: -->
<p>新規<code>use</code>行を追加して標準ライブラリから<code>process</code>をインポートしました。クロージャ内のエラー時に走るコードは、
たった2行です: <code>err</code>の値を出力し、それから<code>process::exit</code>を呼び出します。<code>process::exit</code>関数は、
即座にプログラムを停止させ、渡された数字を終了コードとして返します。これは、リスト12-8で使用した<code>panic!</code>ベースの処理と似ていますが、
もう余計な出力はされません。試しましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<!-- Great! This output is much friendlier for our users. -->
<p>素晴らしい！この出力の方が遥かにユーザに優しいです。</p>
<!-- ### Extracting Logic from `main` -->
<a class="header" href="print.html#mainからロジックを抽出する" id="mainからロジックを抽出する"><h3><code>main</code>からロジックを抽出する</h3></a>
<!-- Now that we’ve finished refactoring the configuration parsing, let’s turn to -->
<!-- the program’s logic. As we stated in “Separation of Concerns for Binary -->
<!-- Projects”, we’ll extract a function named `run` that will hold all the logic-->
<!-- currently in the `main` function that isn’t involved with setting up -->
<!-- configuration or handling errors. When we’re done, `main` will be concise and -->
<!-- easy to verify by inspection, and we’ll be able to write tests for all the -->
<!-- other logic. -->
<p>ようやく設定解析のリファクタリングが終了したので、プログラムのロジックに目を向けましょう。
「バイナリプロジェクトの責任の分離」で述べたように、
現在<code>main</code>関数に存在する設定セットやエラー処理に関わらない全てのロジックを保持することになる<code>run</code>という関数を抽出します。
やり終わったら、<code>main</code>は簡潔かつ視察で確かめやすくなり、他のロジック全部に対してテストを書くことができるでしょう。</p>
<!-- Listing 12-11 shows the extracted `run` function. For now, we’re just making -->
<!-- the small, incremental improvement of extracting the function. We’re still -->
<!-- defining the function in *src/main.rs*. -->
<p>リスト12-11は、抜き出した<code>run</code>関数を示しています。今は少しずつ段階的に関数を抽出する改善を行っています。
それでも、<em>src/main.rs</em>に関数を定義していきます。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
</code></pre>
<!-- <span class="caption">Listing 12-11: Extracting a `run` function containing the -->
<!-- rest of the program logic</span> -->
<p><span class="caption">リスト12-11: 残りのプログラムロジックを含む<code>run</code>関数を抽出する</span></p>
<!-- The `run` function now contains all the remaining logic from `main`, starting -->
<!-- from reading the file. The `run` function takes the `Config` instance as an -->
<!-- argument. -->
<p>これで<code>run</code>関数は、ファイル読み込みから始まる<code>main</code>関数の残りのロジック全てを含むようになりました。
この<code>run</code>関数は、引数に<code>Config</code>インスタンスを取ります。</p>
<!-- #### Returning Errors from the `run` Function -->
<a class="header" href="print.html#run関数からエラーを返す" id="run関数からエラーを返す"><h4><code>run</code>関数からエラーを返す</h4></a>
<!-- 1行目。ここではwith ...を順接の理由で訳している。with ...は普通、状態を表す表現 -->
<!-- ちょっと意味が強すぎるかもしれない。 -->
<!-- With you next to me, I'll drive to wherever you like. (君が隣にいる状態で、何処へでも君の好きな場所にドライブするよ) -->
<!-- With the remaining program logic separated into the `run` function, we can -->
<!-- improve the error handling, as we did with `Config::new` in Listing 12-9. -->
<!-- Instead of allowing the program to panic by calling `expect`, the `run` -->
<!-- function will return a `Result<T, E>` when something goes wrong. This will let -->
<!-- us further consolidate into `main` the logic around handling errors in a -->
<!-- user-friendly way. Listing 12-12 shows the changes we need to make to the -->
<!-- signature and body of `run`. -->
<p>残りのプログラムロジックが<code>run</code>関数に隔離されたので、リスト12-9の<code>Config::new</code>のように、
エラー処理を改善することができます。<code>expect</code>を呼び出してプログラムにパニックさせる代わりに、
<code>run</code>関数は、何か問題が起きた時に<code>Result&lt;T, E&gt;</code>を返します。これにより、
さらにエラー処理周りのロジックをユーザに優しい形で<code>main</code>に統合することができます。
リスト12-12にシグニチャと<code>run</code>本体に必要な変更を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// --snip--

fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<!-- <span class="caption">Listing 12-12: Changing the `run` function to return -->
<!-- `Result`</span> -->
<p><span class="caption">リスト12-12: <code>run</code>関数を変更して<code>Result</code>を返す</span></p>
<!-- We’ve made three significant changes here. First, we changed the return type of -->
<!-- the `run` function to `Result<(), Box<Error>>`. This function previously -->
<!-- returned the unit type, `()`, and we keep that as the value returned in the -->
<!-- `Ok` case. -->
<p>ここでは、3つの大きな変更を行いました。まず、<code>run</code>関数の戻り値を<code>Result&lt;(), Box&lt;Error&gt;&gt;</code>に変えました。
この関数は、前はユニット型、<code>()</code>を返していて、それを<code>Ok</code>の場合に返される値として残しました。</p>
<!-- For the error type, we used the *trait object* `Box<Error>` (and we’ve brought -->
<!-- `std::error::Error` into scope with a `use` statement at the top). We’ll cover -->
<!-- trait objects in Chapter 17. For now, just know that `Box<Error>` means the -->
<!-- function will return a type that implements the `Error` trait, but we don’t -->
<!-- have to specify what particular type the return value will be. This gives us -->
<!-- flexibility to return error values that may be of different types in different -->
<!-- error cases. -->
<p>エラー型については、<em>トレイトオブジェクト</em>の<code>Box&lt;Error&gt;</code>を使用しました(同時に冒頭で<code>use</code>文により、
<code>std::error::Error</code>をスコープに導入しています)。トレイトオブジェクトについては、第17章で講義します。
とりあえず、<code>Box&lt;Error&gt;</code>は、関数が<code>Error</code>トレイトを実装する型を返すことを意味しますが、
戻り値の型を具体的に指定しなくても良いことを知っておいてください。これにより、
エラーケースによって異なる型のエラー値を返す柔軟性を得ます。</p>
<!-- Second, we’ve removed the calls to `expect` in favor of the `?` operator, as we -->
<!-- talked about in Chapter 9. Rather than `panic!` on an error, the `?` operator -->
<!-- will return the error value from the current function for the caller to handle. -->
<p>2番目に、<code>expect</code>の呼び出しよりも<code>?</code>演算子を選択して取り除きました。第9章で語りましたね。
エラーでパニックするのではなく、<code>?</code>演算子は呼び出し元が処理できるように、現在の関数からエラー値を返します。</p>
<!-- Third, the `run` function now returns an `Ok` value in the success case. We’ve -->
<!-- declared the `run` function’s success type as `()` in the signature, which -->
<!-- means we need to wrap the unit type value in the `Ok` value. This `Ok(())` -->
<!-- syntax might look a bit strange at first, but using `()` like this is the -->
<!-- idiomatic way to indicate that we’re calling `run` for its side effects only; -->
<!-- it doesn’t return a value we need. -->
<p>3番目に、<code>run</code>関数は今、成功時に<code>Ok</code>値を返すようになりました。<code>run</code>関数の成功型は、
シグニチャで<code>()</code>と定義したので、ユニット型の値を<code>Ok</code>値に包む必要があります。
最初は、この<code>Ok(())</code>という記法は奇妙に見えるかもしれませんが、このように<code>()</code>を使うことは、
<code>run</code>を副作用のためだけに呼び出していると示唆する慣習的な方法です; 必要な値は返しません。</p>
<!-- When you run this code, it will compile but will display a warning: -->
<p>このコードを実行すると、コンパイルは通るものの、警告が表示されるでしょう:</p>
<pre><code class="language-text">warning: unused `std::result::Result` which must be used
(警告: 使用されなければならない`std::result::Result`が未使用です)
  --&gt; src/main.rs:18:5
   |
18 |     run(config);
   |     ^^^^^^^^^^^^
= note: #[warn(unused_must_use)] on by default
</code></pre>
<!-- 3行目中盤、andだが、逆接のように訳している。andはフローが流れていることを表すだけなので、こうなっている模様 -->
<!-- Rust tells us that our code ignored the `Result` value and the `Result` value -->
<!-- might indicate that an error occurred. But we’re not checking to see whether or -->
<!-- not there was an error, and the compiler reminds us that we probably meant to -->
<!-- have some error-handling code here! Let’s rectify that problem now. -->
<p>コンパイラは、コードが<code>Result</code>値を無視していると教えてくれて、この<code>Result</code>値は、
エラーが発生したと示唆しているかもしれません。しかし、エラーがあったか確認するつもりはありませんが、
コンパイラは、ここにエラー処理コードを書くつもりだったんじゃないかと思い出させてくれています！
今、その問題を改修しましょう。</p>
<!-- #### Handling Errors Returned from `run` in `main` -->
<a class="header" href="print.html#mainでrunから返ってきたエラーを処理する" id="mainでrunから返ってきたエラーを処理する"><h4><code>main</code>で<code>run</code>から返ってきたエラーを処理する</h4></a>
<!-- We’ll check for errors and handle them using a technique similar to one we used -->
<!-- with `Config::new` in Listing 12-10, but with a slight difference: -->
<p>リスト12-10の<code>Config::new</code>に対して行った方法に似たテクニックを使用してエラーを確認し、扱いますが、
少し違いがあります:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<!-- We use `if let` rather than `unwrap_or_else` to check whether `run` returns an -->
<!-- `Err` value and call `process::exit(1)` if it does. The `run` function doesn’t -->
<!-- return a value that we want to `unwrap` in the same way that `Config::new` -->
<!-- returns the `Config` instance. Because `run` returns `()` in the success case -->
<!-- we only care about detecting an error, so we don’t need `unwrap_or_else` to -->
<!-- return the unwrapped value because it would only be `()`. -->
<p><code>unwrap_or_else</code>ではなく、<code>if let</code>で<code>run</code>が<code>Err</code>値を返したかどうかを確認し、そうなら<code>process::exit(1)</code>を呼び出しています。
<code>run</code>関数は、<code>Config::new</code>が<code>Config</code>インスタンスを返すのと同じように<code>unwrap</code>したい値を返すことはありません。
<code>run</code>は成功時に<code>()</code>を返すので、エラーを検知することにのみ興味があり、<code>()</code>でしかないので、
<code>unwrap_or_else</code>に包まれた値を返してもらう必要はないのです。</p>
<!-- The bodies of the `if let` and the `unwrap_or_else` functions are the same in -->
<!-- both cases: we print the error and exit. -->
<p><code>if let</code>を<code>unwrap_or_else</code>関数の中身はどちらも同じです: エラーを出力して終了します。</p>
<!-- ### Splitting Code into a Library Crate -->
<a class="header" href="print.html#aコードをライブラリクレートに分割する" id="aコードをライブラリクレートに分割する"><h3>コードをライブラリクレートに分割する</h3></a>
<!-- Our `minigrep` project is looking good so far! Now we’ll split the -->
<!-- *src/main.rs* file and put some code into the *src/lib.rs* file so we can test -->
<!-- it and have a *src/main.rs* file with fewer responsibilities. -->
<p>ここまで<code>minigrep</code>は良さそうですね！では、テストを行い、<em>src/main.rs</em>ファイルの責任が減らせるように、
<em>src/main.rs</em>ファイルを分割し、一部のコードを<em>src/lib.rs</em>ファイルに置きましょう。</p>
<!-- Let’s move all the code that isn’t the `main` function from *src/main.rs* to -->
<!-- *src/lib.rs*: -->
<p><code>main</code>関数以外のコード全部を<em>src/main.rs</em>から<em>src/lib.rs</em>に移動しましょう:</p>
<!-- * The `run` function definition -->
<!-- * The relevant `use` statements -->
<!-- * The definition of `Config` -->
<!-- * The `Config::new` function definition -->
<ul>
<li><code>run</code>関数定義</li>
<li>関係する<code>use</code>文</li>
<li><code>Config</code>の定義</li>
<li><code>Config::new</code>関数定義</li>
</ul>
<!-- The contents of *src/lib.rs* should have the signatures shown in Listing 12-13 -->
<!-- (we’ve omitted the bodies of the functions for brevity). Note that this won't -->
<!-- compile until we modify *src/main.rs* in Listing 12-14. -->
<p><em>src/lib.rs</em>の中身にはリスト12-13に示したようなシグニチャがあるはずです(関数の本体は簡潔性のために省略しました)。
リスト12-14で<em>src/main.rs</em>に変更を加えるまでこのコードはコンパイルできないことに注意してください。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // --snip--
}
</code></pre>
<!-- <span class="caption">Listing 12-13: Moving `Config` and `run` into -->
<!-- *src/lib.rs*</span> -->
<p><span class="caption">リスト12-13: <code>Config</code>と<code>run</code>を<em>src/lib.rs</em>に移動する</span></p>
<!-- We’ve made liberal use of `pub` here: on `Config`, on its fields and its -->
<!-- `new` method, and on the `run` function. We now have a library crate that has a -->
<!-- public API that we can test! -->
<p>ここでは、寛大に<code>pub</code>を使用しています: <code>Config</code>のフィールドと<code>new</code>メソッドと<code>run</code>関数です。
これでテスト可能な公開APIのあるライブラリクレートができました！</p>
<!-- Now we need to bring the code we moved to *src/lib.rs* into the scope of the -->
<!-- binary crate in *src/main.rs*, as shown in Listing 12-14. -->
<p>さて、<em>src/lib.rs</em>に移動したコードを<em>src/main.rs</em>のバイナリクレートのスコープに持っていく必要があります。
リスト12-14に示したようにですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate minigrep;

use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}
</code></pre>
<!-- <span class="caption">Listing 12-14: Bringing the `minigrep` crate into the -->
<!-- scope of *src/main.rs*</span> -->
<p><span class="caption">リスト12-14: <code>minigrep</code>クレートを<em>src/main.rs</em>のスコープに持っていく</span></p>
<!-- To bring the library crate into the binary crate, we use `extern crate -->
<!-- minigrep`. Then we add a `use minigrep::Config` line to bring the `Config` type -->
<!-- into scope, and we prefix the `run` function with our crate name. Now all the -->
<!-- functionality should be connected and should work. Run the program with `cargo -->
<!-- run` and make sure everything works correctly. -->
<p>ライブラリクレートをバイナリクレートに持っていくのに、<code>extern crate minigrep</code>を使用しています。
それから<code>use minigrep::Config</code>行を追加して<code>Config</code>型をスコープに持っていき、
<code>run</code>関数にクレート名を接頭辞として付けます。これで全機能が連結され、動くはずです。
<code>cargo run</code>でプログラムを走らせて、すべてがうまくいっていることを確かめてください。</p>
<!-- Whew! That was a lot of work, but we’ve set ourselves up for success in the -->
<!-- future. Now it’s much easier to handle errors, and we’ve made the code more -->
<!-- modular. Almost all of our work will be done in *src/lib.rs* from here on out. -->
<p>ふう！作業量が多かったですね。ですが、将来成功する準備はできています。
もう、エラー処理は遥かに楽になり、コードのモジュール化もできました。
ここから先の作業は、ほぼ<em>src/lib.rs</em>で完結するでしょう。</p>
<!-- Let’s take advantage of this newfound modularity by doing something that would -->
<!-- have been difficult with the old code but is easy with the new code: we’ll -->
<!-- write some tests! -->
<p>古いコードでは大変だけれども、新しいコードでは楽なことをして新発見のモジュール性を活用しましょう:
テストを書くのです！</p>
<!-- ## Developing the Library’s Functionality with Test Driven Development -->
<a class="header" href="print.html#aテスト駆動開発でライブラリの機能を開発する" id="aテスト駆動開発でライブラリの機能を開発する"><h2>テスト駆動開発でライブラリの機能を開発する</h2></a>
<!-- Now that we’ve extracted the logic into *src/lib.rs* and left the argument -->
<!-- collecting and error handling in *src/main.rs*, it’s much easier to write tests -->
<!-- for the core functionality of our code. We can call functions directly with -->
<!-- various arguments and check return values without having to call our binary -->
<!-- from the command line. Feel free to write some tests for the functionality in -->
<!-- the `Config::new` and `run` functions on your own. -->
<p>今や、ロジックを<em>src/lib.rs</em>に抜き出し、引数集めとエラー処理を<em>src/main.rs</em>に残したので、
コードの核となる機能のテストを書くのが非常に容易になりました。いろんな引数で関数を直接呼び出し、
コマンドラインからバイナリを呼び出す必要なく戻り値を確認できます。ご自由に<code>Config::new</code>や<code>run</code>関数の機能のテストは、
自身でお書きください。</p>
<!-- In this section, we’ll add the searching logic to the `minigrep` program by -->
<!-- using the Test Driven Development (TDD) process. This software development -->
<!-- technique follows these steps: -->
<p>この節では、テスト駆動開発(TDD)過程を使用して<code>minigrep</code>プログラムに検索ロジックを追加します。
このソフトウェア開発テクニックは、以下の手順に従います:</p>
<!-- 1. Write a test that fails, and run it to make sure it fails for the reason you -->
<!--    expected. -->
<!-- 2. Write or modify just enough code to make the new test pass. -->
<!-- 3. Refactor the code you just added or changed and make sure the tests -->
<!--    continue to pass. -->
<!-- 4. Repeat from step 1! -->
<ol>
<li>失敗するテストを書き、走らせて想定通りの理由で失敗することを確かめる。</li>
<li>十分な量のコードを書くか変更して新しいテストを通過するようにする。</li>
<li>追加または変更したばかりのコードをリファクタリングし、テストが通り続けることを確認する。</li>
<li>手順1から繰り返す！</li>
</ol>
<!-- This process is just one of many ways to write software, but TDD can help drive -->
<!-- code design as well. Writing the test before you write the code that makes the -->
<!-- test pass helps to maintain high test coverage throughout the process. -->
<p>この過程は、ソフトウェアを書く多くの方法のうちの一つに過ぎませんが、TDDによりコードデザインも駆動することができます。
テストを通過させるコードを書く前にテストを書くことで、過程を通して高いテストカバー率を保つ助けになります。</p>
<!-- We’ll test drive the implementation of the functionality that will actually do -->
<!-- the searching for the query string in the file contents and produce a list of -->
<!-- lines that match the query. We’ll add this functionality in a function called -->
<!-- `search`. -->
<p>実際にクエリ文字列の検索を行う機能の実装をテスト駆動し、クエリに合致する行のリストを生成します。
この機能を<code>search</code>という関数に追加しましょう。</p>
<!-- ### Writing a Failing Test -->
<a class="header" href="print.html#a失敗するテストを記述する" id="a失敗するテストを記述する"><h3>失敗するテストを記述する</h3></a>
<!-- Because we don’t need them anymore, let’s remove the `println!` statements from -->
<!-- *src/lib.rs* and *src/main.rs* that we used to check the program’s behavior. -->
<!-- Then, in *src/lib.rs*, we’ll add a `test` module with a test function, as we -->
<!-- did in Chapter 11. The test function specifies the behavior we want the -->
<!-- `search` function to have: it will take a query and the text to search for the -->
<!-- query in, and will return only the lines from the text that contain the -->
<!-- query. Listing 12-15 shows this test, which won't compile yet. -->
<p>もう必要ないので、プログラムの振る舞いを確認していた<code>println!</code>文を<em>src/lib.rs</em>と<em>src/main.rs</em>から削除しましょう。
それから<em>src/lib.rs</em>で、テスト関数のある<code>test</code>モジュールを追加します。第11章のようにですね。
このテスト関数が<code>search</code>関数に欲しい振る舞いを指定します: クエリとそれを検索するテキストを受け取り、
クエリを含む行だけをテキストから返します。リスト12-15にこのテストを示していますが、まだコンパイルは通りません。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        // Rustは
        // 安全で速く生産性も高い。
        // 3つ選んで。
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 12-15: Creating a failing test for the `search` -->
<!-- function we wish we had</span> -->
<p><span class="caption">リスト12-15: こうだったらいいなという<code>search</code>関数の失敗するテストを作成する</span></p>
<!-- This test searches for the string `“duct.”` The text we’re searching is three -->
<!-- lines, only one of which contains `“duct.”` We assert that the value returned -->
<!-- from the `search` function contains only the line we expect. -->
<p>このテストは、<code>&quot;duct.&quot;</code>という文字列を検索します。検索対象の文字列は3行で、うち1行だけが<code>&quot;duct.&quot;</code>を含みます。
<code>search</code>関数から返る値が想定している行だけを含むことをアサーションします。</p>
<!-- We aren’t able to run this test and watch it fail because the test doesn’t even -->
<!-- compile: the `search` function doesn’t exist yet! So now we’ll add just enough -->
<!-- code to get the test to compile and run by adding a definition of the `search` -->
<!-- function that always returns an empty vector, as shown in Listing 12-16. Then -->
<!-- the test should compile and fail because an empty vector doesn’t match a vector -->
<!-- containing the line `"safe, fast, productive."`. -->
<p>このテストを走らせ、失敗するところを観察することはできません。このテストはコンパイルもできないからです:
まだ<code>search</code>関数が存在していません！ゆえに今度は、空のベクタを常に返す<code>search</code>関数の定義を追加することで、
テストをコンパイルし走らせるだけのコードを追記します。リスト12-16に示したようにですね。そうすれば、
テストはコンパイルでき、失敗するはずです。なぜなら、空のベクタは、
<code>&quot;safe, fast, productive.&quot;</code>という行を含むベクタとは合致しないからです。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 12-16: Defining just enough of the `search` -->
<!-- function so our test will compile</span> -->
<p><span class="caption">リスト12-16: テストがコンパイルできるのに十分なだけ<code>search</code>関数を定義する</span></p>
<!-- 3行目後半、which argument lifetimeをwhich argument's lifetimeの形で訳している。記述ミス？ -->
<!-- Notice that we need an explicit lifetime `'a` defined in the signature of -->
<!-- `search` and used with the `contents` argument and the return value. Recall in -->
<!-- Chapter 10 that the lifetime parameters specify which argument lifetime is -->
<!-- connected to the lifetime of the return value. In this case, we indicate that -->
<!-- the returned vector should contain string slices that reference slices of the -->
<!-- argument `contents` (rather than the argument `query`). -->
<p>明示的なライフタイムの<code>'a</code>が<code>search</code>のシグニチャで定義され、<code>contents</code>引数と戻り値で使用されていることに気付いてください。
第10章からライフタイム仮引数は、どの実引数のライフタイムが戻り値のライフタイムに関連づけられているかを指定することを思い出してください。
この場合、返却されるベクタは、
(<code>query</code>引数ではなく)<code>contents</code>引数のスライスを参照する文字列スライスを含むべきと示唆しています。</p>
<!-- In other words, we tell Rust that the data returned by the `search` function -->
<!-- will live as long as the data passed into the `search` function in the -->
<!-- `contents` argument. This is important! The data referenced *by* a slice needs -->
<!-- to be valid for the reference to be valid; if the compiler assumes we’re making -->
<!-- string slices of `query` rather than `contents`, it will do its safety checking -->
<!-- incorrectly. -->
<p>言い換えると、コンパイラに<code>search</code>関数に返されるデータは、
<code>search</code>関数に<code>contents</code>引数で渡されているデータと同期間生きることを教えています。
これは重要なことです！スライス<em>に</em>参照されるデータは、参照が有効になるために有効である必要があるのです;
コンパイラが<code>contents</code>ではなく<code>query</code>の文字列スライスを生成すると想定してしまったら、
安全性チェックを間違って行うことになってしまいます。</p>
<!-- If we forget the lifetime annotations and try to compile this function, we’ll -->
<!-- get this error: -->
<p>ライフタイム注釈を忘れてこの関数をコンパイルしようとすると、こんなエラーが出ます:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
(エラー: ライフタイム指定子が欠けています)
 --&gt; src/lib.rs:5:51
  |
5 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                                   ^ expected lifetime
parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
  (助言: この関数の戻り値は、借用された値を含んでいますが、シグニチャにはそれが、
  `query`か`contents`から借用されたものであるかが示されていません)
</code></pre>
<!-- Rust can’t possibly know which of the two arguments we need, so we need to tell -->
<!-- it. Because `contents` is the argument that contains all of our text and we -->
<!-- want to return the parts of that text that match, we know `contents` is the -->
<!-- argument that should be connected to the return value using the lifetime syntax. -->
<p>コンパイラには、二つの引数のどちらが必要なのか知る由がないので、教えてあげる必要があるのです。
<code>contents</code>がテキストを全て含む引数で、合致するそのテキストの一部を返したいので、
<code>contents</code>がライフタイム記法で戻り値に関連づくはずの引数であることをプログラマは知っています。</p>
<!-- Other programming languages don’t require you to connect arguments to return -->
<!-- values in the signature. Although this might seem strange, it will get easier -->
<!-- over time. You might want to compare this example with “Validating -->
<!-- References with Lifetimes” section in Chapter 10.-->
<p>他のプログラミング言語では、シグニチャで引数と戻り値を関連づける必要はありません。これは奇妙に思えるかもしれませんが、
時間とともに楽になっていきます。この例を第10章、「ライフタイムで参照を有効化する」節と比較したくなるかもしれません。</p>
<!-- Now let’s run the test: -->
<p>さあ、テストを実行しましょう:</p>
<pre><code class="language-text">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
--warnings--
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test test::one_result ... FAILED

failures:

---- test::one_result stdout ----
        thread 'test::one_result' panicked at 'assertion failed: `(left ==
right)`
left: `[&quot;safe, fast, productive.&quot;]`,
right: `[]`)', src/lib.rs:48:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    test::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!-- Great, the test fails, exactly as we expected. Let’s get the test to pass! -->
<p>素晴らしい。テストは全く想定通りに失敗しています。テストが通るようにしましょう！</p>
<!-- ### Writing Code to Pass the Test -->
<a class="header" href="print.html#aテストを通過させるコードを書く" id="aテストを通過させるコードを書く"><h3>テストを通過させるコードを書く</h3></a>
<!-- Currently, our test is failing because we always return an empty vector. To fix -->
<!-- that and implement `search`, our program needs to follow these steps: -->
<p>空のベクタを常に返しているために、現状テストは失敗しています。それを解消し、<code>search</code>を実装するには、
プログラムは以下の手順に従う必要があります:</p>
<!-- * Iterate through each line of the contents. -->
<!-- * Check whether the line contains our query string. -->
<!-- * If it does, add it to the list of values we’re returning. -->
<!-- * If it doesn’t, do nothing. -->
<!-- * Return the list of results that match. -->
<ul>
<li>中身を各行ごとに繰り返す。</li>
<li>行にクエリ文字列が含まれるか確認する。</li>
<li>するなら、それを返却する値のリストに追加する。</li>
<li>しないなら、何もしない。</li>
<li>一致する結果のリストを返す。</li>
</ul>
<!-- Let’s work through each step, starting with iterating through lines. -->
<p>各行を繰り返す作業から、この手順に順に取り掛かりましょう。</p>
<!-- #### Iterating Through Lines with the `lines` Method -->
<a class="header" href="print.html#linesメソッドで各行を繰り返す" id="linesメソッドで各行を繰り返す"><h4><code>lines</code>メソッドで各行を繰り返す</h4></a>
<!-- Rust has a helpful method to handle line-by-line iteration of strings, -->
<!-- conveniently named `lines`, that works as shown in Listing 12-17. Note this -->
<!-- won’t compile yet. -->
<p>Rustには、文字列を行ごとに繰り返す役立つメソッドがあり、利便性のために<code>lines</code>と名付けられ、
リスト12-17のように動作します。まだ、これはコンパイルできないことに注意してください。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // 行に対して何かする
        // do something with line
    }
}
</code></pre>
<!-- <span class="caption">Listing 12-17: Iterating through each line in `contents` -->
<!-- </span> -->
<p><span class="caption">リスト12-17: <code>contents</code>の各行を繰り返す</span></p>
<!-- The `lines` method returns an iterator. We’ll talk about iterators in depth in -->
<!-- Chapter 13, but recall that you saw this way of using an iterator in Listing -->
<!-- 3-5, where we used a `for` loop with an iterator to run some code on each item -->
<!-- in a collection. -->
<p><code>lines</code>メソッドはイテレータを返します。イテレータについて詳しくは、第13章で話しますが、
リスト3-5でこのようなイテレータの使用法は見かけたことを思い出してください。
そこでは、イテレータに<code>for</code>ループを使用してコレクションの各要素に対して何らかのコードを走らせていました。</p>
<!-- #### Searching Each Line for the Query -->
<a class="header" href="print.html#aクエリを求めて各行を検索する" id="aクエリを求めて各行を検索する"><h4>クエリを求めて各行を検索する</h4></a>
<!-- Next, we’ll check whether the current line contains our query string. -->
<!-- Fortunately, strings have a helpful method named `contains` that does this for -->
<!-- us! Add a call to the `contains` method in the `search` function, as shown in -->
<!-- Listing 12-18. Note this still won’t compile yet. -->
<p>次に現在の行がクエリ文字列を含むか確認します。幸運なことに、
文字列にはこれを行ってくれる<code>contains</code>という役に立つメソッドがあります！<code>search</code>関数に、
<code>contains</code>メソッドの呼び出しを追加してください。リスト12-18のようにですね。
これもまだコンパイルできないことに注意してください。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<!-- <span class="caption">Listing 12-18: Adding functionality to see whether the -->
<!-- line contains the string in `query`</span> -->
<p><span class="caption">リスト12-18: 行が<code>query</code>の文字列を含むか確認する機能を追加する</span></p>
<!-- #### Storing Matching Lines -->
<a class="header" href="print.html#a合致した行を保存する" id="a合致した行を保存する"><h4>合致した行を保存する</h4></a>
<!-- We also need a way to store the lines that contain our query string. For that, -->
<!-- we can make a mutable vector before the `for` loop and call the `push` method -->
<!-- to store a `line` in the vector. After the `for` loop, we return the vector, as -->
<!-- shown in Listing 12-19. -->
<p>また、クエリ文字列を含む行を保存する方法が必要です。そのために、<code>for</code>ループの前に可変なベクタを生成し、
<code>push</code>メソッドを呼び出して<code>line</code>をベクタに保存することができます。<code>for</code>ループの後でベクタを返却します。
リスト12-19のようにですね。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<!-- <span class="caption">Listing 12-19: Storing the lines that match so we can -->
<!-- return them</span> -->
<p><span class="caption">リスト12-19: 合致する行を保存したので、返すことができる</span></p>
<!-- Now the `search` function should return only the lines that contain `query`, -->
<!-- and our test should pass. Let’s run the test: -->
<p>これで<code>search</code>関数は、<code>query</code>を含む行だけを返すはずであり、テストも通るはずです。
テストを実行しましょう:</p>
<pre><code class="language-text">$ cargo test
--snip--
running 1 test
test test::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- Our test passed, so we know it works! -->
<p>テストが通り、動いていることがわかりました！</p>
<!-- At this point, we could consider opportunities for refactoring the -->
<!-- implementation of the search function while keeping the tests passing to -->
<!-- maintain the same functionality. The code in the search function isn’t too bad, -->
<!-- but it doesn’t take advantage of some useful features of iterators. We’ll -->
<!-- return to this example in Chapter 13, where we’ll explore iterators in detail, -->
<!-- and look at how to improve it. -->
<p>ここで、テストが通過するよう保ったまま、同じ機能を保持しながら、検索関数の実装をリファクタリングする機会を考えることもできます。
検索関数のコードは悪すぎるわけではありませんが、イテレータの有効な機能の一部を活用していません。
この例には第13章で再度触れ、そこでは、イテレータをより深く探求しますが、さらに改善する方法に目を向けます。</p>
<!-- #### Using the `search` Function in the `run` Function -->
<a class="header" href="print.html#run関数内でsearch関数を使用する" id="run関数内でsearch関数を使用する"><h4><code>run</code>関数内で<code>search</code>関数を使用する</h4></a>
<!-- Now that the `search` function is working and tested, we need to call `search` -->
<!-- from our `run` function. We need to pass the `config.query` value and the -->
<!-- `contents` that `run` reads from the file to the `search` function. Then `run` -->
<!-- will print each line returned from `search`: -->
<p><code>search</code>関数が動きテストできたので、<code>run</code>関数から<code>search</code>を呼び出す必要があります。<code>condif.query</code>の値と、
ファイルから<code>run</code>が読み込む<code>contents</code>の値を<code>search</code>関数に渡す必要があります。
それから<code>run</code>は、<code>search</code>から返ってきた各行を出力するでしょう:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<!-- We’re still using a `for` loop to return each line from `search` and print it. -->
<p>それでも<code>for</code>ループで<code>search</code>から各行を返し、出力しています。</p>
<!-- Now the entire program should work! Let’s try it out, first with a word that -->
<!-- should return exactly one line from the Emily Dickinson poem, “frog”: -->
<p>さて、プログラム全体が動くはずです！試してみましょう。まずはエミリー・ディキンソンの詩から、
ちょうど1行だけを返すはずの言葉から。&quot;frog&quot;です:</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<!-- Cool! Now let’s try a word that will match multiple lines, like “body”: -->
<p>かっこいい！今度は、複数行にマッチするであろう言葉を試しましょう。&quot;body&quot;とかね:</p>
<pre><code class="language-text">$ cargo run body poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!-- And finally, let’s make sure that we don’t get any lines when we search for a -->
<!-- word that isn’t anywhere in the poem, such as “monomorphization”: -->
<p>そして最後に、詩のどこにも現れない単語を探したときに、何も出力がないことを確かめましょう。
&quot;monomorphization&quot;などね:</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<!-- Excellent! We’ve built our own mini version of a classic tool and learned a lot -->
<!-- about how to structure applications. We’ve also learned a bit about file input -->
<!-- and output, lifetimes, testing, and command line parsing. -->
<p>最高です！古典的なツールの独自のミニバージョンを構築し、アプリケーションを構造化する方法を多く学びました。
また、ファイル入出力、ライフタイム、テスト、コマンドライン引数の解析についても、少し学びました。</p>
<!-- To round out this project, we’ll briefly demonstrate how to work with -->
<!-- environment variables and how to print to standard error, both of which are -->
<!-- useful when you’re writing command line programs. -->
<p>このプロジェクトをまとめ上げるために、環境変数を扱う方法と標準エラー出力に出力する方法を少しだけデモします。
これらはどちらも、コマンドラインプログラムを書く際に有用です。</p>
<!-- ## Working with Environment Variables -->
<a class="header" href="print.html#a環境変数を取り扱う" id="a環境変数を取り扱う"><h2>環境変数を取り扱う</h2></a>
<!-- We’ll improve `minigrep` by adding an extra feature: an option for -->
<!-- case-insensitive searching that the user can turn on via an environment -->
<!-- variable. We could make this feature a command line option and require that -->
<!-- users enter it each time they want it to apply, but instead we’ll use an -->
<!-- environment variable. Doing so allows our users to set the environment variable -->
<!-- once and have all their searches be case insensitive in that terminal session. -->
<p>おまけの機能を追加して<code>minigrep</code>を改善します: 環境変数でユーザがオンにできる大文字小文字無視の検索用のオプションです。
この機能をコマンドラインオプションにして、適用したい度にユーザが入力しなければならないようにすることもできますが、
代わりに環境変数を使用します。そうすることでユーザは1回環境変数をセットすれば、そのターミナルセッションの間は、
大文字小文字無視の検索を行うことができるようになるわけです。</p>
<!-- ### Writing a Failing Test for the Case-Insensitive `search` Function -->
<a class="header" href="print.html#a大文字小文字を区別しないsearch関数用に失敗するテストを書く" id="a大文字小文字を区別しないsearch関数用に失敗するテストを書く"><h3>大文字小文字を区別しない<code>search</code>関数用に失敗するテストを書く</h3></a>
<!-- We want to add a new `search_case_insensitive` function that we’ll call when -->
<!-- the environment variable is on. We’ll continue to follow the TDD process, so -->
<!-- the first step is again to write a failing test. We’ll add a new test for the -->
<!-- new `search_case_insensitive` function and rename our old test from -->
<!-- `one_result` to `case_sensitive` to clarify the differences between the two -->
<!-- tests, as shown in Listing 12-20. -->
<p>環境変数がオンの場合に呼び出す<code>search_case_insensitive</code>関数を新しく追加したいです。テスト駆動開発の過程に従い続けるので、
最初の手順は、今回も失敗するテストを書くことです。新しい<code>search``_case_insensitive</code>関数用の新規テストを追加し、
古いテストを<code>one_result</code>から<code>case_sensitive</code>に名前変更して、二つのテストの差異を明確化します。
リスト12-20に示したようにですね。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 12-20: Adding a new failing test for the -->
<!-- case-insensitive function we’re about to add</span> -->
<p><span class="caption">リスト12-20: 追加しようとしている大文字小文字を区別しない関数用の失敗するテストを新しく追加する</span></p>
<!-- Note that we’ve edited the old test’s `contents` too. We’ve added a new line -->
<!-- with the text `“Duct tape”` using a capital D that shouldn’t match the query -->
<!-- `“duct”` when we’re searching in a case-sensitive manner. Changing the old test -->
<!-- in this way helps ensure that we don’t accidentally break the case-sensitive -->
<!-- search functionality that we’ve already implemented. This test should pass now -->
<!-- and should continue to pass as we work on the case-insensitive search. -->
<p>古いテストの<code>contents</code>も変更していることに注意してください。大文字小文字を区別する検索を行う際に、
<code>&quot;duct&quot;</code>というクエリに合致しないはずの大文字Dを使用した<code>&quot;Duct tape&quot;</code>という新しい行を追加しました。
このように古いテストを変更することで、すでに実装済みの大文字小文字を区別する検索機能を誤って壊してしまわないことを保証する助けになります。
このテストはもう通り、大文字小文字を区別しない検索に取り掛かっても通り続けるはずです。</p>
<!-- The new test for the case-*insensitive* search uses “rUsT” as its query. In the -->
<!-- `search_case_insensitive` function we’re about to add, the query “rUsT” -->
<!-- should match the line containing “Rust:” with a capital R and match the line -->
<!-- `“Trust me.”` even though both have different casing than the query. This is -->
<!-- our failing test, and it will fail to compile because we haven’t yet defined -->
<!-- the `search_case_insensitive` function. Feel free to add a skeleton -->
<!-- implementation that always returns an empty vector, similar to the way we did -->
<!-- for the `search` function in Listing 12-16 to see the test compile and fail. -->
<p>大文字小文字を区別<em>しない</em>検索の新しいテストは、クエリに&quot;rUsT&quot;を使用しています。
追加直前の<code>search_case_insensitive</code>関数では、&quot;rUsT&quot;というクエリは、
両方ともクエリとは大文字小文字が異なるのに、大文字Rの&quot;Rust:&quot;を含む行と、
<code>“Trust me.”</code>という行にもマッチするはずです。これが失敗するテストであり、まだ<code>search_case_insensitive</code>関数を定義していないので、
コンパイルは失敗するでしょう。リスト12-16の<code>search</code>関数で行ったように空のベクタを常に返す実装の骨格を追加して、
ご自由にテストがコンパイルされ、失敗する様を確認してください。</p>
<!-- ### Implementing the `search_case_insensitive` Function -->
<a class="header" href="print.html#search_case_insensitive関数を実装する" id="search_case_insensitive関数を実装する"><h3><code>search_case_insensitive</code>関数を実装する</h3></a>
<!-- The `search_case_insensitive` function, shown in Listing 12-21, will be almost -->
<!-- the same as the `search` function. The only difference is that we’ll lowercase -->
<!-- the `query` and each `line` so whatever the case of the input arguments, -->
<!-- they’ll be the same case when we check whether the line contains the query. -->
<p><code>search_case_insensitive</code>関数は、リスト12-21に示しましたが、<code>search</code>関数とほぼ同じです。
唯一の違いは、<code>query</code>と各<code>line</code>を小文字化していることなので、入力引数の大文字小文字によらず、
行がクエリを含んでいるか確認する際には、同じになるわけです。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 12-21: Defining the `search_case_insensitive` -->
<!-- function to lowercase the query and the line before comparing them</span> -->
<p><span class="caption">リスト12-21: 比較する前にクエリと行を小文字化するよう、<code>search_case_insensitive</code>関数を定義する</span></p>
<!-- First, we lowercase the `query` string and store it in a shadowed variable with -->
<!-- the same name. Calling `to_lowercase` on the query is necessary so no matter -->
<!-- whether the user’s query is `“rust”`, `“RUST”`, `“Rust”`, or `“rUsT”`, we’ll treat the -->
<!-- query as if it was `“rust”` and be insensitive to the case. -->
<p>まず、<code>query</code>文字列を小文字化し、同じ名前の上書きされた変数に保存します。ユーザのクエリが<code>&quot;rust&quot;</code>や<code>&quot;RUST&quot;</code>、
<code>&quot;Rust&quot;</code>、<code>&quot;rUsT&quot;</code>などだったりしても、<code>&quot;rust&quot;</code>であり、大文字小文字を区別しないかのようにクエリを扱えるように、
<code>to_lowercase</code>をクエリに対して呼び出すことは必須です。</p>
<!-- Note that `query` is now a `String` rather than a string slice, because calling -->
<!-- `to_lowercase` creates new data rather than referencing existing data. Say the -->
<!-- query is `“rUsT”`, as an example: that string slice doesn’t contain a lowercase -->
<!-- `u` or `t` for us to use, so we have to allocate a new `String` containing -->
<!-- `“rust”`. When we pass `query` as an argument to the `contains` method now, we -->
<!-- need to add an ampersand because the signature of `contains` is defined to take -->
<!-- a string slice. -->
<p><code>query</code>は最早、文字列スライスではなく<code>String</code>であることに注意してください。というのも、
<code>to_lowercase</code>を呼び出すと、既存のデータを参照するというよりも、新しいデータを作成するからです。
例として、クエリは<code>&quot;rUsT&quot;</code>としましょう: その文字列スライスは、小文字の<code>u</code>や<code>t</code>を使えるように含んでいないので、
<code>&quot;rust&quot;</code>を含む新しい<code>String</code>のメモリを確保しなければならないのです。今、<code>contains</code>メソッドに引数として<code>query</code>を渡すと、
アンド記号を追加する必要があります。<code>contains</code>のシグニチャは、文字列スライスを取るよう定義されているからです。</p>
<!-- 2行目真ん中、to lowercase ...がかかる先が微妙。今の訳の通りなら、beforeの前にtoを記述する気もする -->
<!-- Next, we add a call to `to_lowercase` on each `line` before we check whether it -->
<!-- contains `query` to lowercase all characters. Now that we’ve converted `line` -->
<!-- and `query` to lowercase, we’ll find matches no matter what the case of the -->
<!-- query is. -->
<p>次に、各<code>line</code>が<code>query</code>を含むか確かめる前に<code>to_lowercase</code>の呼び出しを追加し、全文字を小文字化しています。
今や<code>line</code>と<code>query</code>を小文字に変換したので、クエリが大文字であろうと小文字であろうとマッチを検索するでしょう。</p>
<!-- Let’s see if this implementation passes the tests: -->
<p>この実装がテストを通過するか確認しましょう:</p>
<pre><code class="language-text">running 2 tests
test test::case_insensitive ... ok
test test::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- Great! They passed. Now, let’s call the new `search_case_insensitive` function -->
<!-- from the `run` function. First, we’ll add a configuration option to the -->
<!-- `Config` struct to switch between case-sensitive and case-insensitive search. -->
<!-- Adding this field will cause compiler errors because we aren’t initializing -->
<!-- this field anywhere yet: -->
<p>素晴らしい！通りました。では、<code>run</code>関数から新しい<code>search_case_insensitive</code>関数を呼び出しましょう。
1番目に大文字小文字の区別を切り替えられるよう、<code>Config</code>構造体に設定オプションを追加します。
まだどこでも、このフィールドの初期化をしていないので、追加するとコンパイラエラーが起きます:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
#}</code></pre></pre>
<!-- Note that we added the `case_sensitive` field that holds a Boolean. Next, we -->
<!-- need the `run` function to check the `case_sensitive` field’s value and use -->
<!-- that to decide whether to call the `search` function or the -->
<!-- `search_case_insensitive` function, as shown in Listing 12-22. Note this still -->
<!-- won’t compile yet. -->
<p>論理値を持つ<code>case_sensitive</code>フィールドを追加したことに注意してください。次に、<code>run</code>関数に、
<code>case_sensitive</code>フィールドの値を確認し、<code>search</code>関数か<code>search_case_insensitive</code>関数を呼ぶかを決定するのに使ってもらう必要があります。
リスト12-22のようにですね。それでも、これはまだコンパイルできないことに注意してください。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::error::Error;
# use std::fs::File;
# use std::io::prelude::*;
#
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# pub fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 12-22: Calling either `search` or -->
<!-- `search_case_insensitive` based on the value in `config.case_sensitive`</span> -->
<p><span class="caption">リスト12-22: <code>config.case_sensitive</code>の値に基づいて<code>search</code>か<code>search_case_insensitive</code>を呼び出す</span></p>
<!-- Finally, we need to check for the environment variable. The functions for -->
<!-- working with environment variables are in the `env` module in the standard -->
<!-- library, so we want to bring that module into scope with a `use std::env;` line -->
<!-- at the top of *src/lib.rs*. Then we’ll use the `var` function from the `env` -->
<!-- module to check for an environment variable named `CASE_INSENSITIVE`, as shown -->
<!-- in Listing 12-23. -->
<p>最後に、環境変数を確認する必要があります。環境変数を扱う関数は、標準ライブラリの<code>env</code>モジュールにあるので、
<code>use std::env;</code>行で<em>src/lib.rs</em>の冒頭でそのモジュールをスコープに持ってくる必要があります。そして、
<code>env</code>モジュールから<code>var</code>関数を使用して<code>CASE_INSENSITIVE</code>という環境変数のチェックを行います。
リスト12-23のようにですね。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env;
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }

// --snip--

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 12-23: Checking for an environment variable named -->
<!-- `CASE_INSENSITIVE`</span> -->
<p><span class="caption">リスト12-23: <code>CASE_INSENSITIVE</code>という環境変数のチェックを行う</span></p>
<!-- Here, we create a new variable `case_sensitive`. To set its value, we call the -->
<!-- `env::var` function and pass it the name of the `CASE_INSENSITIVE` environment -->
<!-- variable. The `env::var` function returns a `Result` that will be the successful -->
<!-- `Ok` variant that contains the value of the environment variable if the -->
<!-- environment variable is set. It will return the `Err` variant if the -->
<!-- environment variable is not set. -->
<p>ここで、<code>case_sensitive</code>という新しい変数を生成しています。その値をセットするために、
<code>env::var</code>関数を呼び出し、<code>CASE_INSENSITIVE</code>環境変数の名前を渡しています。<code>env::var</code>関数は、
環境変数がセットされていたら、環境変数の値を含む<code>Ok</code>バリアントの成功値になる<code>Result</code>を返します。
環境変数がセットされていなければ、<code>Err</code>バリアントを返すでしょう。</p>
<!-- We’re using the `is_err` method on the `Result` to check whether it’s an error -->
<!-- and therefore unset, which means it *should* do a case-sensitive search. If the -->
<!-- `CASE_INSENSITIVE` environment variable is set to anything, `is_err` will -->
<!-- return false and the program will perform a case-insensitive search. We don’t -->
<!-- care about the *value* of the environment variable, just whether it’s set or -->
<!-- unset, so we’re checking `is_err` rather than `unwrap`, `expect`, or any -->
<!-- of the other methods we’ve seen on `Result`. -->
<p><code>Result</code>の<code>is_err</code>メソッドを使用して、エラーでありゆえに、セットされていないことを確認しています。
これは大文字小文字を区別する検索をす<em>べき</em>ことを意味します。<code>CASE_INSENSITIVE</code>環境変数が何かにセットされていれば、
<code>is_err</code>はfalseを返し、プログラムは大文字小文字を区別しない検索を実行するでしょう。環境変数の値はどうでもよく、
セットされているかどうかだけ気にするので、<code>unwrap</code>や<code>expect</code>あるいは、他のここまで見かけた<code>Result</code>のメソッドではなく、
<code>is_err</code>をチェックしています。</p>
<!-- We pass the value in the `case_sensitive` variable to the `Config` instance so -->
<!-- the `run` function can read that value and decide whether to call `search` or -->
<!-- `search_case_insensitive`, as we implemented in Listing 12-22. -->
<p><code>case_sensitive</code>変数の値を<code>Config</code>インスタンスに渡しているので、リスト12-22で実装したように、
<code>run</code>関数はその値を読み取り、<code>search</code>か<code>search_case_insensitive</code>を呼び出すか決定できるのです。</p>
<!-- Let’s give it a try! First, we’ll run our program without the environment -->
<!-- variable set and with the query `to`, which should match any line that contains -->
<!-- the word “to” in all lowercase: -->
<p>試行してみましょう！まず、環境変数をセットせずにクエリは、<code>to</code>でプログラムを実行し、
この時は全て小文字で&quot;to&quot;という言葉を含むあらゆる行が合致するはずです。</p>
<pre><code class="language-text">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!-- Looks like that still works! Now, let’s run the program with `CASE_INSENSITIVE` -->
<!-- set to `1` but with the same query `to`. -->
<p>まだ機能しているようです！では、<code>CASE_INSENSITIVE</code>を1にしつつ、同じクエリの<code>to</code>でプログラムを実行しましょう。</p>
<!-- If you’re using PowerShell, you will need to set the environment variable and -->
<!-- run the program in two commands rather than one: -->
<p>PowerShellを使用しているなら、1コマンドではなく、2コマンドで環境変数をセットし、プログラムを実行する必要があるでしょう:</p>
<pre><code class="language-text">$ $env:CASE_INSENSITIVE=1
$ cargo run to poem.txt
</code></pre>
<!-- We should get lines that contain “to” that might have uppercase letters: -->
<p>大文字も含む可能性のある&quot;to&quot;を含有する行が得られるはずです:</p>
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<!-- Excellent, we also got lines containing “To”! Our `minigrep` program can now do -->
<!-- case-insensitive searching controlled by an environment variable. Now you know -->
<!-- how to manage options set using either command line arguments or environment -->
<!-- variables. -->
<p>素晴らしい、&quot;To&quot;を含む行も出てきましたね！<code>minigrep</code>プログラムはこれで、
環境変数によって制御できる大文字小文字を区別しない検索も行えるようになりました。もうコマンドライン引数か、
環境変数を使ってオプションを管理する方法も知りましたね。</p>
<!-- Some programs allow arguments *and* environment variables for the same -->
<!-- configuration. In those cases, the programs decide that one or the other takes -->
<!-- precedence. For another exercise on your own, try controlling case -->
<!-- insensitivity through either a command line argument or an environment -->
<!-- variable. Decide whether the command line argument or the environment variable -->
<!-- should take precedence if the program is run with one set to case sensitive and -->
<!-- one set to case insensitive. -->
<p>引数<em>と</em>環境変数で同じ設定を行うことができるプログラムもあります。そのような場合、
プログラムはどちらが優先されるか決定します。自身の別の練習として、コマンドライン引数か、
環境変数で大文字小文字の区別を制御できるようにしてみてください。
片方は大文字小文字を区別するようにセットされ、もう片方は区別しないようにセットしてプログラムが実行された時に、
コマンドライン引数と環境変数のどちらの優先度が高くなるかを決めてください。</p>
<!-- The `std::env` module contains many more useful features for dealing with -->
<!-- environment variables: check out its documentation to see what is available. -->
<p><code>std::env</code>モジュールは、環境変数を扱うもっと多くの有用な機能を有しています:
ドキュメントを確認して、何が利用可能か確かめてください。</p>
<!-- ## Writing Error Messages to Standard Error Instead of Standard Output -->
<a class="header" href="print.html#a標準出力ではなく標準エラーにエラーメッセージを書き込む" id="a標準出力ではなく標準エラーにエラーメッセージを書き込む"><h2>標準出力ではなく標準エラーにエラーメッセージを書き込む</h2></a>
<!-- At the moment we’re writing all of our output to the terminal using the -->
<!-- `println!` function. Most terminals provide two kinds of output: *standard -->
<!-- output* (`stdout`) for general information and *standard error* (`stderr`) -->
<!-- for error messages. This distinction enables users to choose to direct the -->
<!-- successful output of a program to a file but still print error messages to the -->
<!-- screen. -->
<p>現時点では、すべての出力を<code>println!</code>関数を使用してターミナルに書き込んでいます。多くのターミナルは、
2種類の出力を提供します: 普通の情報用の<em>標準出力</em>(<code>stdout</code>)とエラーメッセージ用の<em>標準エラー出力</em>(<code>stderr</code>)です。
この差異のおかげで、ユーザは、エラーメッセージを画面に表示しつつ、
プログラムの成功した出力をファイルにリダイレクトすることを選択できます。</p>
<!-- The `println!` function is only capable of printing to standard output, so we -->
<!-- have to use something else to print to standard error. -->
<p><code>println!</code>関数は、標準出力に出力する能力しかないので、標準エラーに出力するには他のものを使用しなければなりません。</p>
<!-- ### Checking Where Errors Are Written to -->
<a class="header" href="print.html#aエラーが書き込まれる場所を確認する" id="aエラーが書き込まれる場所を確認する"><h3>エラーが書き込まれる場所を確認する</h3></a>
<!-- First, let’s observe how the content printed by `minigrep` is currently being -->
<!-- written to standard output, including any error messages we want to write to -->
<!-- standard error instead. We’ll do that by redirecting the standard output stream -->
<!-- to a file while also intentionally causing an error. We won’t redirect the -->
<!-- standard error stream, so any content sent to standard error will continue to -->
<!-- display on the screen. -->
<p>まず、<code>minigrep</code>に出力される中身が、代わりに標準エラーに書き込みたいいかなるエラーメッセージも含め、
どのように標準出力に書き込まれているかを観察しましょう。意図的にエラーを起こしつつ、
ファイルに標準出力ストリームをリダイレクトすることでそうします。標準エラーストリームはリダイレクトしないので、
標準エラーに送られる内容は、すべて画面に表示され続けます。</p>
<!-- Command line programs are expected to send error messages to the standard error -->
<!-- stream so we can still see error messages on the screen even if we redirect the -->
<!-- standard output stream to a file. Our program is not currently well-behaved: -->
<!-- we’re about to see that it saves the error message output to a file instead! -->
<p>コマンドラインプログラムは、エラーメッセージを標準出力に送信していると期待されているので、
標準出力ストリームをファイルにリダイレクトしても、画面にエラーメッセージが見られます。
我々のプログラムは、現状、いい振る舞いをしていません: 代わりにファイルにエラーメッセージ出力を保存するところを、
目撃するところです！</p>
<!-- The way to demonstrate this behavior is by running the program with `>` and the -->
<!-- filename, *output.txt*, that we want to redirect the standard output stream to. -->
<!-- We won’t pass any arguments, which should cause an error: -->
<p>この動作をデモする方法は、<code>&gt;</code>と標準出力ストリームをリダイレクトする先のファイル名、<em>output.txt</em>でプログラムを走らせることによります。
引数は何も渡しませんが、そうするとエラーが起きるはずです:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<!-- The `>` syntax tells the shell to write the contents of standard output to -->
<!-- *output.txt* instead of the screen. We didn’t see the error message we were -->
<!-- expecting printed to the screen, so that means it must have ended up in the -->
<!-- file. This is what *output.txt* contains: -->
<p><code>&gt;</code>記法により、標準出力の中身を画面の代わりに<em>output.txt</em>に書き込むようシェルは指示されます。
画面に出力されると期待していたエラーメッセージは見られないので、ファイルに入っているということでしょう。
以下が<em>output.txt</em>が含んでいる内容です:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<!-- Yup, our error message is being printed to standard output. It’s much more -->
<!-- useful for error messages like this to be printed to standard error so only -->
<!-- data from a successful run ends up in the file. We'll change that. -->
<p>そうです。エラーメッセージは標準出力に出力されているのです。このようなエラーメッセージは標準エラーに出力され、
成功した状態のデータのみがファイルに残ると遥かに有用です。それを変更します。</p>
<!-- ### Printing Errors to Standard Error -->
<a class="header" href="print.html#aエラーを標準エラーに出力する" id="aエラーを標準エラーに出力する"><h3>エラーを標準エラーに出力する</h3></a>
<!-- We’ll use the code in Listing 12-24 to change how error messages are printed. -->
<!-- Because of the refactoring we did earlier in this chapter, all the code that -->
<!-- prints error messages is in one function, `main`. The standard library provides -->
<!-- the `eprintln!` macro that prints to the standard error stream, so let’s change -->
<!-- the two places we were calling `println!` to print errors to use `eprintln!` -->
<!-- instead. -->
<p>リスト12-24のコードを使用して、エラーメッセージの出力の仕方を変更します。この章の前で行ったリファクタリングのため、
エラーメッセージを出力するコードはすべて1関数、<code>main</code>にあります。標準ライブラリは、
標準エラーストリームに出力する<code>eprintln!</code>マクロを提供しているので、
<code>println!</code>を呼び出してエラーを出力していた2箇所を代わりに<code>eprintln!</code>を使うように変更しましょう。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<!-- <span class="caption">Listing 12-24: Writing error messages to standard error -->
<!-- instead of standard output using `eprintln!`</span> -->
<p><span class="caption">リスト12-24: <code>eprintln!</code>を使って標準出力ではなく、標準エラーにエラーメッセージを書き込む</span></p>
<!-- After changing `println!` to `eprintln!`, let’s run the program again in the -->
<!-- same way, without any arguments and redirecting standard output with `>`: -->
<p><code>println!</code>を<code>eprintln!</code>に変えてから、再度同じようにプログラムを実行しましょう。
引数なしかつ、標準出力を<code>&gt;</code>でリダイレクトしてね:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<!-- Now we see the error onscreen and *output.txt* contains nothing, which is the -->
<!-- behavior we expect of command line programs. -->
<p>これで、エラーは画面に見えつつ、<em>output.txt</em>は何も含まなくなり、これはコマンドラインプログラムに期待する動作です。</p>
<!-- Let’s run the program again with arguments that don’t cause an error but still -->
<!-- redirect standard output to a file, like so: -->
<p>再度、エラーは起こさずに標準出力をファイルにリダイレクトする引数でプログラムを走らせましょう。以下のようにですね:</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<!-- We won’t see any output to the terminal, and *output.txt* will contain our -->
<!-- results: -->
<p>ターミナルには出力は見られず、<em>output.txt</em>に結果が含まれます:</p>
<!-- <span class="filename">Filename: output.txt</span> -->
<p><span class="filename">ファイル名: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!-- This demonstrates that we’re now using standard output for successful output -->
<!-- and standard error for error output as appropriate. -->
<p>これは、今や成功した出力には標準出力を、エラー出力には標準エラーを適切に使用していることをデモしています。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-10" id="aまとめ-10"><h2>まとめ</h2></a>
<!-- This chapter recapped some of the major concepts you’ve learned so far and -->
<!-- covered how to perform common I/O operations in Rust. By using command line -->
<!-- arguments, files, environment variables, and the `eprintln!` macro for printing -->
<!-- errors, you’re now prepared to write command line applications. By using the -->
<!-- concepts in previous chapters, your code will be well organized, store data -->
<!-- effectively in the appropriate data structures, handle errors nicely, and be -->
<!-- be well tested. -->
<p>この章では、ここまでに学んできた主要な概念の一部を想起させ、Rustで入出力処理を行う方法を講義しました。
コマンドライン引数、ファイル、環境変数、そしてエラー出力に<code>eprintln!</code>マクロを使用することで、
もう、コマンドラインアプリケーションを書く準備ができています。以前の章の概念を使用することで、
コードはうまく体系化され、適切なデータ構造に効率的にデータを保存し、エラーをうまく扱い、
よくテストされるでしょう。</p>
<!-- Next, we’ll explore some Rust features that were influenced by functional -->
<!-- languages: closures and iterators. -->
<p>次は、関数型言語に影響されたRust機能を一部探求します: クロージャとイテレータです。</p>
<!-- # Functional Language Features: Iterators and Closures -->
<a class="header" href="print.html#a関数型言語の機能-イテレータとクロージャ" id="a関数型言語の機能-イテレータとクロージャ"><h1>関数型言語の機能: イテレータとクロージャ</h1></a>
<!-- Rust’s design has taken inspiration from many existing languages and -->
<!-- techniques, and one significant influence is *functional programming*. -->
<!-- Programming in a functional style often includes using functions as values by -->
<!-- passing them in arguments, returning them from other functions, assigning them -->
<!-- to variables for later execution, and so forth.  -->
<p>Rustの設計は、多くの既存の言語やテクニックにインスピレーションを得ていて、
その一つの大きな影響が<em>関数型プログラミング</em>です。関数型でのプログラミングには、しばしば、
引数で渡すことで関数を値として使用したり、関数から関数を返したり、関数を後ほど使用するために変数に代入することなどが含まれます。</p>
<!-- In this chapter, we won’t debate the issue of what functional programming is or -->
<!-- isn’t but will instead discuss some features of Rust that are similar to -->
<!-- features in many languages often referred to as functional. -->
<p>この章では、関数型プログラミングがどんなものであったり、なかったりするかという問題については議論しませんが、
代わりに関数型とよく言及される多くの言語の機能に似たRustの機能の一部について議論しましょう。</p>
<!-- More specifically, we’ll cover: -->
<p>具体的には、以下を講義します:</p>
<!-- * *Closures*, a function-like construct you can store in a variable -->
<!-- * *Iterators*, a way of processing a series of elements -->
<!-- * How to use these two features to improve the I/O project in Chapter 12 -->
<!-- * The performance of these two features (Spoiler alert: they’re faster than you -->
<!--   might think!) -->
<ul>
<li><em>クロージャ</em>、変数に保存できる関数に似た文法要素</li>
<li><em>イテレータ</em>、一連の要素を処理する方法</li>
<li>これら2つの機能を使用して第12章の入出力プロジェクトを改善する方法</li>
<li>これら2つの機能のパフォーマンス(ネタバレ: 思ったよりも速いです)</li>
</ul>
<!-- Other Rust features, such as pattern matching and enums, which we've covered in -->
<!-- other chapters, are influenced by the functional style as well. Mastering -->
<!-- closures and iterators is an important part of writing idiomatic, fast Rust -->
<!-- code, so we’ll devote this entire chapter to them. -->
<p>パターンマッチングやenumなど、他のRustの機能も関数型に影響されていますが、他の章で講義します。
クロージャとイテレータをマスターすることは、慣用的で速いRustコードを書く重要な部分なので、
この章を丸ごと捧げます。</p>
<!-- ## Closures: Anonymous Functions that Can Capture Their Environment -->
<a class="header" href="print.html#aクロージャ-環境をキャプチャできる匿名関数" id="aクロージャ-環境をキャプチャできる匿名関数"><h2>クロージャ: 環境をキャプチャできる匿名関数</h2></a>
<!-- Rust’s closures are anonymous functions you can save in a variable or pass as -->
<!-- arguments to other functions. You can create the closure in one place and then -->
<!-- call the closure to evaluate it in a different context. Unlike functions, -->
<!-- closures can capture values from the scope in which they’re called. We’ll -->
<!-- demonstrate how these closure features allow for code reuse and behavior -->
<!-- customization. -->
<p>Rustの<em>クロージャ</em>は、変数に保存したり、引数として他の関数に渡すことのできる匿名関数です。
ある場所でクロージャを生成し、それから別の文脈でクロージャを呼び出して評価することができます。
関数と異なり、呼び出されたスコープの値をクロージャは、キャプチャすることができます。
これらのクロージャの機能がコードの再利用や、動作のカスタマイズを行わせてくれる方法を模擬しましょう。</p>
<!-- ### Creating an Abstraction of Behavior with Closures -->
<a class="header" href="print.html#aクロージャで動作の抽象化を行う" id="aクロージャで動作の抽象化を行う"><h3>クロージャで動作の抽象化を行う</h3></a>
<!-- Let’s work on an example of a situation in which it’s useful to store a closure -->
<!-- to be executed later. Along the way, we’ll talk about the syntax of closures, -->
<!-- type inference, and traits. -->
<p>クロージャを保存して後々使用できるようにするのが有効な場面の例に取り掛かりましょう。その過程で、
クロージャの記法、型推論、トレイトについて語ります。</p>
<!-- Consider this hypothetical situation: we work at a startup that’s making an app -->
<!-- to generate custom exercise workout plans. The backend is written in Rust, and -->
<!-- the algorithm that generates the workout plan takes into account many factors, -->
<!-- such as the app user’s age, body mass index, exercise preferences, recent -->
<!-- workouts, and an intensity number they specify. The actual algorithm used isn’t -->
<!-- important in this example; what’s important is that this calculation takes a -->
<!-- few seconds. We want to call this algorithm only when we need to and only call -->
<!-- it once so we don’t make the user wait more than necessary. -->
<p>以下のような架空の場面を考えてください: カスタマイズされたエクササイズのトレーニングプランを生成するアプリを作る立ち上げにかかることになりました。
バックエンドはRustで記述され、トレーニングプランを生成するアルゴリズムは、アプリユーザの年齢や、
BMI、運動の好み、最近のトレーニング、指定された強弱値などの多くの要因を考慮します。
実際に使用されるアルゴリズムは、この例では重要ではありません; 重要なのは、この計算が数秒要することです。
必要なときだけこのアルゴリズムを呼び出し、1回だけ呼び出したいので、必要以上にユーザを待たせないことになります。</p>
<!-- We’ll simulate calling this hypothetical algorithm with the -->
<!-- `simulated_expensive_calculation` shown in Listing 13-1, which will print -->
<!-- `calculating slowly...`, wait for two seconds, and then return whatever number -->
<!-- we passed in. -->
<p>リスト13-1に示した<code>simulated_expensive_calculation</code>関数でこの仮定のアルゴリズムを呼び出すことをシミュレートし、
この関数は<code>calculating slowly</code>と出力し、2秒待ってから、渡した数値をなんでも返します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    // ゆっくり計算します
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-1: A function to stand in for a hypothetical -->
<!-- calculation that takes about 2 seconds to run</span> -->
<p><span class="caption">リスト13-1: 実行に約2秒かかる架空の計算の代役を務める関数</span></p>
<!-- Next is the `main` function that contains the parts of the workout app -->
<!-- important for this example. This function represents the code that the app will -->
<!-- call when a user asks for a workout plan. Because the interaction with the -->
<!-- app’s frontend isn’t relevant to the use of closures, we’ll hardcode values -->
<!-- representing inputs to our program and print the outputs. -->
<p>次は、この例で重要なトレーニングアプリの部分を含む<code>main</code>関数です。この関数は、
ユーザがトレーニングプランを要求した時にアプリが呼び出すコードを表します。
アプリのフロントエンドと相互作用する部分は、クロージャの使用と関係ないので、プログラムへの入力を表す値をハードコードし、
その出力を出力します。</p>
<!-- The required inputs are these: -->
<p>必要な入力は以下の通りです:</p>
<!-- * An intensity number from the user, which is specified when they request -->
<!--   a workout to indicate whether they want a low-intensity workout or a -->
<!--   high-intensity workout. -->
<!-- * A random number that will generate some variety in the workout plans. -->
<ul>
<li>ユーザの強弱値、これはユーザがトレーニングを要求して、低強度のトレーニングか、
高強度のトレーニングがしたいかを示したときに指定されます。</li>
<li>乱数、これはトレーニングプランにバリエーションを起こします。</li>
</ul>
<!-- The output will be the recommended workout plan. Listing 13-2 shows the `main` -->
<!-- function we’ll use. -->
<p>出力は、推奨されるトレーニングプランになります。リスト13-2は使用する<code>main</code>関数を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(
        simulated_user_specified_value,
        simulated_random_number
    );
}
# fn generate_workout(intensity: u32, random_number: u32) {}
</code></pre></pre>
<!-- <span class="caption">Listing 13-2: A `main` function with hardcoded values to -->
<!-- simulate user input and random number generation</span> -->
<p><span class="caption">リスト13-2: ユーザ入力や乱数生成をシミュレートするハードコードされた値がある<code>main</code>関数</span></p>
<!-- We’ve hardcoded the variable `simulated_user_specified_value` as 10 and the -->
<!-- variable `simulated_random_number` as 7 for simplicity’s sake; in an actual -->
<!-- program, we’d get the intensity number from the app frontend, and we’d use the -->
<!-- `rand` crate to generate a random number, as we did in the Guessing Game -->
<!-- example in Chapter 2. The `main` function calls a `generate_workout` function -->
<!-- with the simulated input values. -->
<p>簡潔性のために、変数<code>simulated_user_specified_value</code>は10と、変数<code>simulated_random_number</code>は7とハードコードしました;
実際のプログラムにおいては、強弱値はアプリのフロントエンドから取得し、乱数の生成には、<code>rand</code>クレートを使用します。
第2章の数当てゲームの例みたいにですね。<code>main</code>関数は、シミュレートされた入力値とともに<code>generate_workout</code>関数を呼び出します。</p>
<!-- Now that we have the context, let’s get to the algorithm. The -->
<!-- `generate_workout` function in Listing 13-3 contains the business logic of the -->
<!-- app that we’re most concerned with in this example. The rest of the code -->
<!-- changes in this example will be made to this function. -->
<p>今や文脈ができたので、アルゴリズムに取り掛かりましょう。リスト13-3の<code>generate_workout</code>関数は、
この例で最も気にかかるアプリのビジネスロジックを含んでいます。この例での残りの変更は、
この関数に対して行われるでしょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: u32) -&gt; u32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        // 今日は{}回腕立て伏せをしてください！
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        // 次に、{}回腹筋をしてください！
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            // 今日は休憩してください！水分補給を忘れずに！
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            // 今日は、{}分間走ってください！
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-3: The business logic that prints the workout -->
<!-- plans based on the inputs and calls to the `simulated_expensive_calculation` -->
<!-- function</span> -->
<p><span class="caption">リスト13-3: 入力に基づいてトレーニングプランを出力するビジネスロジックと、
<code>simulated_expensive_calculation</code>関数の呼び出し</span></p>
<!-- The code in Listing 13-3 has multiple calls to the slow calculation function. -->
<!-- The first `if` block calls `simulated_expensive_calculation` twice, the `if` -->
<!-- inside the outer `else` doesn’t call it at all, and the code inside the -->
<!-- second `else` case calls it once. -->
<p>リスト13-3のコードには、遅い計算を行う関数への呼び出しが複数あります。最初の<code>if</code>ブロックが、
<code>simulated_expensive_calculation</code>を2回呼び出し、外側の<code>else</code>内の<code>if</code>は全く呼び出さず、
2番目の<code>else</code>ケースの内側にあるコードは1回呼び出しています。</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<!-- The desired behavior of the `generate_workout` function is to first check -->
<!-- whether the user wants a low-intensity workout (indicated by a number less -->
<!-- than 25) or a high-intensity workout (a number of 25 or greater). -->
<p><code>generate_workout</code>関数の期待される振る舞いは、まずユーザが低強度のトレーニング(25より小さい数値で表される)か、
高強度のトレーニング(25以上の数値)を欲しているか確認することです。</p>
<!-- Low-intensity workout plans will recommend a number of push-ups and sit-ups -->
<!-- based on the complex algorithm we’re simulating. -->
<p>低強度のトレーニングプランは、シミュレーションしようとしている複雑なアルゴリズムに基づいて、
多くの腕立て伏せや腹筋運動を推奨してきます。</p>
<!-- If the user wants a high-intensity workout, there’s some additional logic: if -->
<!-- the value of the random number generated by the app happens to be 3, the app -->
<!-- will recommend a break and hydration. If not, the user will get a number of -->
<!-- minutes of running based on the complex algorithm. -->
<p>ユーザが高強度のトレーニングを欲していれば、追加のロジックがあります: アプリが生成した乱数がたまたま3なら、
アプリは休憩と水分補給を勧めます。そうでなければ、ユーザは複雑なアルゴリズムに基づいて数分間のランニングをします。</p>
<!-- This code works the way the business wants it to now, but let's say the data -->
<!-- science team decides that we need to make some changes to the way we call the -->
<!-- `simulated_expensive_calculation` function in the future. To simplify the -->
<!-- the update when those changes happen, we want to refactor this code so it calls the -->
<!-- `simulated_expensive_calculation` function only once. We also want to cut the -->
<!-- place where we’re currently unnecessarily calling the function twice without -->
<!-- adding any other calls to that function in the process. That is, we don’t want -->
<!-- to call it if the result isn’t needed, and we still want to call it only once. -->
<p>このコードは、ビジネスのほしいままに動くでしょうが、データサイエンスチームが、
<code>simulated_expensive_calculation</code>関数を呼び出す方法に何らかの変更を加える必要があると決定したとしましょう。
そのような変更が起きた時に更新を簡略化するため、<code>simulated_expensive_calculation</code>関数を1回だけ呼び出すように、
このコードをリファクタリングしたいです。また、過程でその関数への呼び出しを増やすことなく無駄に2回、
この関数を現時点で呼んでいるところを切り捨てたくもあります。要するに、結果が必要なければ関数を呼び出したくなく、
それでも1回だけ呼び出したいのです。</p>
<!-- #### Refactoring Using Functions -->
<a class="header" href="print.html#a関数でリファクタリング" id="a関数でリファクタリング"><h4>関数でリファクタリング</h4></a>
<!-- We could restructure the workout program in many ways. First, we’ll try -->
<!-- extracting the duplicated call to the `expensive_expensive_calculation` -->
<!-- function into a variable, as shown in Listing 13-4. -->
<p>多くの方法でトレーニングプログラムを再構築することもできます。
1番目に<code>expensive_expensive_calculation</code>関数への重複した呼び出しを変数に抽出しようとしましょう。リスト13-4に示したように。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: u32) -&gt; u32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            );
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-4: Extracting the calls to -->
<!-- `simulated_expensive_calculation` to one place and storing the result in the -->
<!-- `expensive_result` variable</span> -->
<p><span class="caption">リスト13-4: 複数の<code>simulated_expensive_calculation</code>の呼び出しを1箇所に抽出し、
結果を<code>expensive_result</code>変数に保存する</span></p>
<!-- This change unifies all the calls to `simulated_expensive_calculation` and -->
<!-- solves the problem of the first `if` block unnecessarily calling the function -->
<!-- twice. Unfortunately, we’re now calling this function and waiting for the -->
<!-- result in all cases, which includes the inner `if` block that doesn’t use the -->
<!-- result value at all. -->
<p>この変更により<code>simulated_expensive_calculation</code>の呼び出しが単一化され、
最初の<code>if</code>ブロックが無駄に関数を2回呼んでいた問題を解消します。不幸なことに、これでは、
あらゆる場合にこの関数を呼び出し、その結果を待つことになり、結果値を全く使用しない内側の<code>if</code>ブロックでもそうしてしまいます。</p>
<!-- We want to define code in one place in our program, but only *execute* that -->
<!-- code where we actually need the result. This is a use case for closures! -->
<p>プログラムの1箇所でコードを定義したいですが、結果が本当に必要なところでだけコードを<em>実行</em>します。
これは、クロージャのユースケースです！</p>
<!-- #### Refactoring with Closures to Store Code -->
<a class="header" href="print.html#aクロージャでリファクタリングしてコードを保存する" id="aクロージャでリファクタリングしてコードを保存する"><h4>クロージャでリファクタリングして、コードを保存する</h4></a>
<!-- Instead of always calling the `simulated_expensive_calculation` function before -->
<!-- the `if` blocks, we can define a closure and store the *closure* in a variable -->
<!-- rather than storing the result of the function call, as shown in Listing 13-5. -->
<!-- We can actually move the whole body of `simulated_expensive_calculation` within -->
<!-- the closure we’re introducing here. -->
<p><code>if</code>ブロックの前にいつも<code>simulated_expensive_calculation</code>関数を呼び出す代わりに、
クロージャを定義し、関数呼び出しの結果を保存するのではなく、その<em>クロージャ</em>を変数に保存できます。リスト13-5のようにですね。
<code>simulated_expensive_calculation</code>の本体全体を実際に、ここで導入しているクロージャ内に移すことができます。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
# expensive_closure(5);
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-5: Defining a closure and storing it in the -->
<!-- `expensive_closure` variable</span> -->
<p><span class="caption">リスト13-5: クロージャを定義し、<code>expensive_closure</code>変数に保存する</span></p>
<!-- The closure definition comes after the `=` to assign it to the variable -->
<!-- `expensive_closure`. To define a closure, we start with a pair of vertical -->
<!-- pipes (`|`), inside which we specify the parameters to the closure; this syntax -->
<!-- was chosen because of its similarity to closure definitions in Smalltalk and -->
<!-- Ruby. This closure has one parameter named `num`: if we had more than one -->
<!-- parameter, we would separate them with commas, like `|param1, param2|`. -->
<p>クロージャ定義が<code>=</code>に続き、変数<code>expensive_closure</code>に代入しています。クロージャを定義するには、
1組の縦棒から始め、その内部にクロージャの仮引数を指定します; この記法は、SmalltalkやRubyのクロージャ定義と類似していることから、
選択されました。このクロージャには、<code>num</code>という引数が1つあります: 2つ以上引数があるなら、
<code>|param1, param2|</code>のように、カンマで区切ります。</p>
<!-- After the parameters, we place curly brackets that hold the body of the -->
<!-- closure—these are optional if the closure body is a single expression. The end -->
<!-- of the closure, after the curly brackets, needs a semicolon to complete the -->
<!-- `let` statement. The value returned from the last line in the closure body -->
<!-- (`num`) will be the value returned from the closure when it’s called, because -->
<!-- that line doesn’t end in a semicolon; just as in function bodies. -->
<p>引数の後に、クロージャの本体を保持する波括弧を配置します(これはクロージャ本体が式一つなら省略可能です)。
波括弧の後、クロージャのお尻には、セミコロンが必要で、<code>let</code>文を完成させます。クロージャ本体の最後の行から返る値(<code>num</code>)が、
呼び出された時にクロージャから返る値になります。その行がセミコロンで終わっていないからです;
関数の本体みたいですね。</p>
<!-- Note that this `let` statement means `expensive_closure` contains the -->
<!-- *definition* of an anonymous function, not the *resulting value* of calling the -->
<!-- anonymous function. Recall that we’re using a closure because we want to define -->
<!-- the code to call at one point, store that code, and call it at a later point; -->
<!-- the code we want to call is now stored in `expensive_closure`. -->
<p>この<code>let</code>文は、<code>expensive_closure</code>が、匿名関数を呼び出した<em>結果の値</em>ではなく、
匿名関数の<em>定義</em>を含むことを意味することに注意してください。コードを定義して、
1箇所で呼び出し、そのコードを保存し、後々、それを呼び出したいためにクロージャを使用していることを思い出してください;
呼び出したいコードは、現在、<code>expensive_closure</code>に保存されています。</p>
<!-- この冒頭のwithも順接の理由にしている。やはり強すぎるか？ -->
<!-- With the closure defined, we can change the code in the `if` blocks to call the -->
<!-- closure to execute the code and get the resulting value. We call a closure like -->
<!-- we do a function: we specify the variable name that holds the closure -->
<!-- definition and follow it with parentheses containing the argument values we -->
<!-- want to use, as shown in Listing 13-6. -->
<p>クロージャが定義されたので、<code>if</code>ブロックのコードを変更して、そのコードを実行するクロージャを呼び出し、結果値を得ることができます。
クロージャは、関数のように呼び出せます: クロージャ定義を含む変数名を指定し、使用したい引数値を含むかっこを続けます。
リスト13-6に示したようにですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-6: Calling the `expensive_closure` we’ve -->
<!-- defined</span> -->
<p><span class="caption">リスト13-6: 定義した<code>expensive_closure</code>を呼び出す</span></p>
<!-- 2行目最後は、今の通りにもwhereがcodeにかかるようにも取れるが、どちらが最適か考慮し直す必要があるか -->
<!-- Now the expensive calculation is called in only one place, and we’re only -->
<!-- executing that code where we need the results. -->
<p>今では、重い計算はたった1箇所でのみ呼び出され、結果が必要なところでそのコードを実行するだけになりました。</p>
<!-- However, we’ve reintroduced one of the problems from Listing 13-3: we’re still -->
<!-- calling the closure twice in the first `if` block, which will call the -->
<!-- expensive code twice and make the user wait twice as long as they need to. We -->
<!-- could fix this problem by creating a variable local to that `if` block to hold -->
<!-- the result of calling the closure, but closures provide us with another -->
<!-- solution. We’ll talk about that solution in a bit. But first let’s talk about -->
<!-- why there aren’t type annotations in the closure definition and the traits -->
<!-- involved with closures. -->
<p>ところが、リスト13-3の問題の一つを再浮上させてしまいました: それでも、最初の<code>if</code>ブロックでクロージャを2回呼んでいて、
そうすると、重いコードを2回呼び出し、必要な分の2倍ユーザを待たせてしまいます。その<code>if</code>ブロックのみに属する変数を生成して、
クロージャの呼び出し結果を保持するその<code>if</code>ブロックに固有の変数を生成することでこの問題を解消することもできますが、
クロージャは他の解決法も用意してくれます。
その解決策については、もう少し先で語りましょう。でもまずは、
クロージャ定義に型注釈がない理由とクロージャに関わるトレイトについて話しましょう。</p>
<!-- ### Closure Type Inference and Annotation -->
<a class="header" href="print.html#aクロージャの型推論と注釈" id="aクロージャの型推論と注釈"><h3>クロージャの型推論と注釈</h3></a>
<!-- Closures don’t require you to annotate the types of the parameters or the -->
<!-- return value like `fn` functions do. Type annotations are required on functions -->
<!-- because they’re part of an explicit interface exposed to your users. Defining -->
<!-- this interface rigidly is important for ensuring that everyone agrees on what -->
<!-- types of values a function uses and returns. But closures aren’t used in an -->
<!-- exposed interface like this: they’re stored in variables and used without -->
<!-- naming them and exposing them to users of our library. -->
<p>クロージャでは、<code>fn</code>関数のように引数の型や戻り値の型を注釈する必要はありません。関数では、
型注釈は必要です。ユーザに露出する明示的なインターフェイスの一部だからです。このインターフェイスを堅実に定義することは、
関数が使用したり、返したりする値の型についてみんなが合意していることを保証するために重要なのです。
しかし、クロージャはこのような露出するインターフェイスには使用されません: 変数に保存され、
名前付けしたり、ライブラリの使用者に晒されることなく、使用されます。</p>
<!-- Closures are usually short and relevant only within a narrow context rather -->
<!-- than in any arbitrary scenario. Within these limited contexts, the compiler is -->
<!-- reliably able to infer the types of the parameters and the return type, similar -->
<!-- to how it’s able to infer the types of most variables. -->
<p>クロージャは通常短く、あらゆる任意のシナリオではなく、狭い文脈でのみ関係します。
このような限定された文脈内では、コンパイラは、多くの変数の型を推論できるのに似て、
引数や戻り値の型を頼もしく推論することができます。</p>
<!-- Making programmers annotate the types in these small, anonymous functions would -->
<!-- be annoying and largely redundant with the information the compiler already has -->
<!-- available. -->
<p>このような小さく、匿名の関数で型をプログラマに注釈させることは、煩わしくコンパイラがすでに利用可能な情報と、
大筋で余分でしょう。</p>
<!-- As with variables, we can add type annotations if we want to increase -->
<!-- explicitness and clarity at the cost of being more verbose than is strictly -->
<!-- necessary. Annotating the types for the closure we defined in Listing 13-5 -->
<!-- would look like the definition shown in Listing 13-7. -->
<p>変数のように、厳格に必要な以上に冗長になることと引き換えに、明示性と明瞭性を向上させたいなら、型注釈を加えることができます;
リスト13-4で定義したクロージャに型を注釈するなら、リスト13-7に示した定義のようになるでしょう。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num: u32| -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-7: Adding optional type annotations of the -->
<!-- parameter and return value types in the closure</span> -->
<p><span class="caption">リスト13-7: クロージャの引数と戻り値の省略可能な型注釈を追加する</span></p>
<!-- With type annotations added, the syntax of closures looks more similar to the -->
<!-- syntax of functions. The following is a vertical comparison of the syntax for -->
<!-- the definition of a function that adds 1 to its parameter and a closure that -->
<!-- has the same behavior. We’ve added some spaces to line up the relevant parts. -->
<!-- This illustrates how closure syntax is similar to function syntax except for -->
<!-- the use of pipes and the amount of syntax that is optional: -->
<p>クロージャと記法は、型注釈があると関数の記法に酷似して見えます。以下が、引数に1を加える関数の定義と、
同じ振る舞いをするクロージャの定義の記法を縦に比べたものです。
空白を追加して、関連のある部分を並べています。これにより、縦棒の使用と省略可能な記法の量を除いて、
クロージャ記法が関数記法に似ているところを具体化しています。</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<!-- The first line shows a function definition, and the second line shows a fully -->
<!-- annotated closure definition. The third line removes the type annotations from -->
<!-- the closure definition, and the fourth line removes the brackets, which are -->
<!-- optional because the closure body has only one expression. These are all valid -->
<!-- definitions that will produce the same behavior when they’re called. -->
<p>1行目が関数定義を示し、2行目がフルに注釈したクロージャ定義を示しています。
3行目は、クロージャ定義から型注釈を取り除き、4行目は、かっこを取り除いていて、
これはクロージャの本体がただ1つの式からなるので、省略可能です。これらは全て、
呼び出された時に同じ振る舞いになる有効な定義です。</p>
<!-- Closure definitions will have one concrete type inferred for each of their -->
<!-- parameters and for their return value. For instance, Listing 13-8 shows the -->
<!-- definition of a short closure that just returns the value it receives as a -->
<!-- parameter. This closure isn’t very useful except for the purposes of this -->
<!-- example. Note that we haven’t added any type annotations to the definition: if -->
<!-- we then try to call the closure twice, using a `String` as an argument the -->
<!-- first time and a `u32` the second time, we’ll get an error. -->
<p>クロージャ定義には、引数それぞれと戻り値に対して推論される具体的な型が一つあります。例えば、
リスト13-8に引数として受け取った値を返すだけの短いクロージャの定義を示しました。
このクロージャは、この例での目的以外には有用ではありません。この定義には、
何も型注釈を加えていないことに注意してください: それから1回目に<code>String</code>を引数に、
2回目に<code>u32</code>を引数に使用してこのクロージャを2回呼び出そうとしたら、エラーになります。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
</code></pre>
<!-- <span class="caption">Listing 13-8: Attempting to call a closure whose types -->
<!-- are inferred with two different types</span> -->
<p><span class="caption">リスト13-8: 2つの異なる型で型が推論されるクロージャの呼び出しを試みる</span></p>
<!-- The compiler gives us this error: -->
<p>コンパイラは、次のエラーを返します:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs
  |
  | let n = example_closure(5);
  |                         ^ expected struct `std::string::String`, found
  integral variable
  |
  = note: expected type `std::string::String`
             found type `{integer}`
</code></pre>
<!-- The first time we call `example_closure` with the `String` value, the compiler -->
<!-- infers the type of `x` and the return type of the closure to be `String`. Those -->
<!-- types are then locked in to the closure in `example_closure`, and we get a type -->
<!-- error if we try to use a different type with the same closure. -->
<p><code>String</code>値で<code>example_closure</code>を呼び出した最初の時点で、コンパイラは<code>x</code>とクロージャの戻り値の型を<code>String</code>と推論します。
そして、その型が<code>example_closure</code>のクロージャに閉じ込められ、同じクロージャを異なる型で使用しようとすると、
型エラーが出るのです。</p>
<!-- ### Storing Closures Using Generic Parameters and the `Fn` Traits -->
<a class="header" href="print.html#aジェネリック引数とfnトレイトを使用してクロージャを保存する" id="aジェネリック引数とfnトレイトを使用してクロージャを保存する"><h3>ジェネリック引数と<code>Fn</code>トレイトを使用してクロージャを保存する</h3></a>
<!-- Let’s return to our workout generation app. In Listing 13-6, our code was still -->
<!-- calling the expensive calculation closure more times than it needed to. One -->
<!-- option to solve this issue is to save the result of the expensive closure in a -->
<!-- variable for reuse and use the variable in each place we need the result, -->
<!-- instead of calling the closure again. However, this method could result in a -->
<!-- lot of repeated code. -->
<p>トレーニング生成アプリに戻りましょう。リスト13-6において、まだコードは必要以上の回数、重い計算のクロージャを呼んでいました。
この問題を解決する一つの選択肢は、重いクロージャの結果を再利用できるように変数に保存し、クロージャを再度呼ぶ代わりに、
結果が必要になる箇所それぞれでその変数を使用することです。しかしながら、この方法は同じコードを大量に繰り返す可能性があります。</p>
<!-- Fortunately, another solution is available to us. We can create a struct that -->
<!-- will hold the closure and the resulting value of calling the closure. The -->
<!-- struct will execute the closure only if we need the resulting value, and it -->
<!-- will cache the resulting value so the rest of our code doesn’t have to be -->
<!-- responsible for saving and reusing the result. You may know this pattern as -->
<!-- *memoization* or *lazy evaluation*. -->
<p>運のいいことに、別の解決策もあります。クロージャやクロージャの呼び出し結果の値を保持する構造体を作れるのです。
結果の値が必要な場合のみにその構造体はクロージャを実行し、その結果の値をキャッシュするので、残りのコードは、
結果を保存し、再利用する責任を負わなくて済むのです。このパターンは、<em>メモ化</em>(memoization)または、
<em>遅延実行</em>(lazy evaluation)として知っているかもしれません。</p>
<!-- 5行目、structs, enumsにthatがかかるか曖昧だが、この訳の方が自然と思われる -->
<!-- To make a struct that holds a closure, we need to specify the type of the -->
<!-- closure, because a struct definition needs to know the types of each of its -->
<!-- fields. Each closure instance has its own unique anonymous type: that is, even -->
<!-- if two closures have the same signature, their types are still considered -->
<!-- different. To define structs, enums, or function parameters that use closures, -->
<!-- we use generics and trait bounds, as we discussed in Chapter 10. -->
<p>クロージャを保持する構造体を作成するために、クロージャの型を指定する必要があります。
構造体定義は、各フィールドの型を把握しておく必要がありますからね。各クロージャインスタンスには、
独自の匿名の型があります: つまり、2つのクロージャが全く同じシグニチャでも、その型はそれでも違うものと考えられるということです。
クロージャを使用する構造体、enum、関数引数を定義するには、第10章で議論したように、
ジェネリクスとトレイト境界を使用します。</p>
<!-- The `Fn` traits are provided by the standard library. All closures implement -->
<!-- one of the traits: `Fn`, `FnMut`, or `FnOnce`. We’ll discuss the difference -->
<!-- difference between these traits in the "Capturing the Environment with -->
<!-- Closures" section; in this example, we can use the `Fn` trait. -->
<p><code>Fn</code>トレイトは、標準ライブラリで用意されています。全てのクロージャは、そのトレイトのどれかを実装しています:
<code>Fn</code>、<code>FnMut</code>または、<code>FnOnce</code>です。「クロージャで環境をキャプチャする」節で、これらのトレイト間の差異を議論します;
この例では、<code>Fn</code>トレイトを使えます。</p>
<!-- 2行目中盤は一見、mustとhave toが重なっているように見えるが、must have [to ...]という構造と思われる -->
<!-- We add types to the `Fn` trait bound to represent the types of the parameters -->
<!-- and return values the closures must have to match this trait bound. In this -->
<!-- case, our closure has a parameter of type `u32` and returns a `u32`, so the -->
<!-- trait bound we specify is `Fn(u32) -> u32`. -->
<p><code>Fn</code>トレイト境界への型を追加して、クロージャがこのトレイト境界を合致させるために持っていなければならない引数と戻り値の型を表します。
今回の場合、クロージャは、引数の型が<code>u32</code>で、<code>u32</code>を返すので、指定するトレイト境界は、<code>Fn(u32) =&gt; u32</code>です。</p>
<!-- Listing 13-9 shows the definition of the `Cacher` struct that holds a closure -->
<!-- and an optional result value. -->
<p>リスト13-9は、クロージャとオプションの結果値を保持する<code>Cacher</code>構造体の定義を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-9: Defining a `Cacher` struct that holds a -->
<!-- closure in `calculation` and an optional result in `value`</span> -->
<p><span class="caption">リスト13-9: クロージャを<code>calculation</code>に、オプションの結果値を<code>value</code>に保持する<code>Cacher</code>構造体を定義する</span></p>
<!-- The `Cacher` struct has a `calculation` field of the generic type `T`. The -->
<!-- trait bounds on `T` specify that it’s a closure by using the `Fn` trait. Any -->
<!-- closure we want to store in the `calculation` field must have one `u32` -->
<!-- parameter (specified within the parentheses after `Fn`) and must return a -->
<!-- `u32` (specified after the `->`). -->
<p><code>Cacher</code>構造体には、ジェネリックな型<code>T</code>の<code>calculation</code>フィールドがあります。<code>T</code>に関するトレイト境界は、
<code>Fn</code>トレイトを使うことでクロージャであると指定しています。<code>calculation</code>フィールドに保存したいクロージャは全て、
1つの<code>u32</code>引数(<code>Fn</code>の後の括弧内で指定されている)を取り、<code>u32</code>(<code>-&gt;</code>の後に指定されている)を返さなければなりません。</p>
<!-- > Note: Functions implement all three of the `Fn` traits too. If what we want -->
<!-- > to do doesn’t require capturing a value from the environment, we can use a -->
<!-- > function rather than a closure where we need something that implements an `Fn` -->
<!-- > trait. -->
<blockquote>
<p>注釈: 関数も3つの<code>Fn</code>トレイト全部を実装します。したいことに環境から値をキャプチャすることが必要ないなら、
<code>Fn</code>トレイトを実装する何かが必要になるクロージャではなく、関数を使用できます。</p>
</blockquote>
<!-- The `value` field is of type `Option<u32>`. Before we execute the closure, -->
<!-- `value` will be `None`. When code using a `Cacher` asks for the *result* of the -->
<!-- closure, the `Cacher` will execute the closure at that time and store the -->
<!-- result within a `Some` variant in the `value` field. Then if the code asks for -->
<!-- the result of the closure again, instead of executing the closure again, the -->
<!-- `Cacher` will return the result held in the `Some` variant. -->
<p><code>value</code>フィールドの型は、<code>Option&lt;u32&gt;</code>です。クロージャを実行する前に、<code>value</code>は<code>None</code>になるでしょう。
<code>Cacher</code>を使用するコードがクロージャの<em>結果</em>を求めてきたら、その時点で<code>Cacher</code>はクロージャを実行し、
その結果を<code>value</code>フィールドの<code>Some</code>バリアントに保存します。それから、コードが再度クロージャの結果を求めたら、
クロージャを再実行するのではなく、<code>Cacher</code>は<code>Some</code>バリアントに保持された結果を返すでしょう。</p>
<!-- The logic around the `value` field we’ve just described is defined in Listing -->
<!-- 13-10. -->
<p>たった今説明した<code>value</code>フィールド周りのロジックは、リスト13-10で定義されています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     calculation: T,
#     value: Option&lt;u32&gt;,
# }
#
impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-10: The caching logic of `Cacher`</span> -->
<p><span class="caption">リスト13-10: <code>Cacher</code>のキャッシュ機構</span></p>
<!-- We want `Cacher` to manage the struct fields’ values rather than letting the -->
<!-- calling code potentially change the values in these fields directly, so these -->
<!-- fields are private. -->
<p>呼び出し元のコードにこれらのフィールドの値を直接変えてもらうのではなく、<code>Cacher</code>に構造体のフィールドの値を管理してほしいので、
これらのフィールドは非公開になっています。</p>
<!-- The `Cacher::new` function takes a generic parameter `T`, which we’ve defined -->
<!-- as having the same trait bound as the `Cacher` struct. Then `Cacher::new` -->
<!-- returns a `Cacher` instance that holds the closure specified in the -->
<!-- `calculation` field and a `None` value in the `value` field, because we haven’t -->
<!-- executed the closure yet. -->
<p><code>Cacher::new</code>関数は、ジェネリックな引数の<code>T</code>を取り、これは、<code>Cacher</code>構造体と同じトレイト境界を持つと定義しました。
それから<code>calculation</code>フィールドに指定されたクロージャと、
<code>value</code>フィールドに<code>None</code>値を保持する<code>Cacher</code>インスタンスを<code>Cacher::new</code>は返します。
まだクロージャを実行していないからですね。</p>
<!-- When the calling code needs the result of evaluating the closure, instead of -->
<!-- calling the closure directly, it will call the `value` method. This method -->
<!-- checks whether we already have a resulting value in `self.value` in a `Some`; -->
<!-- if we do, it returns the value within the `Some` without executing the closure -->
<!-- again. -->
<p>呼び出し元のコードがクロージャの評価結果を必要としたら、クロージャを直接呼ぶ代わりに、<code>value</code>メソッドを呼びます。
このメソッドは、結果の値が<code>self.value</code>の<code>Some</code>にすでにあるかどうか確認します; そうなら、
クロージャを再度実行することなく<code>Some</code>内の値を返します。</p>
<!-- If `self.value` is `None`, the code calls the closure stored in -->
<!-- `self.calculation`, savea the result in `self.value` for future use, and -->
<!-- return the value as well. -->
<p><code>self.value</code>が<code>None</code>なら、コードは<code>self.calculation</code>に保存されたクロージャを呼び出し、
結果を将来使えるように<code>self.value</code>に保存し、その値を返しもします。</p>
<!-- Listing 13-11 shows how we can use this `Cacher` struct in the function -->
<!-- `generate_workout` from Listing 13-6. -->
<p>リスト13-11は、リスト13-6の関数<code>generate_workout</code>でこの<code>Cacher</code>構造体を使用する方法を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# struct Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     calculation: T,
#     value: Option&lt;u32&gt;,
# }
#
# impl&lt;T&gt; Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
#
#     fn value(&amp;mut self, arg: u32) -&gt; u32 {
#         match self.value {
#             Some(v) =&gt; v,
#             None =&gt; {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             },
#         }
#     }
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-11: Using `Cacher` in the `generate_workout` -->
<!-- function to abstract away the caching logic</span> -->
<p><span class="caption">リスト13-11: <code>generate_workout</code>関数内で<code>Cacher</code>を使用し、キャッシュ機構を抽象化する</span></p>
<!-- Instead of saving the closure in a variable directly, we save a new instance of -->
<!-- `Cacher` that holds the closure. Then, in each place we want the result, we -->
<!-- call the `value` method on the `Cacher` instance. We can call the `value` -->
<!-- method as many times as we want, or not call it at all, and the expensive -->
<!-- calculation will be run a maximum of once. -->
<p>クロージャを変数に直接保存する代わりに、クロージャを保持する<code>Cacher</code>の新規インスタンスを保存しています。
そして、結果が必要な場所それぞれで、その<code>Cacher</code>インスタンスに対して<code>value</code>メソッドを呼び出しています。
必要なだけ<code>value</code>メソッドを呼び出したり、全く呼び出さないこともでき、重い計算は最大でも1回しか走りません。</p>
<!-- Try running this program with the `main` function from Listing 13-2. Change the -->
<!-- values in the `simulated_user_specified_value` and `simulated_random_number` -->
<!-- variables to verify that in all the cases in the various `if` and `else` -->
<!-- blocks, `calculating slowly...` appears only once and only when needed. The -->
<!-- `Cacher` takes care of the logic necessary to ensure we aren’t calling the -->
<!-- expensive calculation more than we need to so `generate_workout` can focus on -->
<!-- the business logic. -->
<p>リスト13-2の<code>main</code>関数とともにこのプログラムを走らせてみてください。
<code>simulated_user_specified_value</code>と<code>simulated_random_number</code>変数の値を変えて、
いろんな<code>if</code>や<code>else</code>ブロックの場合全てで、<code>calculating slowly</code>は1回だけ、必要な時にのみ出現することを実証してください。
必要以上に重い計算を呼び出さないことを保証するのに必要なロジックの面倒を<code>Cacher</code>は見るので、
<code>generate_workout</code>はビジネスロジックに集中できるのです。</p>
<!-- ### Limitations of the `Cacher` Implementation -->
<a class="header" href="print.html#cacher実装の限界" id="cacher実装の限界"><h3><code>Cacher</code>実装の限界</h3></a>
<!-- Caching values is a generally useful behavior that we might want to use in -->
<!-- other parts of our code with different closures. However, there are two -->
<!-- problems with the current implementation of `Cacher` that would make reusing it -->
<!-- in different contexts difficult. -->
<p>値をキャッシュすることは、コードの他の部分でも異なるクロージャで行いたくなるかもしれない一般的に有用な振る舞いです。
しかし、現在の<code>Cacher</code>の実装には、他の文脈で再利用することを困難にしてしまう問題が2つあります。</p>
<!-- The first problem is that a `Cacher` instance assumes it will always get the -->
<!-- same value for the parameter `arg` to the `value` method. That is, this test of -->
<!-- `Cacher` will fail: -->
<p>1番目の問題は、<code>Cacher</code>インスタンスが、常に<code>value</code>メソッドの引数<code>arg</code>に対して同じ値になると想定していることです。
言い換えると、<code>Cacher</code>のこのテストは、失敗するでしょう:</p>
<pre><code class="language-rust ignore">#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
</code></pre>
<!-- This test creates a new `Cacher` instance with a closure that returns the value -->
<!-- passed into it. We call the `value` method on this `Cacher` instance with an -->
<!-- `arg` value of 1 and then an `arg` value of 2, and we expect the call to -->
<!-- `value` with the `arg` value of 2 to return 2. -->
<p>このテストは、渡された値を返すクロージャを伴う<code>Cacher</code>インスタンスを新しく生成しています。
この<code>Cacher</code>インスタンスに対して1という<code>arg</code>値で呼び出し、それから2という<code>arg</code>値で呼び出し、
2という<code>arg</code>値の<code>value</code>呼び出しは2を返すべきと期待しています。</p>
<!-- Run this test with the `Cacher` implementation in Listing 13-9 and Listing -->
<!-- 13-10, and the test will fail on the `assert_eq!` with this message: -->
<p>このテストをリスト13-9とリスト13-10の<code>Cacher</code>実装で動かすと、<code>assert_eq</code>からこんなメッセージが出て、
このテストは失敗します:</p>
<pre><code class="language-text">thread 'call_with_different_values' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/main.rs
</code></pre>
<!-- The problem is that the first time we called `c.value` with 1, the `Cacher` -->
<!-- instance saved `Some(1)` in `self.value`. Thereafter, no matter what we pass in -->
<!-- to the `value` method, it will always return 1. -->
<p>問題は、初めて<code>c.value</code>を1で呼び出した時に、<code>Cacher</code>インスタンスは<code>self.value</code>に<code>Some(1)</code>を保存したことです。
その後<code>value</code>メソッドに何を渡しても、常に1を返すわけです。</p>
<!-- Try modifying `Cacher` to hold a hash map rather than a single value. The keys -->
<!-- of the hash map will be the `arg` values that are passed in, and the values of -->
<!-- the hash map will be the result of calling the closure on that key. Instead of -->
<!-- looking at whether `self.value` directly has a `Some` or a `None` value, the -->
<!-- `value` function will look up the `arg` in the hash map and return the value if -->
<!-- it’s present. If it’s not present, the `Cacher` will call the closure and save -->
<!-- the resulting value in the hash map associated with its `arg` value. -->
<p>単独の値ではなく、ハッシュマップを保持するように<code>Cacher</code>を改変してみてください。ハッシュマップのキーは、
渡される<code>arg</code>値になり、ハッシュマップの値は、そのキーでクロージャを呼び出した結果になるでしょう。
<code>self.value</code>が直接<code>Some</code>か<code>None</code>値であることを調べる代わりに、<code>value</code>関数はハッシュマップの<code>arg</code>を調べ、
存在するならその値を返します。存在しないなら、<code>Cacher</code>はクロージャを呼び出し、
<code>arg</code>値に紐づけてハッシュマップに結果の値を保存します。</p>
<!-- The second problem with the current `Cacher` implementation is that it only -->
<!-- accepts closures that take one parameter of type `u32` and return a `u32`. We -->
<!-- might want to cache the results of closures that take a string slice and return -->
<!-- `usize` values, for example. To fix this issue, try introducing more generic -->
<!-- parameters to increase the flexibility of the `Cacher` functionality. -->
<p>現在の<code>Cacher</code>実装の2番目の問題は、引数の型に<code>u32</code>を一つ取り、<code>u32</code>を返すクロージャしか受け付けないことです。
例えば、文字列スライスを取り、<code>usize</code>を返すクロージャの結果をキャッシュしたくなるかもしれません。
この問題を解決するには、<code>Cacher</code>機能の柔軟性を向上させるためによりジェネリックな引数を導入してみてください。</p>
<!-- ### Capturing the Environment with Closures -->
<a class="header" href="print.html#aクロージャで環境をキャプチャする" id="aクロージャで環境をキャプチャする"><h3>クロージャで環境をキャプチャする</h3></a>
<!-- In the workout generator example, we only used closures as inline anonymous -->
<!-- functions. However, closures have an additional capability that functions don’t -->
<!-- have: they can capture their environment and access variables from the scope in -->
<!-- which they’re defined. -->
<p>トレーニング生成の例において、クロージャをインラインの匿名関数として使っただけでした。しかし、
クロージャには、関数にはない追加の能力があります: 環境をキャプチャし、
自分が定義されたスコープの変数にアクセスできるのです。</p>
<!-- Listing 13-12 has an example of a closure stored in the `equal_to_x` variable -->
<!-- that uses the `x` variable from the closure’s surrounding environment. -->
<p>リスト13-12は、<code>equal_to_x</code>変数に保持されたクロージャを囲む環境から<code>x</code>変数を使用するクロージャの例です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<!-- <span class="caption">Listing 13-12: Example of a closure that refers to a -->
<!-- variable in its enclosing scope</span> -->
<p><span class="caption">リスト13-12: 内包するスコープの変数を参照するクロージャの例</span></p>
<!-- Here, even though `x` is not one of the parameters of `equal_to_x`, the -->
<!-- `equal_to_x` closure is allowed to use the `x` variable that’s defined in the -->
<!-- same scope that `equal_to_x` is defined in. -->
<p>ここで、<code>x</code>は<code>equal_to_x</code>の引数でもないのに、
<code>equal_to_x</code>が定義されているのと同じスコープで定義されている<code>x</code>変数を<code>equal_to_x</code>クロージャは使用できています。</p>
<!-- We can’t do the same with functions; if we try with the following example, our -->
<!-- code won’t compile: -->
<p>同じことを関数では行うことができません; 以下の例で試したら、コードはコンパイルできません:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>
<!-- We get an error: -->
<p>エラーが出ます:</p>
<pre><code class="language-text">error[E0434]: can't capture dynamic environment in a fn item; use the || { ...
} closure form instead
(エラー: fn要素では動的な環境をキャプチャできません; 代わりに|| { ... }のクロージャ形式を
使用してください)
 --&gt; src/main.rs
  |
4 |     fn equal_to_x(z: i32) -&gt; bool { z == x }
  |                                          ^
</code></pre>
<!-- The compiler even reminds us that this only works with closures! -->
<p>コンパイラは、この形式はクロージャでのみ動作することにも触れています！</p>
<!-- When a closure captures a value from its environment, it uses memory to store -->
<!-- the values for use in the closure body. This use of memory is overhead that we -->
<!-- don’t want to pay in more common cases where we want to execute code that -->
<!-- doesn’t capture its environment. Because functions are never allowed to capture -->
<!-- their environment, defining and using functions will never incur this overhead. -->
<p>クロージャが環境から値をキャプチャすると、メモリを使用してクロージャ本体で使用できるようにその値を保存します。
このメモリ使用は、環境をキャプチャしないコードを実行するようなもっと一般的な場合には払いたくないオーバーヘッドです。
関数は、絶対に環境をキャプチャすることが許可されていないので、関数を定義して使えば、このオーバーヘッドを招くことは絶対にありません。</p>
<!-- Closures can capture values from their environment in three ways, which -->
<!-- directly map to the three ways a function can take a parameter: taking -->
<!-- ownership, borrowing mutably, and borrowing immutably. These are encoded in the -->
<!-- three `Fn` traits as follows: -->
<p>クロージャは、3つの方法で環境から値をキャプチャでき、この方法は関数が引数を取れる3つの方法に直に対応します:
所有権を奪う、可変で借用する、不変で借用するです。これらは、以下のように3つの<code>Fn</code>トレイトでコード化されています:</p>
<!-- * `FnOnce` consumes the variables it captures from its enclosing scope, known -->
<!--   as the closure’s *environment*. To consume the captured variables, the -->
<!--   closure must take ownership of these variables and move them into the closure -->
<!--   when it is defined. The `Once` part of the name represents the fact that the -->
<!--   closure can’t take ownership of the same variables more than once, so it can -->
<!--   only be called one time. -->
<!-- * `FnMut` can change the environment because it mutably borrows values. -->
<!-- * `Fn` borrows values from the environment immutably. -->
<ul>
<li><code>FnOnce</code>は内包されたスコープからキャプチャした変数を消費し、これがクロージャの<em>環境</em>として知られています。
キャプチャした変数を消費するために、定義された際にクロージャはこれらの変数の所有権を奪い、
自身にムーブするのです。名前のうち、<code>Once</code>の部分は、
このクロージャは同じ変数の所有権を2回以上奪うことができないという事実を表しているので、1回しか呼ぶことができないのです。</li>
<li><code>FnMut</code>は、可変で値を借用するので、環境を変更することができます。</li>
<li><code>Fn</code>は、環境から値を不変で借用します。</li>
</ul>
<!-- When you create a closure, Rust infers which trait to use based on how the -->
<!-- closure uses the values from the environment. All closures implement `FnOnce`, -->
<!-- because they can all be called at least once. Closures that don't move the -->
<!-- captured variables also implement `FnMut`, and closures that don't need mutable -->
<!-- access to the captured variables also implement `Fn`. In Listing 13-12, the -->
<!-- `equal_to_x` closure borrows `x` immutably (so `equal_to_x` has the `Fn` trait) -->
<!-- because the body of the closure only needs to read the value in `x`. -->
<p>クロージャを生成する時、クロージャが環境を使用する方法に基づいて、コンパイラはどのトレイトを使用するか推論します。
少なくとも1回は呼び出されるので、全てのクロージャは<code>FnOnce</code>を実装しています。キャプチャした変数をムーブしないクロージャは、
<code>FnMut</code>も実装し、キャプチャした変数に可変でアクセスする必要のないクロージャは、<code>Fn</code>も実装しています。
リスト13-12では、<code>equal_to_x</code>クロージャは<code>x</code>を不変で借用しています(ゆえに<code>equal_to_x</code>は<code>Fn</code>トレイトです)。
クロージャの本体は、<code>x</code>を読む必要しかないからです。</p>
<!-- If you want to force the closure to take ownership of the values it uses in the -->
<!-- environment, we can use the `move` keyword before the parameter list. This -->
<!-- technique is mostly useful when passing a closure to a new thread to move the -->
<!-- data so it’s owned by the new thread. -->
<p>環境でクロージャが使用している値の所有権を奪うことをクロージャに強制したいなら、引数リストの前に<code>move</code>キーワードを使用できます。
このテクニックは、新しいスレッドにデータが所有されるように、クロージャを新しいスレッドに渡して、
データをムーブする際に大概は有用です。</p>
<!-- We’ll have more examples of `move` closures in Chapter 16 when we talk about -->
<!-- concurrency. For now, here’s the code from Listing 13-12 with the `move` -->
<!-- keyword added to the closure definition and using vectors instead of integers, -->
<!-- because integers can be copied rather than moved; note that this code will not -->
<!-- yet compile. -->
<p>並行性について語る第16章で、<code>move</code>クロージャの例はもっと多く出てきます。とりあえず、
こちらが<code>move</code>キーワードがクロージャ定義に追加され、整数の代わりにベクタを使用するリスト13-12からのコードです。
整数はムーブではなく、コピーされてしまいますからね; このコードはまだコンパイルできないことに注意してください。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    // ここでは、xを使用できません: {:?}
    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<!-- We receive the following error: -->
<p>以下のようなエラーを受けます:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `x`
(エラー: ムーブされた値の使用: `x`)
 --&gt; src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
                                  (値はここで(クロージャに)ムーブされた)
5 |
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value used here after move
                                             (ムーブ後、値はここで使用された)
  |
  = note: move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not
  implement the `Copy` trait
  (注釈: `x`が`std::vec::Vec&lt;i32&gt;`という`Copy`トレイトを実装しない型のため、ムーブが起きました)
</code></pre>
<!-- The `x` value is moved into the closure when the closure is defined, because we -->
<!-- added the `move` keyword. The closure then has ownership of `x`, and `main` -->
<!-- isn’t allowed to use `x` anymore in the `println!` statement. Removing -->
<!-- `println!` will fix this example. -->
<p>クロージャが定義された際に、クロージャに<code>x</code>の値はムーブされています。<code>move</code>キーワードを追加したからです。
そして、クロージャは<code>x</code>の所有権を持ち、<code>main</code>は<code>println!</code>で<code>x</code>を使うことはもう叶わないのです。
<code>println!</code>を取り除けば、この例は修正されます。</p>
<!-- Most of the time when specifying one of the `Fn` trait bounds, you can start -->
<!-- with `Fn` and the compiler will tell you if you need `FnMut` or `FnOnce` based -->
<!-- on what happens in the closure body. -->
<p><code>Fn</code>トレイトのどれかを指定するほとんどの場合、<code>Fn</code>から始めると、コンパイラがクロージャ本体内で起こっていることにより、
<code>FnMut</code>や<code>FnOnce</code>が必要な場合、教えてくれるでしょう。</p>
<!-- To illustrate situations where closures that can capture their environment are -->
<!-- useful as function parameters, let’s move on to our next topic: iterators. -->
<p>環境をキャプチャできるクロージャが関数の引数として有用な場面を具体化するために、次のトピックに移りましょう: イテレータです。</p>
<!-- ## Processing a Series of Items with Iterators -->
<a class="header" href="print.html#a一連の要素をイテレータで処理する" id="a一連の要素をイテレータで処理する"><h2>一連の要素をイテレータで処理する</h2></a>
<!-- The iterator pattern allows you to perform some task on a sequence of items in -->
<!-- turn. An iterator is responsible for the logic of iterating over each item and -->
<!-- determining when the sequence has finished. When you use iterators, you don’t -->
<!-- have to reimplement that logic yourself. -->
<p>イテレータパターンにより、一連の要素に順番に何らかの作業を行うことができます。イテレータは、
各要素を繰り返し、シーケンスが終わったことを決定するロジックの責任を負います。イテレータを使用すると、
自身でそのロジックを再実装する必要がなくなるのです。</p>
<!-- In Rust, iterators are *lazy*, meaning they have no effect until you call -->
<!-- methods that consume the iterator to use it up. For example, the code in -->
<!-- Listing 13-13 creates an iterator over the items in the vector `v1` by calling -->
<!-- the `iter` method defined on `Vec<T>`. This code by itself doesn’t do anything -->
<!-- useful. -->
<p>Rustにおいて、イテレータは<em>怠惰</em>です。つまり、イテレータを使い込んで消費するメソッドを呼ぶまで何の効果もないということです。
例えば、リスト13-13のコードは、<code>Vec&lt;T&gt;</code>に定義された<code>iter</code>メソッドを呼ぶことで<code>v1</code>ベクタの要素に対するイテレータを生成しています。
このコード単独では、何も有用なことはしません。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-13: Creating an iterator</span> -->
<p><span class="caption">リスト13-13: イテレータを生成する</span></p>
<!-- Once we’ve created an iterator, we can use it in a variety of ways. In Listing -->
<!-- 3-5 in Chapter 3, we used iterators with `for` loops to execute some code on -->
<!-- each item, although we glossed over what the call to `iter` did until now. -->
<p>一旦イテレータを生成したら、いろんな手段で使用することができます。第3章のリスト3-5では、
ここまで<code>iter</code>の呼び出しが何をするかごまかしてきましたが、<code>for</code>ループでイテレータを使い、
各要素に何かコードを実行しています。</p>
<!-- The example in Listing 13-14 separates the creation of the iterator from the -->
<!-- use of the iterator in the `for` loop. The iterator is stored in the `v1_iter` -->
<!-- variable, and no iteration takes place at that time. When the `for` loop is -->
<!-- called using the iterator in `v1_iter`, each element in the iterator is used in -->
<!-- one iteration of the loop, which prints out each value. -->
<p>リスト13-14の例は、イテレータの生成と<code>for</code>ループでイテレータを使用することを区別しています。
イテレータは、<code>v1_iter</code>変数に保存され、その時には繰り返しは起きていません。<code>v1_iter</code>のイテレータで、
<code>for</code>ループが呼び出された時に、イテレータの各要素がループの繰り返しで使用され、各値が出力されます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    // {}でした
    println!(&quot;Got: {}&quot;, val);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-14: Using an iterator in a `for` loop -->
<p><span class="caption">リスト13-14: <code>for</code>ループでイテレータを使用する</span></p>
<!-- In languages that don’t have iterators provided by their standard libraries, -->
<!-- you would likely write this same functionality by starting a variable at index -->
<!-- 0, using that variable to index into the vector to get a value, and -->
<!-- incrementing the variable value in a loop until it reached the total number of -->
<!-- item in the vector. -->
<p>標準ライブラリにより提供されるイテレータが存在しない言語では、変数を添字0から始め、
その変数でベクタを覗き見て値を得て、ベクタの総要素数に到達するまでループでその変数の値をインクリメントすることで、
この同じ機能を書く可能性が高いでしょう。</p>
<!-- Iterators handle all that logic for you, cutting down on repetitive code you -->
<!-- could potentially mess up. Iterators give you more flexibility to use the same -->
<!-- logic with many different kinds of sequences, not just data structures you can -->
<!-- index into, like vectors. Let’s examine how iterators do that. -->
<p>イテレータはそのロジック全てを処理してくれるので、めちゃくちゃにしてしまう可能性のあるコードの繰り返しを減らしてくれます。
イテレータにより、添字を使えるデータ構造、ベクタなどだけではなく、多くの異なるシーケンスに対して同じロジックを使う柔軟性も得られます。
イテレータがそれをする方法を調査しましょう。</p>
<!-- ### The `Iterator` Trait and the `next` Method -->
<a class="header" href="print.html#iteratorトレイトとnextメソッド" id="iteratorトレイトとnextメソッド"><h3><code>Iterator</code>トレイトと<code>next</code>メソッド</h3></a>
<!-- All iterators implement a trait named `Iterator` that is defined in the -->
<!-- standard library. The definition of the trait looks like this: -->
<p>全てのイテレータは、標準ライブラリで定義されている<code>Iterator</code>というトレイトを実装しています。
このトレイトの定義は、以下のようになっています:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // デフォルト実装のあるメソッドは省略
    // methods with default implementations elided
}
#}</code></pre></pre>
<!-- Notice this definition uses some new syntax: `type Item` and `Self::Item`, -->
<!-- which are defining an *associated type* with this trait. We’ll talk about -->
<!-- associated types in depth in Chapter 19. For now, all you need to know is that -->
<!-- this code says implementing the `Iterator` trait requires that you also define -->
<!-- an `Item` type, and this `Item` type is used in the return type of the `next` -->
<!-- method. In other words, the `Item` type will be the type returned from the -->
<!-- iterator. -->
<p>この定義は、何か新しい記法を使用していることに気付いてください: <code>type Item</code>と<code>Self::Item</code>で、
これらはこのトレイトとの<em>関連型</em>(associated type)を定義しています。関連型についての詳細は、第19章で語ります。
とりあえず、知っておく必要があることは、このコードが<code>Iterator</code>トレイトを実装するには、<code>Item</code>型も定義する必要があり、
そしてこの<code>Item</code>型が<code>next</code>メソッドの戻り値の型に使われていると述べていることです。換言すれば、
<code>Item</code>型がイテレータから返ってくる型になるだろうということです。</p>
<!-- The `Iterator` trait only requires implementors to define one method: the -->
<!-- `next` method, which returns one item of the iterator at a time wrapped in -->
<!-- `Some` and, when iteration is over, returns `None`. -->
<p><code>Iterator</code>トレイトは、一つのメソッドを定義することを実装者に要求することだけします: <code>next</code>メソッドで、
これは1度に<code>Some</code>に包まれたイテレータの1要素を返し、繰り返しが終わったら、<code>None</code>を返します。</p>
<!-- We can call the `next` method on iterators directly; Listing 13-15 demonstrates -->
<!-- what values are returned from repeated calls to `next` on the iterator created -->
<!-- from the vector. -->
<p>イテレータに対して直接<code>next</code>メソッドを呼び出すこともできます; リスト13-15は、
ベクタから生成されたイテレータの<code>next</code>を繰り返し呼び出した時にどんな値が返るかを模擬しています。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-15: Calling the `next` method on an -->
<!-- iterator</span> -->
<p><span class="caption">リスト13-15: イテレータに対して<code>next</code>メソッドを呼び出す</span></p>
<!-- Note that we needed to make `v1_iter` mutable: calling the `next` method on an -->
<!-- iterator changes internal state that the iterator uses to keep track of where -->
<!-- it is in the sequence. In other words, this code *consumes*, or uses up, the -->
<!-- iterator. Each call to `next` eats up an item from the iterator. We didn’t need -->
<!-- to make `v1_iter` mutable when we used a `for` loop because the loop took -->
<!-- ownership of `v1_iter` and made it mutable behind the scenes. -->
<p><code>v1_iter</code>を可変にする必要があったことに注目してください: イテレータの<code>next</code>メソッドを呼び出すと、
今シーケンスのどこにいるかを追いかけるためにイテレータが使用している内部の状態が変わります。
つまり、このコードはイテレータを<em>消費</em>、または使い込むのです。
<code>next</code>の各呼び出しは、イテレータの要素を一つ、食います。<code>for</code>ループを使用した時には、
<code>v1_iter</code>を可変にする必要はありませんでした。というのも、ループが<code>v1_iter</code>の所有権を奪い、
陰で可変にしていたからです。</p>
<!-- Also note that the values we get from the calls to `next` are immutable -->
<!-- references to the values in the vector. The `iter` method produces an iterator -->
<!-- over immutable references. If we want to create an iterator that takes -->
<!-- ownership of `v1` and returns owned values, we can call `into_iter` instead of -->
<!-- `iter`. Similarly, if we want to iterate over mutable references, we can call -->
<!-- `iter_mut` instead of `iter`. -->
<p>また、<code>next</code>の呼び出しで得られる値は、ベクタの値への不変な参照であることにも注目してください。
<code>iter</code>メソッドは、不変参照へのイテレータを生成します。<code>v1</code>の所有権を奪い、所有された値を返すイテレータを生成したいなら、
<code>iter</code>ではなく<code>into_iter</code>を呼び出すことができます。同様に、可変参照を繰り返したいなら、
<code>iter</code>ではなく<code>iter_mut</code>を呼び出せます。</p>
<!-- ### Methods that Consume the Iterator -->
<a class="header" href="print.html#aイテレータを消費するメソッド" id="aイテレータを消費するメソッド"><h3>イテレータを消費するメソッド</h3></a>
<!-- The `Iterator` trait has a number of different methods with default -->
<!-- implementations provided by the standard library; you can find out about these -->
<!-- methods by looking in the standard library API documentation for the `Iterator` -->
<!-- trait. Some of these methods call the `next` method in their definition, which -->
<!-- is why we’re required to implement the `next` method when implementing the -->
<!-- `Iterator` trait. -->
<p><code>Iterator</code>トレイトには、標準ライブラリが提供してくれているデフォルト実装のある多くの異なるメソッドがあります;
<code>Iterator</code>トレイトの標準ライブラリのAPIドキュメントを検索することで、これらのメソッドについて知ることができます。
これらのメソッドの中には、定義内で<code>next</code>メソッドを呼ぶものもあり、故に<code>Iterator</code>トレイトを実装する際には、
<code>next</code>メソッドを実装する必要があるのです。</p>
<!-- Methods that call `next` are called *consuming adaptors*, because calling them -->
<!-- uses up the iterator. One example is the `sum` method, which takes ownership of -->
<!-- the iterator and iterates through the items by repeatedly calling `next`, thus -->
<!-- consuming the iterator. As it iterates through, it adds each item to a running -->
<!-- total and returns the total when iteration is complete. Listing 13-16 has a -->
<!-- test illustrating a use of the `sum` method: -->
<p><code>next</code>を呼び出すメソッドは、<em>消費アダプタ</em>(consuming adaptors)と呼ばれます。呼び出しがイテレータの使い込みになるからです。
一例は、<code>sum</code>メソッドで、これはイテレータの所有権を奪い、<code>next</code>を繰り返し呼び出すことで要素を繰り返し、
故にイテレータを消費するのです。繰り返しが進むごとに、各要素を一時的な合計に追加し、
繰り返しが完了したら、その合計を返します。リスト13-16は、<code>sum</code>の使用を具体化したテストです:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-16: Calling the `sum` method to get the total -->
<!-- of all items in the iterator</span> -->
<p><span class="caption">リスト13-16: <code>sum</code>メソッドを呼び出してイテレータの全要素の合計を得る</span></p>
<!-- We aren’t allowed to use `v1_iter` after the call to `sum` because `sum` takes -->
<!-- ownership of the iterator we call it on. -->
<p><code>sum</code>は呼び出し対象のイテレータの所有権を奪うので、<code>sum</code>呼び出し後に<code>v1_iter</code>を使用することはできません。</p>
<!-- ### Methods that Produce Other Iterators -->
<a class="header" href="print.html#a他のイテレータを生成するメソッド" id="a他のイテレータを生成するメソッド"><h2>他のイテレータを生成するメソッド</h2></a>
<!-- Other methods defined on the `Iterator` trait, known as *iterator adaptors*, -->
<!-- allow us to change iterators into different kind of iterators. You can chain -->
<!-- multiple calls to iterator adaptors to perform complex actions in a readable -->
<!-- way. But because all iterators are lazy, we have to call one of the consuming -->
<!-- adaptor methods to get results from calls to iterator adaptors. -->
<p><code>Iterator</code>トレイトに定義された他のメソッドは、<em>イテレータアダプタ</em>(iterator adaptors)として知られていますが、
イテレータを別の種類のイテレータに変えさせてくれます。イテレータアダプタを複数回呼ぶ呼び出しを連結して、
複雑な動作を読みやすい形で行うことができます。ですが、全てのイテレータは怠惰なので、消費アダプタメソッドのどれかを呼び出し、
イテレータアダプタの呼び出しから結果を得なければなりません。</p>
<!-- Listing 13-17 shows an example of calling the iterator adaptor method `map`, -->
<!-- which takes a closure to call on each item to produce a new iterator. The -->
<!-- closure here creates a new iterator in which each item from the vector has been -->
<!-- incremented by 1. However, this code produces a warning: -->
<p>リスト13-17は、イテレータアダプタメソッドの<code>map</code>の呼び出し例を示し、各要素に対して呼び出すクロージャを取り、
新しいイテレータを生成します。ここのクロージャは、ベクタの各要素が1インクリメントされる新しいイテレータを作成します。
ところが、このコードは警告を発します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-17: Calling the iterator adaptor `map` to -->
<!-- create a new iterator</span> -->
<p><span class="caption">リスト13-17: イテレータアダプタの<code>map</code>を呼び出して新規イテレータを作成する</span></p>
<!-- The warning we get is this: -->
<p>出る警告は以下の通りです:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy
and do nothing unless consumed
(警告: 使用されねばならない`std::iter::Map`が未使用です: イテレータアダプタは怠惰で、
消費されるまで何もしません)
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
</code></pre>
<!-- The code in Listing 13-17 doesn’t do anything; the closure we’ve specified -->
<!-- never gets called. The warning reminds us why: iterator adaptors are lazy, and -->
<!-- we need to consume the iterator here. -->
<p>リスト13-17のコードは何もしません; 指定したクロージャは、決して呼ばれないのです。警告が理由に触れています:
イテレータアダプタは怠惰で、ここでイテレータを消費する必要があるのです。</p>
<!-- To fix this and consume the iterator, we’ll use the `collect` method, which we -->
<!-- used in Chapter 12 with `env::args` in Listing 12-1. This method consumes the -->
<!-- iterator and collects the resulting values into a collection data type. -->
<p>これを解消し、イテレータを消費するには、<code>collect</code>メソッドを使用しますが、これは第12章のリスト12-1で<code>env::args</code>とともに使用しました。
このメソッドはイテレータを消費し、結果の値をコレクションデータ型に集結させます。</p>
<!-- In Listing 13-18, we collect the results of iterating over the iterator that’s -->
<!-- returned from the call to `map` into a vector. This vector will end up -->
<!-- containing each item from the original vector incremented by 1. -->
<p>リスト13-18において、<code>map</code>呼び出しから返ってきたイテレータを繰り返した結果をベクタに集結させています。
このベクタは、最終的に元のベクタの各要素に1を足したものが含まれます。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-18: Calling the `map` method to create a new -->
<!-- iterator and then calling the `collect` method to consume the new iterator and -->
<!-- create a vector</span> -->
<p><span class="caption">リスト13-18: <code>map</code>メソッドを呼び出して新規イテレータを作成し、
それから<code>collect</code>メソッドを呼び出してその新規イテレータを消費し、ベクタを生成する</span></p>
<!-- Because `map` takes a closure, we can specify any operation we want to perform -->
<!-- on each item. This is a great example of how closures let us customize some -->
<!-- behavior while reusing the iteration behavior that the `Iterator` trait -->
<!-- provides. -->
<p><code>map</code>はクロージャを取るので、各要素に対して行いたいどんな処理も指定することができます。
これは、<code>Iterator</code>トレイトが提供する繰り返し動作を再利用しつつ、
クロージャにより一部の動作をカスタマイズできる好例になっています。</p>
<!-- ### Using Closures that Capture Their Environment -->
<a class="header" href="print.html#a環境をキャプチャするクロージャを使用する" id="a環境をキャプチャするクロージャを使用する"><h3>環境をキャプチャするクロージャを使用する</h3></a>
<!-- Now that we’ve introduced iterators, we can demonstrate a common use of -->
<!-- closures that capture their environment by using the `filter` iterator adaptor. -->
<!-- The `filter` method on an iterator takes a closure that takes each item from -->
<!-- the iterator and returns a Boolean. If the closure returns `true`, the value -->
<!-- will be included in the iterator produced by `filter`. If the closure returns -->
<!-- `false`, the value won’t be included in the resulting iterator. -->
<p>イテレータが出てきたので、<code>filter</code>イテレータアダプタを使って環境をキャプチャするクロージャの一般的な使用をデモすることができます。
イテレータの<code>filter</code>メソッドは、イテレータの各要素を取り、論理値を返すクロージャを取ります。
このクロージャが<code>true</code>を返せば、<code>filter</code>が生成するイテレータにその値が含まれます。クロージャが<code>false</code>を返したら、
結果のイテレータにその値は含まれません。</p>
<!-- In Listing 13-19 we use `filter` with a closure that captures the `shoe_size` -->
<!-- variable from its environment to iterate over a collection of `Shoe` struct -->
<!-- instances. It will return only shoes that are the specified size. -->
<p>リスト13-19では、環境から<code>shoe_size</code>変数をキャプチャするクロージャで<code>filter</code>を使って、
<code>Shoe</code>構造体インスタンスのコレクションを繰り返しています。指定したサイズの靴だけを返すわけです。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-19: Using the `filter` method with a closure -->
<!-- that captures `shoe_size`</span> -->
<p><span class="caption">リスト13-19: <code>shoe_size</code>をキャプチャするクロージャで<code>fileter</code>メソッドを使用する</span></p>
<!-- The `shoes_in_my_size` function takes ownership of a vector of shoes and a shoe -->
<!-- size as parameters. It returns a vector containing only shoes of the specified -->
<!-- size. -->
<p><code>shoes_in_my_size</code>関数は、引数として靴のベクタとサイズの所有権を奪います。指定されたサイズの靴だけを含むベクタを返します。</p>
<!-- In the body of `shoes_in_my_size`, we call `into_iter` to create an iterator -->
<!-- that takes ownership of the vector. Then we call `filter` to adapt that -->
<!-- iterator into a new iterator that only contains elements for which the closure -->
<!-- returns `true`. -->
<p><code>shoes_in_my_size</code>の本体で、<code>into_iter</code>を呼び出してベクタの所有権を奪うイテレータを作成しています。
そして、<code>filter</code>を呼び出してそのイテレータをクロージャが<code>true</code>を返した要素だけを含む新しいイテレータに適合させます。</p>
<!-- The closure captures the `shoe_size` parameter from the environment and -->
<!-- compares the value with each shoe’s size, keeping only shoes of the size -->
<!-- specified. Finally, calling `collect` gathers the values returned by the -->
<!-- adapted iterator into a vector that’s returned by the function. -->
<p>クロージャは、環境から<code>shoe_size</code>引数をキャプチャし、指定されたサイズの靴だけを保持しながら、
その値を各靴のサイズと比較します。最後に、<code>collect</code>を呼び出すと、
関数により返ってきたベクタに適合させたイテレータから返ってきた値が集まるのです。</p>
<!-- The test shows that when we call `shoes_in_my_size`, we get back only shoes -->
<!-- that have the same size as the value we specified. -->
<p><code>shoes_in_my_size</code>を呼び出した時に、指定した値と同じサイズの靴だけが得られることをテストは示しています。</p>
<!-- ### Creating Our Own Iterators with `Iterator` Trait -->
<a class="header" href="print.html#iteratorトレイトで独自のイテレータを作成する" id="iteratorトレイトで独自のイテレータを作成する"><h3><code>Iterator</code>トレイトで独自のイテレータを作成する</h3></a>
<!-- We’ve shown that you can create an iterator by calling `iter`, `into_iter`, or -->
<!-- `iter_mut` on a vector. You can create iterators from the other collection -->
<!-- types in the standard library, such as hash map. You can also create iterators -->
<!-- that do anything you want by implementing the `Iterator` trait on your own -->
<!-- types. As previously mentioned, the only method you’re required to provide a -->
<!-- definition for is the `next` method. Once you’ve done that, you can use all -->
<!-- other methods that have default implementations provided by the `Iterator` -->
<!-- trait! -->
<p>ベクタに対し、<code>iter</code>、<code>into_iter</code>、<code>iter_mut</code>を呼び出すことでイテレータを作成できることを示してきました。
ハッシュマップなどの標準ライブラリの他のコレクション型からもイテレータを作成できます。
<code>Iterator</code>トレイトを自分で実装することで、したいことを何でもするイテレータを作成することもできます。
前述の通り、定義を提供する必要のある唯一のメソッドは、<code>next</code>メソッドなのです。一旦、そうしてしまえば、
<code>Iterator</code>トレイトが用意しているデフォルト実装のある他の全てのメソッドを使うことができるのです！</p>
<!-- To demonstrate, let’s create an iterator that will only ever count from 1 to 5. -->
<!-- First, we’ll create a struct to hold some values. Then we’ll make this struct -->
<!-- into an iterator by implementing the `Iterator` trait and use the values in -->
<!-- that implementation. -->
<p>デモ用に、1から5を絶対にカウントするだけのイテレータを作成しましょう。まず、値を保持する構造体を生成し、
<code>Iterator</code>トレイトを実装することでこの構造体をイテレータにし、その実装内の値を使用します。</p>
<!-- Listing 13-20 has the definition of the `Counter` struct and an associated -->
<!-- `new` function to create instances of `Counter`: -->
<p>リスト13-20は、<code>Counter</code>構造体と<code>Counter</code>のインスタンスを作る<code>new</code>関連関数の定義です:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-20: Defining the `Counter` struct and a `new` -->
<!-- function that creates instances of `Counter` with an initial value of 0 for -->
<!-- `count`</span> -->
<p><span class="caption">リスト13-20: <code>Counter</code>構造体と<code>count</code>に対して0という初期値で<code>Counter</code>のインスタンスを作る<code>new</code>関数を定義する</span></p>
<!-- The `Counter` struct has one field named `count`. This field holds a `u32` -->
<!-- value that will keep track of where we are in the process of iterating from 1 -->
<!-- to 5. The `count` field is private because we want the implementation of -->
<!-- `Counter` to manage its value. The `new` function enforces the behavior of -->
<!-- always starting new instances with a value of 0 in the `count` field. -->
<p><code>Counter</code>構造体には、<code>count</code>というフィールドがあります。このフィールドは、
1から5までの繰り返しのどこにいるかを追いかける<code>u32</code>値を保持しています。<code>Counter</code>の実装にその値を管理してほしいので、
<code>count</code>フィールドは非公開です。<code>count</code>フィールドは常に0という値から新規インスタンスを開始するという動作を<code>new</code>関数は強要します。</p>
<!-- Next, we’ll implement the `Iterator` trait for our `Counter` type by defining -->
<!-- the body of the `next` method to specify what we want to happen when this -->
<!-- iterator is used, as shown in Listing 13-21: -->
<p>次に、<code>next</code>メソッドの本体をこのイテレータが使用された際に起きてほしいことを指定するように定義して、
<code>Counter</code>型に対して<code>Iterator</code>トレイトを実装します。リスト13-21のようにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-21: Implementing the `Iterator` trait on our -->
<!-- `Counter` struct</span> -->
<p><span class="caption">リスト13-21: <code>Counter</code>構造体に<code>Iterator</code>トレイトを実装する</span></p>
<!-- We set the associated `Item` type for our iterator to `u32`, meaning the -->
<!-- iterator will return `u32` values. Again, don’t worry about associated types -->
<!-- yet, we’ll cover them in Chapter 19. -->
<p>イテレータの<code>Item</code>関連型を<code>u32</code>に設定しました。つまり、イテレータは、<code>u32</code>の値を返します。
ここでも、まだ関連型について心配しないでください。第19章で講義します。</p>
<!-- We want our iterator to add 1 to the current state, so we initialized `count` -->
<!-- to 0 so it would return 1 first. If the value of `count` is less than 6, `next` -->
<!-- will return the current value wrapped in `Some`, but if `count` is 6 or higher, -->
<!-- our iterator will return `None`. -->
<p>イテレータに現在の状態に1を足してほしいので、まず1を返すように0に<code>count</code>を初期化しました。
<code>count</code>の値が5以下なら、<code>next</code>は<code>Some</code>に包まれた現在の値を返しますが、
<code>count</code>が6以上なら、イテレータは<code>None</code>を返します。</p>
<!-- #### Using Our `Counter` Iterator’s `next` Method -->
<a class="header" href="print.html#counterイテレータのnextメソッドを使用する" id="counterイテレータのnextメソッドを使用する"><h4><code>Counter</code>イテレータの<code>next</code>メソッドを使用する</h4></a>
<!-- Once we’ve implemented the `Iterator` trait, we have an iterator! Listing 13-22 -->
<!-- shows a test demonstrating that we can use the iterator functionality of our -->
<!-- `Counter` struct by calling the `next` method on it directly, just as we did -->
<!-- with the iterator created from a vector in Listing 13-15. -->
<p>一旦<code>Iterator</code>トレイトを実装し終わったら、イテレータの出来上がりです！リスト13-22は、
リスト13-15のベクタから生成したイテレータと全く同様に、直接<code>next</code>メソッドを呼び出すことで、
<code>Counter</code>構造体のイテレータ機能を使用できることをデモするテストを示しています。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Iterator for Counter {
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         self.count += 1;
#
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-22: Testing the functionality of the `next` -->
<!-- method implementation</span> -->
<p><span class="caption">リスト13-22: <code>next</code>メソッド実装の機能をテストする</span></p>
<!-- This test creates a new `Counter` instance in the `counter` variable and then -->
<!-- calls `next` repeatedly, verifying that we have implemented the behavior we -->
<!-- want this iterator to have: returning the values from 1 to 5. -->
<p>このテストは、<code>counter</code>変数に新しい<code>Counter</code>インスタンスを生成し、
それからイテレータにほしい動作が実装し終わっていることを実証しながら、<code>next</code>を繰り返し呼び出しています:
1から5の値を返すことです。</p>
<!-- #### Using Other `Iterator` Trait Methods -->
<a class="header" href="print.html#a他のiteratorトレイトメソッドを使用する" id="a他のiteratorトレイトメソッドを使用する"><h4>他の<code>Iterator</code>トレイトメソッドを使用する</h4></a>
<!-- We implemented the `Iterator` trait by defining the `next` method, so we -->
<!-- can now use any `Iterator` trait method’s default implementations as defined in -->
<!-- the standard library, because they all use the `next` method’s functionality. -->
<p><code>next</code>メソッドを定義して<code>Iterator</code>トレイトを実装したので、今では、標準ライブラリで定義されているように、
どんな<code>Iterator</code>トレイトメソッドのデフォルト実装も使えるようになりました。全て<code>next</code>メソッドの機能を使っているからです。</p>
<!-- For example, if for some reason we wanted to take the values produced by an -->
<!-- instance of `Counter`, pair them with values produced by another `Counter` -->
<!-- instance after skipping the first value, multiply each pair together, keep only -->
<!-- those results that are divisible by 3, and add all the resulting values -->
<!-- together, we could do so, as shown in the test in Listing 13-23: -->
<p>例えば、何らかの理由で、<code>Counter</code>インスタンスが生成する値を取り、最初の値を飛ばしてから、
別の<code>Counter</code>インスタンスが生成する値と一組にし、各ペアを掛け算し、3で割り切れる結果だけを残し、
全結果の値を足し合わせたくなったら、リスト13-23のテストに示したように、そうすることができます:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<!-- check to seeは畳語だが、いい訳はあるだろうか -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Counter {
#     fn new() -&gt; Counter {
#         Counter { count: 0 }
#     }
# }
#
# impl Iterator for Counter {
#     // このイテレータはu32を生成します
#     // Our iterator will produce u32s
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         // カウントをインクリメントする。故に0から始まる
#         // increment our count. This is why we started at zero.
#         self.count += 1;
#
#         // カウントが終わったかどうか確認する
#         // check to see if we've finished counting or not.
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 13-23: Using a variety of `Iterator` trait -->
<!-- methods on our `Counter` iterator</span> -->
<p><span class="caption">リスト13-23: <code>Counter</code>イテレータに対していろんな<code>Iterator</code>トレイトのメソッドを使用する</span></p>
<!-- Note that `zip` produces only four pairs; the theoretical fifth pair `(5, -->
<!-- None)` is never produced because `zip` returns `None` when either of its input -->
<!-- iterators return `None`. -->
<p><code>zip</code>は4組しか生成しないことに注意してください; 理論的な5番目の組の<code>(5, None)</code>は、
入力イテレータのどちらかが<code>None</code>を返したら、<code>zip</code>は<code>None</code>を返却するため、決して生成されることはありません。</p>
<!-- All of these method calls are possible because we specified how the `next` -->
<!-- method works, and the standard library provides default implementations for -->
<!-- other methods that call `next`. -->
<p><code>next</code>メソッドの動作方法を指定し、標準ライブラリが<code>next</code>を呼び出す他のメソッドにデフォルト実装を提供しているので、
これらのメソッド呼び出しは全てあり得ます。</p>
<!-- ## Improving Our I/O Project -->
<a class="header" href="print.html#a入出力プロジェクトを改善する" id="a入出力プロジェクトを改善する"><h2>入出力プロジェクトを改善する</h2></a>
<!-- ここでは、withを条件のように訳している。(今まではなかったのに、)今はある状態で -> ...があればという意訳である -->
<!-- やはりwithは状態を表すだけなので、強すぎる気がしなくもない -->
<!-- With this new knowledge about iterators, we can improve the I/O project in -->
<!-- Chapter 12 by using iterators to make places in the code clearer and more -->
<!-- concise. Let’s look at how iterators can improve our implementation of the -->
<!-- `Config::new` function and the `search` function. -->
<p>このイテレータに関する新しい知識があれば、イテレータを使用してコードのいろんな場所をより明確で簡潔にすることで、
第12章の入出力プロジェクトを改善することができます。イテレータが<code>Config::new</code>関数と<code>search</code>関数の実装を改善する方法に目を向けましょう。</p>
<!-- ### Removing a `clone` Using an Iterator -->
<a class="header" href="print.html#aイテレータを使用してcloneを取り除く" id="aイテレータを使用してcloneを取り除く"><h3>イテレータを使用して<code>clone</code>を取り除く</h3></a>
<!-- In Listing 12-6, we added code that took a slice of `String` values and created -->
<!-- an instance of the `Config` struct by indexing into the slice and cloning the -->
<!-- values, allowing the `Config` struct to own those values. In Listing 13-24, -->
<!-- we’ve reproduced the implementation of the `Config::new` function as it was in -->
<!-- Listing 12-23: -->
<p>リスト12-6において、スライスに添字アクセスして値をクローンすることで、<code>Config</code>構造体に値を所有させながら、
<code>String</code>値のスライスを取り、<code>Config</code>構造体のインスタンスを作るコードを追記しました。リスト13-24では、
リスト12-23のような<code>Config::new</code>の実装を再現しました。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre>
<!-- <span class="caption">Listing 13-24: Reproduction of the `Config::new` function -->
<!-- from Listing 12-23</span> -->
<p><span class="caption">リスト13-24: リスト12-23から<code>Config::new</code>関数の再現</span></p>
<!-- At the time, we said not to worry about the inefficient `clone` calls because -->
<!-- we would remove them in the future. Well, that time is now! -->
<p>その際、将来的に除去する予定なので、非効率的な<code>clone</code>呼び出しを憂慮するなと述べました。
えっと、その時は今です！</p>
<!-- We needed `clone` here because we have a slice with `String` elements in the -->
<!-- parameter `args`, but the `new` function doesn’t own `args`. To return -->
<!-- ownership of a `Config` instance, we had to clone the values from the `query` -->
<!-- and `filename` fields of `Config` so the `Config` instance can own its values. -->
<p>引数<code>args</code>に<code>String</code>要素のスライスがあるためにここで<code>clone</code>が必要だったのですが、
<code>new</code>関数は<code>args</code>を所有していません。<code>Config</code>インスタンスの所有権を返すためには、
<code>Config</code>インスタンスがその値を所有できるように、<code>Config</code>の<code>query</code>と<code>filename</code>フィールドから値をクローンしなければなりませんでした。</p>
<!-- ここも節冒頭と同様。やはり強すぎるか？ -->
<!-- With our new knowledge about iterators, we can change the `new` function to -->
<!-- take ownership of an iterator as its argument instead of borrowing a slice. -->
<!-- We’ll use the iterator functionality instead of the code that checks the length -->
<!-- of the slice and indexes into specific locations. This will clarify what the -->
<!-- `Config::new` function is doing because the iterator will access the values. -->
<p>イテレータについての新しい知識があれば、<code>new</code>関数をスライスを借用する代わりに、
引数としてイテレータの所有権を奪うように変更することができます。スライスの長さを確認し、
特定の場所に添字アクセスするコードの代わりにイテレータの機能を使います。これにより、
イテレータは値にアクセスするので、<code>Config::new</code>関数がすることが明確化します。</p>
<!-- Once `Config::new` takes ownership of the iterator and stops using indexing -->
<!-- operations that borrow, we can move the `String` values from the iterator into -->
<!-- `Config` rather than calling `clone` and making a new allocation. -->
<p>ひとたび、<code>Config::new</code>がイテレータの所有権を奪い、借用する添字アクセス処理をやめたら、
<code>clone</code>を呼び出して新しくメモリ確保するのではなく、イテレータからの<code>String</code>値を<code>Config</code>にムーブできます。</p>
<!-- #### Using the Returned Iterator Directly -->
<a class="header" href="print.html#a返却されるイテレータを直接使う" id="a返却されるイテレータを直接使う"><h4>返却されるイテレータを直接使う</h4></a>
<!-- Open your I/O project’s *src/main.rs* file, which should look like this: -->
<p>入出力プロジェクトの<em>src/main.rs</em>ファイルを開いてください。こんな見た目のはずです:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<!-- 1行目最後のatは消し忘れ？ -->
<!-- We’ll change the start of the `main` function that we had in Listing 12-24 at -->
<!-- to the code in Listing 13-25. This won’t compile until we update `Config::new` -->
<!-- as well. -->
<p>リスト12-24のような<code>main</code>関数の冒頭をリスト13-25のコードに変更します。
これは、<code>Config::new</code>も更新するまでコンパイルできません。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<!-- <span class="caption">Listing 13-25: Passing the return value of `env::args` to -->
<!-- `Config::new`</span> -->
<p><span class="caption">リスト13-25: <code>env::args</code>の戻り値を<code>Config::new</code>に渡す</span></p>
<!-- The `env::args` function returns an iterator! Rather than collecting the -->
<!-- iterator values into a vector and then passing a slice to `Config::new`, now -->
<!-- we’re passing ownership of the iterator returned from `env::args` to -->
<!-- `Config::new` directly. -->
<p><code>env::args</code>関数は、イテレータを返します！イテレータの値をベクタに集結させ、それからスライスを<code>Config::new</code>に渡すのではなく、
今では<code>env::args</code>から返ってくるイテレータの所有権を直接<code>Config::new</code>に渡しています。</p>
<!-- Next, we need to update the definition of `Config::new`. In your I/O project’s -->
<!-- *src/lib.rs* file, let’s change the signature of `Config::new` to look like -->
<!-- Listing 13-26. This still won’t compile because we need to update the function -->
<!-- body. -->
<p>次に、<code>Config::new</code>の定義を更新する必要があります。入出力プロジェクトの<em>src/lib.rs</em>ファイルで、
<code>Config::new</code>のシグニチャをリスト13-26のように変えましょう。関数本体を更新する必要があるので、
それでもコンパイルはできません。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
</code></pre>
<!-- <span class="caption">Listing 13-26: Updating the signature of `Config::new` to -->
<!-- expect an iterator</span> -->
<p><span class="caption">リスト13-26: <code>Config::new</code>のシグニチャをイテレータを期待するように更新する</span></p>
<!-- The standard library documentation for the `env::args` function shows that the -->
<!-- type of the iterator it returns is `std::env::Args`. We’ve updated the -->
<!-- signature of the `Config::new` function so the parameter `args` has the type -->
<!-- `std::env::Args` instead of `&[String]`. Because we’re taking ownership of -->
<!-- `args` and we’ll be mutating `args` by iterating over it, we can add the `mut` -->
<!-- keyword into the specification of the `args` parameter to make it mutable. -->
<p><code>env::args</code>関数の標準ライブラリドキュメントは、自身が返すイテレータの型は、<code>std::env::Args</code>であると表示しています。
<code>Config::new</code>関数のシグニチャを更新したので、引数<code>args</code>の型は、<code>&amp;[String]</code>ではなく、
<code>std::env::Args</code>になりました。<code>args</code>の所有権を奪い、繰り返しを行うことで<code>args</code>を可変化する予定なので、
<code>args</code>引数の仕様に<code>mut</code>キーワードを追記し、可変にできます。</p>
<!-- #### Using `Iterator` Trait Methods Instead of Indexing -->
<a class="header" href="print.html#a添字の代わりにiteratorトレイトのメソッドを使用する" id="a添字の代わりにiteratorトレイトのメソッドを使用する"><h4>添字の代わりに<code>Iterator</code>トレイトのメソッドを使用する</h4></a>
<!-- Next, we’ll fix the body of `Config::new`. The standard library documentation -->
<!-- also mentions that `std::env::Args` implements the `Iterator` trait, so we know -->
<!-- we can call the `next` method on it! Listing 13-27 updates the code from -->
<!-- Listing 12-23 to use the `next` method: -->
<p>次に、<code>Config::new</code>の本体を修正しましょう。標準ライブラリのドキュメントは、
<code>std::env::Args</code>が<code>Iterator</code>トレイトを実装していることにも言及しているので、
それに対して<code>next</code>メソッドを呼び出せることがわかります！リスト13-27は、
リスト13-23のコードを<code>next</code>メソッドを使用するように更新したものです:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
# use std::env;
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            // クエリ文字列を得られませんでした
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            // ファイル名を得られませんでした
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 13-27: Changing the body of `Config::new` to use -->
<!-- iterator methods</span> -->
<p><span class="caption">リスト13-27: <code>Config::new</code>の本体をイテレータメソッドを使うように変更する</span></p>
<!-- 6行目真ん中のandを順接の理由で訳している。 -->
<!-- Remember that the first value in the return value of `env::args` is the name of -->
<!-- the program. We want to ignore that and get to the next value, so first we call -->
<!-- `next` and do nothing with the return value. Second, we call `next` to get the -->
<!-- value we want to put in the `query` field of `Config`. If `next` returns a -->
<!-- `Some`, we use a `match` to extract the value. If it returns `None`, it means -->
<!-- not enough arguments were given and we return early with an `Err` value. We do -->
<!-- the same thing for the `filename` value. -->
<p><code>env::args</code>の戻り値の1番目の値は、プログラム名であることを思い出してください。それは無視し、
次の値を取得したいので、まず<code>next</code>を呼び出し、戻り値に対して何もしません。2番目に、
<code>next</code>を呼び出して<code>Config</code>の<code>query</code>フィールドに置きたい値を得ます。<code>next</code>が<code>Some</code>を返したら、
<code>match</code>を使用してその値を抜き出します。<code>None</code>を返したら、十分な引数が与えられなかったということなので、
<code>Err</code>値で早期リターンします。<code>filename</code>値に対しても同じことをします。</p>
<!-- ### Making Code Clearer with Iterator Adaptors -->
<a class="header" href="print.html#aイテレータアダプタでコードをより明確にする" id="aイテレータアダプタでコードをより明確にする"><h3>イテレータアダプタでコードをより明確にする</h3></a>
<!-- We can also take advantage of iterators in the `search` function in our I/O -->
<!-- project, which is reproduced here in Listing 13-28 as it was in Listing 12-19: -->
<p>入出力プロジェクトの<code>search</code>関数でも、イテレータを活用することができ、その関数は、
リスト12-19のように、ここリスト13-28に再現しました。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<!-- <span class="caption">Listing 13-28: The implementation of the `search` -->
<!-- function from Listing 12-19</span> -->
<p><span class="caption">リスト13-28: リスト12-19の<code>search</code>関数の実装</span></p>
<!-- We can write this code in a more concise way using iterator adaptor methods. -->
<!-- Doing so also lets us avoid having a mutable intermediate `results` vector. The -->
<!-- functional programming style prefers to minimize the amount of mutable state to -->
<!-- make code clearer. Removing the mutable state might enable a future enhancement -->
<!-- to make searching happen in parallel, because we wouldn’t have to manage -->
<!-- concurrent access to the `results` vector. Listing 13-29 shows this change: -->
<p>イテレータアダプタメソッドを使用して、このコードをもっと簡潔に書くことができます。そうすれば、
可変な中間の<code>results</code>ベクタをなくすこともできます。関数型プログラミングスタイルは、可変な状態の量を最小化することを好み、
コードを明瞭化します。可変な状態を除去すると、検索を同時並行に行うという将来的な改善をするのが、
可能になる可能性があります。なぜなら、<code>results</code>ベクタへの同時アクセスを管理する必要がなくなるからです。
リスト13-29は、この変更を示しています:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre>
<!-- <span class="caption">Listing 13-29: Using iterator adaptor methods in the -->
<!-- implementation of the `search` function</span> -->
<p><span class="caption">リスト13-29: <code>search</code>関数の実装でイテレータアダプタのメソッドを使用する</span></p>
<!-- Recall that the purpose of the `search` function is to return all lines in -->
<!-- `contents` that contain the `query`. Similar to the `filter` example in Listing -->
<!-- 13-19, this code uses the `filter` adaptor to keep only the lines that -->
<!-- `line.contains(query)` returns true for. We then collect the matching lines -->
<!-- into another vector with `collect`. Much simpler! Feel free to make the same -->
<!-- change to use iterator methods in the `search_case_insensitive` function as -->
<!-- well. -->
<p><code>search</code>関数の目的は、<code>query</code>を含む<code>contents</code>の行全てを返すことであることを思い出してください。
リスト13-19の<code>filter</code>例に酷似して、このコードは<code>filter</code>アダプタを使用して<code>line.contains(query)</code>が真を返す行だけを残すことができます。
それから、合致した行を別のベクタに<code>collect</code>で集結させます。ずっと単純です！ご自由に、
同じ変更を行い、<code>search_case_insensitive</code>関数でもイテレータメソッドを使うようにしてください。</p>
<!-- The next logical question is which style you should choose in your own code and -->
<!-- why: the original implementation in Listing 13-28 or the version using -->
<!-- iterators in Listing 13-29. Most Rust programmers prefer to use the iterator -->
<!-- style. It’s a bit tougher to get the hang of at first, but once you get a feel -->
<!-- for the various iterator adaptors and what they do, iterators can be easier to -->
<!-- understand. Instead of fiddling with the various bits of looping and building -->
<!-- new vectors, the code focuses on the high-level objective of the loop. This -->
<!-- abstracts away some of the commonplace code so it’s easier to see the concepts -->
<!-- that are unique to this code, such as the filtering condition each element in -->
<!-- the iterator must pass. -->
<p>次の論理的な疑問は、自身のコードでどちらのスタイルを選ぶかと理由です: リスト13-28の元の実装とリスト13-29のイテレータを使用するバージョンです。
多くのRustプログラマは、イテレータスタイルを好みます。とっかかりが少し困難ですが、
いろんなイテレータアダプタとそれがすることの感覚を一度掴めれば、イテレータの方が理解しやすいこともあるでしょう。
いろんなループを少しずつもてあそんだり、新しいベクタを構築する代わりに、コードは、ループの高難度の目的に集中できるのです。
これは、ありふれたコードの一部を抽象化するので、イテレータの各要素が通過しなければならないふるい条件など、
このコードに独特の概念を理解しやすくなります。</p>
<!-- But are the two implementations truly equivalent? The intuitive assumption -->
<!-- might be that the more low-level loop will be faster. Let’s talk about -->
<!-- performance. -->
<p>ですが、本当に2つの実装は等価なのでしょうか？直観的な仮説は、より低レベルのループの方がより高速ということかもしれません。
パフォーマンスに触れましょう。</p>
<!-- ## Comparing Performance: Loops vs. Iterators -->
<a class="header" href="print.html#aパフォーマンス比較-ループvsイテレータ" id="aパフォーマンス比較-ループvsイテレータ"><h2>パフォーマンス比較: ループVSイテレータ</h2></a>
<!-- To determine whether to use loops or iterators, you need to know which version -->
<!-- of our `search` functions is faster: the version with an explicit `for` loop or -->
<!-- the version with iterators. -->
<p>ループを使うべきかイテレータを使うべきか決定するために、<code>search</code>関数のうち、どちらのバージョンが速いか知る必要があります:
明示的な<code>for</code>ループがあるバージョンと、イテレータのバージョンです。</p>
<!-- We ran a benchmark by loading the entire contents of *The Adventures of -->
<!-- Sherlock Holmes* by Sir Arthur Conan Doyle into a `String` and looking for the -->
<!-- word *the* in the contents. Here are the results of the benchmark on the -->
<!-- version of `search` using the `for` loop and the version using iterators: -->
<p>サー・アーサー・コナン・ドイル(Sir Arthur Conan Doyle)の、
<em>シャーロックホームズの冒険</em>(The Adventures of Sherlock Homes)全体を<code>String</code>に読み込み、
そのコンテンツで<em>the</em>という単語を検索することでベンチマークを行いました。
こちらが、<code>for</code>を使用した<code>search</code>関数のバージョンと、イテレータを使用したバージョンに関するベンチマーク結果です。</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<!-- The iterator version was slightly faster! We won’t explain the benchmark code -->
<!-- here, because the point is not to prove that the two versions are equivalent -->
<!-- but to get a general sense of how these two implementations compare -->
<!-- performance-wise. -->
<p>イテレータバージョンの方が些か高速ですね！ここでは、ベンチマークのコードは説明しません。
なぜなら、要点は、2つのバージョンが等価であることを証明することではなく、
これら2つの実装がパフォーマンス的にどう比較されるかを大まかに把握することだからです。</p>
<!-- For a more comprehensive benchmark, you should check various texts of -->
<!-- various sizes as the `contents`, different words and words of different lengths -->
<!-- as the `query`, and all kinds of other variations. The point is this: -->
<!-- iterators, although a high-level abstraction, get compiled down to roughly the -->
<!-- same code as if you’d written the lower-level code yourself. Iterators are one -->
<!-- of Rust’s *zero-cost abstractions*, by which we mean using the abstraction -->
<!-- imposes no additional runtime overhead. This is analogous to how Bjarne -->
<!-- Stroustrup, the original designer and implementor of C++, defines -->
<!-- *zero-overhead* in “Foundations of C++” (2012): -->
<p>より理解しやすいベンチマークには、いろんなサイズの様々なテキストを<code>contents</code>として、異なる単語、異なる長さの単語を<code>query</code>として、
他のあらゆる種類のバリエーションを確認するべきです。重要なのは: イテレータは、
高度な抽象化にも関わらず、低レベルのコードを自身で書いているかのように、ほぼ同じコードにコンパイルされることです。
イテレータは、Rustの<em>ゼロ代償抽象化</em>の一つであり、これは、抽象化を使うことが追加の実行時オーバーヘッドを生まないことを意味しています。
このことは、C++の元の設計者であり実装者のビャーネ・ストルヴストルップ(Bjarne Stroustrup)が、
<em>ゼロオーバーヘッド</em>を「C++の基礎(2012)」で定義したのと類似しています。</p>
<!-- > In general, C++ implementations obey the zero-overhead principle: What you -->
<!-- > don’t use, you don’t pay for. And further: What you do use, you couldn’t hand -->
<!-- > code any better. -->
<blockquote>
<p>一般的に、C++の実装は、ゼロオーバーヘッド原則を遵守します: 使用しないものには、支払わなくてよい。
さらに: 実際に使っているものに対して、コードをそれ以上うまく渡すことはできない。</p>
</blockquote>
<!-- As another example, the following code is taken from an audio decoder. The -->
<!-- decoding algorithm uses the linear prediction mathematical operation to -->
<!-- estimate future values based on a linear function of the previous samples. This -->
<!-- code uses an iterator chain to do some math on three variables in scope: a -->
<!-- `buffer` slice of data, an array of 12 `coefficients`, and an amount by which -->
<!-- to shift data in `qlp_shift`. We’ve declared the variables within this example -->
<!-- but not given them any values; although this code doesn’t have much meaning -->
<!-- outside of its context, it’s still a concise, real-world example of how Rust -->
<!-- translates high-level ideas to low-level code: -->
<p>別の例として、以下のコードは、オーディオデコーダから取ってきました。デコードアルゴリズムは、
線形予測数学演算を使用して、以前のサンプルの線形関数に基づいて未来の値を予測します。このコードは、
イテレータ連結をしてスコープにある3つの変数に計算を行っています: <code>buffer</code>というデータのスライス、
12の<code>coefficients</code>の配列、<code>qlp_shift</code>でデータをシフトする量です。この例の中で変数を宣言しましたが、
値は与えていません; このコードは、文脈の外では大して意味を持ちませんが、
それでもRustが高レベルな考えを低レベルなコードに翻訳する簡潔で現実的な例になっています:</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<!-- To calculate the value of `prediction`, this code iterates through each of the -->
<!-- 12 values in `coefficients` and uses the `zip` method to pair the coefficient -->
<!-- values with the previous 12 values in `buffer`. Then, for each pair, we -->
<!-- multiply the values together, sum all the results, and shift the bits in the -->
<!-- sum `qlp_shift` bits to the right. -->
<p><code>prediction</code>の値を算出するために、このコードは、<code>coefficients</code>の12の値を繰り返し、<code>zip</code>メソッドを使用して、
係数値を前の<code>buffer</code>の12の値と組にします。それから各組について、その値をかけ合わせ、結果を全て合計し、
合計のビットを<code>qlp_shift</code>ビット分だけ右にシフトさせます。</p>
<!-- Calculations in applications like audio decoders often prioritize performance -->
<!-- most highly. Here, we’re creating an iterator, using two adaptors, and then -->
<!-- consuming the value. What assembly code would this Rust code compile to? Well, -->
<!-- as of this writing, it compiles down to the same assembly you’d write by hand. -->
<!-- There’s no loop at all corresponding to the iteration over the values in -->
<!-- `coefficients`: Rust knows that there are 12 iterations, so it “unrolls” the -->
<!-- loop. *Unrolling* is an optimization that removes the overhead of the loop -->
<!-- controlling code and instead generates repetitive code for each iteration of -->
<!-- the loop. -->
<p>オーディオデコーダのようなアプリケーションの計算は、しばしばパフォーマンスに最も重きを置きます。
ここでは、イテレータを作成し、2つのアダプタを使用し、それから値を消費しています。
このRustコードは、どんな機械語コードにコンパイルされるのでしょうか？えー、執筆時点では、
手作業で書いたものと同じ機械語にコンパイルされます。<code>coefficients</code>の値の繰り返しに対応するループは全く存在しません:
コンパイラは、12回繰り返しがあることを把握しているので、ループを「展開」します。
<em>ループの展開</em>は、ループ制御コードのオーバーヘッドを除去し、代わりにループの繰り返しごとに同じコードを生成する最適化です。</p>
<!-- All of the coefficients get stored in registers, which means accessing the -->
<!-- values is very fast. There are no bounds checks on the array access at runtime. -->
<!-- All these optimizations that Rust is able to apply make the resulting code -->
<!-- extremely efficient. Now that you know this, you can use iterators and closures -->
<!-- without fear! They make code seem like it’s higher level but don’t impose a -->
<!-- runtime performance penalty for doing so. -->
<p>係数は全てレジスタに保存されます。つまり、値に非常に高速にアクセスします。実行時に配列の境界チェックをすることもありません。
コンパイラが適用可能なこれらの最適化全てにより、結果のコードは究極的に効率化されます。このことがわかったので、
イテレータとクロージャを恐れなしに使用することができますね！それらのおかげでコードは、高レベルだけれども、
そうすることに対して実行時のパフォーマンスを犠牲にしないようになります。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-11" id="aまとめ-11"><h2>まとめ</h2></a>
<!-- Closures and iterators are Rust features inspired by functional programming -->
<!-- language ideas. They contribute to Rust’s capability to clearly express -->
<!-- high-level ideas at low-level performance. The implementations of closures and -->
<!-- iterators are such that runtime performance is not affected. This is part of -->
<!-- Rust’s goal to strive to provide zero-cost abstractions. -->
<p>クロージャとイテレータは、関数型言語の考えに着想を得たRustの機能です。低レベルのパフォーマンスで、
高レベルの考えを明確に表現するというRustの能力に貢献しています。クロージャとイテレータの実装は、
実行時のパフォーマンスが影響されないようなものです。これは、ゼロ代償抽象化を提供するのに努力を惜しまないRustの目標の一部です。</p>
<!-- Now that we’ve improved the expressiveness of our I/O project, let’s look at -->
<!-- some more features of `cargo` that will help us share the project with the -->
<!-- world. -->
<p>今や入出力プロジェクトの表現力を改善したので、プロジェクトを世界と共有するのに役に立つ<code>cargo</code>の機能にもっと目を向けましょう。</p>
<!-- # More About Cargo and Crates.io -->
<a class="header" href="print.html#cargoとcratesioについてより詳しく" id="cargoとcratesioについてより詳しく"><h1>CargoとCrates.ioについてより詳しく</h1></a>
<!-- So far we’ve used only the most basic features of Cargo to build, run, and test -->
<!-- our code, but it can do a lot more. In this chapter, we’ll discuss some of its -->
<!-- other, more advanced features to show you how to do the following: -->
<p>今までCargoのビルド、実行、コードのテストを行うという最も基礎的な機能のみを使ってきましたが、
他にもできることはたくさんあります。この章では、そのような他のより高度な機能の一部を議論し、
以下のことをする方法をお見せしましょう:</p>
<!-- * Customize your build through release profiles -->
<!-- * Publish libraries on [crates.io](https://crates.io)-->
<!-- * Organize large projects with workspaces -->
<!-- * Install binaries from [crates.io](https://crates.io)-->
<!-- * Extend Cargo using custom commands -->
<ul>
<li>リリースプロファイルでビルドをカスタマイズする</li>
<li><a href="https://crates.io">crates.io</a>でライブラリを公開する</li>
<li>ワークスペースで巨大なプロジェクトを体系化する</li>
<li><a href="https://crates.io">crates.io</a>からバイナリをインストールする</li>
<li>独自のコマンドを使用してCargoを拡張する</li>
</ul>
<!-- Cargo can do even more than what we cover in this chapter, so for a full -->
<!-- explanation of all its features, see [its -->
<!-- documentation](https://doc.rust-lang.org/cargo/). -->
<p>また、Cargoはこの章で講義する以上のこともできるので、機能の全解説を見るには、
<a href="https://doc.rust-lang.org/cargo/">ドキュメンテーション</a>を参照されたし。</p>
<!-- ## Customizing Builds with Release Profiles -->
<a class="header" href="print.html#aリリースプロファイルでビルドをカスタマイズする" id="aリリースプロファイルでビルドをカスタマイズする"><h2>リリースプロファイルでビルドをカスタマイズする</h2></a>
<!-- In Rust, *release profiles* are predefined and customizable profiles with -->
<!-- different configurations that allow a programmer to have more control over -->
<!-- various options for compiling code. Each profile is configured independently of -->
<!-- the others. -->
<p>Rustにおいて、<em>リリースプロファイル</em>とは、プログラマがコードのコンパイルオプションについて制御可能な異なる設定を持つ、
定義済みのカスタマイズ可能なプロファイルです。各プロファイルは、それぞれ個別で設定されます。</p>
<!-- Cargo has two main profiles: the `dev` profile Cargo uses when you run `cargo -->
<!-- build` and the `release` profile Cargo uses when you run `cargo build -->
<!-- --release`. The `dev` profile is defined with good defaults for development, -->
<!-- and the `release` profile has good defaults for release builds. -->
<p>Cargoには2つの主なプロファイルが存在します: <code>dev</code>プロファイルは、<code>cargo build</code>コマンドを実行したときに使用され、
<code>release</code>プロファイルは、<code>cargo build --release</code>コマンドを実行したときに使用されます。
<code>dev</code>プロファイルは、開発中に役に立つデフォルト設定がなされており、<code>release</code>プロファイルは、
リリース用の設定がなされています。</p>
<!-- These profile names might be familiar from the output of your builds: -->
<p>これらのプロファイル名は、ビルドの出力で馴染みのあるものかもしれません:</p>
<pre><code class="language-text">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
</code></pre>
<!-- The `dev` and `release` shown in this build output indicate that the compiler -->
<!-- is using different profiles. -->
<p>このビルド出力で表示されている<code>dev</code>と<code>release</code>は、コンパイラが異なるプロファイルを使用していることを示しています。</p>
<!-- Cargo has default settings for each of the profiles that apply when there -->
<!-- aren’t any `[profile.*]` sections in the project’s *Cargo.toml* file. By adding -->
<!-- `[profile.*]` sections for any profile you want to customize, you can override -->
<!-- any subset of the default settings. For example, here are the default values -->
<!-- for the `opt-level` setting for the `dev` and `release` profiles: -->
<p>プロジェクトの<em>Cargo.toml</em>ファイルに<code>[profile.*]</code>セクションが存在しない際に適用される各プロファイル用のデフォルト設定が、
Cargoには存在します。カスタマイズしたいプロファイル用の<code>[profile.*]</code>セクションを追加することで、
デフォルト設定の一部を上書きすることができます。例えば、こちらが<code>dev</code>と<code>release</code>プロファイルの<code>opt-level</code>設定のデフォルト値です:</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<!-- 4行目、最後、唯一の理由と言っているのは、the reasonになっているから -->
<!-- The `opt-level` setting controls the number of optimizations Rust will apply to -->
<!-- your code with a range of 0 to 3. Applying more optimizations extends -->
<!-- compiling time, so if you’re in development and compiling your code often, -->
<!-- you’ll want faster compiling even if the resulting code runs slower. That is -->
<!-- the reason the default `opt-level` for `dev` is `0`. When you’re ready to -->
<!-- release your code, it’s best to spend more time compiling. You’ll only compile -->
<!-- in release mode once, but you’ll run the compiled program many times, so -->
<!-- release mode trades longer compile time for code that runs faster. That is why -->
<!-- the default `opt-level` for the `release` profile is `3`. -->
<p><code>opt-level</code>設定は、0から3の範囲でコンパイラがコードに適用する最適化の度合いを制御します。
最適化を多くかけると、コンパイル時間が延びるので、開発中に頻繁にコードをコンパイルするのなら、
たとえ出力結果のコードの動作速度が遅くなっても早くコンパイルが済んでほしいですよね。
これが、<code>dev</code>の<code>opt-level</code>のデフォルト設定が<code>0</code>になっている唯一の理由です。
コードのリリース準備ができたら、より長い時間をコンパイルにかけるのが最善の策です。
リリースモードでコンパイルするのはたった1回ですが、コンパイル結果のプログラムは何度も実行するので、
リリースモードでは、長いコンパイル時間と引き換えに、生成したコードが速く動作します。
これが<code>release</code>の<code>opt-level</code>のデフォルト設定が<code>3</code>になっている唯一の理由です。</p>
<!-- You can override any default setting by adding a different value for it in -->
<!-- *Cargo.toml*. For example, if we want to use optimization level 1 in the -->
<!-- development profile, we can add these two lines to our project’s *Cargo.toml* -->
<!-- file: -->
<p>デフォルト設定に対して<code>Cargo.toml</code>で異なる値を追加すれば、上書きすることができます。
例として、開発用プロファイルで最適化レベル1を使用したければ、以下の2行をプロジェクトの<em>Cargo.toml</em>ファイルに追加できます:</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<!-- This code overrides the default setting of `0`. Now when we run `cargo build`, -->
<!-- Cargo will use the defaults for the `dev` profile plus our customization to -->
<!-- `opt-level`. Because we set `opt-level` to `1`, Cargo will apply more -->
<!-- optimizations than the default, but not as many as in a release build. -->
<p>このコードは、デフォルト設定の<code>0</code>を上書きします。こうすると、<code>cargo build</code>を実行したときに、
<code>dev</code>プロファイル用のデフォルト設定に加えて、Cargoは<code>opt-level</code>の変更を適用します。
<code>opt-level</code>を<code>1</code>に設定したので、Cargoはデフォルトよりは最適化を行いますが、リリースビルドほどではありません。</p>
<!-- For the full list of configuration options and defaults for each profile, see -->
<!-- [Cargo’s documentation](https://doc.rust-lang.org/cargo/). -->
<p>設定の選択肢と各プロファイルのデフォルト設定の一覧は、<a href="https://doc.rust-lang.org/cargo/">Cargoのドキュメンテーション</a>を参照されたし。</p>
<!-- ## Publishing a Crate to Crates.io -->
<a class="header" href="print.html#cratesioにクレートを公開する" id="cratesioにクレートを公開する"><h2>Crates.ioにクレートを公開する</h2></a>
<!-- We’ve used packages from [crates.io](https://crates.io) as -->
<!-- dependencies of our project, but you can also share your code with other people -->
<!-- by publishing your own packages. The crate registry at -->
<!-- [crates.io](https://crates.io) distributes the source code of -->
<!-- your packages, so it primarily hosts code that is open source. -->
<p>プロジェクトの依存として<a href="https://crates.io">crates.io</a>のパッケージを使用しましたが、
自分のパッケージを公開することで他の人とコードを共有することもできます。
<a href="https://crates.io">crates.io</a>のクレート登録所は、自分のパッケージのソースコードを配布するので、
主にオープンソースのコードをホストします。</p>
<!-- Rust and Cargo have features that help make your published package easier for -->
<!-- people to use and to find in the first place. We’ll talk about some of these -->
<!-- features next and then explain how to publish a package. -->
<p>RustとCargoは、公開したパッケージを人が使用し、まず見つけやすくしてくれる機能を有しています。
これらの機能の一部を次に語り、そして、パッケージの公開方法を説明します。</p>
<!-- ### Making Useful Documentation Comments -->
<a class="header" href="print.html#a役に立つドキュメンテーションコメントを行う" id="a役に立つドキュメンテーションコメントを行う"><h3>役に立つドキュメンテーションコメントを行う</h3></a>
<!-- Accurately documenting your packages will help other users know how and when to -->
<!-- use them, so it’s worth investing the time to write documentation. In Chapter -->
<!-- 3, we discussed how to comment Rust code using two slashes, `//`. Rust also has -->
<!-- a paticular kind of comment for documentation, known conveniently as -->
<!-- a *documentation comment*, that will generate HTML documentation. The HTML -->
<!-- displays the contents of documentation comments for public API items intended -->
<!-- for programmers interested in knowing how to *use* your crate as opposed to how -->
<!-- your crate is *implemented*. -->
<p>パッケージを正確にドキュメントすることで、他のユーザがパッケージを使用する方法や、いつ使用すべきかを理解する手助けをすることになるので、
ドキュメンテーションを書くことに時間を費やす価値があります。第3章で、2スラッシュ、<code>//</code>でRustのコードにコメントをつける方法を議論しました。
Rustには、ドキュメンテーション用のコメントも用意されていて、都合のいいことに<em>ドキュメンテーションコメント</em>として知られ、
HTMLドキュメントを生成します。クレートの<em>実装</em>法とは対照的にクレートの<em>使用</em>法を知ることに興味のあるプログラマ向けの、
公開API用のドキュメンテーションコメントの中身をこのHTMLは表示します。</p>
<!-- Documentation comments use three slashes, `///`, instead of two and support -->
<!-- Markdown notation for formatting the text. Place documentation comments just -->
<!-- before the item they’re documenting. Listing 14-1 shows documentation comments -->
<!-- for an `add_one` function in a crate named `my_crate`: -->
<p>ドキュメンテーションコメントは、2つではなく、3スラッシュ、<code>///</code>を使用し、テキストを整形するMarkdown記法もサポートしています。
ドキュメント対象の要素の直前にドキュメンテーションコメントを配置してください。
リスト14-1は、<code>my_crate</code>という名のクレートの<code>add_one</code>関数用のドキュメンテーションコメントを示しています:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// 与えられた数値に1を足す。
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, my_crate::add_one(5));
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<!-- <span class="caption">Listing 14-1: A documentation comment for a -->
<!-- function</span> -->
<p><span class="caption">リスト14-1: 関数のドキュメンテーションコメント</span></p>
<!-- Here, we give a description of what the `add_one` function does, start a -->
<!-- section with the heading `Examples`, and then provide code that demonstrates -->
<!-- how to use the `add_one` function. We can generate the HTML documentation from -->
<!-- this documentation comment by running `cargo doc`. This command runs the -->
<!-- `rustdoc` tool distributed with Rust and puts the generated HTML documentation -->
<!-- in the *target/doc* directory. -->
<p>ここで、<code>add_one</code>関数がすることの説明を与え、<code>Examples</code>というタイトルでセクションを開始し、
<code>add_one</code>関数の使用法を模擬するコードを提供しています。このドキュメンテーションコメントから<code>cargo doc</code>を実行することで、
HTMLドキュメントを生成することができます。このコマンドはコンパイラとともに配布されている<code>rustdoc</code>ツールを実行し、
生成されたHTMLドキュメントを<em>target/doc</em>ディレクトリに配置します。</p>
<!-- For convenience, running `cargo doc --open` will build the HTML for your -->
<!-- current crate’s documentation (as well as the documentation for all of your -->
<!-- crate’s dependencies) and open the result in a web browser. Navigate to the -->
<!-- `add_one` function and you’ll see how the text in the documentation comments is -->
<!-- rendered, as shown in Figure 14-1: -->
<p>利便性のために、<code>cargo doc --open</code>を走らせれば、現在のクレートのドキュメント用のHTML(と、
自分のクレートが依存している全てのドキュメント)を構築し、その結果をWebブラウザで開きます。
<code>add_one</code>関数まで下り、図14-1に示したように、ドキュメンテーションコメントのテキストがどう描画されるかを確認しましょう:</p>
<!-- <img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" /> -->
<p><img alt="`my_crate`の`add_one`関数の描画済みのHTMLドキュメント" src="img/trpl14-01.png" class="center" /></p>
<!-- <span class="caption">Figure 14-1: HTML documentation for the `add_one` -->
<!-- function</span> -->
<p><span class="caption">図14-1: <code>add_one</code>関数のHTMLドキュメント</span></p>
<!-- #### Commonly Used Sections -->
<a class="header" href="print.html#aよく使われるセクション" id="aよく使われるセクション"><h4>よく使われるセクション</h4></a>
<!-- We used the `# Examples` Markdown heading in Listing 14-1 to create a section -->
<!-- in the HTML with the title “Examples.” Here are some other sections that crate -->
<!-- authors commonly use in their documentation: -->
<p><code># Examples</code>マークダウンのタイトルをリスト14-1で使用し、「例」というタイトルのセクションをHTMLに生成しました。
こちらがこれ以外にドキュメントでよくクレート筆者が使用するセクションです:</p>
<!-- * **Panics**: The scenarios in which the function being documented could -->
<!--   `panic!`. Callers of the function who don’t want their programs to panic should -->
<!--   make sure they don’t call the function in these situations. -->
<!-- * **Errors**: If the function returns a `Result`, describing the kinds of -->
<!--   errors that might occur and what conditions might cause those errors to be -->
<!--   returned can be helpful to callers so they can write code to handle the -->
<!--   different kinds of errors in different ways. -->
<!-- * **Safety**: If the function is `unsafe` to call (we discuss unsafety in -->
<!--   Chapter 19), there should be a section explaining why the function is unsafe -->
<!--   and covering the invariants that the function expects callers to uphold. -->
<ul>
<li><strong>Panics</strong>: ドキュメント対象の関数が<code>panic!</code>する可能性のある筋書きです。プログラムをパニックさせたくない関数の使用者は、
これらの状況で関数が呼ばれないことを確かめる必要があります。</li>
<li><strong>Errors</strong>: 関数が<code>Result</code>を返すなら、起きうるエラーの種類とどんな条件がそれらのエラーを引き起こす可能性があるのか解説すると、
呼び出し側の役に立つので、エラーの種類によって処理するコードを変えて書くことができます。</li>
<li><strong>Safety</strong>: 関数が呼び出すのに<code>unsafe</code>(unsafeについては第19章で議論します)なら、
関数がunsafeな理由を説明し、関数が呼び出し元に保持していると期待する不変条件を講義するセクションがあるべきです。</li>
</ul>
<!-- Most documentation comments don’t need all of these sections, but this is a -->
<!-- good checklist to remind you of the aspects of your code that people calling -->
<!-- your code will be interested in knowing about. -->
<p>多くのドキュメンテーションコメントでは、これら全てのセクションが必要になることはありませんが、
これは自分のコードを呼び出している人が知りたいと思うコードの方向性を思い出させてくれるいいチェックリストになります。</p>
<!-- #### Documentation Comments as Tests -->
<a class="header" href="print.html#aテストとしてのドキュメンテーションコメント" id="aテストとしてのドキュメンテーションコメント"><h4>テストとしてのドキュメンテーションコメント</h4></a>
<!-- Adding example code blocks in your documentation comments can help demonstrate -->
<!-- how to use your library, and doing so has an additional bonus: running `cargo -->
<!-- test` will run the code examples in your documentation as tests! Nothing is -->
<!-- better than documentation with examples. But nothing is worse than examples -->
<!-- that don’t work because the code has changed since the documentation was -->
<!-- written. If we run `cargo test` with the documentation for the `add_one` -->
<!-- function from Listing 14-1, we will see a section in the test results like this: -->
<p>ドキュメンテーションコメントに例のコードブロックを追加すると、ライブラリの使用方法のデモに役立ち、
おまけもついてきます: <code>cargo test</code>を走らせると、ドキュメントのコード例をテストとして実行するのです！
例付きのドキュメントに上回るものはありません。しかし、ドキュメントが書かれてからコードが変更されたがために、
動かない例がついているよりも悪いものもありません。リスト14-1から<code>add_one</code>関数のドキュメンテーションとともに、
<code>cargo test</code>を走らせたら、テスト結果に以下のような区域が見られます:</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- 2行目最後、catch that S Vの用法は辞書に載っていなかった。Oxfordには載っているのかもしれません -->
<!-- Now if we change either the function or the example so the `assert_eq!` in the -->
<!-- example panics and run `cargo test` again, we’ll see that the doc tests catch -->
<!-- that the example and the code are out of sync from one another! -->
<p>さて、例の<code>assert_eq!</code>がパニックするように、関数か例を変更し、再度<code>cargo test</code>を実行したら、
docテストが、例とコードがお互いに同期されていないことを捕捉するところを目撃するでしょう！</p>
<!-- #### Commenting Contained Items -->
<a class="header" href="print.html#a含まれている要素にコメントする" id="a含まれている要素にコメントする"><h4>含まれている要素にコメントする</h4></a>
<!-- Another style of doc comment, `//!`, adds documentation to the item that -->
<!-- contains the comments rather than adding documentation to the items following -->
<!-- the comments. We typically use these doc comments inside the crate root file -->
<!-- (*src/lib.rs* by convention) or inside a module to document the crate or the -->
<!-- module as a whole. -->
<p>docコメントの別スタイル、<code>//!</code>は、コメントに続く要素にドキュメンテーションを付け加えるのではなく、
コマンドを含む要素にドキュメンテーションを付け加えます。典型的には、クレートのルートファイル(規定では、<em>src/lib.rs</em>)内部や、
モジュールの内部で使用して、クレートやモジュール全体にドキュメントをつけます。</p>
<!-- For example, if we want to add documentation that describes the purpose of the -->
<!-- `my_crate` crate that contains the `add_one` function, we can add documentation -->
<!-- comments that start with `//!` to the beginning of the *src/lib.rs* file, as -->
<!-- shown in Listing 14-2: -->
<p>例えば、<code>add_one</code>関数を含む<code>my_crate</code>クレートの目的を解説するドキュメンテーションを追加したいのなら、
<code>//!</code>で始まるドキュメンテーションコメントを<em>src/lib.rs</em>ファイルの先頭につけることができます。
リスト14-2に示したようにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

//! #自分のクレート
//!
//! `my_crate`は、ユーティリティの集まりであり、特定の計算をより便利に行うことができます。

/// Adds one to the number given.
// --snip--
</code></pre>
<!-- <span class="caption">Listing 14-2: Documentation for the `my_crate` crate as a -->
<!-- whole</span> -->
<p><span class="caption">リスト14-2: 全体として<code>my_crate</code>クレートにドキュメントをつける</span></p>
<!-- Notice there isn’t any code after the last line that begins with `//!`. Because -->
<!-- we started the comments with `//!` instead of `///`, we’re documenting the item -->
<!-- that contains this comment rather than an item that follows this comment. In -->
<!-- this case, the item that contains this comment is the *src/lib.rs* file, which -->
<!-- is the crate root. These comments describe the entire crate. -->
<p><code>//!</code>で始まる最後の行以降には、コードが何もないことに気付いてください。<code>///</code>ではなく、<code>//!</code>でコメントを開始しているので、
このコメントに続く要素ではなく、このコメントを含む要素にドキュメントをつけているわけです。
今回の場合、このコメントを含む要素は<em>src/lib.rs</em>ファイルであり、クレートのルートです。
これらのコメントは、クレート全体を解説しています。</p>
<!-- When we run `cargo doc --open`, these comments will display on the front -->
<!-- page of the documentation for `my_crate` above the list of public items in the -->
<!-- crate, as shown in Figure 14-2: -->
<p><code>cargo doc --open</code>を実行すると、これらのコメントは、<code>my_crate</code>のドキュメントの最初のページ、
クレートの公開要素のリストの上部に表示されます。図14-2のようにですね:</p>
<!-- <img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" /> -->
<p><img alt="クレート全体のコメント付きの描画済みHTMLドキュメンテーション" src="img/trpl14-02.png" class="center" /></p>
<!-- <span class="caption">Figure 14-2: Rendered documentation for `my_crate`, -->
<!-- including the comment describing the crate as a whole</span> -->
<p><span class="caption">図14-2: クレート全体を解説するコメントを含む<code>my_crate</code>の描画されたドキュメンテーション</span></p>
<!-- Documentation comments within items are useful for describing crates and -->
<!-- modules especially. Use them to explain the overall purpose of the container to -->
<!-- help your crate users understand the crate’s organization. -->
<p>要素内のドキュメンテーションコメントは、特にクレートやモジュールを解説するのに有用です。
コンテナの全体の目的を説明し、クレートの使用者がクレートの体系を理解する手助けをするのに使用してください。</p>
<!-- ### Exporting a Convenient Public API with `pub use` -->
<a class="header" href="print.html#pub-useで便利な公開apiをエクスポートする" id="pub-useで便利な公開apiをエクスポートする"><h3><code>pub use</code>で便利な公開APIをエクスポートする</h3></a>
<!-- In Chapter 7, we covered how to organize our code into modules using the `mod` -->
<!-- keyword, how to make items public using the `pub` keyword, and how to bring -->
<!-- items into a scope with the `use` keyword. However, the structure that makes -->
<!-- sense to you while you’re developing a crate might not be very convenient for -->
<!-- your users. You might want to organize your structs in a hierarchy containing -->
<!-- multiple levels, but then people who want to use a type you’ve defined deep in -->
<!-- the hierarchy might have trouble finding out that type exists. They might also -->
<!-- be annoyed at having to enter `use` -->
<!-- `my_crate::some_module::another_module::UsefulType;` rather than `use` -->
<!-- `my_crate::UsefulType;`. -->
<p>第7章において、<code>mod</code>キーワードを使用してモジュールにコードを体系化する方法、<code>pub</code>キーワードで要素を公開にする方法、
<code>use</code>キーワードで要素をスコープに導入する方法について講義しました。しかしながら、クレートの開発中に、
自分にとって意味のある構造は、ユーザにはあまり便利ではない可能性があります。複数階層を含むヒエラルキーで、
自分の構造体を体系化したくなるかもしれませんが、それからヒエラルキーの深いところで定義した型を使用したい人は、
型が存在することを見つけ出すのに困難を伴う可能性もあります。また、そのような人は、
<code>use my_crate::UsefulType</code>の代わりに<code>use my_crate::some_module::another_module::UsefulType;</code>と入力するのを煩わしく感じる可能性もあります。</p>
<!-- The structure of your public API is a major consideration when publishing a -->
<!-- crate. People who use your crate are less familiar with the structure than you -->
<!-- are and might have difficulty finding the pieces they want to use if your crate -->
<!-- has a large module hierarchy. -->
<p>自分の公開APIの構造は、クレートを公開する際に考慮すべき点です。自分のクレートを使用したい人は、
自分よりもその構造に馴染みがないですし、クレートのモジュール階層が大きければ、使用したい部分を見つけるのが困難になる可能性があります。</p>
<!-- The good news is that if the structure *isn’t* convenient for others to use -->
<!-- from another library, you don’t have to rearrange your internal organization: -->
<!-- instead, you can re-export items to make a public structure that’s different -->
<!-- than your private structure by using `pub use`. Re-exporting takes a public -->
<!-- item in one location and makes it public in another location, as if it ware -->
<!-- defined in the other location instead. -->
<p>嬉しいお知らせは、構造が他人が他のライブラリから使用するのに便利では<em>ない</em>場合、内部的な体系を再構築する必要はないということです:
代わりに、要素を再エクスポートし、<code>pub use</code>で自分の非公開構造とは異なる公開構造にできます。
再エクスポートは、ある場所の公開要素を一つ取り、別の場所で定義されているかのように別の場所で公開します。</p>
<!-- For example, say we made a library named `art` for modeling artistic concepts. -->
<!-- Within this library are two modules: a `kinds` module containing two enums -->
<!-- named `PrimaryColor` and `SecondaryColor` and a `utils` module containing a -->
<!-- function named `mix`, as shown in Listing 14-3: -->
<p>例えば、芸術的な概念をモデル化するために<code>art</code>という名のライブラリを作ったとしましょう。
このライブラリ内には、2つのモジュールがあります: <code>PrimaryColor</code>と<code>SecondaryColor</code>という名前の2つのeunmを含む、
<code>kinds</code>モジュールと<code>mix</code>という関数を含む<code>utils</code>モジュールです。リスト14-3のようにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.
//! #芸術
//!
//! 芸術的な概念をモデル化するライブラリ。

pub mod kinds {
    /// The primary colors according to the RYB color model.
    /// RYBカラーモデルによる主色
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    /// RYBカラーモデルによる副色
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    ///2つの主色を同じ割合で混合し、副色にする
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
    }
}
</code></pre>
<!-- <span class="caption">Listing 14-3: An `art` library with items organized into -->
<!-- `kinds` and `utils` modules</span> -->
<p><span class="caption">リスト14-3: <code>kinds</code>と<code>utils</code>モジュールに体系化される要素を含む<code>art</code>ライブラリ</span></p>
<!-- Figure 14-3 shows what the front page of the documentation for this crate -->
<!-- generated by `cargo doc` would look like: -->
<p>図14-3は、<code>cargo doc</code>により生成されるこのクレートのドキュメンテーションの最初のページがどんな見た目になるか示しています:</p>
<!-- <img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" /> -->
<p><img alt="`kinds`と`utils`モジュールを列挙する`art`クレートの描画されたドキュメンテーション" src="img/trpl14-03.png" class="center" /></p>
<!-- <span class="caption">Figure 14-3: Front page of the documentation for `art` -->
<!-- that lists the `kinds` and `utils` modules</span> -->
<p><span class="caption">図14-3: <code>kinds</code>と<code>utils</code>モジュールを列挙する<code>art</code>のドキュメンテーションのトップページ</span></p>
<!-- Note that the `PrimaryColor` and `SecondaryColor` types aren’t listed on the -->
<!-- front page, nor is the `mix` function. We have to click `kinds` and `utils` to -->
<!-- see them. -->
<p><code>PrimaryColor</code>も<code>SecondaryColor</code>型も、<code>mix</code>関数もトップページには列挙されていないことに注意してください。
<code>kinds</code>と<code>utils</code>をクリックしなければ、参照することができません。</p>
<!-- Another crate that depends on this library would need `use` statements that -->
<!-- import the items from `art`, specifying the module structure that’s currently -->
<!-- defined. Listing 14-4 shows an example of a crate that uses the `PrimaryColor` -->
<!-- and `mix` items from the `art` crate: -->
<p>このライブラリに依存する別のクレートは、現在定義されているモジュール構造を指定して、
<code>art</code>の要素をインポートする<code>use</code>文が必要になるでしょう。リスト14-4は、
<code>art</code>クレートから<code>PrimaryColor</code>と<code>mix</code>要素を使用するクレートの例を示しています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<!-- <span class="caption">Listing 14-4: A crate using the `art` crate’s items with -->
<!-- its internal structure exported</span> -->
<p><span class="caption">リスト14-4: 内部構造もエクスポートされて<code>art</code>クレートの要素を使用するクレート</span></p>
<!-- The author of the code in Listing 14-4, which uses the `art` crate, had to -->
<!-- figure out that `PrimaryColor` is in the `kinds` module and `mix` is in the -->
<!-- `utils` module. The module structure of the `art` crate is more relevant to -->
<!-- developers working on the `art` crate than to developers using the `art` crate. -->
<!-- The internal structure that organizes parts of the crate into the `kinds` -->
<!-- module and the `utils` module doesn’t contain any useful information for -->
<!-- someone trying to understand how to use the `art` crate. Instead, the `art` -->
<!-- crate’s module structure causes confusion because developers have to figure out -->
<!-- where to look, and the structure is inconvenient because developers must -->
<!-- specify the module names in the `use` statements. -->
<p>リスト14-4は<code>art</code>クレートを使用していますが、このコードの筆者は、<code>PrimaryColor</code>が<code>kinds</code>モジュールにあり、
<code>mix</code>が<code>utils</code>モジュールにあることを割り出さなければなりませんでした。<code>art</code>クレートのモジュール構造は、
<code>art</code>クレートの使用者よりも、<code>art</code>クレートに取り組む開発者などに関係が深いです。
クレートの一部を<code>kinds</code>モジュールと<code>utils</code>モジュールに体系化する内部構造は、<code>art</code>クレートの使用方法を理解しようとする人には、
何も役に立つ情報を含んでいません。代わりに、開発者がどこを見るべきか割り出す必要があるので、
<code>art</code>クレートのモジュール構造は混乱を招き、また、開発者はモジュール名を<code>use</code>文で指定しなければならないので、
この構造は不便です。</p>
<!-- To remove the internal organization from the public API, we can modify the -->
<!-- `art` crate code in Listing 14-3 to add `pub use` statements to re-export the -->
<!-- items at the top level, as shown in Listing 14-5: -->
<p>公開APIから内部体系を除去するために、リスト14-3の<code>art</code>クレートコードを変更し、<code>pub use</code>文を追加して、
最上位で要素を再エクスポートすることができます。リスト14-5みたいにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use kinds::PrimaryColor;
pub use kinds::SecondaryColor;
pub use utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
</code></pre>
<!-- <span class="caption">Listing 14-5: Adding `pub use` statements to re-export -->
<!-- items</span> -->
<p><span class="caption">リスト14-5: <code>pub use</code>文を追加して要素を再エクスポートする</span></p>
<!-- The API documentation that `cargo doc` generates for this crate will now list -->
<!-- and link re-exports on the front page, as shown in Figure 14-4, making the -->
<!-- `PrimaryColor` and `SecondaryColor` types and the `mix` function easier to find. -->
<p>このクレートに対して<code>cargo doc</code>が生成するAPIドキュメンテーションは、これで図14-4のようにトップページに再エクスポートを列挙しリンクするので、
<code>PrimaryColor</code>と<code>SecondaryColor</code>型と<code>mix</code>関数を見つけやすくします。</p>
<!-- <img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" /> -->
<p><img alt="トップページに再エクスポートのある`art`クレートの描画されたドキュメンテーション" src="img/trpl14-04.png" class="center" /></p>
<!-- <span class="caption">Figure 14-4: The front page of the documentation for `art` -->
<!-- that lists the re-exports</span> -->
<p><span class="caption">図14-4: 再エクスポートを列挙する<code>art</code>のドキュメンテーションのトップページ</span></p>
<!-- The `art` crate users can still see and use the internal structure from Listing -->
<!-- 14-3 as demonstrated in Listing 14-4, or they can use the more convenient -->
<!-- structure in Listing 14-5, as shown in Listing 14-6: -->
<p><code>art</code>クレートのユーザは、それでも、リスト14-4にデモされているように、リスト14-3の内部構造を見て使用することもできますし、
リスト14-5のより便利な構造を使用することもできます。リスト14-6に示したようにですね:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
}
</code></pre>
<!-- <span class="caption">Listing 14-6: A program using the re-exported items from -->
<!-- the `art` crate</span> -->
<p><span class="caption">リスト14-6: <code>art</code>クレートの再エクスポートされた要素を使用するプログラム</span></p>
<!-- In cases where there are many nested modules, re-exporting the types at the top -->
<!-- level with `pub use` can make a significant difference in the experience of -->
<!-- people who use the crate. -->
<p>ネストされたモジュールがたくさんあるような場合、最上位階層で<code>pub use</code>により型を再エクスポートすることは、
クレートの使用者の経験に大きな違いを生みます。</p>
<!-- Creating a useful public API structure is more of an art than a science, and -->
<!-- you can iterate to find the API that works best for your users. Choosing `pub -->
<!-- use` gives you flexibility in how you structure your crate internally and -->
<!-- decouples that internal structure from what you present to your users. Look at -->
<!-- some of the code of crates you’ve installed to see if their internal structure -->
<!-- differs from their public API. -->
<p>役に立つAPI構造を作ることは、科学というよりも芸術の領域であり、ユーザにとって何が最善のAPIなのか、
探求するために繰り返してみることができます。<code>pub use</code>は、内部的なクレート構造に柔軟性をもたらし、
その内部構造をユーザに提示する構造から切り離してくれます。インストールしてある他のクレートを見て、
内部構造が公開APIと異なっているか確認してみてください。</p>
<!-- ### Setting Up a Crates.io Account -->
<a class="header" href="print.html#cratesioのアカウントをセットアップする" id="cratesioのアカウントをセットアップする"><h3>Crates.ioのアカウントをセットアップする</h3></a>
<!-- Before you can publish any crates, you need to create an account on -->
<!-- [crates.io](https://crates.io) and get an API token. To do so, -->
<!-- visit the home page at [crates.io](https://crates.io) and log in -->
<!-- via a GitHub account. (The GitHub account is currently a requirement, but the -->
<!-- site might support other ways of creating an account in the future.) Once -->
<!-- you're logged in, visit your account settings at -->
<!-- [https://crates.io/me/](https://crates.io/me/) and retrieve your -->
<!-- API key. Then run the `cargo login` command with your API key, like this: -->
<p>クレートを公開する前に、<a href="https://crates.io">crates.io</a>のアカウントを作成し、
APIトークンを取得する必要があります。そうするには、<a href="https://crates.io">crates.io</a>のホームページを訪れ、
Githubアカウントでログインしてください。(現状は、Githubアカウントがなければなりませんが、
いずれは他の方法でもアカウントを作成できるようになる可能性があります。)ログインしたら、
<a href="https://crates.io/me/">https://crates.io/me/</a>で自分のアカウントの設定に行き、
APIキーを取り扱ってください。そして、<code>cargo login</code>コマンドをAPIキーとともに実行してください。
以下のようにですね:</p>
<pre><code class="language-text">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<!-- This command will inform Cargo of your API token and store it locally in -->
<!-- *~/.cargo/credentials*. Note that this token is a *secret*: do not share it -->
<!-- with anyone else. If you do share it with anyone for any reason, you should -->
<!-- revoke it and generate a new token on [crates.io](https://crates.io)-->
<p>このコマンドは、CargoにAPIトークンを知らせ、<em>~/.cargo/credentials</em>にローカルに保存します。
このトークンは、<em>秘密</em>です: 他人とは共有しないでください。なんらかの理由で他人と共有してしまったら、
古いものを破棄して<a href="https://crates.io">crates.io</a>で新しいトークンを生成するべきです。</p>
<!-- ### Adding Metadata to a New Crate -->
<a class="header" href="print.html#a新しいクレートにメタデータを追加する" id="a新しいクレートにメタデータを追加する"><h3>新しいクレートにメタデータを追加する</h3></a>
<!-- Now that you have an account, let’s say you have a crate you want to publish. -->
<!-- Before publishing, you’ll need to add some metadata to your crate by adding it -->
<!-- to the `[package]` section of the crate’s *Cargo.toml* file. -->
<p>アカウントはできたので、公開したいクレートがあるとしましょう。公開前に、
<em>Cargo.toml</em>ファイルの<code>[package]</code>セクションに追加することでクレートにメタデータを追加する必要があるでしょう。</p>
<!-- Your crate will need a unique name. While you’re working on a crate locally, -->
<!-- you can name a crate whatever you’d like. However, crate names on -->
<!-- [crates.io](https://crates.io) are allocated on a first-come, -->
<!-- first-served basis. Once a crate name is taken, no one else can publish a crate -->
<!-- with that name. Search for the name you want to use on the site to find out -->
<!-- whether it has been used. If it hasn’t, edit the name in the *Cargo.toml* file -->
<!-- under `[package]` to use the name for publishing, like so: -->
<p>クレートには、独自の名前が必要でしょう。クレートをローカルで作成している間、
クレートの名前はなんでもいい状態でした。ところが、<a href="https://crates.io">crates.io</a>のクレート名は、
最初に来たもの勝ちの精神で付与されていますので、一旦クレート名が取られてしまったら、
その名前のクレートを他の人が公開することは絶対できません。もう使われているか、
サイトで使いたい名前を検索してください。まだなら、<em>Cargo.toml</em>ファイルの<code>[package]</code>以下の名前を編集して、
名前を公開用に使ってください。以下のように:</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<!-- Even if you’ve chosen a unique name, when you run `cargo publish` to publish -->
<!-- the crate at this point, you’ll get a warning and then an error: -->
<p>たとえ、独自の名前を選択していたとしても、この時点で<code>cargo publish</code>を実行すると、警告とエラーが出ます:</p>
<pre><code class="language-text">$ cargo publish
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: manifest has no description, license, license-file, documentation,
homepage or repository.
(警告: マニフェストに説明、ライセンス、ライセンスファイル、ドキュメンテーション、ホームページ、
リポジトリのいずれかがありません)
--snip--
error: api errors: missing or empty metadata fields: description, license.
(エラー: APIエラー: 存在しないメタデータフィールド: description, license)
</code></pre>
<!-- The reason is that you’re missing some crucial information: a description and -->
<!-- license are required so people will know what your crate does and under what -->
<!-- terms they can use it. To rectify this error, you need to include this -->
<!-- information in the *Cargo.toml* file. -->
<p>原因は、大事な情報を一部入れていないからです: 説明とライセンスは、
他の人が自分のクレートは何をし、どんな条件の元で使っていいのかを知るために必要なのです。
このエラーを解消するには、<em>Cargo.toml</em>ファイルにこの情報を入れ込む必要があります。</p>
<!-- Add a description that is just a sentence or two, because it will appear with -->
<!-- your crate in search results. For the `license` field, you need to give a -->
<!-- *license identifier value*. The [Linux Foundation’s Software Package Data -->
<!-- Exchange (SPDX)][spdx] lists the identifiers you can use for this value. For -->
<!-- example, to specify that you’ve licensed your crate using the MIT License, add -->
<!-- the `MIT` identifier: -->
<p>1文か2文程度の説明をつけてください。これは、検索結果に表示されますからね。
<code>license</code>フィールドには、<em>ライセンス識別子</em>を与える必要があります。
<a href="http://spdx.org/licenses/">Linux団体のSoftware Package Data Exchange(SPDX)</a>に、この値に使用できる識別子が列挙されています。
例えば、自分のクレートをMITライセンスでライセンスするためには、
<code>MIT</code>識別子を追加してください:</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<!-- If you want to use a license that doesn’t appear in the SPDX, you need to place -->
<!-- the text of that license in a file, include the file in your project, and then -->
<!-- use `license-file` to specify the name of that file instead of using the -->
<!-- `license` key. -->
<p>SPDXに出現しないライセンスを使用したい場合、そのライセンスをファイルに配置し、
プロジェクトにそのファイルを含め、それから<code>license</code>キーを使う代わりに、
そのファイルの名前を指定するのに<code>license-file</code>を使う必要があります。</p>
<!-- Guidance on which license is appropriate for your project is beyond the scope -->
<!-- of this book. Many people in the Rust community license their projects in the -->
<!-- same way as Rust by using a dual license of `MIT OR Apache-2.0`. This practice -->
<!-- demonstrates that you can also specify multiple license identifiers separated -->
<!-- by `OR` to have multiple licenses for your project. -->
<p>どのライセンスが自分のプロジェクトに<ruby>相<rp>(</rp><rt>ふ</rt><rp>)</rp>応<rp>(</rp><rt>さわ</rt><rp>)</rp></ruby>しいというガイドは、
この本の範疇を超えています。Rustコミュニティの多くの人間は、<code>MIT OR Apache-2.0</code>のデュアルライセンスを使用することで、
Rust自体と同じようにプロジェクトをライセンスします。この実践は、<code>OR</code>で区切られる複数のライセンス識別子を指定して、
プロジェクトに複数のライセンスを持たせることもできることを模擬しています。</p>
<!-- With a unique name, the version, the author details that `cargo new` added -->
<!-- when you created the crate, your description, and a license added, the -->
<!-- *Cargo.toml* file for a project that is ready to publish might look like this: -->
<p>独自の名前、バージョン、クレート作成時に<code>cargo new</code>が追加した筆者の詳細、説明、ライセンスが追加され、
公開準備のできたプロジェクト用の<code>Cargo.toml</code>ファイルは以下のような見た目になっていることでしょう:</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
              (コンピュータが選択した数字を言い当てる面白いゲーム)
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<!-- [Cargo’s documentation](https://doc.rust-lang.org/cargo/) describes other -->
<!-- metadata you can specify to ensure others can discover and use your crate more -->
<!-- easily. -->
<p><a href="https://doc.rust-lang.org/cargo">Cargoのドキュメンテーション</a>には、
指定して他人が発見しより容易くクレートを使用できることを保証する他のメタデータが解説されています。</p>
<!-- ### Publishing to Crates.io -->
<a class="header" href="print.html#cratesioに公開する" id="cratesioに公開する"><h3>Crates.ioに公開する</h3></a>
<!-- Now that you’ve created an account, saved your API token, chosen a name for -->
<!-- your crate, and specified the required metadata, you’re ready to publish! -->
<!-- Publishing a crate uploads a specific version to -->
<!-- [crates.io](https://crates.io) for others to use. -->
<p>アカウントを作成し、APIトークンを保存し、クレートの名前を決め、必要なメタデータを指定したので、
公開する準備が整いました！クレートを公開すると、特定のバージョンが、
<a href="http://crates.io">crates.io</a>に他の人が使用できるようにアップロードされます。</p>
<!-- Be careful when publishing a crate because a publish is *permanent*. The -->
<!-- version can never be overwritten, and the code cannot be deleted. One major -->
<!-- goal of [crates.io](https://crates.io) is to act as a permanent -->
<!-- archive of code so that builds of all projects that depend on crates from -->
<!-- [crates.io](https://crates.io) will continue to work. Allowing -->
<!-- version deletions would make fulfilling that goal impossible. However, there is -->
<!-- no limit to the number of crate versions you can publish. -->
<p>公開は<em>永久</em>なので、クレートの公開時には気をつけてください。バージョンは絶対に上書きできず、
コードも削除できません。<a href="https://crates.io">crates.io</a>の一つの主な目標が、
<a href="https://crates.io">crates.io</a>のクレートに依存している全てのプロジェクトのビルドが、
動き続けるようにコードの永久アーカイブとして機能することなのです。バージョン削除を可能にしてしまうと、
その目標を達成するのが不可能になってしまいます。ですが、公開できるクレートバージョンの数には制限はありません。</p>
<!-- Run the `cargo publish` command again. It should succeed now: -->
<p>再度<code>cargo publish</code>コマンドを実行してください。今度は成功するはずです:</p>
<pre><code class="language-text">$ cargo publish
 Updating registry `https://github.com/rust-lang/crates.io-index`
Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
 Finished dev [unoptimized + debuginfo] target(s) in 0.19 secs
Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<!-- Congratulations! You’ve now shared your code with the Rust community, and -->
<!-- anyone can easily add your crate as a dependency of their project. -->
<p>おめでとうございます！Rustコミュニティとコードを共有し、誰でも自分のクレートを依存として簡単に追加できます。</p>
<!-- ### Publishing a New Version of an Existing Crate -->
<a class="header" href="print.html#a既存のクレートの新バージョンを公開する" id="a既存のクレートの新バージョンを公開する"><h3>既存のクレートの新バージョンを公開する</h3></a>
<!-- When you’ve made changes to your crate and are ready to release a new version, -->
<!-- you change the `version` value specified in your *Cargo.toml* file and -->
<!-- republish. Use the [Semantic Versioning rules][semver] to decide what an -->
<!-- appropriate next version number is based on the kinds of changes you’ve made. -->
<!-- Then run `cargo publish` to upload the new version. -->
<p>クレートに変更を行い、新バージョンをリリースする準備ができたら、
<em>Cargo.toml</em>ファイルに指定された<code>version</code>の値を変更し、再公開します。
<a href="http://semver.org/">セマンティックバージョンルール</a>を使用して加えた変更の種類に基づいて次の適切なバージョン番号を決定してください。
そして、<code>cargo publish</code>を実行し、新バージョンをアップロードします。</p>
<!-- ### Removing Versions from Crates.io with `cargo yank` -->
<a class="header" href="print.html#cargo-yankでcratesioからバージョンを削除する" id="cargo-yankでcratesioからバージョンを削除する"><h3><code>cargo yank</code>でCrates.ioからバージョンを削除する</h3></a>
<!-- 最後の行。辞書には、yankingはグイっと引っ張ることとしかないが、ここでは取り下げと意訳しておく -->
<!-- Although you can’t remove previous versions of a crate, you can prevent any -->
<!-- future projects from adding them as a new dependency. This is useful when a -->
<!-- crate version is broken for one reason or another. In such situations, Cargo -->
<!-- supports *yanking* a crate version. -->
<p>以前のバージョンのクレートを削除することはできないものの、新しい依存として将来的にプロジェクトに追加することを防ぐことはできます。
ある理由により、クレートバージョンが壊れている場合に有用です。そのような場面において、
Cargoはクレートバージョンの<em>取り下げ</em>をサポートしています。</p>
<!-- Yanking a version prevents new projects from starting to depend on that version -->
<!-- while allowing all existing projects that depend on it to continue to download -->
<!-- and depend on that version. Essentially, a yank means that all projects with a -->
<!-- *Cargo.lock* will not break, and any future *Cargo.lock* files generated will -->
<!-- not use the yanked version. -->
<p>バージョンを取り下げると、他の既存のプロジェクトには、引き続きダウンロードし、そのバージョンに依存させ続けつつ、
新規プロジェクトが新しくそのバージョンに依存しだすことを防ぎます。本質的に取り下げは、
<em>Cargo.lock</em>が存在するプロジェクトは全て壊れないことを意味し、将来的に<em>Cargo.lock</em>ファイルが生成されるものは、
取り下げられたバージョンを使わないのです。</p>
<!-- To yank a version of a crate, run `cargo yank` and specify which version you -->
<!-- want to yank: -->
<p>あるバージョンのクレートを取り下げるには、<code>cargo yank</code>を実行し、取り下げたいバージョンを指定します:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1
</code></pre>
<!-- By adding `--undo` to the command, you can also undo a yank and allow projects -->
<!-- to start depending on a version again: -->
<p><code>--undo</code>をコマンドに付与することで、取り下げを取り消し、再度あるバージョンにプロジェクトを依存させ始めることもできます:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<!-- A yank *does not* delete any code. For example, the yank feature is not -->
<!-- intended for deleting accidentally uploaded secrets. If that happens, you must -->
<!-- reset those secrets immediately. -->
<p>取り下げは、コードの削除は一切し<em>ません</em>。例として、取り下げ機能は、誤ってアップロードされた秘密鍵を削除するためのものではありません。
もしそうなってしまったら、即座に秘密鍵をリセットしなければなりません。</p>
<!-- ## Cargo Workspaces -->
<a class="header" href="print.html#cargoのワークスペース" id="cargoのワークスペース"><h2>Cargoのワークスペース</h2></a>
<!-- In Chapter 12, we built a package that included a binary crate and a library -->
<!-- crate. As your project develops, you might find that the library crate -->
<!-- continues to get bigger and you want to split up your package further into -->
<!-- multiple library crates. In this situation, Cargo offers a feature called -->
<!-- *workspaces* that can help manage multiple related packages that are developed -->
<!-- in tandem. -->
<p>第12章で、バイナリクレートとライブラリクレートを含むパッケージを構築しました。プロジェクトの開発が進むにつれて、
ライブラリクレートの肥大化が続き、さらに複数のライブラリクレートにパッケージを分割したくなることでしょう。
この場面において、Cargoは<em>ワークスペース</em>という協調して開発された関連のある複数のパッケージを管理するのに役立つ機能を提供しています。</p>
<a class="header" href="print.html#creating-a-workspace" id="creating-a-workspace"><h3>Creating a Workspace</h3></a>
<a class="header" href="print.html#aワークスペースを生成する" id="aワークスペースを生成する"><h3>ワークスペースを生成する</h3></a>
<!-- A *workspace* is a set of packages that share the same *Cargo.lock* and output -->
<!-- directory. Let’s make a project using a workspace-we'll use trivial code so we -->
<!-- can concentrate on the structure of the workspace. There are multiple ways to -->
<!-- structure a workspace; we’re going to show a common way. We’ll have a -->
<!-- workspace containing a binary and two libraries. The binary, which will provide -->
<!-- the main functionality, will depend on the two libraries. One library will -->
<!-- provide an `add_one` function, and a second library an `add_two` function. -->
<!-- These three crates will be part of the same workspace. We'll start by creating-->
<!-- a new directory for the workspace: -->
<p><em>ワークスペース</em>は、同じ<em>Cargo.lock</em>と出力ディレクトリを共有する一連のパッケージです。
ワークスペースを使用したプロジェクトを作成し、ワークスペースの構造に集中できるよう、瑣末なコードを使用しましょう。
ワークスペースを構築する方法は複数ありますが、一般的な方法を提示しましょう。バイナリ1つとライブラリ2つを含むワークスペースを作ります。
バイナリは、主要な機能を提供しますが、2つのライブラリに依存しています。
一方のライブラリは、<code>add_one</code>関数を提供し、2番目のライブラリは、<code>add_two</code>関数を提供します。
これら3つのクレートが同じワークスペースの一部になります。ワークスペース用の新しいディレクトリを作ることから始めましょう:</p>
<pre><code class="language-text">$ mkdir add
$ cd add
</code></pre>
<!-- Next, in the *add* directory, we create the *Cargo.toml* file that will -->
<!-- configure the entire workspace. This file won't have a `[package]` section or-->
<!-- the metadata we’ve seen in other *Cargo.toml* files. Instead,  it will start -->
<!-- with a `[workspace]` section that will allow us to add members to the workspace -->
<!-- by specifying the path to our binary crate; in this case, that path is *adder*: -->
<p>次に<em>add</em>ディレクトリにワークスペース全体を設定する<em>Cargo.toml</em>ファイルを作成します。
このファイルには、他の<em>Cargo.toml</em>ファイルで見かけるような<code>[package]</code>セクションやメタデータはありません。
代わりにバイナリクレートへのパスを指定することでワークスペースにメンバを追加させてくれる<code>[workspace]</code>セクションから開始します;
今回の場合、そのパスは<em>adder</em>です:</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<!-- Next, we’ll create the `adder` binary crate by running `cargo new` within the -->
<!-- *add* directory: -->
<p>次に、<em>add</em>ディレクトリ内で<code>cargo new</code>を実行することで<code>adder</code>バイナリクレートを作成しましょう:</p>
<pre><code class="language-text">$ cargo new --bin adder
     Created binary (application) `adder` project
</code></pre>
<!-- At this point, we can build the workspace by running `cargo build`. The files -->
<!-- in your *add* directory should look like this: -->
<p>この時点で、<code>cargo build</code>を走らせるとワークスペースを構築できます。<em>add</em>ディレクトリに存在するファイルは、
以下のようになるはずです:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<!-- The workspace has one *target* directory at the top level for the compiled -->
<!-- artifacts to be placed into; the `adder` crate doesn’t have its own *target* -->
<!-- directory. Even if we were to run `cargo build` from inside the *adder* -->
<!-- directory, the compiled artifacts would still end up in *add/target* rather -->
<!-- than *add/adder/target*. Cargo structures the *target* directory in a workspace -->
<!-- like this because the crates in a workspace are meant to depend on each other. -->
<!-- If each crate had its own *target* directory, each crate would have to -->
<!-- recompile each of the other crates in the workspace to have the artifacts in -->
<!-- its own *target* directory. By sharing one *target* directory, the crates can -->
<!-- avoid unnecessary rebuilding. -->
<p>ワークスペースには、コンパイルした生成物を置けるように最上位に<em>ターゲット</em>のディレクトリがあります;
<code>adder</code>クレートには<em>ターゲット</em>ディレクトリはありません。
<em>adder</em>ディレクトリ内部から<code>cargo build</code>を走らせることになっていたとしても、コンパイルされる生成物は、
<em>add/adder/target</em>ではなく、<em>add/target</em>に落ち着くでしょう。ワークスペースのクレートは、
お互いに依存しあうことを意味するので、Cargoはワークスペースの<em>ターゲット</em>ディレクトリをこのように構成します。
各クレートが<em>ターゲット</em>ディレクトリを持っていたら、各クレートがワークスペースの他のクレートを再コンパイルし、
<em>ターゲット</em>ディレクトリに生成物がある状態にしなければならないでしょう。一つの<em>ターゲット</em>ディレクトリを共有することで、
クレートは不必要な再ビルドを回避できるのです。</p>
<!-- ### Creating the Second Crate in the Workspace -->
<a class="header" href="print.html#aワークスペース内に2番目のクレートを作成する" id="aワークスペース内に2番目のクレートを作成する"><h3>ワークスペース内に2番目のクレートを作成する</h3></a>
<!-- Next, let’s create another member crate in the workspace and call it `add-one`. -->
<!-- Change the top-level *Cargo.toml* to specify the *add-one* path in the -->
<!-- `members` list: -->
<p>次に、ワークスペースに別のメンバクレートを作成し、<code>add-one</code>と呼びましょう。
最上位の<em>Cargo.toml</em>を変更して<code>members</code>リストで<em>add-one</em>パスを指定するようにしてください:</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add-one&quot;,
]
</code></pre>
<!-- Then generate a new library crate named `add-one`: -->
<p>それから、<code>add-one</code>という名前のライブラリクレートを生成してください:</p>
<pre><code class="language-text">$ cargo new add-one
     Created library `add-one` project
</code></pre>
<!-- Your *add* directory should now have these directories and files: -->
<p>これで<em>add</em>ディレクトリには、以下のディレクトリやファイルが存在するはずです:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<!-- In the *add-one/src/lib.rs* file, let’s add an `add_one` function: -->
<p><em>add-one/src/lib.rs</em>ファイルに<code>add_one</code>関数を追加しましょう:</p>
<!-- <span class="filename">Filename: add-one/src/lib.rs</span> -->
<p><span class="filename">ファイル名: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<!-- Now that we have a library crate in the workspace, we can have the binary crate -->
<!-- `adder` depend on the library crate `add-one`. First, we’ll need to add a path -->
<!-- dependency on `add-one` to *adder/Cargo.toml*: -->
<p>ワークスペースにライブラリクレートが存在するようになったので、バイナリクレート<code>adder</code>をライブラリクレートの<code>add-one</code>に依存させられます。
まず、<code>add-one</code>へのパス依存を<em>adder/Cargo.toml</em>に追加する必要があります:</p>
<!-- <span class="filename">Filename: adder/Cargo.toml</span> -->
<p><span class="filename">ファイル名: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

add-one = { path = &quot;../add-one&quot; }
</code></pre>
<!-- Cargo doesn't assume that crates in a workspace will depend on each other, so -->
<!-- we need to be explicit about the dependency relationships between the crates. -->
<p>Cargoはワークスペースのクレートが、お互いに依存しているとは想定していないので、
クレート間の依存関係について明示する必要があります。</p>
<!-- Next, let’s use the `add_one` function from the `add-one` crate in the `adder` -->
<!-- crate. Open the *adder/src/main.rs* file and add an `extern crate` line at -->
<!-- the top to bring the new `add-one` library crate into scope. Then change the -->
<!-- `main` function to call the `add_one` function, as in Listing 14-7: -->
<p>次に、<code>adder</code>クレートの<code>add-one</code>クレートから<code>add_one</code>関数を使用しましょう。<em>adder/src/main.rs</em>ファイルを開き、
冒頭に<code>extern crate</code>行を追加して新しい<code>add-one</code>ライブラリクレートをスコープに導入してください。
それから<code>main</code>関数を変更し、<code>add_one</code>関数を呼び出します。リスト14-7のようにですね:</p>
<!-- <span class="filename">Filename: adder/src/main.rs</span> -->
<p><span class="filename">ファイル名: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate add_one;

fn main() {
    let num = 10;
    // こんにちは世界！{}+1は{}!
    println!(&quot;Hello, world! {} plus one is {}!&quot;, num, add_one::add_one(num));
}
</code></pre>
<!-- <span class="caption">Listing 14-7: Using the `add-one` library crate from the -->
<!-- `adder` crate</span> -->
<p><span class="caption">リスト14-7: <code>adder</code>クレートから<code>add-one</code>ライブラリクレートを使用する</span></p>
<!-- Let’s build the workspace by running `cargo build` in the top-level *add* -->
<!-- directory! -->
<p>最上位の<em>add</em>ディレクトリで<code>cargo build</code>を実行することでワークスペースをビルドしましょう！</p>
<pre><code class="language-text">$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
</code></pre>
<!-- To run the binary crate from the *add* directory, we need to specify which -->
<!-- package in the workspace we want to use by using the `-p` argument and the -->
<!-- package name with `cargo run`: -->
<p><em>add</em>ディレクトリからバイナリクレートを実行するには、<code>-p</code>引数とパッケージ名を<code>cargo run</code>と共に使用して、
使用したいワークスペースのパッケージを指定する必要があります:</p>
<pre><code class="language-text">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<!-- This runs the code in *adder/src/main.rs*, which depends on the `add-one` crate. -->
<p>これにより、<em>adder/src/main.rs</em>のコードが実行され、これは<code>add_one</code>クレートに依存しています。</p>
<!-- #### Depending on an External Crate in a Workspace -->
<a class="header" href="print.html#aワークスペースの外部クレートに依存する" id="aワークスペースの外部クレートに依存する"><h4>ワークスペースの外部クレートに依存する</h4></a>
<!-- Notice that the workspace has only one *Cargo.lock* file at the top level of -->
<!-- the workspace rather than having a *Cargo.lock* in each crate’s directory. This -->
<!-- ensures that all crates are using the same version of all dependencies. If we -->
<!-- add the `rand` crate to the *adder/Cargo.toml* and *add-one/Cargo.toml* -->
<!-- files, Cargo will resolve both of those to one version of `rand` and record -->
<!-- that in the one *Cargo.lock*. Making all crates in the workspace use the same -->
<!-- dependencies means the crates in the workspace will always be compatible with -->
<!-- each other. Let’s add the `rand` crate to the `[dependencies]` section in the -->
<!-- *add-one/Cargo.toml* file to be able to use the `rand` crate in the `add-one` -->
<!-- crate: -->
<p>ワークスペースには、各クレートのディレクトリそれぞれに<em>Cargo.lock</em>が存在するのではなく、
ワークスペースの最上位階層にただ一つの<em>Cargo.lock</em>が存在するだけのことに注目してください。
これにより、全クレートが全依存の同じバージョンを使用していることが確認されます。
<code>rand</code>クレートを<em>adder/Cargo.toml</em>と<em>add-one/Cargo.toml</em>ファイルに追加すると、
Cargoは両者をあるバージョンの<code>rand</code>に解決し、それを一つの<em>Cargo.lock</em>に記録します。
ワークスペースの全クレートに同じ依存を使用させるということは、
ワークスペースのクレートが相互に互換性を常に維持するということになります。
<em>add-one/Cargo.toml</em>ファイルの<code>[dependencies]</code>セクションに<code>rand</code>クレートを追加して、
<code>add-one</code>クレートで<code>rand</code>クレートを使用できます:</p>
<!-- <span class="filename">Filename: add-one/Cargo.toml</span> -->
<p><span class="filename">ファイル名: add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<!-- We can now add `extern crate rand;` to the *add-one/src/lib.rs* file, and -->
<!-- building the whole workspace by running `cargo build` in the *add* directory -->
<!-- will bring in and compile the `rand` crate: -->
<p>これで、<em>add-one/src/lib.rs</em>ファイルに<code>extern crate rand;</code>を追加でき、
<em>add</em>ディレクトリで<code>cargo build</code>を実行することでワークスペース全体をビルドすると、
<code>rand</code>クレートを持ってきてコンパイルするでしょう:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
   --snip--
   Compiling rand v0.3.14
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
</code></pre>
<!-- The top-level *Cargo.lock* now contains information about the dependency of -->
<!-- `add-one` on `rand`. However, even though `rand` is used somewhere in the -->
<!-- workspace, we can’t use it in other crates in the workspace unless we add -->
<!-- `rand` to their *Cargo.toml* files as well. For example, if we add `extern -->
<!-- crate rand;` to the *adder/src/main.rs* file for the `adder` crate, we’ll get -->
<!-- an error: -->
<p>さて、最上位の<em>Cargo.lock</em>は、<code>rand</code>に対する<code>add-one</code>の依存の情報を含むようになりました。
ですが、<code>rand</code>はワークスペースのどこかで使用されているにも関わらず、それぞれの<em>Cargo.toml</em>ファイルにも、
<code>rand</code>を追加しない限り、ワークスペースの他のクレートでそれを使用することはできません。
例えば、<code>adder</code>クレートの<em>adder/src/main.rs</em>ファイルに<code>extern crate rand;</code>を追加すると、
エラーが出ます:</p>
<pre><code class="language-text">$ cargo build
   Compiling adder v0.1.0 (file:///projects/add/adder)
error: use of unstable library feature 'rand': use `rand` from crates.io (see
issue #27703)
(エラー: 不安定なライブラリの機能'rand'を使用しています: crates.ioの`rand`を使用してください)
 --&gt; adder/src/main.rs:1:1
  |
1 | extern crate rand;
</code></pre>
<!-- To fix this, edit the *Cargo.toml* file for the `adder` crate and indicate that -->
<!-- `rand` is a dependency for that crate as well. Building the `adder` crate will -->
<!-- add `rand` to the list of dependencies for `adder` in *Cargo.lock*, but no -->
<!-- additional copies of `rand` will be downloaded. Cargo has ensured that any -->
<!-- crate in the workspace using the `rand` crate will be using the same version. -->
<!-- Using the same version of `rand` across the workspace saves space because we -->
<!-- won’t have multiple copies and ensures that the crates in the workspace will be -->
<!-- compatible with each other. -->
<p>これを修正するには、<code>adder</code>クレートの<em>Cargo.toml</em>ファイルを編集し、同様にそのクレートが<code>rand</code>に依存していることを示してください。
<code>adder</code>クレートをビルドすると、<code>rand</code>を<em>Cargo.lock</em>の<code>adder</code>の依存一覧に追加しますが、
<code>rand</code>のファイルが追加でダウンロードされることはありません。Cargoが、ワークスペースの<code>rand</code>を使用するどのクレートも、
同じバージョンを使っていることを確かめてくれるのです。ワークスペース全体で<code>rand</code>の同じバージョンを使用することにより、
複数のコピーが存在しないのでスペースを節約し、ワークスペースのクレートが相互に互換性を維持することを確かめます。</p>
<!-- #### Adding a Test to a Workspace -->
<a class="header" href="print.html#aワークスペースにテストを追加する" id="aワークスペースにテストを追加する"><h4>ワークスペースにテストを追加する</h4></a>
<!-- For another enhancement, let’s add a test of the `add_one::add_one` function -->
<!-- within the `add_one` crate: -->
<p>さらなる改善として、<code>add_one</code>クレート内に<code>add_one::add_one</code>関数のテストを追加しましょう:</p>
<!-- <span class="filename">Filename: add-one/src/lib.rs</span> -->
<p><span class="filename">ファイル名: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
#}</code></pre></pre>
<!-- Now run `cargo test` in the top-level *add* directory: -->
<p>では、最上位の<em>add</em>ディレクトリで<code>cargo test</code>を実行してください:</p>
<pre><code class="language-text">$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-f88af9d2cc175a5e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- The first section of the output shows that the `it_works` test in the `add-one` -->
<!-- crate passed. The next section shows that zero tests were found in the `adder` -->
<!-- crate, and then the last section shows zero documentation tests were found in -->
<!-- the `add-one` crate. Running `cargo test` in a workspace structured like this -->
<!-- one will run the tests for all the crates in the workspace. -->
<p>出力の最初の区域が、<code>add-one</code>クレートの<code>it_works</code>テストが通ったことを示しています。
次の区域には、<code>adder</code>クレートにはテストが見つなかったことが示され、
さらに最後の区域には、<code>add-one</code>クレートにドキュメンテーションテストは見つからなかったと表示されています。
このような構造をしたワークスペースで<code>cargo test</code>を走らせると、ワークスペースの全クレートのテストを実行します。</p>
<!-- We can also run tests for one particular crate in a workspace from the -->
<!-- top-level directory by using the `-p` flag and specifying the name of the crate -->
<!-- we want to test: -->
<p><code>-p</code>フラグを使用し、テストしたいクレートの名前を指定することで最上位ディレクトリから、
ワークスペースのある特定のクレート用のテストを実行することもできます:</p>
<pre><code class="language-text">$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!-- This output shows `cargo test` only ran the tests for the `add-one` crate and -->
<!-- didn’t run the `adder` crate tests. -->
<p>この出力は、<code>cargo test</code>が<code>add-one</code>クレートのテストのみを実行し、<code>adder</code>クレートのテストは実行しなかったことを示しています。</p>
<!-- FIXME: やはり、URLがイタリックにならない -->
<!-- If you publish the crates in the workspace to *https://crates.io/*, each crate -->
<!-- in the workspace will need to be published separately. The `cargo publish` -->
<!-- command does not have an `--all` flag or a `-p` flag, so you must change to -->
<!-- each crate’s directory and run `cargo publish` on each crate in the workspace -->
<!-- to publish the crates. -->
<p>ワークスペースのクレートを <em>https://crates.io/</em> に公開したら、ワークスペースのクレートは個別に公開される必要があります。
<code>cargo publish</code>コマンドには<code>--all</code>フラグや<code>-p</code>フラグはないので、各クレートのディレクトリに移動して、
ワークスペースの各クレートを<code>cargo publish</code>して、公開しなければなりません。</p>
<!-- For additional practice, add an `add-two` crate to this workspace in a similar -->
<!-- way as the `add-one` crate! -->
<p>鍛錬を積むために、<code>add-one</code>クレートと同様の方法でワークスペースに<code>add-two</code>クレートを追加してください！</p>
<!-- As your project grows, consider using a workspace: it’s easier to understand -->
<!-- smaller, individual components than one big blob of code. Furthermore, keeping -->
<!-- the crates in a workspace can make coordination between them easier if they are -->
<!-- often changed at the same time. -->
<p>プロジェクトが肥大化してきたら、ワークスペースの使用を考えてみてください: 大きな一つのコードの塊よりも、
微細で個別のコンポーネントの方が理解しやすいです。またワークスペースにクレートを保持することは、
同時に変更されることが多いのなら、協調しやすくなることにも繋がります。</p>
<!-- ## Installing Binaries from Crates.io with `cargo install` -->
<a class="header" href="print.html#cargo-installでcratesioからバイナリをインストールする" id="cargo-installでcratesioからバイナリをインストールする"><h2><code>cargo install</code>でCrates.ioからバイナリをインストールする</h2></a>
<!-- The `cargo install` command allows you to install and use binary crates -->
<!-- locally. This isn’t intended to replace system packages; it’s meant to be a -->
<!-- convenient way for Rust developers to install tools that others have shared on -->
<!-- [crates.io](https://crates.io). Note that you can only install -->
<!-- packages that have binary targets. A binary target is the runnable program -->
<!-- tht is created if the crate has a *src/main.rs* file or another file specified -->
<!-- as a binary, as opposed to a library target that isn’t runnable on its own but -->
<!-- is suitable for including within other programs. Usually, crates have -->
<!-- information in the *README* file about whether a crate is a library, has a -->
<!-- binary target, or both. -->
<p><code>cargo install</code>コマンドにより、バイナリクレートをローカルにインストールし、使用することができます。
これは、システムパッケージを置き換えることを意図したものではありません。<ruby>即<rp>(</rp><rt>すなわ</rt><rp>)</rp></ruby>ち、
Rustの開発者が、他人が<a href="https://crates.io">crates.io</a>に共有したツールをインストールするのに便利な方法を意味するのです。
バイナリターゲットを持つパッケージのみインストールできることに注意してください。バイナリターゲットとは、
クレートが<em>src/main.rs</em>ファイルやバイナリとして指定された他のファイルを持つ場合に生成される実行可能なプログラムのことであり、
単独では実行不可能なものの、他のプログラムに含むのには適しているライブラリターゲットとは一線を画します。
通常、クレートには、<em>README</em>ファイルに、クレートがライブラリかバイナリターゲットか、両方をもつかという情報があります。</p>
<!-- All binaries installed with `cargo install` are stored in the installation -->
<!-- root’s *bin* folder. If you installed Rust using `rustup` and don’t have any -->
<!-- custom configurations, this directory will be *$HOME/.cargo/bin*. Ensure that -->
<!-- directory is in your `$PATH` to be able to run programs you’ve installed with -->
<!-- `cargo install`. -->
<p><code>cargo install</code>でインストールされるバイナリは全て、インストールのルートの<em>bin</em>フォルダに保持されます。
Rustを<code>rustup</code>を使用し、独自の設定を何も行なっていなければ、このディレクトは、<em>$HOME/.cargo/bin</em>になります。
<code>cargo install</code>でインストールしたプログラムを実行できるようにするためには、そのディレクトリが<code>$PATH</code>に含まれていることを確かめてください。</p>
<!-- For example, in Chapter 12 we mentioned that there’s a Rust implementation of -->
<!-- the `grep` tool called `ripgrep` for searching files. If we want to install -->
<!-- `ripgrep`, we can run the following: -->
<p>例えば、第12章で、ファイルを検索する<code>ripgrep</code>という<code>grep</code>ツールのRust版があることに触れました。
<code>ripgrep</code>をインストールしたかったら、以下を実行することができます:</p>
<pre><code class="language-text">$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 --snip--
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
</code></pre>
<!-- The last line of the output shows the location and the name of the installed -->
<!-- binary, which in the case of `ripgrep` is `rg`. As long as the installation -->
<!-- directory is in your `$PATH`, as mentioned previously, you can then run `rg -->
<!-- --help` and start using a faster, rustier tool for searching files! -->
<p>出力の最後の行が、インストールされたバイナリの位置と名前を示していて、<code>ripgrep</code>の場合、<code>rg</code>です。
インストールディレクトリが<code>$PATH</code>に存在する限り、前述したように、<code>rg --help</code>を走らせて、
より高速でRustらしいファイル検索ツールを使用し始めることができます！</p>
<!-- ## Extending Cargo with Custom Commands -->
<a class="header" href="print.html#a独自のコマンドでcargoを拡張する" id="a独自のコマンドでcargoを拡張する"><h2>独自のコマンドでCargoを拡張する</h2></a>
<!-- Cargo is designed so you can extend it with new subcommands without having to -->
<!-- modify Cargo. If a binary in your `$PATH` is named `cargo-something`, you can -->
<!-- run it as if it was a Cargo subcommand by running `cargo something`. Custom -->
<!-- commands like this are also listed when you run `cargo --list`. Being able to -->
<!-- use `cargo install` to install extensions and then run them just like the -->
<!-- built-in Cargo tools is a super convenient benefit of Cargo’s design! -->
<p>Cargoは変更する必要なく、新しいサブコマンドで拡張できるように設計されています。
<code>$PATH</code>にあるバイナリが<code>cargo-something</code>という名前なら、<code>cargo something</code>を実行することで、
Cargoのサブコマンドであるかのように実行することができます。このような独自のコマンドは、
<code>cargo --list</code>を実行すると、列挙もされます。<code>cargo install</code>を使用して拡張をインストールし、
それから組み込みのCargoツール同様に実行できることは、Cargoの設計上の非常に便利な恩恵です！</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-12" id="aまとめ-12"><h2>まとめ</h2></a>
<!-- Sharing code with Cargo and [crates.io](https://crates.io) is -->
<!-- part of what makes the Rust ecosystem useful for many different tasks. Rust’s -->
<!-- standard library is small and stable, but crates are easy to share, use, and -->
<!-- improve on a timeline different from that of the language. Don’t be shy about -->
<!-- sharing code that’s useful to you on [crates.io](https://crates.io); -->
<!-- it’s likely that it will be useful to someone else as well! -->
<p>Cargoで<a href="https://crates.io">crates.io</a>とコードを共有することは、
Rustのエコシステムを多くの異なる作業に有用にするものの一部です。Rustの標準ライブラリは、
小さく安定的ですが、クレートは共有および使用しやすく、言語とは異なるタイムラインで進化します。
積極的に<a href="https://crates.io">crates.io</a>で自分にとって有用なコードを共有してください;
他の誰かにとっても、役に立つものであることでしょう！</p>
<!-- # Smart Pointers -->
<a class="header" href="print.html#aスマートポインタ" id="aスマートポインタ"><h1>スマートポインタ</h1></a>
<!-- A *pointer* is a general concept for a variable that contains an address in -->
<!-- memory. This address refers to, or “points at,” some other data. The most -->
<!-- common kind of pointer in Rust is a reference, which you learned about in -->
<!-- Chapter 4. References are indicated by the `&` symbol and borrow the value they -->
<!-- point to. They don’t have any special capabilities other than referring to -->
<!-- data. Also, they don’t have any overhead and are the kind of pointer we use -->
<!-- most often. -->
<p><em>ポインタ</em>は、メモリのアドレスを含む変数の一般的な概念です。このアドレスは、何らかの他のデータを参照、または「指します」。
Rustにおいて、最もありふれた種類のポインタは、参照であり、第4章で習いましたね。参照は、
<code>&amp;</code>記号で示唆され、指している値を借用します。データを参照すること以外に特別な能力は何もありません。
また、オーバーヘッドもなく、最も頻繁に使われる種類のポインタです。</p>
<!-- *Smart pointers*, on the other hand, are data structures that not only act like -->
<!-- a pointer but also have additional metadata and capabilities. The concept of -->
<!-- smart pointers isn’t unique to Rust: smart pointers originated in C++ and exist -->
<!-- in other languages as well. In Rust, the different smart pointers defined in -->
<!-- the standard library provide functionality beyond that provided by references. -->
<!-- One example that we’ll explore in this chapter is the *reference counting* -->
<!-- smart pointer type. This pointer enables you to have multiple owners of data by -->
<!-- keeping track of the number of owners and, when no owners remain, cleaning up -->
<!-- cleaning up the data. -->
<p>一方、<em>スマートポインタ</em>は、ポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造です。
スマートポインタという概念は、Rustに固有のものではありません: スマートポインタは、C++に端を発し、
他の言語にも存在しています。Rustでは、標準ライブラリに定義された色々なスマートポインタが、
参照以上の機能を提供します。この章で探究する一つの例が、<em>参照カウント</em>方式のスマートポインタ型です。
このポインタにより、所有者の数を追いかけることでデータに複数の所有者を持たせることができ、
所有者がいなくなったら、データの片付けをしてくれます。</p>
<!-- In Rust, which uses the concept of ownership and borrowing, an additional -->
<!-- difference between references and smart pointers is that references are -->
<!-- pointers that only borrow data; in contrast, in many cases, smart pointers -->
<!-- *own* the data they point to. -->
<p>所有権と借用の概念を使うRustで、参照とスマートポインタの別の差異は、参照はデータを借用するだけのポインタであることです;
対照的に多くの場合、スマートポインタは指しているデータを<em>所有</em>します。</p>
<!-- We’ve already encountered a few smart pointers in this book, such as `String` -->
<!-- and `Vec<T>` in Chapter 8, although we didn’t call them smart pointers at the -->
<!-- time. Both these types count as smart pointers because they own some memory and -->
<!-- allow you to manipulate it. They also have metadata (such as their capacity) -->
<!-- and extra capabilities or guarantees (such as with `String` ensuring its data -->
<!-- will always be valid UTF-8). -->
<p>当時は、スマートポインタとは呼ばなかったものの、第8章の<code>String</code>や<code>Vec&lt;T&gt;</code>のように、
この本の中でいくつかのスマートポインタに遭遇してきました。これらの型はどちらも、
あるメモリを所有し、それを弄ることができるので、スマートポインタに数えられます。また、
メタデータ(キャパシティなど)や追加の能力、あるいは保証(<code>String</code>ならデータが常に有効なUTF-8であると保証することなど)もあります。</p>
<!-- Smart pointers are usually implemented using structs. The characteristic that -->
<!-- distinguishes a smart pointer from an ordinary struct is that smart pointers -->
<!-- implement the `Deref` and `Drop` traits. The `Deref` trait allows an instance -->
<!-- of the smart pointer struct to behave like a reference so you can write code -->
<!-- that works with either references or smart pointers. The `Drop` trait allows -->
<!-- you to customize the code that is run when an instance of the smart pointer -->
<!-- goes out of scope. In this chapter, we’ll discuss both traits and demonstrate -->
<!-- why they’re important to smart pointers. -->
<p>スマートポインタは普通、構造体を使用して実装されています。スマートポインタを通常の構造体と区別する特徴は、
スマートポインタは、<code>Deref</code>と<code>Drop</code>トレイトを実装していることです。<code>Deref</code>トレイトにより、スマートポインタ構造体のインスタンスは、
参照のように振る舞うことができるので、参照あるいはスマートポインタのどちらとも動作するコードを書くことができるのです。
<code>Drop</code>トレイトにより、スマートポインタのインスタンスがスコープを外れた時に走るコードをカスタマイズすることができます。
この章では、どちらのトレイトについても議論し、これらのトレイトがスマートポインタにとって重要な理由をデモします。</p>
<!-- Given that the smart pointer pattern is a general design pattern used -->
<!-- frequently in Rust, this chapter won’t cover every existing smart pointer. Many -->
<!-- libraries have their own smart pointers, and you can even write your own. We’ll -->
<!-- cover the most common smart pointers in the standard library: -->
<p>スマートポインタパターンがRustにおいてよく使われる一般的なデザインパターンだとして、この章では、全ての既存のスマートポインタを講義しません。
多くのライブラリに独自のスマートポインタがあり、自分だけのスマートポインタを書くことさえできます。
標準ライブラリの最もありふれたスマートポインタを講義します:</p>
<!-- * `Box<T>` for allocating values on the heap -->
<!-- * `Rc<T>`, a reference counting type that enables multiple ownership -->
<!-- * `Ref<T>` and `RefMut<T>`, accessed through `RefCell<T>`, a type that enforces -->
<!--   the borrowing rules at runtime instead of compile time -->
<ul>
<li>ヒープに値を確保する<code>Box&lt;T&gt;</code></li>
<li>複数の所有権を可能にする参照カウント型の<code>Rc&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code>を通してアクセスされ、コンパイル時ではなく実行時に借用ルールを強制する型の<code>Ref&lt;T&gt;</code>と<code>RefMut&lt;T&gt;</code></li>
</ul>
<!-- In addition, we’ll cover the *interior mutability* pattern where an immutable -->
<!-- type exposes an API for mutating an interior value. We’ll also discuss -->
<!-- *reference cycles*: how they can leak memory and how to prevent them. -->
<p>さらに、不変な型が、内部の値を可変化するAPIを晒す<em>内部可変性</em>パターンについても講義します。
また、<em>循環参照</em>についても議論します: 循環参照により、メモリがリークする方法とそれを回避する方法です。</p>
<!-- Let’s dive in! -->
<p>さあ、飛び込みましょう！</p>
<!-- ## Using `Box<T>` to Point to Data on the Heap -->
<a class="header" href="print.html#aヒープのデータを指すboxtを使用する" id="aヒープのデータを指すboxtを使用する"><h2>ヒープのデータを指す<code>Box&lt;T&gt;</code>を使用する</h2></a>
<!-- The most straightforward smart pointer is a *box*, whose type is written -->
<!-- `Box<T>`. Boxes allow you to store data on the heap rather than the stack. What -->
<!-- remains on the stack is the pointer to the heap data. Refer to Chapter 4 to -->
<!-- review the difference between the stack and the heap. -->
<p>最も素直なスマートポインタは<em>ボックス</em>であり、その型は<code>Box&lt;T&gt;</code>と記述されます。
ボックスにより、スタックではなくヒープにデータを格納することができます。スタックに残るのは、
ヒープデータへのポインタです。スタックとヒープの違いを再確認するには、第4章を参照されたし。</p>
<!-- Boxes don’t have performance overhead, other than storing their data on the -->
<!-- heap instead of on the stack. But they don’t have many extra capabilities -->
<!-- either. You’ll use them most often in these situations: -->
<p>ボックスは、データをスタックの代わりにヒープに格納する以外は、パフォーマンスのオーバーヘッドはありません。
しかし、多くのおまけの能力もありません。以下のような場面で最もよく使用するでしょう:</p>
<!-- * When you have a type whose size can’t be known at compile time and you want -->
<!--   to use a value of that type in a context that requires an exact size -->
<!-- * When you have a large amount of data and you want to transfer ownership but -->
<!--   ensure the data won’t be copied when you do so -->
<!-- * When you want to own a value and you care only that it’s a type that -->
<!--   implements a particular trait rather than being of a specific type -->
<ul>
<li>コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時</li>
<li>多くのデータがあり、所有権を転送したいが、そうする時にデータがコピーされないことを確認する時</li>
<li>値を所有する必要があり、特定の型ではなく特定のトレイトを実装する型であることのみ気にかけている時</li>
</ul>
<!-- 最後の行がよくわからない。what ... (that) you'll apply ... なのか？ -->
<!-- We’ll demonstrate the first situation in the “Enabling Recursive Types with -->
<!-- Boxes” section. In the second case, transferring ownership of a large amount of -->
<!-- data can take a long time because the data is copied around on the stack. To -->
<!-- improve performance in this situation, we can store the large amount of data on -->
<!-- the heap in a box. Then, only the small amount of pointer data is copied around -->
<!-- on the stack, while the data it references stays in one place on the heap. The -->
<!-- third case is known as a *trait object*, and Chapter 17 devotes an entire -->
<!-- section, “Using Trait Objects That Allow for Values of Different Types,” just -->
<!-- to that topic. So what you learn here you’ll apply again in Chapter 17! -->
<p>この節では、「ボックスで再帰的型を可能にする」節の最初の場面を模擬します。
2番目の場合、多くのデータの所有権を転送するには、データがスタック上でコピーされるので、長い時間がかかり得ます。
この場面でパフォーマンスを向上させるには、多くのデータをヒープ上にボックスとして格納することができます。
そして、参照しているデータはヒープ上の1箇所に留まりつつ、少量のポインタのデータのみをスタック上でコピーするのです。
3番目のケースは、<em>トレイトオブジェクト</em>として知られ、第17章は、
その話題だけに「異なる型の値を許容するトレイトオブジェクトを使用する」1節全体を捧げています。
従って、ここで学ぶことは、第17章でまた適用するでしょう！</p>
<!-- ### Using a `Box<T>` to Store Data on the Heap -->
<a class="header" href="print.html#boxtを使ってヒープにデータを格納する" id="boxtを使ってヒープにデータを格納する"><h3><code>Box&lt;T&gt;</code>を使ってヒープにデータを格納する</h3></a>
<!-- Before we discuss this use case for `Box<T>`, we’ll cover the syntax and how to -->
<!-- interact with values stored within a `Box<T>`. -->
<p><code>Box&lt;T&gt;</code>のこのユースケースを議論する前に、記法と<code>Box&lt;T&gt;</code>内に格納された値と相互作用する方法について講義しましょう。</p>
<!-- Listing 15-1 shows how to use a box to store an `i32` value on the heap: -->
<p>リスト15-1は、ボックスを使用してヒープに<code>i32</code>の値を格納する方法を示しています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-1: Storing an `i32` value on the heap using a -->
<!-- box</span> -->
<p><span class="caption">リスト15-1: ボックスを使用して<code>i32</code>の値をヒープに格納する</span></p>
<!-- We define the variable `b` to have the value of a `Box` that points to the -->
<!-- value `5`, which is allocated on the heap. This program will print `b = 5`; in -->
<!-- this case, we can access the data in the box similar to how we would if this -->
<!-- data was on the stack. Just like any owned value, when a box goes out of -->
<!-- scope, as `b` does at the end of `main`, it will be deallocated. The -->
<!-- deallocation happens for the box (stored on the stack) and the data it points -->
<!-- to (stored on the heap). -->
<p>変数<code>b</code>を定義して値<code>5</code>を指す<code>Box</code>の値を持っていて、この値はヒープに確保されています。このプログラムは、
<code>b = 5</code>と出力するでしょう; この場合、このデータがスタックにあるのと同じような方法でボックスのデータにアクセスできます。
あらゆる所有された値同様、<code>b</code>が<code>main</code>の終わりでするようにボックスがスコープを抜けたら、
メモリから解放されます。メモリの解放は(スタックに格納されている)ボックスと(ヒープに格納されている)指しているデータに対して起きます。</p>
<!-- Putting a single value on the heap isn’t very useful, so you won’t use boxes by -->
<!-- themselves in this way very often. Having values like a single `i32` on the -->
<!-- stack, where they’re stored by default, is more appropriate in the majority of -->
<!-- situations. Let’s look at a case where boxes allow us to define types that we -->
<!-- wouldn’t be allowed to if we didn’t have boxes. -->
<p>ヒープに単独の値を置くことはあまり有用ではないので、このように単独でボックスを使用することはあまりありません。
単独の<code>i32</code>のような値を規定で格納される場所であるスタックに置くことが、大多数の場合にはより適切です。
ボックスがなかったら定義することの叶わない型をボックスが定義させてくれる場合を見ましょう。</p>
<!-- ### Enabling Recursive types with Boxes -->
<a class="header" href="print.html#aボックスで再帰的な型を可能にする" id="aボックスで再帰的な型を可能にする"><h3>ボックスで再帰的な型を可能にする</h3></a>
<!-- At compile time, Rust needs to know how much space a type takes up. One type -->
<!-- whose size can’t be known at compile time is a *recursive type*, where a value -->
<!-- can have as part of itself another value of the same type. Because this nesting -->
<!-- of values could theoretically continue infinitely, Rust doesn’t know how much -->
<!-- space a value of a recursive type needs. However, boxes have a known size, so -->
<!-- by inserting a box in a recursive type definition, you can have recursive types. -->
<p>コンパイル時に、コンパイラは、ある型が取る領域を知る必要があります。コンパイル時にサイズがわからない型の1つは、
<em>再帰的な型</em>であり、これは、型の一部として同じ型の他の値を持つものです。この値のネストは、
理論的には無限に続く可能性があるので、コンパイラは再帰的な型の値が必要とする領域を知ることができないのです。
しかしながら、ボックスは既知のサイズなので、再帰的な型の定義にボックスを挟むことで再帰的な型を存在させることができるのです。</p>
<!-- Let’s explore the *cons list*, which is a data type common in functional -->
<!-- programming languages, as an example of a recursive type. The cons list type -->
<!-- we’ll define is straightforward except for the recursion; therefore, the -->
<!-- concepts in the example we’ll work with will be useful any time you get into -->
<!-- more complex situations involving recursive types. -->
<p><em>コンスリスト</em>は関数型プログラミング言語では一般的なデータ型ですが、これを再帰的な型の例として探求しましょう。
我々が定義するコンスリストは、再帰を除いて素直です; 故に、これから取り掛かる例の概念は、
再帰的な型が関わるもっと複雑な場面に遭遇したら必ず役に立つでしょう。</p>
<!-- #### More Information About the Cons List -->
<a class="header" href="print.html#aコンスリストについてもっと詳しく" id="aコンスリストについてもっと詳しく"><h4>コンスリストについてもっと詳しく</h4></a>
<!-- A *cons list* is a data structure that comes from the Lisp programming language -->
<!-- and its dialects. In Lisp, the `cons` function (short for “construct function”) -->
<!-- constructs a new pair from its two arguments, which usually are a single value -->
<!-- and another pair. These pairs containing pairs form a list. -->
<p>コンスリストは、Lispプログラミング言語とその方言に由来するデータ構造です。Lispでは、
<code>cons</code>関数(&quot;construct function&quot;の省略形です)が2つの引数から新しいペアを構成し、
この引数は通常、単独の値と別のペアからなります。これらのペアを含むペアがリストをなすのです。</p>
<!-- The cons function concept has made its way into more general functional -->
<!-- programming jargon: “to cons *x* onto *y*” informally means to construct a new -->
<!-- container instance by putting the element *x* at the start of this new -->
<!-- container, followed by the container *y*. -->
<p>cons関数の概念は、より一般的な関数型プログラミングのスラングにもなっています: &quot;to cons <em>x</em> onto <em>y</em>&quot;は、
俗に要素<em>x</em>をこの新しいコンテナの初めに置き、コンテナ<em>y</em>を従わせて新しいコンテナのインスタンスを生成することを意味します。</p>
<!-- Each item in a cons list contains two elements: the value of the current item -->
<!-- and the next item. The last item in the list contains only a value called `Nil` -->
<!-- without a next item. A cons list is produced by recursively calling the `cons` -->
<!-- function. The canonical name to denote the base case of the recursion is `Nil`. -->
<!-- Note that this is not the same as the “null” or “nil” concept in Chapter 6, -->
<!-- which is an invalid or absent value. -->
<p>コンスリストの各要素は、2つの要素を含みます: 現在の要素の値と次の要素です。リストの最後の要素は、
次の要素なしに<code>Nil</code>と呼ばれる値だけを含みます。コンスリストは、繰り返し<code>cons</code>関数を呼び出すことで生成されます。
繰り返しの規範事例を意味する標準的な名前は、<code>Nil</code>です。これは第6章の&quot;null&quot;や&quot;nil&quot;の概念とは異なることに注意してください。
&quot;null&quot;や&quot;nil&quot;は、無効だったり存在しない値です。</p>
<!-- Although functional programming languages use cons lists frequently, the cons -->
<!-- list isn't a commonly used data structure in Rust. Most of the time when you -->
<!-- have a list of items in Rust, `Vec<T>` is a better choice to use. Other, more -->
<!-- complext recursive data types *are* useful in various situations, but by -->
<!-- starting with the cons list, we can explore how boxes let us define a recursive -->
<!-- data type without much distraction. -->
<p>関数型プログラミング言語は、頻繁にコンスリストを使用するものの、Rustではあまり使用されないデータ構造です。
Rustで要素のリストがある場合はほとんどの場合、<code>Vec&lt;T&gt;</code>を使用するのがよりよい選択になります。
他のより複雑な再帰的なデータ型は、様々な場面で役に立ち<em>ます</em>が、コンスリストから始めることで、
大して気を散らすことなく再帰的なデータ型をボックスが定義させてくれる方法を探求することができます。</p>
<!-- この, whichは短い日本語に訳すのが難しい -->
<!-- Listing 15-2 contains an enum definition for a cons list. Note that this code -->
<!-- won’t compile yet because the `List` type doesn’t have a known size, which -->
<!-- we’ll demonstrate. -->
<p>リスト15-2には、コンスリストのenum定義が含まれています。このコードは、
<code>List</code>型が既知のサイズではないため、まだコンパイルできないことに注意してください。
既知のサイズがないことをこれから模擬します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<!-- <span class="caption">Listing 15-2: The first attempt at defining an enum to -->
<!-- represent a cons list data structure of `i32` values</span> -->
<p><span class="caption">リスト15-2: <code>i32</code>値のコンスリストデータ構造を表すenumを定義する最初の試行</span></p>
<!-- Note: We’re implementing a cons list that holds only `i32` values for the -->
<!-- purposes of this example. We could have implemented it using generics, as we -->
<!-- discussed in Chapter 10, to define a cons list type that could store values of -->
<!-- any type. -->
<blockquote>
<p>注釈: この例のためだけに<code>i32</code>値をだけを保持するコンスリストを実装します。第10章で議論したように、
ジェネリクスを使用してどんな型の値も格納できるコンスリストを定義して実装することもできました。</p>
</blockquote>
<!-- Using the `List` type to store the list `1, 2, 3` would look like the code in -->
<!-- Listing 15-3: -->
<p>この<code>List</code>型を使用してリスト<code>1, 2, 3</code>を格納すると、リスト15-3のコードのような見た目になるでしょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<!-- <span class="caption">Listing 15-3: Using the `List` enum to store the list `1, -->
<!-- 2, 3`</span> -->
<p><span class="caption">リスト15-3: <code>List</code> enumを使用してリスト<code>1, 2, 3</code>を格納する</span></p>
<!-- The first `Cons` value holds `1` and another `List` value. This `List` value is -->
<!-- another `Cons` value that holds `2` and another `List` value. This `List` value -->
<!-- is one more `Cons` value that holds `3` and a `List` value, which is finally -->
<!-- `Nil`, the non-recursive variant that signals the end of the list. -->
<p>最初の<code>Cons</code>値は、<code>1</code>と別の<code>List</code>値を保持しています。この<code>List</code>値は、
<code>2</code>とまた別の<code>List</code>値を保持する別の<code>Cons</code>値です。この<code>List</code>値は、
<code>3</code>と、ついにリストの終端を通知する非再帰的なバリアントの<code>Nil</code>になる<code>List</code>値を保持するまたまた別の<code>Cons</code>値です。</p>
<!-- If we try to compile the code in Listing 15-3, we get the error shown in -->
<!-- Listing 15-4: -->
<p>リスト15-3のコードをコンパイルしようとすると、リスト15-4に示したエラーが出ます:</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
(エラー: 再帰的な型`List`は無限のサイズです)
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
  (助言: 間接参照(例: `Box`、`Rc`、あるいは`&amp;`)をどこかに挿入して、`List`を表現可能にしてください)
</code></pre>
<!-- <span class="caption">Listing 15-4: The error we get when attempting to define -->
<!-- a recursive enum</span> -->
<p><span class="caption">リスト15-4: 再帰的なenumを定義しようとすると得られるエラー</span></p>
<!-- The error shows this type “has infinite size.” The reason is that we’ve defined -->
<!-- `List` with a variant that is recursive: it holds another value of itself -->
<!-- directly. As a result, Rust can’t figure out how much space it needs to store a -->
<!-- `List` value. Let’s break down why we get this error a bit. First, let’s look -->
<!-- at how Rust decides how much space it needs to store a value of a non-recursive -->
<!-- type. -->
<p>エラーは、この型は「無限のサイズである」と表示しています。理由は、再帰的な列挙子を含む<code>List</code>を定義したからです:
自身の別の値を直接保持しているのです。結果として、コンパイラは、<code>List</code>値を格納するのに必要な領域が計算できないのです。
このエラーが得られた理由を少し噛み砕きましょう。まず、非再帰的な型の値を格納するのに必要な領域をどうコンパイラが決定しているかを見ましょう。</p>
<!-- #### Computing the Size of a Non-Recursive Type -->
<a class="header" href="print.html#a非再帰的な型のサイズを計算する" id="a非再帰的な型のサイズを計算する"><h4>非再帰的な型のサイズを計算する</h4></a>
<!-- Recall the `Message` enum we defined in Listing 6-2 when we discussed enum -->
<!-- definitions in Chapter 6: -->
<p>第6章でenum定義を議論した時にリスト6-2で定義した<code>Message</code> enumを思い出してください:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<!-- To determine how much space to allocate for a `Message` value, Rust goes -->
<!-- through each of the variants to see which variant needs the most space. Rust -->
<!-- sees that `Message::Quit` doesn’t need any space, `Message::Move` needs enough -->
<!-- space to store two `i32` values, and so forth. Because only one variant will be -->
<!-- used, the most space a `Message` value will need is the space it would take to -->
<!-- store the largest of its variants. -->
<p><code>Message</code>値一つにメモリを確保するために必要な領域を決定するために、コンパイラは、
各列挙子を見てどの列挙子が最も領域を必要とするかを確認します。コンパイラは、
<code>Message::Quit</code>は全く領域を必要とせず、<code>Message::Move</code>は<code>i32</code>値を2つ格納するのに十分な領域が必要などと確かめます。
ただ1つの列挙子しか使用されないので、<code>Message</code>値一つが必要とする最大の領域は、
最大の列挙子を格納するのに必要になる領域です。</p>
<!-- Contrast this with what happens when Rust tries to determine how much space a -->
<!-- recursive type like the `List` enum in Listing 15-2 needs. The compiler starts -->
<!-- by looking at the `Cons` variant, which holds a value of type `i32` and a value -->
<!-- of type `List`. Therefore, `Cons` needs an amount of space equal to the size of -->
<!-- an `i32` plus the size of a `List`. To figure out how much memory the `List` -->
<!-- type needs, the compiler looks at the variants, starting with the `Cons` -->
<!-- variant. The `Cons` variant holds a value of type `i32` and a value of type -->
<!-- `List`, and this process continues infinitely, as shown in Figure 15-1. -->
<p>これをコンパイラがリスト15-2の<code>List</code> enumのような再帰的な型が必要とする領域を決定しようとする時に起こることと比較してください。
コンパイラは、<code>Cons</code>列挙子を見ることから始め、この列挙子には、型<code>i32</code>値が一つと型<code>List</code>の値が一つ保持されます。
故に、<code>Cons</code>は1つの<code>i32</code>と<code>List</code>のサイズに等しい領域を必要とします。<code>List</code>が必要とするメモリ量を計算するのに、
コンパイラは<code>Cons</code>列挙子から列挙子を観察します。<code>Cons</code>列挙子は型<code>i32</code>を1つと型<code>List</code>の値1つを保持し、
この過程は無限に続きます。図15-1のようにですね。</p>
<!-- <img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" /> -->
<p><img alt="無限のコンスリスト" src="img/trpl15-01.svg" class="center" style="width: 50%;" /></p>
<!-- <span class="caption">Figure 15-1: An infinite `List` consisting of infinite -->
<!-- `Cons` variants</span> -->
<p><span class="caption">図15-1: 無限の<code>Cons</code>列挙子からなる無限の<code>List</code></span></p>
<!-- #### Using `Box<T>` to Get a Recursive Type with a Known Size -->
<a class="header" href="print.html#boxtで既知のサイズの再帰的な型を得る" id="boxtで既知のサイズの再帰的な型を得る"><h4><code>Box&lt;T&gt;</code>で既知のサイズの再帰的な型を得る</h4></a>
<!-- Rust can’t figure out how much space to allocate for recursively defined types, -->
<!-- so the compiler gives the error in Listing 15-4. But the error does include -->
<!-- this helpful suggestion: -->
<p>コンパイラは、再帰的に定義された型に必要なメモリ量を計算できないので、リスト15-4ではエラーを返します。
しかし、エラーには確かにこの役に立つ提言が含まれています:</p>
<pre><code class="language-text">  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<!-- In this suggestion, “indirection” means that instead of storing a value -->
<!-- directly, we’ll change the data structure to store the value indirectly by -->
<!-- storing a pointer to the value instead. -->
<p>この提言において、「間接参照」は、値を直接格納する代わりに、データ構造を変更して値へのポインタを代わりに格納することで、
値を間接的に格納することを意味します。</p>
<!-- Because a `Box<T>` is a pointer, Rust always knows how much space a `Box<T>` -->
<!-- needs: a pointer’s size doesn’t change based on the amount of data it’s -->
<!-- pointing to. This means we can put a `Box<T>` inside the `Cons` variant instead -->
<!-- of another `List` value directly. The `Box<T>` will point to the next `List` -->
<!-- value that will be on the heap rather than inside the `Cons` variant. -->
<!-- Conceptually, we still have a list, created with lists “holding” other lists, -->
<!-- but this implementation is now more like placing the items next to one another -->
<!-- rather than inside one another. -->
<p><code>Box&lt;T&gt;</code>はポインタなので、コンパイラには<code>Box&lt;T&gt;</code>が必要とする領域が必ずわかります: ポインタのサイズは、
指しているデータの量によって変わることはありません。つまり、別の<code>List</code>値を直接置く代わりに、
<code>Cons</code>列挙子の中に<code>Box&lt;T&gt;</code>を配置することができます。<code>Box&lt;T&gt;</code>は、
<code>Cons</code>列挙子の中ではなく、ヒープに置かれる次の<code>List</code>値を指します。概念的には、
それでも他のリストを「保持する」リストとともに作られたリストがありますが、
この実装は今では、要素はお互いの中にあるというよりも、隣り合って配置するような感じになります。</p>
<!-- We can change the definition of the `List` enum in Listing 15-2 and the usage -->
<!-- of the `List` in Listing 15-3 to the code in Listing 15-5, which will compile: -->
<p>リスト15-2の<code>List</code> enumの定義とリスト15-3の<code>List</code>の使用をリスト15-5のコードに変更することができ、
これはコンパイルが通ります:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-5: Definition of `List` that uses `Box<T>` in -->
<!-- order to have a known size</span> -->
<p><span class="caption">リスト15-5: 既知のサイズを得るために<code>Box&lt;T&gt;</code>を使用する<code>List</code>の定義</span></p>
<!-- The `Cons` variant will need the size of an `i32` plus the space to store the -->
<!-- box’s pointer data. The `Nil` variant stores no values, so it needs less space -->
<!-- than the `Cons` variant. We now know that any `List` value will take up the -->
<!-- size of an `i32` plus the size of a box’s pointer data. By using a box, we’ve -->
<!-- broken the infinite, recursive chain, so the compiler can figure out the size -->
<!-- it needs to store a `List` value. Figure 15-2 shows what the `Cons` variant -->
<!-- looks like now. -->
<p><code>Cons</code>列挙子は、1つの<code>i32</code>のサイズプラスボックスのポインタデータを格納する領域を必要とするでしょう。
<code>Nil</code>列挙子は、値を格納しないので、<code>Cons</code>列挙子よりも必要な領域は小さいです。これで、
どんな<code>List</code>値も<code>i32</code>1つのサイズプラスボックスのポインタデータのサイズを必要とすることがわかりました。
ボックスを使うことで、無限の再帰的な繰り返しを破壊したので、コンパイラは、<code>List</code>値を格納するのに必要なサイズを計算できます。
図15-2は、<code>Cons</code>列挙子の今の見た目を示しています。</p>
<!-- <img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" /> -->
<p><img alt="有限のコンスリスト" src="img/trpl15-02.svg" class="center" /></p>
<!-- <span class="caption">Figure 15-2: A `List` that is not infinitely sized -->
<!-- because `Cons` holds a `Box`</span> -->
<p><span class="caption">図15-2: <code>Cons</code>が<code>Box</code>を保持しているので、無限にサイズがあるわけではない<code>List</code></span></p>
<!-- Boxes provide only the indirection and heap allocation; they don’t have any -->
<!-- other special capabilities, like those we’ll see with the other smart pointer -->
<!-- types. They also don’t have any performance overhead that these special -->
<!-- capabilities incur, so they can be useful in cases like the cons list where the -->
<!-- indirection is the only feature we need. We’ll look at more use cases for boxes -->
<!-- in Chapter 17, too. -->
<p>ボックスは、間接参照とヒープメモリ確保だけを提供します; 他のスマートポインタ型で目撃するような、
他の特別な能力は何もありません。これらの特別な能力が招くパフォーマンスのオーバーヘッドもないので、
間接参照だけが必要になる唯一の機能であるコンスリストのような場合に有用になり得ます。
より多くのボックスのユースケースは第17章でもお見かけするでしょう。</p>
<!-- The `Box<T>` type is a smart pointer because it implements the `Deref` trait, -->
<!-- which allows `Box<T>` values to be treated like references. When a `Box<T>` -->
<!-- value goes out of scope, the heap data that the box is pointing to is cleaned -->
<!-- up as well because of the `Drop` trait implementation. Let’s explore these two -->
<!-- traits in more detail. These two traits will be even more important to the -->
<!-- functionality provided by the other smart pointer types we’ll discuss in the -->
<!-- rest of this chapter. -->
<p><code>Box&lt;T&gt;</code>型は、<code>Deref</code>トレイトを実装しているので、スマートポインタであり、
このトレイトにより<code>Box&lt;T&gt;</code>の値を参照のように扱うことができます。<code>Box&lt;T&gt;</code>値がスコープを抜けると、
<code>Drop</code>トレイト実装によりボックスが参照しているヒープデータも片付けられます。
これら2つのトレイトをより詳しく探求しましょう。これら2つのトレイトは、
この章の残りで議論する他のスマートポインタ型で提供される機能にとってさらに重要でしょう。</p>
<!-- ## Treating Smart Pointers Like Regular References with the `Deref` Trait -->
<a class="header" href="print.html#derefトレイトでスマートポインタを普通の参照のように扱う" id="derefトレイトでスマートポインタを普通の参照のように扱う"><h2><code>Deref</code>トレイトでスマートポインタを普通の参照のように扱う</h2></a>
<!-- Implementing the `Deref` trait allows you to customize the behavior of the -->
<!-- *dereference operator*, `*` (as opposed to the multiplication or glob -->
<!-- operator). By implementing `Deref` in such a way that a smart pointer can be -->
<!-- treated like a regular reference, you can write code that operates on -->
<!-- references and use that code with smart pointers too. -->
<p><code>Deref</code>トレイトを実装することで<em>参照外し演算子</em>の<code>*</code>(掛け算やグロブ演算子とは対照的に)の振る舞いをカスタマイズすることができます。
スマートポインタを普通の参照のように扱えるように<code>Deref</code>を実装することで、
参照に対して処理を行うコードを書き、そのコードをスマートポインタとともに使用することもできます。</p>
<!-- Let’s first look at how dereference operator works with regular references.-->
<!-- Then we'll try to define a custom type that behaves like `Box<T>`, and see why -->
<!-- the dereference operator doesn't work like a reference on our newly defined -->
<!-- type. We’ll explore how implementing the `Deref` trait makes it possible for -->
<!-- smart pointers to work in a similar way as references. Then we’ll look at -->
<!-- Rust’s *deref coercion* feature and how it lets us work with either references -->
<!-- or smart pointers. -->
<p>まずは、参照外し演算子が普通の参照に対して動作するところを見ましょう。それから<code>Box&lt;T&gt;</code>のように振る舞う独自の型を定義し、
参照外し演算子が新しく定義した型に対して参照のように動作しない理由を確認しましょう。
<code>Deref</code>トレイトを実装することでスマートポインタが参照と似た方法で動作するようにできる方法を探求します。
そして、Rustの<em>参照外し型強制</em>機能と、それにより参照やスマートポインタに取り掛かる方法を見ます。</p>
<!-- ### Following the Pointer to the Value with the Dereference Operator -->
<a class="header" href="print.html#a参照外し演算子で値までポインタを追いかける" id="a参照外し演算子で値までポインタを追いかける"><h3>参照外し演算子で値までポインタを追いかける</h3></a>
<!-- A regular reference is a type of pointer, and one way to think of a pointer is -->
<!-- as an arrow to a value stored somewhere else. In Listing 15-6, we create a -->
<!-- reference to an `i32` value and then use the dereference operator to follow the -->
<!-- reference to the data: -->
<p>普通の参照は1種のポインタであり、ポインタの捉え方の一つが、どこか他の場所に格納された値への矢印としてです。
リスト15-6で、<code>i32</code>値への参照を生成し、それから参照外し演算子を使用して参照をデータまで追いかけています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-6: Using the dereference operator to follow a -->
<!-- reference to an `i32` value</span> -->
<p><span class="caption">リスト15-6: 参照外し演算子を使用して参照を<code>i32</code>値まで追いかける</span></p>
<!-- The variable `x` holds an `i32` value, `5`. We set `y` equal to a reference to -->
<!-- `x`. We can assert that `x` is equal to `5`. However, if we want to make an -->
<!-- assertion about the value in `y`, we have to use `*y` to follow the reference -->
<!-- to the value it’s pointing to (hence *dereference*). Once we dereference `y`, -->
<!-- we have access to the integer value `y` is pointing to that we can compare with -->
<!-- `5`. -->
<p>変数<code>x</code>は<code>i32</code>値の<code>5</code>を保持しています。<code>y</code>を<code>x</code>への参照にセットします。<code>x</code>は<code>5</code>に等しいとアサートできます。
しかしながら、<code>y</code>の値に関するアサートを行いたい場合、<code>*y</code>を使用して参照を指している値まで追いかけなければなりません(そのため<em>参照外し</em>です)。
一旦、<code>y</code>を参照外ししたら、<code>y</code>が指している<code>5</code>と比較できる整数値にアクセスできます。</p>
<!-- If we tried to write `assert_eq!(5, y);` instead, we would get this compilation -->
<!-- error: -->
<p>代わりに<code>assert_eq!(5, y);</code>と書こうとしたら、こんなコンパイルエラーが出るでしょう:</p>
<pre><code class="language-text">error[E0277]: the trait bound `{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;` is
not satisfied
(エラー: トレイト境界`{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;`は満たされていません)
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ can't compare `{integer}` with `&amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for
  `{integer}`
  (助言: トレイト`std::cmp::PartialEq&lt;&amp;{integer}&gt;`は`{integer}`に対して実装されていません)
</code></pre>
<!-- Comparing a number and a reference to a number isn’t allowed because they’re -->
<!-- different types. We must use the dereference operator to follow the reference -->
<!-- to the value it's pointing to. -->
<p>参照と数値は異なる型なので、比較することは許容されていません。参照外し演算子を使用して、
参照を指している値まで追いかけなければならないのです。</p>
<!-- ### Using `Box<T>` Like a Reference -->
<a class="header" href="print.html#boxtを参照のように使う" id="boxtを参照のように使う"><h3><code>Box&lt;T&gt;</code>を参照のように使う</h3></a>
<!-- We can rewrite the code in Listing 15-6 to use a `Box<T>` instead of a -->
<!-- reference; the dereference operator will work as shown in Listing 15-7: -->
<p>リスト15-6のコードを参照の代わりに<code>Box&lt;T&gt;</code>を使うように書き直すことができます;
参照外し演算子は、リスト15-7に示したように動くでしょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-7: Using the dereference operator on a -->
<!-- `Box<i32>`</span> -->
<p><span class="caption">リスト15-7: <code>Box&lt;i32&gt;</code>に対して参照外し演算子を使用する</span></p>
<!-- The only difference between Listing 15-7 and Listing 15-6 is that here we set -->
<!-- `y` to be an instance of a box pointing to the value in `x` rather than a -->
<!-- reference pointing to the value of `x`. In the last assertion, we can use the -->
<!-- dereference operator to follow the box’s pointer in the same way that we did -->
<!-- when `y` was a reference. Next, we’ll explore what is special about `Box<T>` -->
<!-- that enables us to use the dereference operator by defining our own box type. -->
<p>リスト15-7とリスト15-6の唯一の違いは、ここでは、<code>x</code>の値を指す参照ではなく、
<code>x</code>の値を指すボックスのインスタンスに<code>y</code>をセットしていることです。
最後のアサートで参照外し演算子を使用して<code>y</code>が参照だった時のようにボックスのポインタを追いかけることができます。
次に、独自のボックス型を定義することで参照外し演算子を使用させてくれる<code>Box&lt;T&gt;</code>について何が特別なのかを探求します。</p>
<!-- ### Defining Our Own Smart Pointer -->
<a class="header" href="print.html#a独自のスマートポインタを定義する" id="a独自のスマートポインタを定義する"><h3>独自のスマートポインタを定義する</h3></a>
<!-- Let’s build a smart pointer similar to the `Box<T>` type provided by the -->
<!-- standard library to experience how smart pointers behave differently than -->
<!-- references by default. Then we’ll look at how to add the ability to use the -->
<!-- dereference operator. -->
<p>標準ライブラリが提供している<code>Box&lt;T&gt;</code>型に似たスマートポインタを構築して、スマートポインタは規定で、
どう異なって参照に比べて振る舞うのか経験しましょう。それから、参照外し演算子を使う能力を追加する方法に目を向けましょう。</p>
<!-- The `Box<T>` type is ultimately defined as a tuple struct with one element, so -->
<!-- Listing 15-8 defines a `MyBox<T>` type in the same way. We’ll also define a -->
<!-- `new` function to match the `new` function defined on `Box<T>`. -->
<p><code>Box&lt;T&gt;</code>型は究極的に1要素のタプル構造体として定義されているので、リスト15-8は、同じように<code>MyBox&lt;T&gt;</code>型を定義しています。
また、<code>Box&lt;T&gt;</code>に定義された<code>new</code>関数と合致する<code>new</code>関数も定義しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 15-8: Defining a `MyBox<T>` type</span> -->
<p><span class="caption">リスト15-8: <code>MyBox&lt;T&gt;</code>型を定義する</span></p>
<!-- We define a struct named `MyBox` and declare a generic parameter `T`, because -->
<!-- we want our type to hold values of any type. The `MyBox` type is a tuple struct -->
<!-- with one element of type `T`. The `MyBox::new` function takes one parameter of -->
<!-- type `T` and returns a `MyBox` instance that holds the value passed in. -->
<p><code>MyBox</code>という構造体を定義し、ジェネリック引数の<code>T</code>を宣言しています。自分の型にどんな型の値も保持させたいからです。
<code>MyBox</code>型は、型<code>T</code>を1要素持つタプル構造体です。<code>MyBox::new</code>関数は型<code>T</code>の引数を1つ取り、
渡した値を保持する<code>MyBox</code>インスタンスを返します。</p>
<!-- Let’s try adding the `main` function in Listing 15-7 to Listing 15-8 and -->
<!-- changing it to use the `MyBox<T>` type we’ve defined instead of `Box<T>`. The -->
<!-- code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference -->
<!-- `MyBox`. -->
<p>試しにリスト15-7の<code>main</code>関数をリスト15-8に追加し、<code>Box&lt;T&gt;</code>の代わりに定義した<code>MyBox&lt;T&gt;</code>型を使うよう変更してみてください。
コンパイラは<code>MyBox</code>を参照外しする方法がわからないので、リスト15-9のコードはコンパイルできません。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<!-- <span class="caption">Listing 15-9: Attempting to use `MyBox<T>` in the same -->
<!-- way we used references and `Box<T>`</span> -->
<p><span class="caption">リスト15-9: 参照と<code>Box&lt;T&gt;</code>を使ったのと同じように<code>MyBox&lt;T&gt;</code>を使おうとする</span></p>
<!-- Here’s the resulting compilation error: -->
<p>こちらが結果として出るコンパイルエラーです:</p>
<pre><code class="language-text">error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
(エラー: 型`MyBox&lt;{integer}&gt;`は参照外しできません)
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
</code></pre>
<!-- Our `MyBox<T>` type can’t be dereferenced because we haven’t implemented that -->
<!-- ability on our type. To enable dereferencing with the `*` operator, we -->
<!-- implement the `Deref` trait. -->
<p><code>MyBox&lt;T&gt;</code>に参照外しの能力を実装していないので、参照外しできません。<code>*</code>演算子で参照外しできるようにするには、
<code>Deref</code>トレイトを実装します。</p>
<!-- ### Treating a Type Like a Reference by Implementing the `Deref` Trait -->
<a class="header" href="print.html#derefトレイトを実装して型を参照のように扱う" id="derefトレイトを実装して型を参照のように扱う"><h3><code>Deref</code>トレイトを実装して型を参照のように扱う</h3></a>
<!-- As discussed in Chapter 10, to implement a trait, we need to provide -->
<!-- implementations for the trait’s required methods. The `Deref` trait, provided -->
<!-- by the standard library, requires us to implement one method named `deref` that -->
<!-- borrows `self` and returns a reference to the inner data. Listing 15-10 -->
<!-- contains an implementation of `Deref` to add to the definition of `MyBox`: -->
<p>第10章で議論したように、トレイトを実装するには、トレイトの必須メソッドに実装を提供する必要があります。
<code>Deref</code>トレイトは標準ライブラリで提供されていますが、<code>self</code>を借用し、
内部のデータへの参照を返す<code>deref</code>という1つのメソッドを実装する必要があります。リスト15-10には、
<code>MyBox</code>の定義に追記する<code>Deref</code>の実装が含まれています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Deref;

# struct MyBox&lt;T&gt;(T);
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 15-10: Implementing `Deref` on `MyBox<T>`</span> -->
<p><span class="caption">リスト15-10: <code>MyBox&lt;T&gt;</code>に<code>Deref</code>を実装する</span></p>
<!-- The `type Target = T;` syntax defines an associated type for the `Deref` trait -->
<!-- to use. Associated types are a slightly different way of declaring a generic -->
<!-- parameter, but you don’t need to worry about them for now; we’ll cover them in -->
<!-- more detail in Chapter 19. -->
<p><code>type Target = T;</code>という記法は、<code>Deref</code>トレイトが使用する関連型を定義しています。関連型は、
ジェネリック引数を宣言する少しだけ異なる方法ですが、今は気にする必要はありません; 第19章でより詳しく講義します。</p>
<!-- We fill in the body of the `deref` method with `&self.0` so `deref` returns a -->
<!-- reference to the value we want to access with the `*` operator. The `main` -->
<!-- function in Listing 15-9 that calls `*` on the `MyBox<T>` value now compiles, -->
<!-- and the assertions pass! -->
<p><code>deref</code>メソッドの本体を<code>&amp;self.0</code>で埋めているので、<code>deref</code>は<code>*</code>演算子でアクセスしたい値への参照を返します。
リスト15-9の<code>MyBox&lt;T&gt;</code>に<code>*</code>を呼び出す<code>main</code>関数はこれでコンパイルでき、アサートも通ります！</p>
<!-- Without the `Deref` trait, the compiler can only dereference `&` references. -->
<!-- The `deref` method gives the compiler the ability to take a value of any type -->
<!-- that implements `Deref` and call the `deref` method to get a `&` reference that -->
<!-- it knows how to dereference. -->
<p><code>Deref</code>がなければ、コンパイラは<code>&amp;</code>参照しか参照外しできなくなります。<code>deref</code>メソッドによりコンパイラは、
<code>Deref</code>を実装するあらゆる型の値を取り、<code>deref</code>メソッドを呼び出して参照外しの仕方を知っている<code>&amp;</code>参照を得る能力を獲得するのです。</p>
<!-- When we entered `*y` in Listing 15-9, behind the scenes Rust actually ran this -->
<!-- code: -->
<p>リスト15-9に<code>*y</code>を入力した時、水面下でコンパイラは、実際にはこのようなコードを走らせていました:</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<!-- 最後の行は、これで合っているのか自信がない・・・ -->
<!-- Rust substitutes the `*` operator with a call to the `deref` method and then a -->
<!-- plain dereference so we don’t have to think about whether or not we need to -->
<!-- call the `deref` method. This Rust feature lets us write code that functions -->
<!-- identically whether we have a regular reference or a type that implements -->
<!-- `Deref`. -->
<p>コンパイラは、<code>*</code>演算子を<code>deref</code>メソッド、それから何の変哲もない参照外しの呼び出しに置き換えるので、
<code>deref</code>メソッドを呼び出す必要があるかどうかを考える必要はないわけです。このRustの機能により、
普通の参照か<code>Deref</code>を実装した型があるかどうかと等しく機能するコードを書くことができます。</p>
<!-- The reason the `deref` method returns a reference to a value and that the plain -->
<!-- dereference outside the parentheses in `*(y.deref())` is still necessary is the -->
<!-- ownership system. If the `deref` method returned the value directly instead of -->
<!-- a reference to the value, the value would be moved out of `self`. We don't want -->
<!-- to take ownership of the inner value inside `MyBox<T>` in this case or in most -->
<!-- cases where we use the dereference operator. -->
<p><code>deref</code>メソッドが値への参照を返し、<code>*(y.deref())</code>のかっこの外の何の変哲もない参照外しがそれでも必要な理由は、
所有権システムです。<code>deref</code>メソッドが値への参照ではなく、値を直接返したら、値は<code>self</code>から外にムーブされてしまいます。
今回の場合や、参照外し演算子を使用する多くの場合には<code>MyBox&lt;T&gt;</code>の中の値の所有権を奪いたくはありません。</p>
<!-- 1行目、just once, each timeのところがよくわからないが、おそらくこれで合っていると思われる-->
<!-- Note that the `*` operator is replaced with a call to the `deref` method and -->
<!-- then a call to `*` operator just once, each time we type a `*` in our code. -->
<!-- Because the substitution of the `*` operator does not recurse infinitely, we -->
<!-- end up with data of type `i32`, which matches the `5` in `assert_eq!` in -->
<!-- Listing 15-9. -->
<p><code>*</code>演算子は<code>deref</code>メソッドの呼び出し1回とコードで<code>*</code>打つたび、ただ1回の<code>*</code>演算子の呼び出しに置き換えられることに注意してください。
<code>*</code>演算子の置き換えは、無限に繰り返されないので、型<code>i32</code>に行き着き、リスト15-9で<code>assert_eq!</code>の<code>5</code>と合致します。</p>
<!-- ### Implicit Deref Coercions with Functions and Methods -->
<a class="header" href="print.html#a関数やメソッドで暗黙的な参照外し型強制" id="a関数やメソッドで暗黙的な参照外し型強制"><h3>関数やメソッドで暗黙的な参照外し型強制</h3></a>
<!-- *Deref coercion* is a convenience that Rust performs on arguments to functions -->
<!-- and methods. Deref coercion converts a reference to a type that implements -->
<!-- `Deref` into a reference to a type that `Deref` can convert the original type -->
<!-- into. Deref coercion happens automatically when we pass a reference to a -->
<!-- particular type’s value as an argument to a function or method that doesn’t -->
<!-- match the parameter type in the function or method definition. A sequence of -->
<!-- calls to the `deref` method converts the type we provided into the type the -->
<!-- parameter needs. -->
<p><em>参照外し型強制</em>は、コンパイラが関数やメソッドの実引数に行う便利なものです。参照外し型強制は、
<code>Deref</code>を実装する型への参照を<code>Deref</code>が元の型を変換できる型への参照に変換します。参照外し型強制は、
特定の型の値への参照を関数やメソッド定義の引数型と一致しない引数として関数やメソッドに渡すときに自動的に発生します。
一連の<code>deref</code>メソッドの呼び出しが、提供した型を引数が必要とする型に変換します。</p>
<!-- 2行目、add as many ...がよくわからない-->
<!-- Deref coercion was added to Rust so that programmers writing function and -->
<!-- method calls don’t need to add as many explicit references and dereferences -->
<!-- with `&` and `*`. The deref coercion feature also lets us write more code that -->
<!-- can work for either references or smart pointers. -->
<p>参照外し型強制は、関数やメソッド呼び出しを書くプログラマが<code>&amp;</code>や<code>*</code>で多くの明示的な参照や参照外しとして追加する必要がないように、
Rustに追加されました。また、参照外し型強制のおかげで参照あるいはスマートポインタのどちらかで動くコードをもっと書くことができます。</p>
<!-- To see deref coercion in action, let’s use the `MyBox<T>` type we defined in -->
<!-- Listing 15-8 as well as the implementation of `Deref` that we added in Listing -->
<!-- 15-10. Listing 15-11 shows the definition of a function that has a string slice -->
<!-- parameter: -->
<p>参照外し型強制が実際に動いていることを確認するため、リスト15-8で定義した<code>MyBox&lt;T&gt;</code>と、
リスト15-10で追加した<code>Deref</code>の実装を使用しましょう。リスト15-11は、
文字列スライス引数のある関数の定義を示しています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 15-11: A `hello` function that has the parameter -->
<!-- `name` of type `&str`</span> -->
<p><span class="caption">リスト15-11: 型<code>&amp;str</code>の引数<code>name</code>のある<code>hello</code>関数</span></p>
<!-- We can call the `hello` function with a string slice as an argument, such as -->
<!-- `hello("Rust");` for example. Deref coercion makes it possible to call `hello` -->
<!-- with a reference to a value of type `MyBox<String>`, as shown in Listing 15-12: -->
<p><code>hello</code>関数は、文字列スライスを引数として呼び出すことができます。例えば、<code>hello(&quot;Rust&quot;)</code>などです。
参照外し型強制により、<code>hello</code>を型<code>MyBox&lt;String&gt;</code>の値への参照とともに呼び出すことができます。リスト15-12のようにですね:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MyBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MyBox&lt;T&gt; {
#     fn new(x: T) -&gt; MyBox&lt;T&gt; {
#         MyBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn hello(name: &amp;str) {
#     println!(&quot;Hello, {}!&quot;, name);
# }
#
fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-12: Calling `hello` with a reference to a -->
<!-- `MyBox<String>` value, which works because of deref coercion</span> -->
<p><span class="caption">リスト15-12: <code>hello</code>を<code>MyBox&lt;String&gt;</code>値とともに呼び出し、参照外し型強制のおかげで動く</span></p>
<!-- Here we’re calling the `hello` function with the argument `&m`, which is a -->
<!-- reference to a `MyBox<String>` value. Because we implemented the `Deref` trait -->
<!-- on `MyBox<T>` in Listing 15-10, Rust can turn `&MyBox<String>` into `&String` -->
<!-- by calling `deref`. The standard library provides an implementation of `Deref` -->
<!-- on `String` that returns a string slice, and this is in the API documentation -->
<!-- for `Deref`. Rust calls `deref` again to turn the `&String` into `&str`, which -->
<!-- matches the `hello` function’s definition. -->
<p>ここで、<code>hello</code>関数を引数<code>&amp;m</code>とともに呼び出しています。この引数は、<code>MyBox&lt;String&gt;</code>値への参照です。
リスト15-10で<code>MyBox&lt;T&gt;</code>に<code>Deref</code>トレイトを実装したので、コンパイラは<code>deref</code>を呼び出すことで、
<code>&amp;MyBox&lt;String&gt;</code>を<code>&amp;String</code>に変換できるのです。標準ライブラリは、<code>String</code>に文字列スライスを返す<code>Deref</code>の実装を提供していて、
この実装は、<code>Deref</code>のAPIドキュメンテーションに載っています。コンパイラはさらに<code>deref</code>を呼び出して、
<code>&amp;String</code>を<code>&amp;str</code>に変換し、これは<code>hello</code>関数の定義と合致します。</p>
<!-- If Rust didn’t implement deref coercion, we would have to write the code in -->
<!-- Listing 15-13 instead of the code in Listing 15-12 to call `hello` with a value -->
<!-- of type `&MyBox<String>`. -->
<p>Rustに参照外し型強制が実装されていなかったら、リスト15-12のコードの代わりにリスト15-13のコードを書き、
型<code>&amp;MyBox&lt;String&gt;</code>の値で<code>hello</code>を呼び出さなければならなかったでしょう。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::ops::Deref;
#
# struct MyBox&lt;T&gt;(T);
#
# impl&lt;T&gt; MyBox&lt;T&gt; {
#     fn new(x: T) -&gt; MyBox&lt;T&gt; {
#         MyBox(x)
#     }
# }
#
# impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
#     type Target = T;
#
#     fn deref(&amp;self) -&gt; &amp;T {
#         &amp;self.0
#     }
# }
#
# fn hello(name: &amp;str) {
#     println!(&quot;Hello, {}!&quot;, name);
# }
#
fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-13: The code we would have to write if Rust -->
<!-- didn’t have deref coercion</span> -->
<p><span class="caption">リスト15-13: Rustに参照外し型強制がなかった場合に書かなければならないであろうコード</span></p>
<!-- The `(*m)` dereferences the `MyBox<String>` into a `String`. Then the `&` and -->
<!-- `[..]` take a string slice of the `String` that is equal to the whole string to -->
<!-- match the signature of `hello`. The code without deref coercions is harder to -->
<!-- read, write, and understand with all of these symbols involved. Deref coercion -->
<!-- allows Rust to handle these conversions for us automatically. -->
<p><code>(*m)</code>が<code>MyBox&lt;String&gt;</code>を<code>String</code>に参照外ししています。そして、<code>&amp;</code>と<code>[..]</code>により、
文字列全体と等しい<code>String</code>の文字列スライスを取り、<code>hello</code>のシグニチャと一致するわけです。
参照外し型強制のないコードは、これらの記号が関係するので、読むのも書くのも理解するのもより難しくなります。
参照外し型強制により、コンパイラはこれらの変換を自動的に扱えるのです。</p>
<!-- When the `Deref` trait is defined for the types involved, Rust will analyze the -->
<!-- types and use `Deref::deref` as many times as necessary to get a reference to -->
<!-- match the parameter’s type. The number of times that `Deref::deref` needs to be -->
<!-- inserted is resolved at compile time, so there is no runtime penalty for taking -->
<!-- advantage of deref coercion! -->
<p><code>Deref</code>トレイトが関係する型に定義されていると、コンパイラは、型を分析し必要なだけ<code>Deref::deref</code>を使用して、
参照を得、引数の型と一致させます。<code>Deref::deref</code>が挿入される必要のある回数は、コンパイル時に解決されるので、
参照外し型強制を活用する実行時の代償は何もありません。</p>
<!-- ### How Deref Coercion Interacts with Mutability -->
<a class="header" href="print.html#a参照外し型強制が可変性と相互作用する方法" id="a参照外し型強制が可変性と相互作用する方法"><h3>参照外し型強制が可変性と相互作用する方法</h3></a>
<!-- Similar to how we use the `Deref` trait to override `*` operator on -->
<!-- immutable references, you can use the `DerefMut` trait to override the `*` -->
<!-- operator on mutable references. -->
<p><code>Deref</code>トレイトを使用して不変参照に対して<code>*</code>をオーバーライドするように、R
<code>DerefMut</code>トレイトを使用して可変参照の<code>*</code>演算子をオーバーライドできます。</p>
<!-- Rust does deref coercion when it finds types and trait implementations in three -->
<!-- cases: -->
<p>以下の3つの場合に型やトレイト実装を見つけた時にコンパイラは、参照外し型強制を行います:</p>
<!-- * From `&T` to `&U` when `T: Deref<Target=U>` -->
<!-- * From `&mut T` to `&mut U` when `T: DerefMut<Target=U>` -->
<!-- * From `&mut T` to `&U` when `T: Deref<Target=U>` -->
<ul>
<li><code>T: Deref&lt;Target=U&gt;</code>の時、<code>&amp;T</code>から<code>&amp;U</code></li>
<li><code>T: DerefMut&lt;Target=U&gt;</code>の時、<code>&amp;mut T</code>から<code>&amp;mut U</code></li>
<li><code>T: Deref&lt;Target=U&gt;</code>の時、<code>&amp;mut T</code>から<code>&amp;U</code></li>
</ul>
<!-- The first two cases are the same except for mutability. The first case states -->
<!-- that if you have a `&T`, and `T` implements `Deref` to some type `U`, you can -->
<!-- get a `&U` transparently. The second case states that the same deref coercion -->
<!-- happens for mutable references. -->
<p>前者2つは、可変性を除いて一緒です。最初のケースは、<code>&amp;T</code>があり、<code>T</code>が何らかの型<code>U</code>への<code>Deref</code>を実装しているなら、
透過的に<code>&amp;U</code>を得られると述べています。2番目のケースは、同じ参照外し型強制が可変参照についても起こることを述べています。</p>
<!-- 8行目後半、andだが、逆説で訳した -->
<!-- The third case is trickier: Rust will also coerce a mutable reference to an -->
<!-- immutable one. But the reverse is *not* possible: immutable references will -->
<!-- never coerce to mutable references. Because of the borrowing rules, if you have -->
<!-- a mutable reference, that mutable reference must be the only reference to that -->
<!-- data (otherwise, the program wouldn’t compile). Converting one mutable -->
<!-- reference to one immutable reference will never break the borrowing rules. -->
<!-- Converting an immutable reference to a mutable reference would require that -->
<!-- there is only one immutable reference to that data, and the borrowing rules -->
<!-- don’t guarantee that. Therefore, Rust can’t make the assumption that converting -->
<!-- an immutable reference to a mutable reference is possible. -->
<p>3番目のケースはもっと巧妙です: Rustはさらに、可変参照を不変参照にも型強制するのです。ですが、逆はできま<em>せん</em>:
不変参照は、絶対に可変参照に型強制されないのです。借用ルールにより、可変参照があるなら、
その可変参照がそのデータへの唯一の参照に違いありません(でなければ、プログラムはコンパイルできません)。
1つの可変参照を1つの不変参照に変換することは、借用ルールを絶対に破壊しません。
不変参照を可変参照にするには、そのデータへの不変参照がたった1つしかないことが必要ですが、
借用ルールはそれを保証してくれません。故に、不変参照を可変参照に変換することが可能であるという前提を敷けません。</p>
<!-- ## Running Code on Cleanup with the `Drop` Trait -->
<a class="header" href="print.html#dropトレイトで片付け時にコードを走らせる" id="dropトレイトで片付け時にコードを走らせる"><h2><code>Drop</code>トレイトで片付け時にコードを走らせる</h2></a>
<!-- The second trait important to the smart pointer pattern is `Drop`, which lets -->
<!-- you customize what happens when a value is about to go out of scope. You can -->
<!-- provide an implementation for the `Drop` trait on any type, and the code you -->
<!-- specify can be used to release resources like files or network connections. -->
<!-- We’re introducing `Drop` in the context of smart pointers because the -->
<!-- functionality of the `Drop` trait is almost always used when implementing a -->
<!-- smart pointer. For example, `Box<T>` customizes `Drop` to deallocate the space -->
<!-- on the heap that the box points to. -->
<p>スマートポインタパターンにとって重要な2番目のトレイトは、<code>Drop</code>であり、
これのおかげで値がスコープを抜けそうになった時に起こることをカスタマイズできます。
どんな型に対しても<code>Drop</code>トレイトの実装を提供することができ、指定したコードは、
ファイルやネットワーク接続などのリソースを解放するのに活用できます。
<code>Drop</code>をスマートポインタの文脈で導入しています。<code>Drop</code>トレイトの機能は、ほぼ常にスマートポインタを実装する時に使われるからです。
例えば、<code>Box&lt;T&gt;</code>は<code>Drop</code>をカスタマイズしてボックスが指しているヒープの領域を解放しています。</p>
<!-- In some languages, the programmer must call code to free memory or resources -->
<!-- every time they finish using an instance of a smart pointer. If they forget, -->
<!-- the system might become overloaded and crash. In Rust, you can specify that a -->
<!-- particular bit of code be run whenever a value goes out of scope, and the -->
<!-- compiler will insert this code automatically. As a result, we don’t need to be -->
<!-- careful about placing cleanup code everywhere in a program that an instance of -->
<!-- a particular type is finished with-you still won’t leak resources! -->
<p>ある言語では、プログラマがスマートポインタのインスタンスを使い終わる度にメモリやリソースを解放するコードを呼ばなければなりません。
忘れてしまったら、システムは詰め込みすぎになりクラッシュする可能性があります。Rustでは、
値がスコープを抜ける度に特定のコードが走るよう指定でき、コンパイラはこのコードを自動的に挿入します。
結果として、特定の型のインスタンスを使い終わったプログラムの箇所全部にクリーンアップコードを配置するのに配慮する必要はありません。
それでもリソースをリークすることはありません。</p>
<!-- Specify the code to run when a value goes out of scope by implementing the -->
<!-- `Drop` trait. The `Drop` trait requires you to implement one method named -->
<!-- `drop` that takes a mutable reference to `self`. To see when Rust calls `drop`, -->
<!-- let's implement `drop` with `println!` statements for now. -->
<p><code>Drop</code>トレイトを実装することで値がスコープを抜けた時に走るコードを指定してください。
<code>Drop</code>トレイトは、<code>self</code>への可変参照を取る<code>drop</code>という1つのメソッドを実装する必要があります。
いつRustが<code>drop</code>を呼ぶのか確認するために、今は<code>println!</code>文のある<code>drop</code>を実装しましょう。</p>
<!-- Listing 15-14 shows a `CustomSmartPointer` struct whose only custom -->
<!-- functionality is that it will print `Dropping CustomSmartPointer!` when the -->
<!-- instance goes out of scope. This example demonstrates when Rust runs the `drop` -->
<!-- function. -->
<p>リスト15-14は、唯一の独自の機能が、インスタンスがスコープを抜ける時に<code>Dropping CustomSmartPointer!</code>と出力するだけの、
<code>CustomSmartPointer</code>構造体です。この例は、コンパイラがいつ<code>drop</code>関数を走らせるかをデモしています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        // CustomSmartPointerをデータ`{}`とともにドロップするよ
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;my stuff&quot;) };      // 俺のもの
    let d = CustomSmartPointer { data: String::from(&quot;other stuff&quot;) };   // 別のもの
    println!(&quot;CustomSmartPointers created.&quot;);                           // CustomSmartPointerが生成された
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-14: A `CustomSmartPointer` struct that -->
<!-- implements the `Drop` trait where we would put our cleanup code</span> -->
<p><span class="caption">リスト15-14: クリーンアップコードを配置する<code>Drop</code>トレイトを実装する<code>CustomSmartPointer</code>構造体</span></p>
<!-- The `Drop` trait is included in the prelude, so we don’t need to import it. We -->
<!-- implement the `Drop` trait on `CustomSmartPointer` and provide an -->
<!-- implementation for the `drop` method that calls `println!`. The body of the -->
<!-- `drop` function is where you would place any logic that you wanted to run when -->
<!-- an instance of your type goes out of scope. We’re printing some text here to -->
<!-- demonstrate when Rust will call `drop`. -->
<p><code>Drop</code>トレイトは、初期化処理に含まれるので、インポートする必要はありません。
<code>CustomSmartPointer</code>に<code>Drop</code>トレイトを実装し、<code>println!</code>を呼び出す<code>drop</code>メソッドの実装を提供しています。
<code>drop</code>関数の本体は、自分の型のインスタンスがスコープを抜ける時に走らせたいあらゆるロジックを配置する場所です。
ここで何らかのテキストを出力し、コンパイラがいつ<code>drop</code>を呼ぶのかデモしています。</p>
<!-- In `main`, we create two instances of `CustomSmartPointer` and then print -->
<!-- `CustomSmartPointers created.`. At the end of `main`, our instances of -->
<!-- `CustomSmartPointer` will go out of scope, and Rust will call the code we put -->
<!-- in the `drop` method, printing our final message. Note that we didn’t need to -->
<!-- call the `drop` method explicitly. -->
<p><code>main</code>で、<code>CustomSmartPointer</code>のインスタンスを2つ作り、それから<code>CustomSmartPointers created.</code>と出力しています。
<code>main</code>の最後で、<code>CustomSmartPointer</code>のインスタンスはスコープを抜け、コンパイラは最後のメッセージを出力しながら、
<code>drop</code>メソッドに置いたコードを呼び出します。<code>drop</code>メソッドを明示的に呼び出す必要はなかったことに注意してください。</p>
<!-- When we run this program, we’ll see the following output: -->
<p>このプログラムを実行すると、以下のような出力が出ます:</p>
<pre><code class="language-text">CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<!-- Rust automatically called `drop` for us when our instances went out of scope, -->
<!-- calling the code we specified. Variables are dropped in the reverse order of -->
<!-- their creation, so `d` was dropped before `c`. This example gives you a visual -->
<!-- guide to how the `drop` method works; usually you would specify the cleanup -->
<!-- code that your type needs to run rather than a print message. -->
<p>インスタンスがスコープを抜けた時に指定したコードを呼び出しながらコンパイラは、<code>drop</code>を自動的に呼び出してくれました。
変数は、生成されたのと逆の順序でドロップされるので、<code>d</code>は<code>c</code>より先にドロップされました。
この例は、<code>drop</code>メソッドの動き方を見た目で案内するだけですが、通常は、メッセージ出力ではなく、
自分の型が走らせる必要のあるクリーンアップコードを指定するでしょう。</p>
<!-- ### Dropping a Value Early with `std::mem::drop` -->
<a class="header" href="print.html#stdmemdropで早期に値をドロップする" id="stdmemdropで早期に値をドロップする"><h3><code>std::mem::drop</code>で早期に値をドロップする</h3></a>
<!-- Unfortunately, it’s not straightforward to disable the automatic `drop` -->
<!-- functionality. Disabling `drop` isn’t usually necessary; the whole point of the -->
<!-- `Drop` trait is that it’s taken care of automatically. Occasionally, however -->
<!-- you might want to clean up a value early. One example is when using smart -->
<!-- pointers that manage locks: you might want to force the `drop` method that -->
<!-- releases the lock to run so other code in the same scope can acquire the lock. -->
<!-- Rust doesn't let you call the `Drop` trait’s `drop` method manually; instead -->
<!-- you have to call the `std::mem::drop` function provided by the standard library -->
<!-- if you want to force a value to be dropped before the end of its scope. -->
<p>残念ながら、自動的な<code>drop</code>機能を無効化することは、素直ではありません。通常、<code>drop</code>を無効化する必要はありません;
<code>Drop</code>トレイトの重要な目的は、自動的に考慮されることです。ですが、時として、値を早期に片付けたくなる可能性があります。
一例は、ロックを管理するスマートポインタを使用する時です: 同じスコープの他のコードがロックを獲得できるように、
ロックを解放する<code>drop</code>メソッドを強制的に走らせたくなる可能性があります。Rustは、
<code>Drop</code>トレイトの<code>drop</code>メソッドを手動で呼ばせてくれません; スコープが終わる前に値を強制的にドロップさせたいなら、
標準ライブラリが提供する<code>std::mem:drop</code>関数を呼ばなければなりません。</p>
<!-- If we try to call the `Drop` trait's `drop` method manually by modifying the -->
<!-- `main` function in Listing 15-14, as shown in Listing 15-15, we'll get a -->
<!-- compiler error: -->
<p>リスト15-14の<code>main</code>関数を変更して手動で<code>Drop</code>トレイトの<code>drop</code>メソッドを呼び出そうとしたら、
コンパイルエラーになるでしょう。リスト15-15のようにですね:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    // mainの終端の前にCustomSmartPointerがドロップされた
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre>
<!-- <span class="caption">Listing 15-15: Attempting to call the `drop` method from -->
<!-- the `Drop` trait manually to clean up early</span> -->
<p><span class="caption">リスト15-15: <code>Drop</code>トレイトから<code>drop</code>メソッドを手動で呼び出し、早期に片付けようとする</span></p>
<!-- When we try to compile this code, we’ll get this error: -->
<p>このコードをコンパイルしてみようとすると、こんなエラーが出ます:</p>
<pre><code class="language-text">error[E0040]: explicit use of destructor method
(エラー: デストラクタメソッドを明示的に使用しています)
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
</code></pre>
<!-- This error message states that we’re not allowed to explicitly call `drop`. The -->
<!-- error message uses the term *destructor*, which is the general programming term -->
<!-- for a function that cleans up an instance. A *destructor* is analogous to a -->
<!-- *constructor*, which creates an instance. The `drop` function in Rust is one -->
<!-- particular destructor. -->
<p>明示的に<code>drop</code>を呼び出すことは許されていないことをこのエラーメッセージは述べています。
エラーメッセージは<em>デストラクタ</em>という専門用語を使っていて、これは、
インスタンスを片付ける関数の一般的なプログラミング専門用語です。<em>デストラクタ</em>は、
<em>コンストラクタ</em>に類似していて、これはインスタンスを生成します。Rustの<code>drop</code>関数は、
1種の特定のデストラクタです。</p>
<!-- Rust doesn’t let us call `drop` explicitly because Rust would still -->
<!-- automatically call `drop` on the value at the end of `main`. This would be a -->
<!-- *double free* error because Rust would be trying to clean up the same value -->
<!-- twice. -->
<p>コンパイラはそれでも、<code>main</code>の終端で値に対して自動的に<code>drop</code>を呼び出すので、<code>drop</code>を明示的に呼ばせてくれません。
コンパイラが2回同じ値を片付けようとするので、これは<em>二重解放</em>エラーになるでしょう。</p>
<!-- We can’t disable the automatic insertion of `drop` when a value goes out of -->
<!-- scope, and we can’t call the `drop` method explicitly. So, if we need to force -->
<!-- a value to be cleaned up early, we can use the `std::mem::drop` function. -->
<p>値がスコープを抜けるときに<code>drop</code>が自動的に挿入されるのを無効化できず、<code>drop</code>メソッドを明示的に呼ぶこともできません。
よって、値を早期に片付けさせる必要があるなら、<code>std::mem::drop</code>関数を使用できます。</p>
<!-- The `std::mem::drop` function is different than the `drop` method in the `Drop` -->
<!-- trait. We call it by passing the value we want to force to be dropped early as -->
<!-- an argument. The function is in the prelude, so we can modify `main` in Listing -->
<!-- 15-15 to call the `drop` function, as shown in Listing 15-16: -->
<p><code>std::mem::drop</code>関数は、<code>Drop</code>トレイトの<code>drop</code>メソッドとは異なります。
早期に強制的にドロップさせたい値を引数で渡すことで呼びます。この関数は初期化処理に含まれているので、
リスト15-14の<code>main</code>を変更して<code>drop</code>関数を呼び出せます。リスト15-16のようにですね:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># struct CustomSmartPointer {
#     data: String,
# }
#
# impl Drop for CustomSmartPointer {
#     fn drop(&amp;mut self) {
#         println!(&quot;Dropping CustomSmartPointer!&quot;);
#     }
# }
#
fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    // CustomSmartPointerはmainが終わる前にドロップされた
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-16: Calling `std::mem::drop` to explicitly -->
<!-- drop a value before it goes out of scope</span> -->
<p><span class="caption">リスト15-16: 値がスコープを抜ける前に明示的にドロップするために<code>std::mem::drop</code>を呼び出す</span></p>
<!-- Running this code will print the following: -->
<p>このコードを実行すると、以下のように出力されます:</p>
<pre><code class="language-text">CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<!-- The text ```Dropping CustomSmartPointer with data `some data`!``` is printed -->
<!-- between the `CustomSmartPointer created.` and `CustomSmartPointer dropped -->
<!-- before the end of main.` text, showing that the `drop` method code is called to -->
<!-- drop `c` at that point. -->
<p><code>Dropping CustomSmartPointer with data `some data`!</code>というテキストが、
<code>CustomSmartPointer created.</code>と<code>CustomSmartPointer dropped before the end of main</code>テキストの間に出力されるので、
<code>drop</code>メソッドのコードがその時点で呼び出されて<code>c</code>をドロップしたことを示しています。</p>
<!-- 3行目のwithを...があれば、と訳している。多分辞書にも載っている -->
<!-- You can use code specified in a `Drop` trait implementation in many ways to -->
<!-- make cleanup convenient and safe: for instance, we could use it to create your-->
<!-- own memory allocator! With the `Drop` trait and Rust’s ownership system, you-->
<!-- don't have to remember to clean up because Rust does it automatically. -->
<p><code>Drop</code>トレイト実装で指定されたコードをいろんな方法で使用し、片付けを便利で安全にすることができます:
例を挙げれば、これを使用して独自のメモリアロケータを作ることもできるでしょう。<code>Drop</code>トレイトとRustの所有権システムがあれば、
コンパイラが自動的に行うので、片付けを覚えておく必要はなくなります。</p>
<!-- You also don’t have to worry about problems resulting from accidentally -->
<!-- cleaning up values still in use: the ownership system that makes sure -->
<!-- references are always valid also ensures that `drop` gets called only once when -->
<!-- the value is no longer being used. -->
<p>まだ使用中の値を間違って片付けてしまうことに起因する問題を心配もしなくて済みます:
参照が常に有効であると確認してくれる所有権システムが、値が最早使用されなくなった時に<code>drop</code>が1回だけ呼ばれることを保証してくれるのです。</p>
<!-- Now that we’ve examined `Box<T>` and some of the characteristics of smart -->
<!-- pointers, let’s look at a few other smart pointers defined in the standard -->
<!-- library. -->
<p>これで<code>Box&lt;T&gt;</code>とスマートポインタの特徴の一部を調査したので、標準ライブラリに定義されている他のスマートポインタをいくつか見ましょう。</p>
<!-- ## `Rc<T>`, the Reference Counted Smart Pointer -->
<a class="header" href="print.html#rctは参照カウント方式のスマートポインタ" id="rctは参照カウント方式のスマートポインタ"><h2><code>Rc&lt;T&gt;</code>は、参照カウント方式のスマートポインタ</h2></a>
<!-- In the majority of cases, ownership is clear: you know exactly which variable -->
<!-- owns a given value. However, there are cases when a single value might have -->
<!-- multiple owners. For example, in graph data structures, multiple edges might -->
<!-- point to the same node, and that node is conceptually owned by all of the edges -->
<!-- that point to it. A node shouldn’t be cleaned up unless it doesn’t have any -->
<!-- edges pointing to it. -->
<p>大多数の場合、所有権は明らかです: 一体どの変数が与えられた値を所有しているかわかるのです。
ところが、単独の値が複数の所有者を持つ可能性のある場合もあります。例えば、グラフデータ構造では、
複数の辺が同じノードを指す可能性があり、概念的にそのノードはそれを指す全ての辺に所有されるわけです。
指す辺がなくならない限り、ノードは片付けられるべきではありません。</p>
<!-- To enable multiple ownership, Rust has a type called `Rc<T>`, which is an -->
<!-- abbreviation for *reference counting*. The `Rc<T>` type keeps track of the  -->
<!-- number of references to a value which determines whether or not a value is -->
<!-- still in use. If there are zero references to a value, the value can be cleaned -->
<!-- up without any references becoming invalid. -->
<p>複数の所有権を可能にするため、Rustには<code>Rc&lt;T&gt;</code>という型があり、これは、<em>reference counting</em>の省略形です。
<code>Rc&lt;T&gt;</code>型は、値がまだ使用中かどうか決定する値への参照の数を追跡します。値への参照が0なら、どの参照も無効にすることなく、
値は片付けられます。</p>
<!-- Imagine `Rc<T>` as a TV in a family room. When one person enters to watch TV, -->
<!-- they turn it on. Others can come into the room and watch the TV. When the last -->
<!-- person leaves the room, they turn off the TV because it’s no longer being used. -->
<!-- If someone turns off the TV while others are still watching it, there would be -->
<!-- uproar from the remaining TV watchers! -->
<p><code>Rc&lt;T&gt;</code>を家族部屋のテレビと想像してください。1人がテレビを見に部屋に入ったら、テレビをつけます。
他の人も部屋に入ってテレビを観ることができます。最後の人が部屋を離れる時、
もう使用されていないので、テレビを消します。他の人がまだ観ているのに誰かがテレビを消したら、
残りのテレビ視聴者が騒ぐでしょう！</p>
<!-- We use the `Rc<T>` type when we want to allocate some data on the heap for -->
<!-- multiple parts of our program to read and we can’t determine at compile time -->
<!-- which part will finish using the data last. If we knew which part would finish -->
<!-- last, we could just make that part the data’s owner, and the normal ownership -->
<!-- rules enforced at compile time would take effect. -->
<p>ヒープにプログラムの複数箇所で読む何らかのデータを確保したい時に<code>Rc&lt;T&gt;</code>型を使用し、
コンパイル時には、どの部分が最後にデータを使用し終わるか決定できません。どの部分が最後に使用し終わるかわかれば、
単にその部分をデータの所有者にして、コンパイル時に強制される普通の所有権ルールが効果を発揮するでしょう。</p>
<!-- Note that `Rc<T>` is only for use in single-threaded scenarios. When we discuss -->
<!-- concurrency in Chapter 16, we’ll cover how to do reference counting in -->
<!-- multithreaded programs. -->
<p><code>Rc&lt;T&gt;</code>は、シングルスレッドシナリオで使用するためだけのものであることに注意してください。
第16章で非同期処理について議論する時に、マルチスレッドプログラムで参照カウントをする方法を講義します。</p>
<!-- ### Using `Rc<T>` to Share Data -->
<a class="header" href="print.html#rctでデータを共有する" id="rctでデータを共有する"><h3><code>Rc&lt;T&gt;</code>でデータを共有する</h3></a>
<!-- Let’s return to our cons list example in Listing 15-5. Recall that we defined -->
<!-- it using `Box<T>`. This time, we’ll create two lists that both share ownership -->
<!-- of a third list. Conceptually, this looks similar to Figure 15-3: -->
<p>リスト15-5のコンスリストの例に回帰しましょう。<code>Box&lt;T&gt;</code>を使って定義したことを思い出してください。
今回は、両方とも3番目のリストの所有権を共有する2つのリストを作成します。
これは概念的には図15-3のような見た目になります:</p>
<!-- <img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" /> -->
<p><img alt="3番目のリストの所有権を共有する2つのリスト" src="img/trpl15-03.svg" class="center" /></p>
<!-- <span class="caption">Figure 15-3: Two lists, `b` and `c`, sharing ownership of -->
<!-- a third list, `a`</span> -->
<p><span class="caption">図15-3: 3番目のリスト、<code>a</code>の所有権を共有する2つのリスト、<code>b</code>と<code>c</code></span></p>
<!-- We’ll create list `a` that contains 5 and then 10. Then we’ll make two more -->
<!-- lists: `b` that starts with 3 and `c` that starts with 4. Both `b` and `c` -->
<!-- lists will then continue on to the first `a` list containing 5 and 10. In other -->
<!-- words, both lists will share the first list containing 5 and 10. -->
<p>5と10を含むリスト<code>a</code>を作ります。さらにもう2つリストを作ります: 3で始まる<code>b</code>と4で始まる<code>c</code>です。
<code>b</code>と<code>c</code>のどちらもそれから5と10を含む最初の<code>a</code>リストに続きます。換言すれば、
どちらのリストも5と10を含む最初のリストを共有しています。</p>
<!-- Trying to implement this scenario using our definition of `List` with `Box<T>` -->
<!-- won’t work, as shown in Listing 15-17: -->
<p><code>List</code>の定義を使用して<code>Box&lt;T&gt;</code>とともにこの筋書きを実装しようとしても、うまくいきません。
リスト15-17のようにですね:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<!-- <span class="caption">Listing 15-17: Demonstrating we’re not allowed to have -->
<!-- two lists using `Box<T>` that try to share ownership of a third list</span> -->
<p><span class="caption">リスト15-17: 3番目のリストの所有権を共有しようとする<code>Box&lt;T&gt;</code>を使った2つのリストを存在させることはできないとデモする</span></p>
<!-- When we compile this code, we get this error: -->
<p>このコードをコンパイルすると、こんなエラーが出ます:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
</code></pre>
<!-- The `Cons` variants own the data they hold, so when we create the `b` list, `a` -->
<!-- is moved into `b` and `b` owns `a`. Then, when we try to use `a` again when -->
<!-- creating `c`, we’re not allowed to because `a` has been moved. -->
<p><code>Cons</code>列挙子は、保持しているデータを所有するので、<code>b</code>リストを作成する時に、
<code>a</code>が<code>b</code>にムーブされ、<code>b</code>が<code>a</code>を所有します。それから<code>c</code>を作る際に再度<code>a</code>を使用しようとすると、
<code>a</code>はムーブ済みなので、できないわけです。</p>
<!-- We could change the definition of `Cons` to hold references instead, but then -->
<!-- we would have to specify lifetime parameters. By specifying lifetime -->
<!-- parameters, we would be specifying that every element in the list will live at -->
<!-- least as long as the entire list. The borrow checker wouldn’t let us compile -->
<!-- `let a = Cons(10, &Nil);` for example, because the temporary `Nil` value would -->
<!-- be dropped before `a` could take a reference to it. -->
<p><code>Cons</code>定義を代わりに参照を保持するように変更することもできますが、そうしたら、
ライフタイム引数を指定しなければなりません。ライフタイム引数を指定することで、
リストの各要素が最低でもリスト全体と同じ期間だけ生きることを指定することになります。
例えば、借用精査機は<code>let a = Cons(10, &amp;Nil);</code>をコンパイルさせてくれません。
一時的な<code>Nil</code>値が、<code>a</code>が参照を得られるより前にドロップされてしまうからです。</p>
<!-- Instead, we’ll change our definition of `List` to use `Rc<T>` in place of -->
<!-- `Box<T>`, as shown in Listing 15-18. Each `Cons` variant will now hold a value -->
<!-- and an `Rc<T>` pointing to a `List`. When we create `b`, instead of taking -->
<!-- ownership of `a`, we’ll clone the `Rc<List>` that `a` is holding, thereby -->
<!-- increasing the number of references from one to two and letting `a` and `b` -->
<!-- share ownership of the data in that `Rc<List>`. We’ll also clone `a` when -->
<!-- creating `c`, increasing the number of references from two to three. Every time -->
<!-- we call `Rc::clone`, the reference count to the data within the `Rc<List>` will -->
<!-- increase, and the data won’t be cleaned up unless there are zero references to -->
<!-- it. -->
<p>代わりに、<code>List</code>の定義をリスト15-18のように、<code>Box&lt;T&gt;</code>の箇所に<code>Rc&lt;T&gt;</code>を使うように変更します。
これで各<code>Cons</code>列挙子は、値と<code>List</code>を指す<code>Rc&lt;T&gt;</code>を保持するようになりました。<code>b</code>を作る際、
<code>a</code>の所有権を奪うのではなく、<code>a</code>が保持している<code>Rc&lt;List&gt;</code>をクローンします。それによって、
参照の数が1から2に増え、<code>a</code>と<code>b</code>にその<code>Rc&lt;List&gt;</code>にあるデータの所有権を共有させます。
また、<code>c</code>を生成する際にも<code>a</code>をクローンするので、参照の数は2から3になります。<code>Rc::clone</code>を呼ぶ度に、
<code>Rc&lt;List&gt;</code>内のデータの参照カウントが増え、参照が0にならない限りデータは片付けられません。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-18: A definition of `List` that uses -->
<!-- `Rc<T>`</span> -->
<p><span class="caption">リスト15-18: <code>Rc&lt;T&gt;</code>を使用する<code>List</code>の定義</span></p>
<!-- We need to add a `use` statement to bring `Rc<T>` into scope because it’s not -->
<!-- in the prelude. In `main`, we create the list holding 5 and 10 and store it in -->
<!-- a new `Rc<List>` in `a`. Then when we create `b` and `c`, we call the -->
<!-- `Rc::clone` function and pass a reference to the `Rc<List>` in `a` as an -->
<!-- argument. -->
<p>初期化処理に含まれていないので、<code>use</code>文を追加して<code>Rc&lt;T&gt;</code>をスコープに導入する必要があります。
<code>main</code>で5と10を保持するリストを作成し、<code>a</code>の新しい<code>Rc&lt;List&gt;</code>に格納しています。それから、
<code>b</code>と<code>c</code>を作成する際に、<code>Rc::clone</code>関数を呼び出し、引数として<code>a</code>の<code>Rc&lt;List&gt;</code>への参照を渡しています。</p>
<!-- We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rust’s -->
<!-- convention is to use `Rc::clone` in this case. The implementation of -->
<!-- `Rc::clone` doesn’t make a deep copy of all the data like most types’ -->
<!-- implementations of `clone` do. The call to `Rc::clone` only increments the -->
<!-- reference count, which doesn’t take much time. Deep copies of data can take a -->
<!-- lot of time. By using `Rc::clone` for reference counting, we can visually -->
<!-- distinguish between the deep-copy kinds of clones and the kinds of clones that -->
<!-- increase the reference count. When looking for performance problems in the -->
<!-- code, we only need to consider the deep-copy clones and can disregard calls to -->
<!-- `Rc::clone`. -->
<p><code>Rc::clone(&amp;a)</code>ではなく、<code>a.clone()</code>を呼ぶこともできますが、Rustのしきたりは、この場合<code>Rc::clone</code>を使うことです。
<code>Rc::clone</code>の実装は、多くの型の<code>clone</code>実装がするように、全てのデータのディープコピーをすることではありません。
<code>Rc::clone</code>の呼び出しは、参照カウントをインクリメントするだけであり、時間はかかりません。
データのディープコピーは時間がかかることもあります。参照カウントに<code>Rc::clone</code>を使うことで、
視覚的にディープコピーをする類のクローンと参照カウントを増やす種類のクローンを区別することができます。
コード内でパフォーマンスの問題を探す際、ディープコピーのクローンだけを考慮し、<code>Rc::clone</code>の呼び出しを無視できるのです。</p>
<!-- ### Cloning an `Rc<T>` Increases the Reference Count -->
<a class="header" href="print.html#rctをクローンすると参照カウントが増える" id="rctをクローンすると参照カウントが増える"><h3><code>Rc&lt;T&gt;</code>をクローンすると、参照カウントが増える</h3></a>
<!-- Let’s change our working example in Listing 15-18 so we can see the reference -->
<!-- counts changing as we create and drop references to the `Rc<List>` in `a`. -->
<p><code>a</code>の<code>Rc&lt;List&gt;</code>への参照を作ったりドロップする毎に参照カウントが変化するのが確かめられるように、
リスト15-18の動く例を変更しましょう。</p>
<!-- In Listing 15-19, we’ll change `main` so it has an inner scope around list `c`; -->
<!-- then we can see how the reference count changes when `c` goes out of scope. -->
<p>リスト15-19で、リスト<code>c</code>を囲む内側のスコープができるよう<code>main</code>を変更します;
そうすれば、<code>c</code>がスコープを抜けるときに参照カウントがどう変化するか確認できます。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># enum List {
#     Cons(i32, Rc&lt;List&gt;),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    // a生成後のカウント = {}
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    // b生成後のカウント = {}
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        // c生成後のカウント = {}
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    // cがスコープを抜けた後のカウント = {}
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-19: Printing the reference count</span> -->
<p><span class="caption">リスト15-19: 参照カウントを出力する</span></p>
<!-- At each point in the program where the reference count changes, we print the -->
<!-- reference count, which we can get by calling the `Rc::strong_count` function. -->
<!-- This function is named `strong_count` rather than `count` because the `Rc<T>` -->
<!-- type also has a `weak_count`; we’ll see what `weak_count` is used for in the -->
<!-- “Preventing Reference Cycles” section. -->
<p>プログラム内で参照カウントが変更される度に、参照カウントを出力します。参照カウントは、
<code>Rc::strong_count</code>関数を呼び出すことで得られます。<code>Rc&lt;T&gt;</code>型には<code>weak_count</code>もあるので、
この関数は<code>count</code>ではなく<code>strong_count</code>と命名されています; <code>weak_count</code>の使用目的は、
「循環参照を回避する」節で確かめます。</p>
<!-- This code prints the following: -->
<p>このコードは、以下の出力をします:</p>
<pre><code class="language-text">count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<!-- We can see that the `Rc<List>` in `a` has an initial reference count of 1; then -->
<!-- each time we call `clone`, the count goes up by 1. When `c` goes out of scope, -->
<!-- the count goes down by 1. We don’t have to call a function to decrease the -->
<!-- reference count like we have to call `Rc::clone` to increase the reference -->
<!-- count: the implementation of the `Drop` trait decreases the reference count -->
<!-- automatically when an `Rc<T>` value goes out of scope. -->
<p><code>a</code>の<code>Rc&lt;List&gt;</code>は最初1という参照カウントであることがわかります; そして、<code>clone</code>を呼び出す度に、
カウントは1ずつ上がります。<code>c</code>がスコープを抜けると、カウントは1下がります。参照カウントを増やすのに、
<code>Rc::clone</code>を呼ばなければいけなかったみたいに参照カウントを減らすのに関数を呼び出す必要はありません:
<code>Rc&lt;T&gt;</code>値がスコープを抜けるときに<code>Drop</code>トレイトの実装が自動的に参照カウントを減らします。</p>
<!-- What we can’t see in this example is that when `b` and then `a` go out of scope -->
<!-- at the end of `main`, the count is then 0, and the `Rc<List>` is cleaned up -->
<!-- completely at that point. Using `Rc<T>` allows a single value to have -->
<!-- multiple owners, and the count ensures that the value remains valid as long as -->
<!-- any of the owners still exist. -->
<p>この例ではわからないことは、<code>b</code>そして<code>a</code>が、<code>main</code>の終端でスコープを抜ける時に、カウントが0になり、
その時点で<code>Rc&lt;List&gt;</code>が完全に片付けられることです。<code>Rc&lt;T&gt;</code>で単独の値に複数の所有者を持たせることができ、
所有者のいずれも存在している限り、値が有効であり続けることをカウントは保証します。</p>
<!-- Via immutable references, `Rc<T>` allows you to share data between multiple -->
<!-- parts of our program for reading only. If `Rc<T>` allowed you to have multiple -->
<!-- mutable references too, you might violate one of the borrowing rules discussed -->
<!-- in Chapter 4: multiple mutable borrows to the same place can cause data races -->
<!-- and inconsistencies. But being able to mutate data is very useful! In the next -->
<!-- section, we’ll discuss the interior mutability pattern and the `RefCell<T>` -->
<!-- type that you can use in conjunction with an `Rc<T>` to work with this -->
<!-- immutability restriction. -->
<p>不変参照経由で、<code>Rc&lt;T&gt;</code>は読み取り専用にプログラムの複数箇所間でデータを共有させてくれます。
<code>Rc&lt;T&gt;</code>が複数の可変参照を存在させることも許可してくれたら、第4章で議論した借用ルールの1つを侵害する恐れがあります:
同じ場所への複数の可変借用は、データ競合や矛盾を引き起こすことがあるのです。しかし、
データを可変化する能力はとても有用です！次の節では、内部可変性パターンと、
<code>Rc&lt;T&gt;</code>と絡めて使用してこの不変性制限を手がけられる<code>RefCell&lt;T&gt;</code>型について議論します。</p>
<!-- ## `RefCell<T>` and the Interior Mutability Pattern -->
<a class="header" href="print.html#refcelltと内部可変性パターン" id="refcelltと内部可変性パターン"><h2><code>RefCell&lt;T&gt;</code>と内部可変性パターン</h2></a>
<!-- *Interior mutability* is a design pattern in Rust that allows you to mutate -->
<!-- data even when there are immutable references to that data; normally, this -->
<!-- action is disallowed by the borrowing rules. To mutate data, the pattern uses -->
<!-- `unsafe` code inside a data structure to bend Rust’s usual rules that govern -->
<!-- mutation and borrowing. We haven’t yet covered unsafe code; we will in -->
<!-- Chapter 19. We can use types that use the interior mutability pattern when we -->
<!-- can ensure that the borrowing rules will be followed at runtime, even though -->
<!-- the compiler can’t guarantee that. The `unsafe` code involved is then wrapped -->
<!-- in a safe API, and the outer type is still immutable. -->
<p>内部可変性は、そのデータへの不変参照がある時でさえもデータを可変化できるRustでのデザインパターンです:
普通、この行動は借用ルールにより許可されません。データを可変化するために、このパターンは、データ構造内で<code>unsafe</code>コードを使用して、
可変性と借用を支配するRustの通常のルールを捻じ曲げています。まだ、unsafeコードについては講義していません;
第19章で行います。たとえ、コンパイラが保証できなくても、借用ルールに実行時に従うことが保証できる時、
内部可変性パターンを使用した型を使用できます。関係する<code>unsafe</code>コードはそうしたら、安全なAPIにラップされ、
外側の型は、不変です。</p>
<!-- Let’s explore this concept by looking at the `RefCell<T>` type that follows the -->
<!-- interior mutability pattern. -->
<p>内部可変性パターンに従う<code>RefCell&lt;T&gt;</code>型を眺めてこの概念を探求しましょう。</p>
<!-- ### Enforcing Borrowing Rules at Runtime with `RefCell<T>` -->
<a class="header" href="print.html#refcelltで実行時に借用ルールを強制する" id="refcelltで実行時に借用ルールを強制する"><h3><code>RefCell&lt;T&gt;</code>で実行時に借用ルールを強制する</h3></a>
<!-- Unlike `Rc<T>`, the `RefCell<T>` type represents single ownership over the data -->
<!-- it holds. So, what makes `RefCell<T>` different from a type like `Box<T>`? -->
<!-- Recall the borrowing rules you learned in Chapter 4: -->
<p><code>Rc&lt;T&gt;</code>と異なり、<code>RefCell&lt;T&gt;</code>型は、保持するデータに対して単独の所有権を表します。では、
どうして<code>RefCell&lt;T&gt;</code>が<code>Box&lt;T&gt;</code>のような型と異なるのでしょうか？第4章で学んだ借用ルールを思い出してください:</p>
<!-- * At any given time, you can have *either* (but not both of) one mutable -->
<!-- reference or any number of immutable references. -->
<!-- * References must always be valid. -->
<ul>
<li>いかなる時も(以下の両方ではなく、)1つの可変参照かいくつもの不変参照の<em>どちらか</em>が可能になる</li>
<li>参照は常に有効でなければならない。</li>
</ul>
<!-- With references and `Box<T>`, the borrowing rules’ invariants are enforced at -->
<!-- compile time. With `RefCell<T>`, these invariants are enforced *at runtime*. -->
<!-- With references, if you break these rules, you’ll get a compiler error. With -->
<!-- `RefCell<T>`, if you break these rules, your program will panic and exit. -->
<p>参照と<code>Box&lt;T&gt;</code>では、借用ルールの不変条件は、コンパイル時に強制されています。<code>RefCell&lt;T&gt;</code>では、
これらの不変条件は、<em>実行時に</em>強制されます。参照でこれらの規則を破ったら、コンパイルエラーになりました。
<code>RefCell&lt;T&gt;</code>でこれらの規則を破ったら、プログラムはパニックし、終了します。</p>
<!-- 1行目、are that がどこまでかかるか不明だが、3行目最後、For those reasonsとあるので、最後までかかるように訳す -->
<!-- The advantages of checking the borrowing rules at compile time are that errors -->
<!-- will be caught sooner in the development process, and there is no impact on -->
<!-- runtime performance because all the analysis is completed beforehand. For those -->
<!-- reasons, checking the borrowing rules at compile time is the best choice in the -->
<!-- majority of cases, which is why this is Rust’s default. -->
<p>コンパイル時に借用ルールを精査することの利点は、エラーが開発過程の早い段階で捕捉されることと、
あらかじめ全ての分析が終わるので、実行パフォーマンスへの影響がないことです。それらの理由により、
多くの場合でコンパイル時に借用ルールを精査することが最善の選択肢であり、これがRustの規定になっているのです。</p>
<!-- The advantage of checking the borrowing rules at runtime instead is that -->
<!-- certain memory-safe scenarios are then allowed, whereas they are disallowed by -->
<!-- the compile-time checks. Static analysis, like the Rust compiler, is inherently -->
<!-- conservative. Some properties of code are impossible to detect by analyzing the -->
<!-- code: the most famous example is the Halting Problem, which is beyond the scope -->
<!-- of this book but is an interesting topic to research. -->
<p>借用ルールを実行時に代わりに精査する利点は、コンパイル時の精査では許容されない特定のメモリ安全な筋書きが許容されることです。
Rustコンパイラのような静的解析は、本質的に保守的です。コードの特性には、コードを解析するだけでは検知できないものもあります:
最も有名な例は停止性問題であり、この本の範疇を超えていますが、調べると面白い話題です。</p>
<!-- Because some analysis is impossible, if the Rust compiler can’t be sure the -->
<!-- code complies with the ownership rules, it might reject a correct program; in -->
<!-- this way, it’s conservative. If Rust accepted an incorrect program, users -->
<!-- wouldn’t be able to trust in the guarantees Rust makes. However, if Rust -->
<!-- rejects a correct program, the programmer will be inconvenienced, but nothing -->
<!-- catastrophic can occur. The `RefCell<T>` type is useful when you’re sure your -->
<!-- code follows the borrowing rules but the compiler is unable to understand and -->
<!-- guarantee that. -->
<p>不可能な分析もあるので、Rustのコンパイラが、コードが所有権ルールに応じていると確証を得られない場合、
正しいプログラムを拒否する可能性があります; このように、保守的なのです。コンパイラが不正なプログラムを受け入れたら、
ユーザは、コンパイラが行う保証を信じることはできなくなるでしょう。しかしながら、
コンパイラが正当なプログラムを拒否するのなら、プログラマは不便に思うでしょうが、悲劇的なことは何も起こり得ません。
コードが借用ルールに従っていると確証を得られる時に<code>RefCell&lt;T&gt;</code>型は有用ですが、
コンパイラはそれを理解し、保証できません。</p>
<!-- Similar to `Rc<T>`, `RefCell<T>` is only for use in single-threaded scenarios -->
<!-- and will give you a compile-time error if you try using it in a multithreaded -->
<!-- context. We’ll talk about how to get the functionality of `RefCell<T>` in a -->
<!-- multithreaded program in Chapter 16. -->
<p><code>Rc&lt;T&gt;</code>と類似して、<code>RefCell&lt;T&gt;</code>もシングルスレッドシナリオで使用するためのものであり、
試しにマルチスレッドの文脈で使ってみようとすると、コンパイルエラーを出します。
<code>RefCell&lt;T&gt;</code>の機能をマルチスレッドのプログラムで得る方法については、第16章で語ります。</p>
<!-- Here is a recap of the reasons to choose `Box<T>`, `Rc<T>`, or `RefCell<T>`: -->
<p>こちらに<code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>を選択する理由を要約しておきます:</p>
<!-- * `Rc<T>` enables multiple owners of the same data; `Box<T>` and `RefCell<T>` -->
<!--   have single owners. -->
<!-- * `Box<T>` allows immutable or mutable borrows checked at compile time; `Rc<T>` -->
<!--   allows only immutable borrows checked at compile time; `RefCell<T>` allows -->
<!--   immutable or mutable borrows checked at runtime. -->
<!-- * Because `RefCell<T>` allows mutable borrows checked at runtime, you can -->
<!--   mutate the value inside the `RefCell<T>` even when the `RefCell<T>` is -->
<!--   immutable. -->
<ul>
<li><code>Rc&lt;T&gt;</code>は、同じデータに複数の所有者を持たせてくれる; <code>Box&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>は単独の所有者。</li>
<li><code>Box&lt;T&gt;</code>は、不変または可変借用をコンパイル時に精査してくれる; <code>Rc&lt;T&gt;</code>は不変借用のみをコンパイル時に精査してくれる;
<code>RefCell&lt;T&gt;</code>は、不変または可変借用を実行時に精査してくれる。</li>
<li><code>RefCell&lt;T&gt;</code>は実行時に精査される可変借用を許可するので、<code>RefCell&lt;T&gt;</code>が不変でも、
<code>RefCell&lt;T&gt;</code>内の値を可変化できる。</li>
</ul>
<!-- Mutating the value inside an immutable value is the *interior mutability* -->
<!-- pattern. Let’s look at a situation in which interior mutability is useful and -->
<!-- examine how it’s possible. -->
<p>不変な値の中の値を可変化することは、<em>内部可変性</em>パターンです。内部可変性が有用になる場面を見て、
それが可能になる方法を調査しましょう。</p>
<!-- ### Interior Mutability: A Mutable Borrow to an Immutable Value -->
<a class="header" href="print.html#a内部可変性-不変値への可変借用" id="a内部可変性-不変値への可変借用"><h3>内部可変性: 不変値への可変借用</h3></a>
<!-- A consequence of the borrowing rules is that when you have an immutable value, -->
<!-- you can’t borrow it mutably. For example, this code won’t compile: -->
<p>借用ルールの結果は、不変値がある時、可変で借用することはできないということです。
例えば、このコードはコンパイルできません:</p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<!-- If you tried to compile this code, you'd get the following error: -->
<p>このコードをコンパイルしようとしたら、以下のようなエラーが出るでしょう:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable local variable `x` as mutable
(エラー: ローカル変数`x`を可変で借用することはできません)
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - consider changing this to `mut x`
3 |     let y = &amp;mut x;
  |                  ^ cannot borrow mutably
</code></pre>
<!-- However, there are situations in which it would be useful for a value to mutate -->
<!-- itself in its methods but appear immutable to other code. Code outside the -->
<!-- value’s methods would not be able to mutate the value. Using `RefCell<T>` is -->
<!-- one way to get the ability to have interior mutability. But `RefCell<T>` -->
<!-- doesn’t get around the borrowing rules completely: the borrow checker in the -->
<!-- compiler allows this interior mutability, and the borrowing rules are checked -->
<!-- at runtime instead. If you violate the rules, you’ll get a `panic!` instead of -->
<!-- a compiler error. -->
<p>ですが、メソッド内で値が自身を可変化するけれども、他のコードにとっては、
不変に見えることが有用な場面もあります。その値のメソッドの外のコードは、その値を可変化することはできないでしょう。
<code>RefCell&lt;T&gt;</code>を使うことは、内部可変性を取得する能力を得る1つの方法です。しかし、
<code>RefCell&lt;T&gt;</code>は借用ルールを完全に回避するものではありません: コンパイラの借用精査機は、内部可変性を許可し、
借用ルールは代わりに実行時に精査されます。この規則を侵害したら、コンパイルエラーではなく<code>panic!</code>になるでしょう。</p>
<!-- Let’s work through a practical example where we can use `RefCell<T>` to mutate -->
<!-- an immutable value and see why that is useful. -->
<p><code>RefCell&lt;T&gt;</code>を使用して不変値を可変化する実践的な例に取り組み、それが役に立つ理由を確認しましょう。</p>
<!-- #### A Use Case for Interior Mutability: Mock Objects -->
<a class="header" href="print.html#a内部可変性のユースケース-モックオブジェクト" id="a内部可変性のユースケース-モックオブジェクト"><h4>内部可変性のユースケース: モックオブジェクト</h4></a>
<!-- A *test double* is the general programming concept for a type used in place of -->
<!-- another type during testing. *Mock objects* are specific types of test doubles -->
<!-- that record what happens during a test so you can assert that the correct -->
<!-- actions took place. -->
<p><em>テストダブル</em>は、テスト中に別の型の代わりに使用される型の一般的なプログラミングの概念です。
<em>モックオブジェクト</em>は、テスト中に起きることを記録するテストダブルの特定の型なので、
正しい動作が起きたことをアサートできます。</p>
<blockquote>
<p><code>編注</code>: テストダブルとは、ソフトウェアテストにおいて、テスト対象が依存しているコンポーネントを置き換える代用品のこと</p>
</blockquote>
<!-- Rust doesn’t have objects in the same sense as other languages have objects, -->
<!-- and Rust doesn’t have mock object functionality built into the standard library -->
<!-- as some other languages do. However, you can definitely create a struct that -->
<!-- will serve the same purposes as a mock object. -->
<p>Rustには、他の言語でいうオブジェクトは存在せず、また、他の言語のように標準ライブラリにモックオブジェクトの機能が組み込まれてもいません。
ですが、同じ目的をモックオブジェクトとして提供する構造体を作成することは確かにできます。</p>
<!-- Here’s the scenario we’ll test: we’ll create a library that tracks a value -->
<!-- against a maximum value and sends messages based on how close to the maximum -->
<!-- value the current value is. This library could be used to keep track of a -->
<!-- user’s quota for the number of API calls they’re allowed to make, for example. -->
<p>以下が、テストを行う筋書きです: 値を最大値に対して追跡し、現在値が最大値に近い程度に基づいてメッセージを送信するライブラリを作成します。
このライブラリは、ユーザが行うことのできるAPIコールの数の割り当てを追跡するのに使用することができるでしょう。</p>
<!-- Our library will only provide the functionality of tracking how close to the -->
<!-- maximum a value is and what the messages should be at what times. Applications -->
<!-- that use our library will be expected to provide the mechanism for sending the -->
<!-- messages: the application could put a message in the application, send an -->
<!-- email, send a text message, or something else. The library doesn’t need to know -->
<!-- that detail. All it needs is something that implements a trait we’ll provide -->
<!-- called `Messenger`. Listing 15-20 shows the library code: -->
<p>作成するライブラリは、値がどれくらい最大に近いかと、いつどんなメッセージになるべきかを追いかける機能を提供するだけです。
このライブラリを使用するアプリケーションは、メッセージを送信する機構を提供すると期待されるでしょう:
アプリケーションは、アプリケーションにメッセージを置いたり、メールを送ったり、テキストメッセージを送るなどできるでしょう。
ライブラリはその詳細を知る必要はありません。必要なのは、提供する<code>Messenger</code>と呼ばれるトレイトを実装している何かなのです。
リスト15-20は、ライブラリのコードを示しています:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: 'a + Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
    where T: Messenger {
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 0.75 &amp;&amp; percentage_of_max &lt; 0.9 {
            // 警告: 割り当ての75％以上を使用してしまいました
            self.messenger.send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 &amp;&amp; percentage_of_max &lt; 1.0 {
            // 切迫した警告: 割り当ての90%以上を使用してしまいました
            self.messenger.send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 1.0 {
            // エラー: 割り当てを超えています
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 15-20: A library to keep track of how close a -->
<!-- value is to a maximum value and warn when the value is at certain levels</span> -->
<p><span class="caption">リスト15-20: 値が最大値にどれくらい近いかを追跡し、任意のレベルの時に警告するライブラリ</span></p>
<!-- One important part of this code is that the `Messenger` trait has one method -->
<!-- called `send` that takes an immutable reference to `self` and the text of the -->
<!-- message. This is the interface our mock object needs to have. The other -->
<!-- important part is that we want to test the behavior of the `set_value` method -->
<!-- on the `LimitTracker`. We can change what we pass in for the `value` parameter, -->
<!-- but `set_value` doesn’t return anything for us to make assertions on. We want -->
<!-- to be able to say that if we create a `LimitTracker` with something that -->
<!-- implements the `Messenger` trait and a particular value for `max`, when we pass -->
<!-- different numbers for `value`, the messenger is told to send the appropriate -->
<!-- messages. -->
<p>このコードの重要な部分の1つは、<code>Messenger</code>トレイトには、<code>self</code>への不変参照とメッセージのテキストを取る<code>send</code>というメソッドが1つあることです。
これが、モックオブジェクトが持つ必要のあるインターフェイスなのです。もう1つの重要な部分は、
<code>LimitTracker</code>の<code>set_value</code>メソッドの振る舞いをテストしたいということです。<code>value</code>引数に渡すものを変えることができますが、
<code>set_value</code>はアサートを行えるものは何も返してくれません。<code>LimitTracker</code>を<code>Messenger</code>トレイトを実装する何かと、
<code>max</code>の特定の値で生成したら、<code>value</code>に異なる数値を渡した時にメッセンジャーは適切なメッセージを送ると指示されると言えるようになりたいです。</p>
<!-- We need a mock object that, instead of sending an email or text message when we -->
<!-- call `send`, will only keep track of the messages it’s told to send. We can -->
<!-- create a new instance of the mock object, create a `LimitTracker` that uses the -->
<!-- mock object, call the `set_value` method on `LimitTracker`, and then check that -->
<!-- the mock object has the messages we expect. Listing 15-21 shows an attempt to -->
<!-- implement a mock object to do just that, but the borrow checker won’t allow it: -->
<p><code>send</code>を呼び出す時にメールやテキストメッセージを送る代わりに送ると指示されたメッセージを追跡するだけのモックオブジェクトが必要です。
モックオブジェクトの新規インスタンスを生成し、モックオブジェクトを使用する<code>LimitTracker</code>を生成し、
<code>LimitTracker</code>の<code>set_value</code>を呼び出し、それからモックオブジェクトに期待しているメッセージがあることを確認できます。
リスト15-21は、それだけをするモックオブジェクトを実装しようとするところを示しますが、借用精査機が許可してくれません:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 15-21: An attempt to implement a `MockMessenger` -->
<!-- that isn’t allowed by the borrow checker</span> -->
<p><span class="caption">リスト15-21: 借用精査機が許可してくれない<code>MockMessanger</code>を実装しようとする</span></p>
<!-- This test code defines a `MockMessenger` struct that has a `sent_messages` -->
<!-- field with a `Vec` of `String` values to keep track of the messages it’s told -->
<!-- to send. We also define an associated function `new` to make it convenient to -->
<!-- create new `MockMessenger` values that start with an empty list of messages. We -->
<!-- then implement the `Messenger` trait for `MockMessenger` so we can give a -->
<!-- `MockMessenger` to a `LimitTracker`. In the definition of the `send` method, we -->
<!-- take the message passed in as a parameter and store it in the `MockMessenger` -->
<!-- list of `sent_messages`. -->
<p>このテストコードは<code>String</code>の<code>Vec</code>で送信すると指示されたメッセージを追跡する<code>sent_messages</code>フィールドのある<code>MockMessenger</code>構造体を定義しています。
また、空のメッセージリストから始まる新しい<code>MockMessenger</code>値を作るのを便利にしてくれる関連関数の<code>new</code>も定義しています。
それから<code>MockMessenger</code>に<code>Messenger</code>トレイトを実装しているので、<code>LimitTracker</code>に<code>MockMessenger</code>を与えられます。
<code>send</code>メソッドの定義で引数として渡されたメッセージを取り、<code>sent_messages</code>の<code>MockMessenger</code>リストに格納しています。</p>
<!-- In the test, we’re testing what happens when the `LimitTracker` is told to set -->
<!-- `value` to something that is more than 75 percent of the `max` value. First, we -->
<!-- create a new `MockMessenger`, which will start with an empty list of messages. -->
<!-- Then we create a new `LimitTracker` and give it a reference to the new -->
<!-- `MockMessenger` and a `max` value of 100. We call the `set_value` method on the -->
<!-- `LimitTracker` with a value of 80, which is more than 75 percent of 100. Then -->
<!-- we assert that the list of messages that the `MockMessenger` is keeping track -->
<!-- of should now have one message in it. -->
<p>テストでは、<code>max</code>値の75%以上になる何かに<code>value</code>をセットしろと<code>LimitTracker</code>が指示される時に起きることをテストしています。
まず、新しい<code>MockMessenger</code>を生成し、空のメッセージリストから始まります。そして、
新しい<code>LimitTracker</code>を生成し、新しい<code>MockMessenger</code>の参照と100という<code>max</code>値を与えます。
<code>LimitTracker</code>の<code>set_value</code>メソッドは80という値で呼び出し、これは100の75%を上回っています。
そして、<code>MockMessenger</code>が追いかけているメッセージのリストが今は1つのメッセージを含んでいるはずとアサートします。</p>
<!-- However, there’s one problem with this test, as shown here: -->
<p>ところが、以下のようにこのテストには1つ問題があります:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
(エラー: 不変なフィールド`self.sent_messages`を可変で借用できません)
  --&gt; src/lib.rs:52:13
   |
51 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` here to make mutable
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field
</code></pre>
<!-- We can’t modify the `MockMessenger` to keep track of the messages, because the -->
<!-- `send` method takes an immutable reference to `self`. We also can’t take the -->
<!-- suggestion from the error text to use `&mut self` instead, because then the -->
<!-- signature of `send` wouldn’t match the signature in the `Messenger` trait -->
<!-- definition (feel free to try and see what error message you get). -->
<p><code>send</code>メソッドは<code>self</code>への不変参照を取るので、<code>MockMessenger</code>を変更してメッセージを追跡できないのです。
代わりに<code>&amp;mut self</code>を使用するというエラーテキストからの提言を選ぶこともできないのです。
そうしたら、<code>send</code>のシグニチャが、<code>Messenger</code>トレイト定義のシグニチャと一致しなくなるからです(気軽に試してエラーメッセージを確認してください)。</p>
<!-- This is a situation in which interior mutability can help! We’ll store the -->
<!-- `sent_messages` within a `RefCell<T>`, and then the `send` message will be -->
<!-- able to modify `sent_messages` to store the messages we’ve seen. Listing 15-22 -->
<!-- shows what that looks like: -->
<p>これは、内部可変性が役に立つ場面なのです！<code>sent_messages</code>を<code>RefCell&lt;T&gt;</code>内部に格納し、
そして<code>send</code>メッセージは、<code>sent_messages</code>を変更して見かけたメッセージを格納できるようになるでしょう。
リスト15-22は、それがどんな感じかを示しています:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
#         let mock_messenger = MockMessenger::new();
#         let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
#         limit_tracker.set_value(75);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 15-22: Using `RefCell<T>` to mutate an inner -->
<!-- value while the outer value is considered immutable</span> -->
<p><span class="caption">リスト15-22: 外側の値は不変と考えられる一方で<code>RefCell&lt;T&gt;</code>で内部の値を可変化する</span></p>
<!-- The `sent_messages` field is now of type `RefCell<Vec<String>>` instead of -->
<!-- `Vec<String>`. In the `new` function, we create a new `RefCell<Vec<String>>` -->
<!-- instance around the empty vector. -->
<p>さて、<code>sent_messages</code>フィールドは、<code>Vec&lt;String&gt;</code>ではなく、型<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>になりました。
<code>new</code>関数で、空のベクタの周りに<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>を新しく作成しています。</p>
<!-- For the implementation of the `send` method, the first parameter is still an -->
<!-- immutable borrow of `self`, which matches the trait definition. We call -->
<!-- `borrow_mut` on the `RefCell<Vec<String>>` in `self.sent_messages` to get a -->
<!-- mutable reference to the value inside the `RefCell<Vec<String>>`, which is -->
<!-- the vector. Then we can call `push` on the mutable reference to the vector to -->
<!-- keep track of the messages sent during the test. -->
<p><code>send</code>メソッドの実装については、最初の引数はそれでも<code>self</code>への不変借用で、トレイト定義と合致しています。
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>の<code>borrow_mut</code>を<code>self.sent_messages</code>に呼び出し、
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>の中の値への可変参照を得て、これはベクタになります。
それからベクタへの可変参照に<code>push</code>を呼び出して、テスト中に送られるメッセージを追跡しています。</p>
<!-- The last change we have to make is in the assertion: to see how many items are -->
<!-- in the inner vector, we call `borrow` on the `RefCell<Vec<String>>` to get an -->
<!-- immutable reference to the vector. -->
<p>行わなければならない最後の変更は、アサート内部にあります: 内部のベクタにある要素の数を確認するため、
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>に<code>borrow</code>を呼び出し、ベクタへの不変参照を得ています。</p>
<!-- Now that you’ve seen how to use `RefCell<T>`, let’s dig into how it works! -->
<p><code>RefCell&lt;T&gt;</code>の使用法を見かけたので、動作法を深掘りしましょう！</p>
<!-- #### Keeping track of Borrows at Runtime with `RefCell<T>` -->
<a class="header" href="print.html#refcelltで実行時に借用を追いかける" id="refcelltで実行時に借用を追いかける"><h4><code>RefCell&lt;T&gt;</code>で実行時に借用を追いかける</h4></a>
<!-- When creating immutable and mutable references, we use the `&` and `&mut` -->
<!-- syntax, respectively. With `RefCell<T>`, we use the `borrow` and `borrow_mut` -->
<!-- methods, which are part of the safe API that belongs to `RefCell<T>`. The -->
<!-- `borrow` method returns the smart pointer type `Ref<T>`, and `borrow_mut` -->
<!-- returns the smart pointer type `RefMut<T>`. Both types implement `Deref`, so we -->
<!-- can treat them like regular references. -->
<p>不変および可変参照を作成する時、それぞれ<code>&amp;</code>と<code>&amp;mut</code>記法を使用します。<code>RefCell&lt;T&gt;</code>では、
<code>borrow</code>と<code>borrow_mut</code>メソッドを使用し、これらは<code>RefCell&lt;T&gt;</code>に所属する安全なAPIの一部です。
<code>borrow</code>メソッドは、スマートポインタ型の<code>Ref&lt;T&gt;</code>を返し、<code>borrow_mut</code>はスマートポインタ型の<code>RefMut&lt;T&gt;</code>を返します。
どちらの型も<code>Deref</code>を実装しているので、普通の参照のように扱うことができます。</p>
<!-- The `RefCell<T>` keeps track of how many `Ref<T>` and `RefMut<T>` smart -->
<!-- pointers are currently active. Every time we call `borrow`, the `RefCell<T>` -->
<!-- increases its count of how many immutable borrows are active. When a `Ref<T>` -->
<!-- value goes out of scope, the count of immutable borrows goes down by one. Just -->
<!-- like the compile-time borrowing rules, `RefCell<T>` lets us have many immutable -->
<!-- borrows or one mutable borrow at any point in time. -->
<p><code>RefCell&lt;T&gt;</code>は、現在活動中の<code>Ref&lt;T&gt;</code>と<code>RefMut&lt;T&gt;</code>スマートポインタの数を追いかけます。
<code>borrow</code>を呼び出す度に、<code>RefCell&lt;T&gt;</code>は活動中の不変参照の数を増やします。<code>Ref&lt;T&gt;</code>の値がスコープを抜けたら、
不変参照の数は1下がります。コンパイル時の借用ルールと全く同じように、<code>RefCell&lt;T&gt;</code>はいかなる時も、
複数の不変借用または1つの可変借用を持たせてくれるのです。</p>
<!-- If we try to violate these rules, rather than getting a compiler error as we -->
<!-- would with references, the implementation of `RefCell<T>` will panic at -->
<!-- runtime. Listing 15-23 shows a modification of the implementation of `send` in -->
<!-- Listing 15-22. We’re deliberately trying to create two mutable borrows active -->
<!-- for the same scope to illustrate that `RefCell<T>` prevents us from doing this -->
<!-- at runtime. -->
<p>これらの規則を侵害しようとすれば、参照のようにコンパイルエラーになるのではなく、
<code>RefCell&lt;T&gt;</code>の実装は実行時にパニックするでしょう。リスト15-23は、リスト15-22の<code>send</code>実装に対する変更を示しています。
同じスコープで2つの可変借用が活動するようわざと生成し、<code>RefCell&lt;T&gt;</code>が実行時にこれをすることを阻止してくれるところを具体化しています。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Messenger for MockMessenger {
    fn send(&amp;self, message: &amp;str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
</code></pre>
<!-- <span class="caption">Listing 15-23: Creating two mutable references in the -->
<!-- same scope to see that `RefCell<T>` will panic</span> -->
<p><span class="caption">リスト15-23: 同じスコープで2つの可変参照を生成して<code>RefCell&lt;T&gt;</code>がパニックすることを確かめる</span></p>
<!-- We create a variable `one_borrow` for the `RefMut<T>` smart pointer returned -->
<!-- from `borrow_mut`. Then we create another mutable borrow in the same way in the -->
<!-- variable `two_borrow`. This makes two mutable references in the same scope, -->
<!-- which isn’t allowed. When we run the tests for our library, the code in Listing -->
<!-- 15-23 will compile without any errors, but the test will fail: -->
<p><code>borrow_mut</code>から返ってきた<code>RefMut&lt;T&gt;</code>スマートポインタに対して変数<code>one_borrow</code>を生成しています。
そして、同様にして変数<code>two_borrow</code>にも別の可変借用を生成しています。これにより同じスコープで2つの可変参照ができ、
これは許可されないことです。このテストを自分のライブラリ用に走らせると、リスト15-23のコードはエラーなくコンパイルできますが、
テストは失敗するでしょう:</p>
<pre><code class="language-text">---- tests::it_sends_an_over_75_percent_warning_message stdout ----
    thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
  (スレッド'tests::it_sends_an_over_75_percent_warning_message'は、
'すでに借用されています: BorrowMutError', src/libcore/result.rs:906:4でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!-- Notice that the code panicked with the message `already borrowed: -->
<!-- BorrowMutError`. This is how `RefCell<T>` handles violations of the borrowing -->
<!-- rules at runtime. -->
<p>コードは、<code>already borrowed: BorrowMutError</code>というメッセージとともにパニックしたことに気付いてください。
このようにして<code>RefCell&lt;T&gt;</code>は実行時に借用ルールの侵害を扱うのです。</p>
<!-- Catching borrowing errors at runtime rather than compile time means that you -->
<!-- would find a mistake in your code later in the development process and possibly -->
<!-- not until our code was deployed to production. Also, your code will incur a -->
<!-- small runtime performance penalty as a result of keeping track of the borrows -->
<!-- at runtime rather than compile time. However, using `RefCell<T>` makes it -->
<!-- possible to write a mock object that can modify itself to keep track of the -->
<!-- messages it has seen while you're using it in a context where only immutable -->
<!-- values are allowed. You can use `RefCell<T>` despite its trade-offs to get more -->
<!-- functionality than regular references provide. -->
<p>コンパイル時ではなく実行時に借用エラーをキャッチするということは、開発過程の遅い段階でコードのミスを発見し、
コードをプロダクションにデプロイする時まで発見しないことを意味します。また、
コンパイル時ではなく、実行時に借用を追いかける結果として、少し実行時にパフォーマンスを犠牲にするでしょう。
しかしながら、<code>RefCell&lt;T&gt;</code>を使うことで不変値のみが許可される文脈で使用しつつ、
自身を変更して見かけたメッセージを追跡するモックオブジェクトを書くことを可能にしてくれます。
代償にも関わらず<code>RefCell&lt;T&gt;</code>を使用して、普通の参照よりも多くの機能を得ることができるわけです。</p>
<!-- ### Having Multiple Owners of Mutable Data by Combining `Rc<T>` and `RefCell<T>` -->
<a class="header" href="print.html#rctとrefcelltを組み合わせることで可変なデータに複数の所有者を持たせる" id="rctとrefcelltを組み合わせることで可変なデータに複数の所有者を持たせる"><h3><code>Rc&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>を組み合わせることで可変なデータに複数の所有者を持たせる</h3></a>
<!-- A common way to use `RefCell<T>` is in combination with `Rc<T>`. Recall that -->
<!-- `Rc<T>` lets you have multiple owners of some data, but it only gives immutable -->
<!-- access to that data. If you have an `Rc<T>` that holds a `RefCell<T>`, you can -->
<!-- get a value that can have multiple owners *and* that you can mutate! -->
<p><code>RefCell&lt;T&gt;</code>の一般的な使用法は、<code>Rc&lt;T&gt;</code>と組み合わせることにあります。<code>Rc&lt;T&gt;</code>は何らかのデータに複数の所有者を持たせてくれるけれども、
そのデータに不変のアクセスしかさせてくれないことを思い出してください。<code>RefCell&lt;T&gt;</code>を抱える<code>Rc&lt;T&gt;</code>があれば、
複数の所有者を持ち<em>そして</em>、可変化できる値を得ることができるのです。</p>
<!-- For example, recall the cons list example in Listing 15-18 where we used -->
<!-- `Rc<T>` to allow multiple lists to share ownership of another list. Because -->
<!-- `Rc<T>` holds only immutable values, we can’t change any of the values in the -->
<!-- list once we’ve created them. Let’s add in `RefCell<T>` to gain the ability to -->
<!-- change the values in the lists. Listing 15-24 shows that by using a -->
<!-- `RefCell<T>` in the `Cons` definition, we can modify the value stored in all -->
<!-- the lists: -->
<p>例を挙げれば、<code>Rc&lt;T&gt;</code>を使用して複数のリストに別のリストの所有権を共有させたリスト15-18のコンスリストの例を思い出してください。
<code>Rc&lt;T&gt;</code>は不変値だけを抱えるので、一旦生成したら、リストの値はどれも変更できません。<code>RefCell&lt;T&gt;</code>を含めて、
リストの値を変更する能力を得ましょう。<code>RefCell&lt;T&gt;</code>を<code>Cons</code>定義で使用することで、
リスト全てに格納されている値を変更できることをリスト15-24は示しています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-24: Using `Rc<RefCell<i32>>` to create a -->
<!-- `List` that we can mutate</span> -->
<p><span class="caption">リスト15-24: <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>で可変化できる<code>List</code>を生成する</span></p>
<!-- We create a value that is an instance of `Rc<RefCell<i32>>` and store it in a -->
<!-- variable named `value` so we can access it directly later. Then we create a -->
<!-- `List` in `a` with a `Cons` variant that holds `value`. We need to clone -->
<!-- `value` so both `a` and `value` have ownership of the inner `5` value rather -->
<!-- than transferring ownership from `value` to `a` or having `a` borrow from -->
<!-- `value`. -->
<p><code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>のインスタンスの値を生成し、<code>value</code>という名前の変数に格納しているので、
直接後ほどアクセスすることができます。そして、<code>a</code>に<code>value</code>を持つ<code>Cons</code>列挙子で<code>List</code>を生成しています。
<code>value</code>から<code>a</code>に所有権を移したり、<code>a</code>が<code>value</code>から借用するのではなく、<code>a</code>と<code>value</code>どちらにも中の<code>5</code>の値の所有権を持たせるよう、
<code>value</code>をクローンする必要があります。</p>
<!-- We wrap the list `a` in an `Rc<T>` so when we create lists `b` and `c`, they -->
<!-- can both refer to `a`, which is what we did in Listing 15-18. -->
<p>リスト<code>a</code>を<code>Rc&lt;T&gt;</code>に包んでいるので、リスト<code>b</code>と<code>c</code>を生成する時に、どちらも<code>a</code>を参照できます。
リスト15-18ではそうしていました。</p>
<!-- After we’ve created the lists in `a`, `b`, and `c`, we add 10 to the value in -->
<!-- `value`. We do this by calling `borrow_mut` on `value`, which uses the -->
<!-- automatic dereferencing feature we discussed in Chapter 5 (see the section -->
<!-- “Where’s the `->` Operator?”) to dereference the `Rc<T>` to the inner -->
<!-- `RefCell<T>` value. The `borrow_mut` method returns a `RefMut<T>` smart -->
<!-- pointer, and we use the dereference operator on it and change the inner value. -->
<p><code>a</code>、<code>b</code>、<code>c</code>のリストを作成した後、<code>value</code>の値に10を足しています。これを<code>value</code>の<code>borrow_mut</code>を呼び出すことで行い、
これは、第5章で議論した自動参照外し機能(「<code>-&gt;</code>演算子はどこに行ったの？」節をご覧ください)を使用して、
<code>Rc&lt;T&gt;</code>を内部の<code>RefCell&lt;T&gt;</code>値に参照外ししています。<code>borrow_mut</code>メソッドは、
<code>RefMut&lt;T&gt;</code>スマートポインタを返し、それに対して参照外し演算子を使用し、中の値を変更します。</p>
<!-- When we print `a`, `b`, and `c`, we can see that they all have the modified -->
<!-- value of 15 rather than 5: -->
<p><code>a</code>、<code>b</code>、<code>c</code>を出力すると、全て5ではなく、変更された15という値になっていることがわかります。</p>
<pre><code class="language-text">a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<!-- This technique is pretty neat! By using `RefCell<T>`, we have an outwardly -->
<!-- immutable `List` value. But we can use the methods on `RefCell<T>` that provide -->
<!-- access to its interior mutability so we can modify our data when we need to. -->
<!-- The runtime checks of the borrowing rules protect us from data races, and it’s -->
<!-- sometimes worth trading a bit of speed for this flexibility in our data -->
<!-- structures. -->
<p>このテクニックは非常に綺麗です！<code>RefCell&lt;T&gt;</code>を使用することで表面上は不変な<code>List</code>値を持てます。
しかし、内部可変性へのアクセスを提供する<code>RefCell&lt;T&gt;</code>のメソッドを使用できるので、必要な時にはデータを変更できます。
借用ルールを実行時に精査することでデータ競合を防ぎ、時としてデータ構造でちょっとのスピードを犠牲にこの柔軟性を得るのは価値があります。</p>
<!-- The standard library has other types that provide interior mutability, such as -->
<!-- `Cell<T>`, which is similar except that instead of giving references to the -->
<!-- inner value, the value is copied in and out of the `Cell<T>`. There’s also -->
<!-- `Mutex<T>`, which offers interior mutability that’s safe to use across threads; -->
<!-- we’ll discuss its use in Chapter 16. Check out the standard library docs for -->
<!-- more details on the differences between these types. -->
<p>標準ライブラリには、<code>Cell&lt;T&gt;</code>などの内部可変性を提供する他の型もあり、この型は、内部値への参照を与える代わりに、
値は<code>Cell&lt;T&gt;</code>の内部や外部へコピーされる点を除き似ています。また<code>Mutex&lt;T&gt;</code>もあり、
これはスレッド間で使用するのが安全な内部可変性を提供します; 第16章で使用することを議論しましょう。
標準ライブラリのドキュメンテーションをチェックして、これらの型の違いを詳しく知ってください。</p>
<!-- ## Reference Cycles Can Leak Memory -->
<a class="header" href="print.html#a循環参照してメモリをリークすることもある" id="a循環参照してメモリをリークすることもある"><h2>循環参照してメモリをリークすることもある</h2></a>
<!-- Rust’s memory safety guarantees make it difficult, but not impossible, to -->
<!-- accidentally create memory that is never cleaned up (known as a *memory leak*). -->
<!-- Preventing memory leaks entirely is not one of Rust’s guarantees in the same -->
<!-- way that disallowing data races at compile time is, meaning memory leaks are -->
<!-- memory safe in Rust. We can see that Rust allows memory leaks by using `Rc<T>` -->
<!-- and `RefCell<T>`: it’s possible to create references where items refer to each -->
<!-- other in a cycle. This creates memory leaks because the reference count of each -->
<!-- item in the cycle will never reach 0, and the values will never be dropped. -->
<p>Rustのメモリ安全保証により誤って絶対に片付けられることのないメモリ(<em>メモリリーク</em>として知られています)を生成してしまうことが困難にはなりますが、
不可能にはなりません。コンパイル時にデータ競合を防ぐのと同じようにメモリリークを完全に回避することは、
Rustの保証の一つではなく、メモリリークはRustにおいてはメモリ安全であることを意味します。
Rustでは、<code>Rc&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>を使用してメモリリークを許可するとわかります:
要素がお互いに循環して参照する参照を生成することも可能ということです。循環の各要素の参照カウントが絶対に0にならないので、
これはメモリリークを起こし、値は絶対にドロップされません。</p>
<!-- ### Creating a Reference Cycle -->
<a class="header" href="print.html#a循環参照させる" id="a循環参照させる"><h3>循環参照させる</h3></a>
<!-- Let’s look at how a reference cycle might happen and how to prevent it, -->
<!-- starting with the definition of the `List` enum and a `tail` method in Listing -->
<!-- 15-25: -->
<p>リスト15-25の<code>List</code> enumの定義と<code>tail</code>メソッドから始めて、循環参照が起こる可能性のある方法とその回避策を見ましょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- Hidden fn main is here to disable the automatic wrapping in fn main that
doc tests do; the `use List` fails if this listing is put within a main -->
<pre><pre class="playpen"><code class="language-rust"># fn main() {}
use std::rc::Rc;
use std::cell::RefCell;
use List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match *self {
            Cons(_, ref item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-25: A cons list definition that holds a -->
<!-- `RefCell<T>` so we can modify what a `Cons` variant is referring to</span> -->
<p><span class="caption">リスト15-25: <code>Cons</code>列挙子が参照しているものを変更できるように<code>RefCell&lt;T&gt;</code>を抱えているコンスリストの定義</span></p>
<!-- We’re using another variation of the `List` definition in Listing 15-5. The -->
<!-- second element in the `Cons` variant is now `RefCell<Rc<List>>`, meaning that -->
<!-- instead of having the ability to modify the `i32` value as we did in Listing -->
<!-- 15-24, we want to modify which `List` value a `Cons` variant is pointing to. -->
<!-- We're also adding a `tail` method to make it convenient for us to access the -->
<!-- second item if we have a `Cons` variant. -->
<p>リスト15-5の<code>List</code>定義の別バリエーションを使用しています。<code>Cons</code>列挙子の2番目の要素はこれで<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>になり、
リスト15-24のように<code>i32</code>値を変更する能力があるのではなく、<code>Cons</code>列挙子が指している<code>List</code>値の先を変えたいということです。
また、<code>tail</code>メソッドを追加して<code>Cons</code>列挙子があるときに2番目の要素にアクセスするのが便利になるようにしています。</p>
<!-- In Listing 15-26, we’re adding a `main` function that uses the definitions in -->
<!-- Listing 15-25. This code creates a list in `a` and a list in `b` that points to -->
<!-- the list in `a`. Then it modifies the list in `a` to point to `b`, creating a -->
<!-- reference cycle. There are `println!` statements along the way to show what the -->
<!-- reference counts are at various points in this process. -->
<p>リスト15-26でリスト15-25の定義を使用する<code>main</code>関数を追加しています。このコードは、<code>a</code>にリストを、
<code>b</code>に<code>a</code>のリストを指すリストを作成します。それから<code>a</code>のリストを変更して<code>b</code>を指し、循環参照させます。
その流れの中に過程のいろんな場所での参照カウントを示す<code>println!</code>文が存在しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use List::{Cons, Nil};
# use std::rc::Rc;
# use std::cell::RefCell;
# #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
#     Nil,
# }
#
# impl List {
#     fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
#         match *self {
#             Cons(_, ref item) =&gt; Some(item),
#             Nil =&gt; None,
#         }
#     }
# }
#
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    // aの最初の参照カウント = {}
    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    // aの次の要素は = {:?}
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    // b作成後のaの参照カウント = {}
    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    // bの最初の参照カウント = {}
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    // bの次の要素 = {:?}
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    // aを変更後のbの参照カウント = {}
    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    // aを変更後のaの参照カウント = {}
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // 次の行のコメントを外して循環していると確認してください; スタックオーバーフローします
    // println!(&quot;a next item = {:?}&quot;, a.tail());        // aの次の要素 = {:?}
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-26: Creating a reference cycle of two `List` -->
<!-- values pointing to each other</span> -->
<p><span class="caption">リスト15-26: 2つの<code>List</code>値がお互いを指して循環参照する</span></p>
<!-- in the variable `a` | `b`がかかる先が不明瞭だが、コード例を見る限り、この訳が合っているようだ -->
<!-- We create an `Rc<List>` instance holding a `List` value in the variable `a` -->
<!-- with an initial list of `5, Nil`. We then create an `Rc<List>` instance -->
<!-- holding another `List` value in the variable `b` that contains the value 10 and -->
<!-- points to the list in `a`. -->
<p>最初のリストが<code>5, Nil</code>の<code>List</code>値を保持する<code>Rc&lt;List&gt;</code>インスタンスを変数<code>a</code>に生成します。
そして、値10と<code>a</code>のリストを指す別の<code>List</code>値を保持する<code>Rc&lt;List&gt;</code>インスタンスを変数<code>b</code>に生成します。</p>
<!-- We modify `a` so it points to `b` instead of `Nil`, creating a cycle. We -->
<!-- do that by using the `tail` method to get a reference to the -->
<!-- `RefCell<Rc<List>>` in `a`, which we put in the variable `link`. Then we use -->
<!-- the `borrow_mut` method on the `RefCell<Rc<List>>` to change the value inside -->
<!-- from an `Rc<List>` that holds a `Nil` value to the `Rc<List>` in `b`. -->
<p><code>a</code>が<code>Nil</code>ではなく<code>b</code>を指すように変更して、循環させます。<code>tail</code>メソッドを使用して、
<code>a</code>の<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>への参照を得ることで循環させて、この参照は変数<code>link</code>に配置します。
それから<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>の<code>borrow_mut</code>メソッドを使用して中の値を<code>Nil</code>値を持つ<code>Rc&lt;List&gt;</code>から、
<code>b</code>の<code>Rc&lt;List&gt;</code>に変更します。</p>
<!-- When we run this code, keeping the last `println!` commented out for the -->
<!-- moment, we’ll get this output: -->
<p>最後の<code>println!</code>を今だけコメントアウトしたまま、このコードを実行すると、こんな出力が得られます:</p>
<pre><code class="language-text">a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<!-- The reference count of the `Rc<List>` instances in both `a` and `b` are 2 -->
<!-- after we change the list in `a` to point to `b`. At the end of `main`, Rust -->
<!-- will try to drop `b` first, which will decrease the count in each of the -->
<!-- `Rc<List>` instances in `a` and `b` by 1. -->
<p><code>a</code>のリストを<code>b</code>を指すように変更した後の<code>a</code>と<code>b</code>の<code>Rc&lt;List&gt;</code>インスタンスの参照カウントは2です。
<code>main</code>の終端で、コンパイラはまず<code>b</code>をドロップしようとし、<code>a</code>と<code>b</code>の各<code>Rc&lt;List&gt;</code>インスタンスのカウントを1減らします。</p>
<!-- However, because `a` is still referencing the `Rc<List>` that was in `b`, that -->
<!-- `Rc<List>` has a count of 1 rather than 0, so the memory the `Rc<List>` has on -->
<!-- the heap won’t be dropped. The memory will just sit there with a count of 1, -->
<!-- forever. To visualize this reference cycle, we’ve created a diagram in Figure -->
<!-- 15-4: -->
<p>しかしながら、それでも<code>a</code>は<code>b</code>にあった<code>Rc&lt;List&gt;</code>を参照しているので、その<code>Rc&lt;List&gt;</code>のカウントは0ではなく1になり、
その<code>Rc&lt;List&gt;</code>がヒープに確保していたメモリはドロップされません。メモリはただ、カウント1のままそこに永遠に居座るのです。
この循環参照を可視化するために、図15-4に図式を作成しました:</p>
<!-- <img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" /> -->
<p><img alt="リストの循環参照" src="img/trpl15-04.svg" class="center" /></p>
<!-- <span class="caption">Figure 15-4: A reference cycle of lists `a` and `b` -->
<!-- pointing to each other</span> -->
<p><span class="caption">図15-4: お互いを指すリスト<code>a</code>と<code>b</code>の循環参照</span></p>
<!-- If you uncomment the last `println!` and run the program, Rust will try to -->
<!-- print this cycle with `a` pointing to `b` pointing to `a` and so forth until it -->
<!-- overflows the stack. -->
<p>最後の<code>println!</code>のコメントを外してプログラムを実行したら、<code>a</code>が<code>b</code>を指して、<code>b</code>が<code>a</code>を指してと、
スタックがオーバーフローするまでコンパイラはこの循環を出力しようとするでしょう。</p>
<!-- In this case, right after we create the reference cycle, the program ends. The -->
<!-- consequences of this cycle aren’t very dire. However, if a more complex program -->
<!-- allocated lots of memory in a cycle and held onto it for a long time, the -->
<!-- program would use more memory than it needed and might overwhelm the system, -->
<!-- causing it to run out of available memory. -->
<p>この場合、循環参照を作る直後にプログラムは終了します。この循環の結果は、それほど悲壮なものではありません。しかしながら、
より複雑なプログラムが多くのメモリを循環で確保し長い間その状態を保ったら、プログラムは必要以上のメモリを使用し、
使用可能なメモリを枯渇させてシステムを参らせてしまう可能性があります。</p>
<!-- Creating reference cycles is not easily done, but it’s not impossible either. -->
<!-- If you have `RefCell<T>` values that contain `Rc<T>` values or similar nested -->
<!-- combinations of types with interior mutability and reference counting, you must -->
<!-- ensure that you don’t create cycles; you can’t rely on Rust to catch them. -->
<!-- Creating a reference cycle would be a logic bug in your program that you should -->
<!-- use automated tests, code reviews, and other software development practices to -->
<!-- minimize. -->
<p>循環参照は簡単にできることではありませんが、不可能というわけでもありません。
<code>Rc&lt;T&gt;</code>値を含む<code>RefCell&lt;T&gt;</code>値があるなどの内部可変性と参照カウントのある型がネストして組み合わさっていたら、
循環していないことを保証しなければなりません; コンパイラがそれを捕捉することを信頼できないのです。
循環参照をするのは、自動化テストやコードレビューなどの他のソフトウェア開発手段を使用して最小化すべきプログラム上のロジックバグでしょう。</p>
<!-- Another solution for avoiding reference cycles is reorganizing your data -->
<!-- structures so that some references express ownership and some references don’t. -->
<!-- As a result, you can have cycles made up of some ownership relationships and -->
<!-- some non-ownership relationships, and only the ownership relationships affect -->
<!-- whether or not a value can be dropped. In Listing 15-25, we always want `Cons` -->
<!-- variants to own their list, so reorganizing the data structure isn’t possible. -->
<!-- Let’s look at an example using graphs made up of parent nodes and child nodes -->
<!-- to see when non-ownership relationships are an appropriate way to prevent -->
<!-- reference cycles. -->
<p>循環参照を回避する別の解決策は、ある参照は所有権を表現して他の参照はしないというようにデータ構造を再構成することです。
結果として所有権のある関係と所有権のない関係からなる循環ができ、所有権のある関係だけが値がドロップされうるかどうかに影響します。
リスト15-25では、常に<code>Cons</code>列挙子にリストを所有してほしいので、データ構造を再構成することはできません。
親ノードと子ノードからなるグラフを使った例に目を向けて、どんな時に所有権のない関係が循環参照を回避するのに適切な方法になるか確認しましょう。</p>
<!-- ### Preventing Reference Cycles: Turning an `Rc<T>` into a `Weak<T>` -->
<a class="header" href="print.html#a循環参照を回避する-rctをweaktに変換する" id="a循環参照を回避する-rctをweaktに変換する"><h3>循環参照を回避する: <code>Rc&lt;T&gt;</code>を<code>Weak&lt;T&gt;</code>に変換する</h3></a>
<!-- So far, we’ve demonstrated that calling `Rc::clone` increases the -->
<!-- `strong_count` of an `Rc<T>` instance, and an `Rc<T>` instance is only cleaned -->
<!-- up if its `strong_count` is 0. You can also create a *weak reference* to the -->
<!-- value within an `Rc<T>` instance by calling `Rc::downgrade` and passing a -->
<!-- reference to the `Rc<T>`. When you call `Rc::downgrade`, you get a smart -->
<!-- pointer of type `Weak<T>`. Instead of increasing the `strong_count` in the -->
<!-- `Rc<T>` instance by 1, calling `Rc::downgrade` increases the `weak_count` by 1.-->
<!-- The `Rc<T>` type uses `weak_count` to keep track of how many `Weak<T>` -->
<!-- references exist, similar to `strong_count`. The difference is the `weak_count` -->
<!-- doesn’t need to be 0 for the `Rc<T>` instance to be cleaned up. -->
<p>ここまで、<code>Rc::clone</code>を呼び出すと<code>Rc&lt;T&gt;</code>インスタンスの<code>strong_count</code>が増えることと、
<code>strong_count</code>が0になった時に<code>Rc&lt;T&gt;</code>インスタンスは片付けられることをデモしてきました。
<code>Rc::downgrade</code>を呼び出し、<code>Rc&lt;T&gt;</code>への参照を渡すことで、<code>Rc&lt;T&gt;</code>インスタンス内部の値への<em>弱い参照</em>(weak reference)を作ることもできます。
<code>Rc::downgrade</code>を呼び出すと、型<code>Weak&lt;T&gt;</code>のスマートポインタが得られます。
<code>Rc&lt;T&gt;</code>インスタンスの<code>strong_count</code>を1増やす代わりに、<code>Rc::downgrade</code>を呼び出すと、<code>weak_count</code>が1増えます。
<code>strong_count</code>同様、<code>Rc&lt;T&gt;</code>型は<code>weak_count</code>を使用して、幾つの<code>Weak&lt;T&gt;</code>参照が存在しているかを追跡します。
違いは、<code>Rc&lt;T&gt;</code>が片付けられるのに、<code>weak_count</code>が0である必要はないということです。</p>
<!-- Strong references are how you can share ownership of an `Rc<T>` instance. Weak -->
<!-- references don’t express an ownership relationship. They won’t cause a -->
<!-- reference cycle because any cycle involving some weak references will be broken -->
<!-- once the strong reference count of values involved is 0. -->
<p>強い参照は、<code>Rc&lt;T&gt;</code>インスタンスの所有権を共有する方法です。弱い参照は、所有権関係を表現しません。
ひとたび、関係する値の強い参照カウントが0になれば、弱い参照が関わる循環はなんでも破壊されるので、
循環参照にはなりません。</p>
<!-- Because the value that `Weak<T>` references might have been dropped, to do -->
<!-- anything with the value that a `Weak<T>` is pointing to, you must make sure the -->
<!-- value still exists. Do this by calling the `upgrade` method on a `Weak<T>` -->
<!-- instance, which will return an `Option<Rc<T>>`. You’ll get a result of `Some` -->
<!-- if the `Rc<T>` value has not been dropped yet and a result of `None` if the -->
<!-- `Rc<T>` value has been dropped. Because `upgrade` returns an `Option<T>`, Rust -->
<!-- will ensure that the `Some` case and the `None` case are handled, and there -->
<!-- won't be an invalid pointer. -->
<p><code>Weak&lt;T&gt;</code>が参照する値はドロップされてしまう可能性があるので、<code>Weak&lt;T&gt;</code>が指す値に何かをするには、
値がまだ存在することを確認しなければなりません。<code>Weak&lt;T&gt;</code>の<code>upgrade</code>メソッドを呼び出すことでこれをしてください。
このメソッドは<code>Option&lt;Rc&lt;T&gt;&gt;</code>を返します。<code>Rc&lt;T&gt;</code>値がまだドロップされていなければ、<code>Some</code>の結果が、
<code>Rc&lt;T&gt;</code>値がドロップ済みなら、<code>None</code>の結果が得られます。<code>upgrade</code>が<code>Option&lt;T&gt;</code>を返すので、
コンパイラは、<code>Some</code>ケースと<code>None</code>ケースが扱われていることを確かめてくれ、無効なポインタは存在しません。</p>
<!-- As an example, rather than using a list whose items know only about the next -->
<!-- item, we’ll create a tree whose items know about their children items *and* -->
<!-- their parent items. -->
<p>例として、要素が次の要素を知っているだけのリストを使うのではなく、要素が子要素<em>と</em>親要素を知っている木を作りましょう。</p>
<!-- #### Creating a Tree Data Structure: a `Node` with Child Nodes -->
<a class="header" href="print.html#a木データ構造を作る-子ノードのあるnode" id="a木データ構造を作る-子ノードのあるnode"><h4>木データ構造を作る: 子ノードのある<code>Node</code></h4></a>
<!-- To start, we’ll build a tree with nodes that know about their child nodes. -->
<!-- We’ll create a struct named `Node` that holds its own `i32` value as well as -->
<!-- references to its children `Node` values: -->
<p>手始めに子ノードを知っているノードのある木を構成します。独自の<code>i32</code>値と子供の<code>Node</code>値への参照を抱える<code>Node</code>という構造体を作ります:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<!-- We want a `Node` to own its children, and we want to share that ownership with -->
<!-- variables so we can access each `Node` in the tree directly. To do this, we -->
<!-- define the `Vec<T>` items to be values of type `Rc<Node>`. We also want to -->
<!-- modify which nodes are children of another node, so we have a `RefCell<T>` in -->
<!-- `children` around the `Vec<Rc<Node>>`. -->
<p><code>Node</code>に子供を所有してほしく、木の各<code>Node</code>に直接アクセスできるよう、その所有権を変数と共有したいです。
こうするために、<code>Vec&lt;T&gt;</code>要素を型<code>Rc&lt;Node&gt;</code>の値になるよう定義しています。どのノードが他のノードの子供になるかも変更したいので、
<code>Vec&lt;Rc&lt;Node&gt;&gt;</code>の周りの<code>children</code>を<code>RefCell&lt;T&gt;</code>にしています。</p>
<!-- Next, we’ll use our struct definition and create one `Node` instance named -->
<!-- `leaf` with the value 3 and no children, and another instance named `branch` -->
<!-- with the value 5 and `leaf` as one of its children, as shown in Listing 15-27: -->
<p>次にこの構造体定義を使って値3と子供なしの<code>leaf</code>という1つの<code>Node</code>インスタンスと、
値5と<code>leaf</code>を子要素の一つとして持つ<code>branch</code>という別のインスタンスを作成します。
リスト15-27のようにですね:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::Rc;
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-27: Creating a `leaf` node with no children -->
<!-- and a `branch` node with `leaf` as one of its children</span> -->
<p><span class="caption">リスト15-27: 子供なしの<code>leaf</code>ノードと<code>leaf</code>を子要素に持つ<code>branch</code>ノードを作る</span></p>
<!-- We clone the `Rc<Node>` in `leaf` and store that in `branch`, meaning the -->
<!-- `Node` in `leaf` now has two owners: `leaf` and `branch`. We can get from -->
<!-- `branch` to `leaf` through `branch.children`, but there’s no way to get from -->
<!-- `leaf` to `branch`. The reason is that `leaf` has no reference to `branch` and -->
<!-- doesn’t know they’re related. We want `leaf` to know that `branch` is its -->
<!-- parent. We’ll do that next. -->
<p><code>leaf</code>の<code>Rc&lt;Node&gt;</code>をクローンし、<code>branch</code>に格納しているので、<code>leaf</code>の<code>Node</code>は<code>leaf</code>と<code>branch</code>という2つの所有者を持つことになります。
<code>branch.children</code>を通して<code>branch</code>から<code>leaf</code>へ辿ることはできるものの、<code>leaf</code>から<code>branch</code>へ辿る方法はありません。
理由は、<code>leaf</code>には<code>branch</code>への参照がなく、関係していることを知らないからです。<code>leaf</code>に<code>branch</code>が親であることを知ってほしいです。
次はそれを行います。</p>
<!-- #### Adding a Reference from a Child to Its Parent -->
<a class="header" href="print.html#a子供から親に参照を追加する" id="a子供から親に参照を追加する"><h4>子供から親に参照を追加する</h4></a>
<!-- To make the child node aware of its parent, we need to add a `parent` field to -->
<!-- our `Node` struct definition. The trouble is in deciding what the type of -->
<!-- `parent` should be. We know it can’t contain an `Rc<T>`, because that would -->
<!-- create a reference cycle with `leaf.parent` pointing to `branch` and -->
<!-- `branch.children` pointing to `leaf`, which would cause their `strong_count` -->
<!-- values to never be 0. -->
<p>子供に親の存在を気付かせるために、<code>Node</code>構造体定義に<code>parent</code>フィールドを追加する必要があります。
<code>parent</code>の型を決める際に困ったことになります。<code>Rc&lt;T&gt;</code>を含むことができないのはわかります。
そうしたら、<code>leaf.parent</code>が<code>branch</code>を指し、<code>branch.children</code>が<code>leaf</code>を指して循環参照になり、
<code>strong_count</code>値が絶対に0にならなくなってしまうからです。</p>
<!-- Thinking about the relationships another way, a parent node should own its -->
<!-- children: if a parent node is dropped, its child nodes should be dropped as -->
<!-- well. However, a child should not own its parent: if we drop a child node, the -->
<!-- parent should still exist. This is a case for weak references! -->
<p>この関係を別の方法で捉えると、親ノードは子供を所有すべきです: 親ノードがドロップされたら、
子ノードもドロップされるべきなのです。ですが、子供は親を所有するべきではありません:
子ノードをドロップしても、親はまだ存在するべきです。弱い参照を使う場面ですね！</p>
<!-- So instead of `Rc<T>`, we’ll make the type of `parent` use `Weak<T>`, -->
<!-- specifically a `RefCell<Weak<Node>>`. Now our `Node` struct definition looks -->
<!-- like this: -->
<p>従って、<code>Rc&lt;T&gt;</code>の代わりに<code>parent</code>の型を<code>Weak&lt;T&gt;</code>を使ったもの、具体的には<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>にします。
さあ、<code>Node</code>構造体定義はこんな見た目になりました:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<!-- A node will be able to refer to its parent node but doesn’t own its parent. -->
<!-- In Listing 15-28, we update `main` to use this new definition so the `leaf` -->
<!-- node will have a way to refer to its parent, `branch`: -->
<p>ノードは親ノードを参照できるものの、所有はしないでしょう。リスト15-28で、
<code>leaf</code>ノードが親の<code>branch</code>を参照できるよう、この新しい定義を使用するように<code>main</code>を更新します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
#     children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    // leafの親 = {:?}
    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-28: A `leaf` node with a weak reference to its -->
<!-- parent node `branch`</span> -->
<p><span class="caption">リスト15-28: 親ノードの<code>branch</code>への弱い参照がある<code>leaf</code>ノード</span></p>
<!-- Creating the `leaf` node looks similar to how creating the `leaf` node looked -->
<!-- in Listing 15-27 with the exception of the `parent` field: `leaf` starts out -->
<!-- without a parent, so we create a new, empty `Weak<Node>` reference instance. -->
<p><code>leaf</code>ノードを作成することは、<code>parent</code>フィールドの例外を除いてリスト15-27での<code>leaf</code>ノードの作成法に似ています:
<code>leaf</code>は親なしで始まるので、新しく空の<code>Weak&lt;Node&gt;</code>参照インスタンスを作ります。</p>
<!-- At this point, when we try to get a reference to the parent of `leaf` by using -->
<!-- the `upgrade` method, we get a `None` value. We see this in the output from the -->
<!-- first `println!` statement: -->
<p>この時点で<code>upgrade</code>メソッドを使用して<code>leaf</code>の親への参照を得ようとすると、<code>None</code>値になります。
このことは、最初の<code>println!</code>文の出力でわかります:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<!-- When we create the `branch` node, it will also have a new `Weak<Node>` -->
<!-- reference in the `parent` field, because `branch` doesn’t have a parent node. -->
<!-- We still have `leaf` as one of the children of `branch`. Once we have the -->
<!-- `Node` instance in `branch`, we can modify `leaf` to give it a `Weak<Node>` -->
<!-- reference to its parent. We use the `borrow_mut` method on the -->
<!-- `RefCell<Weak<Node>>` in the `parent` field of `leaf`, and then we use the -->
<!-- `Rc::downgrade` function to create a `Weak<Node>` reference to `branch` from -->
<!-- the `Rc<Node>` in `branch.` -->
<p><code>branch</code>ノードを作る際、<code>branch</code>には親ノードがないので、こちらも<code>parent</code>フィールドには新しい<code>Weak&lt;Node&gt;</code>参照が入ります。
それでも、<code>leaf</code>は<code>branch</code>の子供になっています。一旦<code>branch</code>に<code>Node</code>インスタンスができたら、
<code>leaf</code>を変更して親への<code>Weak&lt;Node&gt;</code>参照を与えることができます。<code>leaf</code>の<code>parent</code>フィールドには、
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>の<code>borrow_mut</code>メソッドを使用して、それから<code>Rc::downgrade</code>関数を使用して、
<code>branch</code>の<code>Rc&lt;Node&gt;</code>から<code>branch</code>への<code>Weak&lt;Node&gt;</code>参照を作ります。</p>
<!-- When we print the parent of `leaf` again, this time we’ll get a `Some` variant -->
<!-- holding `branch`: now `leaf` can access its parent! When we print `leaf`, we -->
<!-- also avoid the cycle that eventually ended in a stack overflow like we had in -->
<!-- Listing 15-26; the `Weak<Node>` references are printed as `(Weak)`: -->
<p>再度<code>leaf</code>の親を出力すると、今度は<code>branch</code>を保持する<code>Some</code>列挙子が得られます: これで<code>leaf</code>が親にアクセスできるようになったのです！
<code>leaf</code>を出力すると、リスト15-26で起こっていたような最終的にスタックオーバーフローに行き着く循環を避けることもできます;
<code>Weak&lt;Node&gt;</code>参照は、<code>(Weak)</code>と出力されます:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<!-- The lack of infinite output indicates that this code didn’t create a reference -->
<!-- cycle. We can also tell this by looking at the values we get from calling -->
<!-- `Rc::strong_count` and `Rc::weak_count`. -->
<p>無限の出力が欠けているということは、このコードは循環参照しないことを示唆します。
このことは、<code>Rc::strong_count</code>と<code>Rc::weak_count</code>を呼び出すことで得られる値を見てもわかります。</p>
<!-- #### Visualizing Changes to `strong_count` and `weak_count` -->
<a class="header" href="print.html#strong_countとweak_countへの変更を可視化する" id="strong_countとweak_countへの変更を可視化する"><h4><code>strong_count</code>と<code>weak_count</code>への変更を可視化する</h4></a>
<!-- Let’s look at how the `strong_count` and `weak_count` values of the `Rc<Node>` -->
<!-- instances change by creating a new inner scope and moving the creation of -->
<!-- `branch` into that scope. By doing so, we can see what happens when `branch` is -->
<!-- created and then dropped when it goes out of scope. The modifications are shown -->
<!-- in Listing 15-29: -->
<p>新しい内部スコープを作り、<code>branch</code>の作成をそのスコープに移動することで、
<code>Rc&lt;Node&gt;</code>インスタンスの<code>strong_count</code>と<code>weak_count</code>値がどう変化するかを眺めましょう。
そうすることで、<code>branch</code>が作成され、それからスコープを抜けてドロップされる時に起こることが確認できます。
変更は、リスト15-29に示してあります:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::rc::{Rc, Weak};
# use std::cell::RefCell;
#
# #[derive(Debug)]
# struct Node {
#     value: i32,
#     parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
#     children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
# }
#
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    // leafのstrong_count = {}, weak_count = {}
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        // branchのstrong_count = {}, weak_count = {}
        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<!-- <span class="caption">Listing 15-29: Creating `branch` in an inner scope and -->
<!-- examining strong and weak reference counts</span> -->
<p><span class="caption">リスト15-29: 内側のスコープで<code>branch</code>を作成し、強弱参照カウントを調査する</span></p>
<!-- 4行目後半、カッコ内、forは接続詞の用法かと思ったが、文ではなかった。for S to Vのように訳した -->
<!-- 通常forの後は、現在分詞が来るため、そう書いているだけだろうか -->
<!-- After `leaf` is created, its `Rc<Node>` has a strong count of 1 and a weak -->
<!-- count of 0. In the inner scope, we create `branch` and associate it with -->
<!-- `leaf`, at which point when we print the counts, the `Rc<Node>` in `branch` -->
<!-- will have a strong count of 1 and a weak count of 1 (for `leaf.parent` pointing -->
<!-- to `branch` with a `Weak<Node>`). When we print the counts in `leaf`, we’ll see -->
<!-- it will have a strong count of 2, because `branch` now has a clone of the -->
<!-- `Rc<Node>` of `leaf` stored in `branch.children`, but will still have a weak -->
<!-- count of 0. -->
<p><code>leaf</code>作成後、その<code>Rc&lt;Node&gt;</code>の強カウントは1、弱カウントは0になります。内側のスコープで<code>branch</code>を作成し、
<code>leaf</code>に紐付け、この時点でカウントを出力すると、<code>branch</code>の<code>Rc&lt;Node&gt;</code>の強カウントは1、
弱カウントも1になります(<code>leaf.parent</code>が<code>Weak&lt;Node&gt;</code>で<code>branch</code>を指しているため)。
<code>leaf</code>のカウントを出力すると、強カウントが2になっていることがわかります。<code>branch</code>が今は、
<code>branch.children</code>に格納された<code>leaf</code>の<code>Rc&lt;Node&gt;</code>のクローンを持っているからですが、
それでも弱カウントは0でしょう。</p>
<!-- When the inner scope ends, `branch` goes out of scope and the strong count of -->
<!-- the `Rc<Node>` decreases to 0, so its `Node` is dropped. The weak count of 1 -->
<!-- from `leaf.parent` has no bearing on whether or not `Node` is dropped, so we -->
<!-- don’t get any memory leaks! -->
<p>内側のスコープが終わると、<code>branch</code>はスコープを抜け、<code>Rc&lt;Node&gt;</code>の強カウントは0に減るので、
この<code>Node</code>はドロップされます。<code>leaf.parent</code>からの弱カウント1は、<code>Node</code>がドロップされるか否かには関係ないので、
メモリリークはしないのです！</p>
<!-- If we try to access the parent of `leaf` after the end of the scope, we’ll get -->
<!-- `None` again. At the end of the program, the `Rc<Node>` in `leaf` has a strong -->
<!-- count of 1 and a weak count of 0, because the variable `leaf` is now the only -->
<!-- reference to the `Rc<Node>` again. -->
<p>このスコープの終端以後に<code>leaf</code>の親にアクセスしようとしたら、再び<code>None</code>が得られます。
プログラムの終端で<code>leaf</code>の<code>Rc&lt;Node&gt;</code>の強カウントは1、弱カウントは0です。
変数<code>leaf</code>が今では<code>Rc&lt;Node&gt;</code>への唯一の参照に再度なったからです。</p>
<!-- All of the logic that manages the counts and value dropping is built into -->
<!-- `Rc<T>` and `Weak<T>` and their implementations of the `Drop` trait. By -->
<!-- specifying that the relationship from a child to its parent should be a -->
<!-- `Weak<T>` reference in the definition of `Node`, you’re able to have parent -->
<!-- nodes point to child nodes and vice versa without creating a reference cycle -->
<!-- and memory leaks. -->
<p>カウントや値のドロップを管理するロジックは全て、<code>Rc&lt;T&gt;</code>や<code>Weak&lt;T&gt;</code>とその<code>Drop</code>トレイトの実装に組み込まれています。
<code>Node</code>の定義で子供から親への関係は<code>Weak&lt;T&gt;</code>参照になるべきと指定することで、
循環参照やメモリリークを引き起こさずに親ノードに子ノードを参照させたり、その逆を行うことができます。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-13" id="aまとめ-13"><h2>まとめ</h2></a>
<!-- This chapter covered how to use smart pointers to make different guarantees and -->
<!-- trade-offs than those Rust makes by default with regular references. The -->
<!-- `Box<T>` type has a known size and points to data allocated on the heap. The -->
<!-- `Rc<T>` type keeps track of the number of references to data on the heap so -->
<!-- that data can have multiple owners. The `RefCell<T>` type with its interior -->
<!-- mutability gives us a type that we can use when we need an immutable type but -->
<!-- need to change an inner value of that type; it also enforces the borrowing -->
<!-- rules at runtime instead of at compile time. -->
<p>この章は、スマートポインタを使用してRustが規定で普通の参照に対して行うのと異なる保証や代償を行う方法を講義しました。
<code>Box&lt;T&gt;</code>型は、既知のサイズで、ヒープに確保されたデータを指します。<code>Rc&lt;T&gt;</code>型は、ヒープのデータへの参照の数を追跡するので、
データは複数の所有者を保有できます。内部可変性のある<code>RefCell&lt;T&gt;</code>型は、不変型が必要だけれども、
その型の中の値を変更する必要がある時に使用できる型を与えてくれます; また、コンパイル時ではなく実行時に借用ルールを強制します。</p>
<!-- Also discussed were the `Deref` and `Drop` traits, which enable a lot of the -->
<!-- functionality of smart pointers. We explored reference cycles that can cause -->
<!-- memory leaks and how to prevent them using `Weak<T>`. -->
<p><code>Deref</code>と<code>Drop</code>トレイトについても議論しましたね。これらは、スマートポインタの多くの機能を可能にしてくれます。
メモリリークを引き起こす循環参照と<code>Weak&lt;T&gt;</code>でそれを回避する方法も探求しました。</p>
<!-- FIXME: URLがイタリックになっていない -->
<!-- If this chapter has piqued your interest and you want to implement your own -->
<!-- smart pointers, check out [“The Rustonomicon”][nomicon] for more useful -->
<!-- information. -->
<p>この章で興味をそそられ、独自のスマートポインタを実装したくなったら、もっと役に立つ情報を求めて、
<a href="https://doc.rust-lang.org/stable/nomicon/">“The Rustonomicon”</a>をチェックしてください。</p>
<!-- Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new -->
<!-- smart pointers. -->
<p>次は、Rustでの非同期処理について語ります。もういくつか新しいスマートポインタについてさえも学ぶでしょう。</p>
<!-- # Fearless Concurrency -->
<a class="header" href="print.html#a恐れるな並行性" id="a恐れるな並行性"><h1>恐れるな！並行性</h1></a>
<!-- Handling concurrent programming safely and efficiently is another of Rust’s -->
<!-- major goals. *Concurrent programming*, where different parts of a program -->
<!-- execute independently, and *parallel programming*, where different parts of a -->
<!-- program execute at the same time, are becoming increasingly important as more -->
<!-- computers take advantage of their multiple processors. Historically, -->
<!-- programming in these contexts has been difficult and error prone: Rust hopes to -->
<!-- change that. -->
<p>並行性を安全かつ効率的に扱うことは、Rustの別の主な目標です。<em>並行プログラミング</em>は、プログラムの異なる部分が個別に実行することであり、
<em>並列プログラミング</em>はプログラムの異なる部分が同時に実行することですが、多くのコンピュータが複数のプロセッサの利点を生かすようになるにつれ、
重要度を増しています。歴史的に、これらの文脈で行うプログラミングは困難で、エラーが起きやすいものでした:
Rustはこれを変えると期待されています。</p>
<!-- Initially, the Rust team thought that ensuring memory safety and preventing -->
<!-- concurrency problems were two separate challenges to be solved with different -->
<!-- methods. Over time, the team discovered that the ownership and type systems are -->
<!-- a powerful set of tools to help manage memory safety *and* concurrency -->
<!-- problems! By leveraging ownership and type checking, many concurrency errors -->
<!-- are compile-time errors in Rust rather than runtime errors. Therefore, rather -->
<!-- than making you spend lots of time trying to reproduce the exact circumstances -->
<!-- under which a runtime concurrency bug occurs, incorrect code will refuse to -->
<!-- compile and present an error explaining the problem. As a result, you can fix -->
<!-- your code while you’re working on it rather than potentially after it has been -->
<!-- shipped to production. We’ve nicknamed this aspect of Rust *fearless* -->
<!-- *concurrency*. Fearless concurrency allows you to write code that is free of -->
<!-- subtle bugs and is easy to refactor without introducing new bugs. -->
<p>当初、Rustチームは、メモリ安全性を保証することと、並行性問題を回避することは、
異なる方法で解決すべき別々の課題だと考えていました。時間とともに、チームは、所有権と型システムは、
メモリ安全性<em>と</em>並行性問題を管理する役に立つ一連の強力な道具であることを発見しました。
所有権と型チェックを活用することで、多くの並行性エラーは、実行時エラーではなくコンパイル時エラーになります。
故に、実行時に並行性のバグが起きた状況と全く同じ状況を再現しようと時間を浪費させるよりも、
不正なコードはコンパイルを拒み、問題を説明するエラーを提示するでしょう。結果として、
プロダクトになった後でなく、作業中にコードを修正できます。
Rustのこの方向性を<em>恐れるな！並行性</em>とニックネーム付けしました。これにより、潜在的なバグがなく、
新しいバグを導入することなく簡単にリファクタリングできるコードを書くことができます。</p>
<!-- Note: For simplicity’s sake, we’ll refer to many of the problems as -->
<!-- *concurrent* rather than being more precise by saying *concurrent and/or -->
<!-- parallel*. If this book were about concurrency and/or parallelism, we'd be -->
<!-- more specific. For this chapter, please mentally substitute *concurrent -->
<!-- and/or parallel* whenever we use *concurrent*. -->
<blockquote>
<p>注釈: 簡潔性のため、並行または並列と述べることで正確を期するのではなく、
多くの問題を<em>並行</em>と割り切ってしまいます。この本がもし<em>並行性あるいは並列性</em>に関した本ならば、
詳述していたでしょう。この章に対しては、<em>非同期</em>を使ったら、
脳内で<em>並行性または並列性</em>と置き換えてください。</p>
</blockquote>
<!-- Many languages are dogmatic about the solutions they offer for handling -->
<!-- concurrent problems. For example, Erlang has elegant functionality for -->
<!-- message-passing concurrency but has only obscure ways to share state between -->
<!-- threads. Supporting only a subset of possible solutions is a reasonable -->
<!-- strategy for higher-level languages, because a higher-level language promises -->
<!-- benefits from giving up some control to gain abstractions. However, lower-level -->
<!-- languages are expected to provide the solution with the best performance in any -->
<!-- given situation and have fewer abstractions over the hardware. Therefore, Rust -->
<!-- offers a variety of tools for modeling problems in whatever way is appropriate -->
<!-- for your situation and requirements. -->
<p>多くの言語は、自分が提供する並行性問題を扱う解決策について独断的です。例えば、Erlangには、
メッセージ受け渡しの並行性に関する素晴らしい機能がありますが、スレッド間で状態を共有することに関しては、
曖昧な方法しかありません。可能な解決策の一部のみをサポートすることは、高級言語にとっては合理的な施策です。
なぜなら、高級言語は一部の制御を失う代わりに抽象化することから恩恵を受けるからです。ところが、
低級言語は、どんな場面でも最高のパフォーマンスで解決策を提供すると想定され、ハードウェアに関してほとんど抽象化はしません。
そのため、Rustは、自分の状況と必要性に適した方法が何であれ、問題をモデル化するためのいろんな道具を備えています。</p>
<!-- Here are the topics we’ll cover in this chapter: -->
<p>こちらが、この章で講義する話題です:</p>
<!-- * How to create threads to run multiple pieces of code at the same time -->
<!-- * *Message-passing* concurrency, where channels send messages between threads -->
<!-- * *Shared-state* concurrency, where multiple threads have access to some piece -->
<!--   of data -->
<!-- * The `Sync` and `Send` traits, which extend Rust’s concurrency guarantees to -->
<!--   user-defined types as well as types provided by the standard library -->
<ul>
<li>スレッドを生成して、複数のコードを同時に走らせる方法</li>
<li>チャンネルがスレッド間でメッセージを送る<em>メッセージ受け渡し</em>並行性</li>
<li>複数のスレッドが何らかのデータにアクセスする<em>状態共有</em>並行性</li>
<li>標準ライブラリが提供する型だけでなく、ユーザが定義した型に対してもRustの並行性の安全保証を拡張する<code>Sync</code>と<code>Send</code>トレイト</li>
</ul>
<!-- ## Using Threads to Run Code Simultaneously -->
<a class="header" href="print.html#aスレッドを使用してコードを同時に走らせる" id="aスレッドを使用してコードを同時に走らせる"><h2>スレッドを使用してコードを同時に走らせる</h2></a>
<!-- In most current operating systems, an executed program’s code is run in a -->
<!-- *process*, and the operating system manages multiple processes at once. Within -->
<!-- your program, you can also have independent parts that run simultaneously. The -->
<!-- features that run these independent parts are called *threads*. -->
<p>多くの現代のOSでは、実行中のプログラムのコードは<em>プロセス</em>で走り、OSは同時に複数のプロセスを管理します。
自分のプログラム内で、独立した部分を同時に実行できます。これらの独立した部分を走らせる機能を<em>スレッド</em>と呼びます。</p>
<!-- Splitting the computation in your program into multiple threads can improve -->
<!-- performance because the program does multiple tasks at the same time, but it -->
<!-- also adds complexity. Because threads can run simultaneously, there’s no -->
<!-- inherent guarantee about the order in which parts of your code on different -->
<!-- threads will run. This can lead to problems, such as: -->
<p>プログラム内の計算を複数のスレッドに分けると、パフォーマンスが改善します。プログラムが同時に複数の作業をするからですが、
複雑度も増します。スレッドは同時に走らせることができるので、異なるスレッドのコードが走る順番に関して、
本来の保証はありません。これは問題を招きます。例えば:</p>
<!-- * Race conditions, where threads are accessing data or resources in an -->
<!--   inconsistent order -->
<!-- * Deadlocks, where two threads are waiting for each other to finish using a -->
<!--   resource the other thread has, preventing both threads from continuing -->
<!-- * Bugs that happen only in certain situations and are hard to reproduce and fix -->
<!--   reliably -->
<ul>
<li>スレッドがデータやリソースに矛盾した順番でアクセスする競合状態</li>
<li>2つのスレッドがお互いにもう一方が持っているリソースを使用し終わるのを待ち、両者が継続するのを防ぐデッドロック</li>
<li>特定の状況でのみ起き、確実な再現や修正が困難なバグ</li>
</ul>
<!-- Rust attempts to mitigate the negative effects of using threads, but -->
<!-- programming in a multithreaded context still takes careful thought and requires -->
<!-- a code structure that is different from programs that run in a single -->
<!-- thread. -->
<p>Rustは、スレッドを使用する際のマイナスの影響を軽減しようとしていますが、それでも、マルチスレッドの文脈でのプログラミングでは、
注意深い思考とシングルスレッドで走るプログラムとは異なるコード構造が必要です。</p>
<!-- Programming languages implement threads in a few different ways. Many operating -->
<!-- systems provide an API for creating new threads. This model where a language -->
<!-- calls the operating system APIs to create threads is sometimes called *1:1*, -->
<!-- meaning one operating system thread per one language thread. -->
<p>プログラミング言語によってスレッドはいくつかの方法で実装されています。多くのOSで、新規スレッドを生成するAPIが提供されています。
言語がOSのAPIを呼び出してスレッドを生成するこのモデルを時に<em>1:1</em>と呼び、1つのOSスレッドに対して1つの言語スレッドを意味します。</p>
<!-- Many programming languages provide their own special implementation of threads. -->
<!-- Programming language-provided threads are known as *green* threads, and -->
<!-- languages that use these green threads will execute them in the context of a -->
<!-- different number of operating system threads. For this reason, the -->
<!-- green-threaded model is called the *M:N* model: there are `M` green threads per -->
<!-- `N` operating system threads, where `M` and `N` are not necessarily the same -->
<!-- number. -->
<p>多くのプログラミング言語がスレッドの独自の特別な実装を提供しています。プログラミング言語が提供するスレッドは、
<em>グリーン</em>スレッドとして知られ、このグリーンスレッドを使用する言語は、それを異なる数のOSスレッドの文脈で実行します。
このため、グリーンスレッドのモデルは<em>M:N</em>モデルと呼ばれます: <code>M</code>個のグリーンスレッドに対して、
<code>N</code>個のOSスレッドがあり、<code>M</code>と<code>N</code>は必ずしも同じ数字ではありません。</p>
<!-- Each model has its own advantages and trade-offs, and the trade-off most -->
<!-- important to Rust is runtime support. *Runtime* is a confusing term and can -->
<!-- have different meanings in different contexts. -->
<p>各モデルには、それだけの利点と妥協点があり、Rustにとって最も重要な妥協点は、ランタイムのサポートです。
<em>ランタイム</em>は、混乱しやすい用語で文脈によって意味も変わります。</p>
<!-- In this context, by *runtime* we mean code that is included by the language in -->
<!-- every binary. This code can be large or small depending on the language, but -->
<!-- every non-assembly language will have some amount of runtime code. For that -->
<!-- reason, colloquially when people say a language has “no runtime,” they often -->
<!-- mean “small runtime.” Smaller runtimes have fewer features but have the -->
<!-- advantage of resulting in smaller binaries, which make it easier to combine the -->
<!-- language with other languages in more contexts. Although many languages are -->
<!-- okay with increasing the runtime size in exchange for more features, Rust needs -->
<!-- to have nearly no runtime and cannot compromise on being able to call into C to -->
<!-- maintain performance. -->
<p>この文脈での<em>ランタイム</em>とは、言語によって全てのバイナリに含まれるコードのことを意味します。
言語によってこのコードの大小は決まりますが、非アセンブリ言語は全てある量の実行時コードを含みます。
そのため、口語的に誰かが「ノーランタイム」と言ったら、「小さいランタイム」のことを意味することがしばしばあります。
ランタイムが小さいと機能も少ないですが、バイナリのサイズも小さくなるという利点があり、
その言語を他の言語とより多くの文脈で組み合わせることが容易になります。多くの言語では、
より多くの機能と引き換えにランタイムのサイズが膨れ上がるのは、受け入れられることですが、
Rustにはほとんどゼロのランタイムが必要でパフォーマンスを維持するためにCコードを呼び出せることを妥協できないのです。</p>
<!-- The green-threading M:N model requires a larger language runtime to manage -->
<!-- threads. As such, the Rust standard library only provides an implementation of -->
<!-- 1:1 threading. Because Rust is such a low-level language, there are crates that -->
<!-- implement M:N threading if you would rather trade overhead for aspects such as -->
<!-- more control over which threads run when and lower costs of context switching, -->
<!-- for example. -->
<p>M:Nのグリーンスレッドモデルは、スレッドを管理するのにより大きな言語ランタイムが必要です。よって、
Rustの標準ライブラリは、1:1スレッドの実装のみを提供しています。Rustはそのような低級言語なので、
例えば、どのスレッドがいつ走るかのより詳細な制御や、文脈切り替えの低コストなどの面でオーバーヘッドと引き換えるなら、
M:Nスレッドの実装をしたクレートもあります。</p>
<!-- Now that we’ve defined threads in Rust, let’s explore how to use the -->
<!-- thread-related API provided by the standard library. -->
<p>今やRustにおけるスレッドを定義したので、標準ライブラリで提供されているスレッド関連のAPIの使用法を探求しましょう。</p>
<!-- ### Creating a New Thread with `spawn` -->
<a class="header" href="print.html#spawnで新規スレッドを生成する" id="spawnで新規スレッドを生成する"><h3><code>spawn</code>で新規スレッドを生成する</h3></a>
<!-- To create a new thread, we call the `thread::spawn` function and pass it a -->
<!-- closure (we talked about closures in Chapter 13) containing the code we want to -->
<!-- run in the new thread. The example in Listing 16-1 prints some text from a main -->
<!-- thread and other text from a new thread: -->
<p>新規スレッドを生成するには、<code>thread::spawn</code>関数を呼び出し、
新規スレッドで走らせたいコードを含むクロージャ(クロージャについては第13章で語りました)を渡します。
リスト16-1の例は、メインスレッドと新規スレッドからテキストを出力します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            // やあ！立ち上げたスレッドから数字{}だよ！
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        // メインスレッドから数字{}だよ！
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 16-1: Creating a new thread to print one thing -->
<!-- while the main thread prints something else</span> -->
<p><span class="caption">リスト16-1: メインスレッドが別のものを出力する間に新規スレッドを生成して何かを出力する</span></p>
<!-- Note that with this function, the new thread will be stopped when the main -->
<!-- thread ends, whether or not it has finished running. The output from this -->
<!-- program might be a little different every time, but it will look similar to the -->
<!-- following: -->
<p>この関数では、新しいスレッドは、実行が終わったかどうかにかかわらず、メインスレッドが終了したら停止することに注意してください。
このプログラムからの出力は毎回少々異なる可能性がありますが、だいたい以下のような感じでしょう:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<!-- The calls to `thread::sleep` force a thread to stop its execution for a short -->
<!-- duration, allowing a different thread to run. The threads will probably take -->
<!-- turns, but that isn’t guaranteed: it depends on how your operating system -->
<!-- schedules the threads. In this run, the main thread printed first, even though -->
<!-- the print statement from the spawned thread appears first in the code. And even -->
<!-- though we told the spawned thread to print until `i` is 9, it only got to 5 -->
<!-- before the main thread shut down. -->
<p><code>thread::sleep</code>を呼び出すと、少々の間、スレッドの実行を止め、違うスレッドを走らせることができます。
スレッドはおそらく切り替わるでしょうが、保証はありません: OSがスレッドのスケジュールを行う方法によります。
この実行では、コード上では立ち上げられたスレッドのprint文が先に現れているのに、メインスレッドが先に出力しています。また、
立ち上げたスレッドには<code>i</code>が9になるまで出力するよう指示しているのに、メインスレッドが終了する前の5までしか到達していません。</p>
<!-- If you run this code and only see output from the main thread, or don’t see any -->
<!-- overlap, try increasing the numbers in the ranges to create more opportunities -->
<!-- for the operating system to switch between the threads. -->
<p>このコードを実行してメインスレッドの出力しか目の当たりにできなかったり、オーバーラップがなければ、
範囲の値を増やしてOSがスレッド切り替えを行う機会を増やしてみてください。</p>
<!-- ### Waiting for All Threads to Finish Using `join` Handles -->
<a class="header" href="print.html#joinハンドルで全スレッドの終了を待つ" id="joinハンドルで全スレッドの終了を待つ"><h3><code>join</code>ハンドルで全スレッドの終了を待つ</h3></a>
<!-- The code in Listing 16-1 not only stops the spawned thread prematurely most of -->
<!-- the time due to the main thread ending, but also can’t guarantee that the -->
<!-- spawned thread will get to run at all. The reason is that there is no guarantee -->
<!-- on the order in which threads run! -->
<p>リスト16-1のコードは、メインスレッドが終了するためにほとんどの場合、立ち上げたスレッドがすべて実行されないだけでなく、
立ち上げたスレッドが実行されるかどうかも保証できません。原因は、スレッドの実行順に保証がないからです。</p>
<!-- We can fix the problem of the spawned thread not getting to run, or not getting -->
<!-- to run completely, by saving the return value of `thread::spawn` in a variable. -->
<!-- The return type of `thread::spawn` is `JoinHandle`. A `JoinHandle` is an owned -->
<!-- value that, when we call the `join` method on it, will wait for its thread to -->
<!-- finish. Listing 16-2 shows how to use the `JoinHandle` of the thread we created -->
<!-- in Listing 16-1 and call `join` to make sure the spawned thread finishes before -->
<!-- `main` exits: -->
<p><code>thread::spawn</code>の戻り値を変数に保存することで、立ち上げたスレッドが実行されなかったり、
完全には実行されなかったりする問題を修正することができます。<code>thread:spawn</code>の戻り値の型は<code>JoinHandle</code>です。
<code>JoinHandle</code>は、<code>join</code>メソッドを呼び出したときにスレッドの終了を待つ所有された値です。
リスト16-2は、リスト16-1で生成したスレッドの<code>JoinHandle</code>を使用し、<code>join</code>を呼び出して、
<code>main</code>が終了する前に、立ち上げたスレッドが確実に完了する方法を示しています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<!-- <span class="caption">Listing 16-2: Saving a `JoinHandle` from `thread::spawn` -->
<!-- to guarantee the thread is run to completion</span> -->
<p><span class="caption">リスト16-2: <code>thread::spawn</code>の<code>JoinHandle</code>を保存してスレッドが完了するのを保証する</span></p>
<!-- Calling `join` on the handle blocks the thread currently running until the -->
<!-- thread represented by the handle terminates. *Blocking* a thread means that -->
<!-- thread is prevented from performing work or exiting. Because we’ve put the call -->
<!-- to `join` after the main thread’s `for` loop, running Listing 16-2 should -->
<!-- produce output similar to this: -->
<p>ハンドルに対して<code>join</code>を呼び出すと、ハンドルが表すスレッドが終了するまで現在実行中のスレッドをブロックします。
スレッドを<em>ブロック</em>するとは、そのスレッドが動いたり、終了したりすることを防ぐことです。
<code>join</code>の呼び出しをメインスレッドの<code>for</code>ループの後に配置したので、リスト16-2を実行すると、
以下のように出力されるはずです:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<!-- The two threads continue alternating, but the main thread waits because of the -->
<!-- call to `handle.join()` and does not end until the spawned thread is finished. -->
<p>2つのスレッドが代わる代わる実行されていますが、<code>handle.join()</code>呼び出しのためにメインスレッドは待機し、
立ち上げたスレッドが終了するまで終わりません。</p>
<!-- But let’s see what happens when we instead move `handle.join()` before the -->
<!-- `for` loop in `main`, like this: -->
<p>ですが、代わりに<code>handle.join()</code>を<code>for</code>ループの前に移動したらどうなるのか確認しましょう。こんな感じに:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!-- The main thread will wait for the spawned thread to finish and then run its -->
<!-- `for` loop, so the output won’t be interleaved anymore, as shown here: -->
<p>メインスレッドは、立ち上げたスレッドが終了するまで待ち、それから<code>for</code>ループを実行するので、
以下のように出力はもう混ざらないでしょう:</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<!-- Small details, such as where to call `join` is called, can affect whether or not your -->
<!-- threads run at the same time. -->
<p>どこで<code>join</code>を呼ぶかといったほんの些細なことが、スレッドが同時に走るかどうかに影響することもあります。</p>
<!-- ### Using `move` Closures with Threads -->
<a class="header" href="print.html#aスレッドでmoveクロージャを使用する" id="aスレッドでmoveクロージャを使用する"><h3>スレッドで<code>move</code>クロージャを使用する</h3></a>
<!-- The `move` closure is often used alongside `thread::spawn` because it allows -->
<!-- you to use data from one thread in another thread. -->
<p><code>move</code>クロージャは、<code>thread::spawn</code>とともによく使用されます。
あるスレッドのデータを別のスレッドで使用できるようになるからです。</p>
<!-- In Chapter 13, we mentioned we can use the `move` keywrod before the parameter -->
<!-- list of a closure to force the closure to take ownership of the values it uses -->
<!-- in the environment. This technique is especially useful when creating new -->
<!-- threads in order to transfer ownership of values from one thread to another. -->
<p>第13章で、クロージャの引数リストの前に<code>move</code>キーワードを使用して、
クロージャに環境で使用している値の所有権を強制的に奪わせることができると述べました。
このテクニックは、あるスレッドから別のスレッドに値の所有権を移すために新しいスレッドを生成する際に特に有用です。</p>
<p>新規スレッドを立ち上げているので、クロージャに値をキャプチャすることについて語りましょう。</p>
<!-- Notice in Listing 16-1 that the closure we pass to `thread::spawn` takes no -->
<!-- arguments: we’re not using any data from the main thread in the spawned -->
<!-- thread’s code. To use data from the main thread in the spawned thread, the -->
<!-- spawned thread’s closure must capture the values it needs. Listing 16-3 shows -->
<!-- an attempt to create a vector in the main thread and use it in the spawned -->
<!-- thread. However, this won’t yet work, as you’ll see in a moment: -->
<p>リスト16-1において、<code>thread::spawn</code>に渡したクロージャには引数がなかったことに注目してください:
立ち上げたスレッドのコードでメインスレッドからのデータは何も使用していないのです。
立ち上げたスレッドでメインスレッドのデータを使用するには、立ち上げるスレッドのクロージャは、
必要な値をキャプチャしなければなりません。リスト16-3は、メインスレッドでベクタを生成し、
立ち上げたスレッドで使用する試みを示しています。しかしながら、すぐにわかるように、これはまだ動きません:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        // こちらがベクタ: {:?}
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<!-- <span class="caption">Listing 16-3: Attempting to use a vector created by the -->
<!-- main thread in another thread</span> -->
<p><span class="caption">リスト16-3: 別のスレッドでメインスレッドが生成したベクタを使用しようとする</span></p>
<!-- The closure uses `v`, so it will capture `v` and make it part of the closure’s -->
<!-- environment. Because `thread::spawn` runs this closure in a new thread, we -->
<!-- should be able to access `v` inside that new thread. But when we compile this -->
<!-- example, we get the following error: -->
<p>クロージャは<code>v</code>を使用しているので、<code>v</code>をキャプチャし、クロージャの環境の一部にしています。
<code>thread::spawn</code>はこのクロージャを新しいスレッドで走らせるので、
その新しいスレッド内で<code>v</code>にアクセスできるはずです。しかし、このコードをコンパイルすると、
以下のようなエラーが出ます:</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
(エラー: クロージャは現在の関数よりも長生きするかもしれませんが、現在の関数が所有している
`v`を借用しています)
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
(ヘルプ: `v`(や他の参照されている変数)の所有権をクロージャに奪わせるには、`move`キーワードを使用してください)
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<!-- Rust *infers* how to capture `v`, and because `println!` only needs a reference -->
<!-- to `v`, the closure tries to borrow `v`. However, there’s a problem: Rust can’t -->
<!-- tell how long the spawned thread will run, so it doesn’t know if the reference -->
<!-- to `v` will always be valid. -->
<p>Rustは<code>v</code>のキャプチャ方法を<em>推論</em>し、<code>println!</code>は<code>v</code>への参照のみを必要とするので、クロージャは、
<code>v</code>を借用しようとします。ですが、問題があります: コンパイラには、立ち上げたスレッドがどのくらいの期間走るのかわからないので、
<code>v</code>への参照が常に有効であるか把握できないのです。</p>
<!-- Listing 16-4 provides a scenario that’s more likely to have a reference to `v` -->
<!-- that won’t be valid: -->
<p>リスト16-4は、<code>v</code>への参照がより有効でなさそうな筋書きです:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    // いや〜！
    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre>
<!-- <span class="caption">Listing 16-4: A thread with a closure that attempts to -->
<!-- capture a reference to `v` from a main thread that drops `v`</span> -->
<p><span class="caption">リスト16-4: <code>v</code>をドロップするメインスレッドから<code>v</code>への参照をキャプチャしようとするクロージャとスレッド</span></p>
<!-- If we were allowed to run this code, there’s a possibility the spawned thread -->
<!-- would be immediately put in the background without running at all. The spawned -->
<!-- thread has a reference to `v` inside, but the main thread immediately drops -->
<!-- `v`, using the `drop` function we discussed in Chapter 15. Then, when the -->
<!-- spawned thread starts to execute, `v` is no longer valid, so a reference to it -->
<!-- is also invalid. Oh no! -->
<p>このコードを実行できてしまうなら、立ち上げたスレッドはまったく実行されることなく即座にバックグラウンドに置かれる可能性があります。
立ち上げたスレッドは内部に<code>v</code>への参照を保持していますが、メインスレッドは、第15章で議論した<code>drop</code>関数を使用して、
即座に<code>v</code>をドロップしています。そして、立ち上げたスレッドが実行を開始する時には、<code>v</code>はもう有効ではなく、
参照も不正になるのです。あちゃー！</p>
<!-- To fix the compiler error in Listing 16-3, we can use the error message’s -->
<!-- advice: -->
<p>リスト16-3のコンパイルエラーを修正するには、エラーメッセージのアドバイスを活用できます:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<!-- By adding the `move` keyword before the closure, we force the closure to take -->
<!-- ownership of the values it’s using rather than allowing Rust to infer that it -->
<!-- should borrow the values. The modification to Listing 16-3 shown in Listing -->
<!-- 16-5 will compile and run as we intend: -->
<p>クロージャの前に<code>move</code>キーワードを付することで、コンパイラに値を借用すべきと推論させるのではなく、
クロージャに使用している値の所有権を強制的に奪わせます。リスト16-5に示したリスト16-3に対する変更は、
コンパイルでき、意図通りに動きます:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<!-- <span class="caption">Listing 16-5: Using the `move` keyword to force a closure -->
<!-- to take ownership of the values it uses</span> -->
<p><span class="caption">リスト16-5: <code>move</code>キーワードを使用してクロージャに使用している値の所有権を強制的に奪わせる</span></p>
<!-- What would happen to the code in Listing 16-4 where the main thread called -->
<!-- `drop` if we use a `move` closure? Would `move` fix that case? Unfortunately, -->
<!-- no; we would get a different error because what Listing 16-4 is trying to do -->
<!-- isn’t allowed for a different reason. If we added `move` to the closure, we -->
<!-- would move `v` into the closure’s environment, and we could no longer call -->
<!-- `drop` on it in the main thread. We would get this compiler error instead: -->
<p><code>move</code>クロージャを使用していたら、メインスレッドが<code>drop</code>を呼び出すリスト16-4のコードはどうなるのでしょうか？
<code>move</code>で解決するのでしょうか？残念ながら、違います; リスト16-4が試みていることは別の理由によりできないので、
違うエラーが出ます。クロージャに<code>move</code>を付与したら、<code>v</code>をクロージャの環境にムーブするので、
最早メインスレッドで<code>drop</code>を呼び出すことは叶わなくなるでしょう。代わりにこのようなコンパイルエラーが出るでしょう:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
(エラー: ムーブされた値の使用: `v`)
  --&gt; src/main.rs:10:10
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
   (注釈: `v`の型が`std::vec::Vec&lt;i32&gt;`のためムーブが起きました。この型は、`Copy`トレイトを実装していません)
</code></pre>
<!-- Rust’s ownership rules have saved us again! We got an error from the code in -->
<!-- Listing 16-3 because Rust was being conservative and only borrowing `v` for the -->
<!-- thread, which meant the main thread could theoretically invalidate the spawned -->
<!-- thread’s reference. By telling Rust to move ownership of `v` to the spawned -->
<!-- thread, we’re guaranteeing Rust that the main thread won’t use `v` anymore. If -->
<!-- we change Listing 16-4 in the same way, we’re then violating the ownership -->
<!-- rules when we try to use `v` in the main thread. The `move` keyword overrides -->
<!-- Rust’s conservative default of borrowing; it doesn’t let us violate the -->
<!-- ownership rules. -->
<p>再三Rustの所有権ルールが救ってくれました！リスト16-3のコードはエラーになりました。
コンパイラが一時的に保守的になり、スレッドに対して<code>v</code>を借用しただけだったからで、
これは、メインスレッドは理論上、立ち上げたスレッドの参照を不正化する可能性があることを意味します。
<code>v</code>の所有権を立ち上げたスレッドに移動するとコンパイラに指示することで、
メインスレッドはもう<code>v</code>を使用しないとコンパイラに保証しているのです。リスト16-4も同様に変更したら、
メインスレッドで<code>v</code>を使用しようとする際に所有権のルールを違反することになります。
<code>move</code>キーワードにより、Rustの保守的な借用のデフォルトが上書きされるのです;
所有権のルールを違反させないのです。</p>
<!-- With a basic understanding of threads and the thread API, let’s look at what we -->
<!-- can *do* with threads. -->
<p>スレッドとスレッドAPIの基礎知識が入ったので、スレッドで<em>できる</em>ことを見ていきましょう。</p>
<!-- ## Using Message Passing to Transfer Data Between Threads -->
<a class="header" href="print.html#aメッセージ受け渡しを使ってスレッド間でデータを転送する" id="aメッセージ受け渡しを使ってスレッド間でデータを転送する"><h2>メッセージ受け渡しを使ってスレッド間でデータを転送する</h2></a>
<!-- One increasingly popular approach to ensuring safe concurrency is *message -->
<!-- passing*, where threads or actors communicate by sending each other messages -->
<!-- containing data. Here’s the idea in a slogan from [the Go language -->
<!-- documentation](http://golang.org/doc/effective_go.html): “Do not communicate by -->
<!-- sharing memory; instead, share memory by communicating.” -->
<p>人気度を増してきている安全な非同期処理を保証する一つのアプローチが<em>メッセージ受け渡し</em>で、
スレッドやアクターがデータを含むメッセージを相互に送り合うことでやり取りします。
こちらが、<a href="http:golang.org/doc/effective_go.html">Go言語のドキュメンテーション</a>のスローガンにある考えです:
「メモリを共有することでやり取りするな; 代わりにやり取りすることでメモリを共有しろ」</p>
<!-- One major tool Rust has for accomplishing message-sending concurrency is the -->
<!-- *channel*, a programming concept that Rust’s standard library provides an -->
<!-- implementation of. You can imagine a channel in programming as being like a -->
<!-- channel of water, such as a stream or a river. If you put something like a -->
<!-- rubber duck or a boat into a stream, it will travel downstream to the end of the -->
<!-- waterway. -->
<p>メッセージ送信非同期処理を達成するためにRustに存在する一つの主な道具は、<em>チャンネル</em>で、
Rustの標準ライブラリが実装を提供しているプログラミング概念です。プログラミングのチャンネルは、
水の流れのように考えることができます。小川とか川ですね。アヒルのおもちゃやボートみたいなものを流れに置いたら、
水路の終端まで下流に流れていきます。</p>
<!-- 5行目終わり、for arriving messagesは本来ならfor messages arrivingのような気がするが、その想定で訳してある -->
<!-- これは自動詞を形容詞のように前からかけているだけと思われる -->
<!-- A channel in programming has two halves: a transmitter and a receiver. The -->
<!-- transmitter half is the upstream location where you put rubber ducks into the -->
<!-- river, and the receiver half is where the rubber duck ends up downstream. One -->
<!-- part of our code calls methods on the transmitter with the data you want to -->
<!-- send, and another part checks the receiving end for arriving messages. A -->
<!-- channel is said to be *closed* if either the transmitter or receiver half is -->
<!-- dropped. -->
<p>プログラミングにおけるチャンネルは、2分割できます: 転送機と受信機です。転送機はアヒルのおもちゃを川に置く上流になり、
受信機は、アヒルのおもちゃが行き着く下流になります。コードのある箇所が送信したいデータとともに転送機のメソッドを呼び出し、
別の部分がメッセージが到着していないか受信側を調べます。転送機と受信機のどちらかがドロップされると、
チャンネルは<em>閉じられた</em>と言います。</p>
<!-- Here, we’ll work up to a program that has one thread to generate values and -->
<!-- send them down a channel, and another thread that will receive the values and -->
<!-- print them out. We’ll be sending simple values between threads using a channel -->
<!-- to illustrate the feature. Once you’re familiar with the technique, you could -->
<!-- use channels to implement a chat system or a system where many threads perform -->
<!-- parts of a calculation and send the parts to one thread that aggregates the -->
<!-- results. -->
<p>ここで、1つのスレッドが値を生成し、それをチャンネルに送信し、別のスレッドがその値を受け取り、
出力するプログラムに取り掛かります。チャンネルを使用してスレッド間に単純な値を送り、
機能の具体化を行います。一旦、そのテクニックに慣れてしまえば、チャンネルを使用してチャットシステムや、
多くのスレッドが計算の一部を担い、結果をまとめる1つのスレッドにその部分を送るようなシステムを実装できるでしょう。</p>
<!-- First, in Listing 16-6, we’ll create a channel but not do anything with it. -->
<!-- Note that this won’t compile yet because Rust can’t tell what type of values we -->
<!-- want to send over the channel. -->
<p>まず、リスト16-6において、チャンネルを生成するものの、何もしません。
チャンネル越しにどんな型の値を送りたいのかコンパイラがわからないため、
これはまだコンパイルできないことに注意してください。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
#     tx.send(()).unwrap();
}
</code></pre></pre>
<!-- <span class="caption">Listing 16-6: Creating a channel and assigning the two -->
<!-- halves to `tx` and `rx`</span> -->
<p><span class="caption">リスト16-6: チャンネルを生成し、2つの部品を<code>tx</code>と<code>rx</code>に代入する</span></p>
<!-- We create a new channel using the `mpsc::channel` function; `mpsc` stands for -->
<!-- *multiple producer, single consumer*. In short, the way Rust’s standard library -->
<!-- implements channels means a channel can have multiple *sending* ends that -->
<!-- produce values but only one *receiving* end that consumes those values. Imagine -->
<!-- multiple streams flowing together into one big river: everything sent down any -->
<!-- of the streams will end up in one river at the end. We’ll start with a single -->
<!-- producer for now, but we’ll add multiple producers when we get this example -->
<!-- working. -->
<p><code>mpsc::channel</code>関数で新しいチャンネルを生成しています; <code>mpsc</code>は<em>multiple producer, single consumer</em>を表しています。
簡潔に言えば、Rustの標準ライブラリがチャンネルを実装している方法は、1つのチャンネルが値を生成する複数の<em>送信</em>側と、
その値を消費するたった1つの<em>受信</em>側を持つことができるということを意味します。
複数の小川が互いに合わさって1つの大きな川になるところを想像してください:
どの川を通っても、送られたものは最終的に1つの川に行き着きます。今は、1つの生成器から始めますが、
この例が動作するようになったら、複数の生成器を追加します。</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<!-- The `mpsc::channel` function returns a tuple, the first element of which is the -->
<!-- sending end and the second element is the receiving end. The abbreviations `tx` -->
<!-- and `rx` are traditionally used in many fields for *transmitter* and *receiver* -->
<!-- respectively, so we name our variables as such to indicate each end. We’re -->
<!-- using a `let` statement with a pattern that destructures the tuples; we’ll -->
<!-- discuss the use of patterns in `let` statements and destructuring in -->
<!-- Chapter 18. Using a `let` statement this way is a convenient approach to -->
<!-- extract the pieces of the tuple returned by `mpsc::channel`. -->
<p><code>mpsc::channel</code>関数はタプルを返し、1つ目の要素は、送信側、2つ目の要素は受信側になります。
<code>tx</code>と<code>rx</code>という略称は、多くの分野で伝統的に<em>転送機</em>と<em>受信機</em>にそれぞれ使用されているので、
変数をそのように名付けて、各終端を示します。タプルを分解するパターンを伴う<code>let</code>文を使用しています;
<code>let</code>文でパターンを使用することと分解については、第18章で議論しましょう。このように<code>let</code>文を使うと、
<code>mpsc::channel</code>で返ってくるタプルの部品を抽出するのが便利になります。</p>
<!-- Let’s move the transmitting end into a spawned thread and have it send one -->
<!-- string so the spawned thread is communicating with the main thread, as shown in -->
<!-- Listing 16-7. This is like putting a rubber duck in the river upstream or -->
<!-- sending a chat message from one thread to another. -->
<p>立ち上げたスレッドがメインスレッドとやり取りするように、転送機を立ち上げたスレッドに移動し、
1文字列を送らせましょう。リスト16-7のようにですね。川の上流にアヒルのおもちゃを置いたり、
チャットのメッセージをあるスレッドから別のスレッドに送るみたいですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<!-- <span class="caption">Listing 16-7: Moving `tx` to a spawned thread and sending -->
<!-- “hi”</span> -->
<p><span class="caption">リスト16-7: <code>tx</code>を立ち上げたスレッドに移動し、「やあ」を送る</span></p>
<!-- Again, we’re using `thread::spawn` to create a new thread and then using `move` -->
<!-- to move `tx` into the closure so the spawned thread owns `tx`. The spawned -->
<!-- thread needs to own the transmitting end of the channel to be able to send -->
<!-- messages through the channel. -->
<p>今回も、<code>thread::spawn</code>を使用して新しいスレッドを生成し、それから<code>move</code>を使用して、
立ち上げたスレッドが<code>tx</code>を所有するようにクロージャに<code>tx</code>をムーブしています。立ち上げたスレッドは、
メッセージをチャンネルを通して送信できるようにチャンネルの送信側を所有する必要があります。</p>
<!-- The transmitting end has a `send` method that takes the value we want to send. -->
<!-- The `send` method returns a `Result<T, E>` type, so if the receiving end has -->
<!-- already been dropped and there’s nowhere to send a value, the send operation -->
<!-- will return an error. In this example, we’re calling `unwrap` to panic in case -->
<!-- of an error. But in a real application, we would handle it properly: return to -->
<!-- Chapter 9 to review strategies for proper error handling. -->
<p>転送側には、送信したい値を取る<code>send</code>メソッドがあります。<code>send</code>メソッドは<code>Result&lt;T, E&gt;</code>型を返すので、
すでに受信側がドロップされ、値を送信する場所がなければ、送信処理はエラーを返します。
この例では、エラーの場合には、パニックするように<code>unwrap</code>を呼び出しています。ですが、実際のアプリケーションでは、
ちゃんと扱うでしょう: 第9章に戻ってちゃんとしたエラー処理の方法を再確認してください。</p>
<!-- In Listing 16-8, we’ll get the value from the receiving end of the channel in -->
<!-- the main thread. This is like retrieving the rubber duck from the water at the -->
<!-- end of the river or like getting a chat message. -->
<p>リスト16-8において、メインスレッドのチャンネルの受信側から値を得ます。
アヒルのおもちゃを川の終端で水から回収したり、チャットメッセージを取得するみたいですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    // 値は{}です
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<!-- <span class="caption">Listing 16-8: Receiving the value “hi” in the main thread -->
<!-- and printing it</span> -->
<p><span class="caption">リスト16-8: 「やあ」の値をメインスレッドで受け取り、出力する</span></p>
<!-- The receiving end of a channel has two useful methods: `recv` and `try_recv`. -->
<!-- We’re using `recv`, short for *receive*, which will block the main thread’s -->
<!-- execution and wait until a value is sent down the channel. Once a value is -->
<!-- sent, `recv` will return it in a `Result<T, E>`. When the sending end of the -->
<!-- channel closes, `recv` will return an error to signal that no more values will -->
<!-- be coming. -->
<p>チャンネルの受信側には有用なメソッドが2つあります: <code>recv</code>と<code>try_recv</code>です。
<em>receive</em>の省略形である<code>recv</code>を使っていて、これは、メインスレッドの実行をブロックし、
値がチャンネルを流れてくるまで待機します。一旦値が送信されたら、<code>recv</code>はそれを<code>Result&lt;T, E&gt;</code>に含んで返します。
チャンネルの送信側が閉じたら、<code>recv</code>はエラーを返し、もう値は来ないと通知します。</p>
<!-- The `try_recv` method doesn’t block, but will instead return a `Result<T, E>` -->
<!-- immediately: an `Ok` value holding a message if one is available and an `Err` -->
<!-- value if there aren’t any messages this time. Using `try_recv` is useful if -->
<!-- this thread has other work to do while waiting for messages: we could write a -->
<!-- loop that calls `try_recv` every so often, handles a message if one is -->
<!-- available, and otherwise does other work for a little while until checking -->
<!-- again. -->
<p><code>try_recv</code>メソッドはブロックせず、代わりに即座に<code>Result&lt;T, E&gt;</code>を返します:
メッセージがあったら、それを含む<code>Ok</code>値、今回は何もメッセージがなければ、<code>Err</code>値です。
メッセージを待つ間にこのスレッドにすることが他にあれば、<code>try_recv</code>は有用です:
<code>try_recv</code>を頻繁に呼び出し、メッセージがあったら処理し、それ以外の場合は、
再度チェックするまでちょっとの間他の作業をするループを書くことができるでしょう。</p>
<!-- We’ve used `recv` in this example for simplicity; we don’t have any other work -->
<!-- for the main thread to do other than wait for messages, so blocking the main -->
<!-- thread is appropriate. -->
<p>この例では、簡潔性のために<code>recv</code>を使用しました; メッセージを待つこと以外にメインスレッドがすべき作業はないので、
メインスレッドをブロックするのは適切です。</p>
<!-- When we run the code in Listing 16-8, we’ll see the value printed from the main -->
<!-- thread: -->
<p>リスト16-8のコードを実行したら、メインスレッドから値が出力されます:</p>
<pre><code class="language-text">Got: hi
</code></pre>
<!-- Perfect! -->
<p>完璧です！</p>
<!-- ### Channels and Ownership Transference -->
<a class="header" href="print.html#aチャンネルと所有権の転送" id="aチャンネルと所有権の転送"><h3>チャンネルと所有権の転送</h3></a>
<!-- The ownership rules play a vital role in message sending because they help you -->
<!-- write safe, concurrent code. Preventing errors in concurrent programming is the -->
<!-- advantage of thinking about ownership throughout your Rust program. Let's do -->
<!-- an experiment to show how channels and ownership work together to prevent -->
<!-- problems: we’ll try to use a `val` value in the spawned thread *after* we’ve -->
<!-- sent it down the channel. Try compiling the code in Listing 16-9 to see why -->
<!-- this code isn’t allowed: -->
<p>安全な並行コードを書く手助けをしてくれるので、所有権ルールは、メッセージ送信で重要な役割を担っています。
並行プログラミングでエラーを回避することは、Rustプログラム全体で所有権について考える利点です。
実験をしてチャンネルと所有権がともに動いてどう問題を回避するかをお見せしましょう:
<code>val</code>値を立ち上げたスレッドで、チャンネルに送った<em>後</em>に使用を試みます。
リスト16-9のコードのコンパイルを試みてこのコードが許容されない理由を確認してください:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        // valは{}
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<!-- <span class="caption">Listing 16-9: Attempting to use `val` after we’ve sent it -->
<!-- down the channel</span> -->
<p><span class="caption">リスト16-9: チャンネルに送信後に<code>val</code>の使用を試みる</span></p>
<!-- Here, we try to print `val` after we’ve sent it down the channel via `tx.send`. -->
<!-- Allowing this would be a bad idea: once the value has been sent to another -->
<!-- thread, that thread could modify or drop it before we try to use the value -->
<!-- again. Potentially, the other thread's modifications could cause errors or -->
<!-- unexpected results due to inconsistent or nonexistent data. However, Rust gives -->
<!-- us an error if we try to compile the code in Listing 16-9: -->
<p>ここで、<code>tx.send</code>経由でチャンネルに送信後に<code>val</code>を出力しようとしています。これを許可するのは、悪い考えです:
一旦、値が他のスレッドに送信されたら、そのスレッドが再度値を使用しようとする前に変更したりドロップできてしまいます。
可能性として、その別のスレッドの変更により、矛盾していたり存在しないデータのせいでエラーが発生したり、
予期しない結果になるでしょう。ですが、リスト16-9のコードのコンパイルを試みると、
Rustはエラーを返します:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `val`
  --&gt; src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`, which does
not implement the `Copy` trait
</code></pre>
<!-- Our concurrency mistake has caused a compile time error. The `send` function -->
<!-- takes ownership of its parameter, and when the value is moved, the receiver -->
<!-- takes ownership of it. This stops us from accidentally using the value again -->
<!-- after sending it; the ownership system checks that everything is okay. -->
<p>非同期処理のミスがコンパイルエラーを招きました。<code>send</code>関数は引数の所有権を奪い、
値がムーブされると、受信側が所有権を得るのです。これにより、送信後に誤って再度値を使用するのを防いでくれます;
所有権システムが、万事問題ないことを確認してくれます。</p>
<!-- ### Sending Multiple Values and Seeing the Receiver Waiting -->
<a class="header" href="print.html#a複数の値を送信し受信側が待機するのを確かめる" id="a複数の値を送信し受信側が待機するのを確かめる"><h3>複数の値を送信し、受信側が待機するのを確かめる</h3></a>
<!-- The code in Listing 16-8 compiled and ran, but it didn’t clearly show us that -->
<!-- two separate threads were talking to each other over the channel. In Listing -->
<!-- 16-10 we’ve made some modifications that will prove the code in Listing 16-8 is -->
<!-- running concurrently: the spawned thread will now send multiple messages and -->
<!-- pause for a second between each message. -->
<p>リスト16-8のコードはコンパイルでき、動きましたが、2つの個別のスレッドがお互いにチャンネル越しに会話していることは、
明瞭に示されませんでした。リスト16-10において、リスト16-8のコードが並行に動いていることを証明する変更を行いました:
立ち上げたスレッドは、複数のメッセージを送信し、各メッセージ間で、1秒待機します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        // スレッドからやあ(hi from the thread)
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 16-10: Sending multiple messages and pausing -->
<!-- between each</span> -->
<p><span class="caption">リスト16-10: 複数のメッセージを送信し、メッセージ間で停止する</span></p>
<!-- This time, the spawned thread has a vector of strings that we want to send to -->
<!-- the main thread. We iterate over them, sending each individually, and pause -->
<!-- between each by calling the `thread::sleep` function with a `Duration` value of -->
<!-- 1 second. -->
<p>今回は、メインスレッドに送信したい文字列のベクタを立ち上げたスレッドが持っています。
それらをイテレートし、各々個別に送信し、<code>Duration</code>の値1秒とともに<code>thread::sleep</code>関数を呼び出すことで、
メッセージ間で停止します。</p>
<!-- In the main thread, we’re not calling the `recv` function explicitly anymore: -->
<!-- instead, we’re treating `rx` as an iterator. For each value received, we’re -->
<!-- printing it. When the channel is closed, iteration will end. -->
<p>メインスレッドにおいて、最早<code>recv</code>関数を明示的に呼んではいません: 代わりに、
<code>rx</code>をイテレータとして扱っています。受信した値それぞれを出力します。
チャンネルが閉じられると、繰り返しも終わります。</p>
<!-- When running the code in Listing 16-10, you should see the following output -->
<!-- with a 1-second pause in between each line: -->
<p>リスト16-10のコードを走らせると、各行の間に1秒の待機をしつつ、以下のような出力を目の当たりにするはずです:</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<!-- Because we don’t have any code that pauses or delays in the `for` loop in the -->
<!-- main thread, we can tell that the main thread is waiting to receive values from -->
<!-- the spawned thread. -->
<p>メインスレッドの<code>for</code>ループには停止したり、遅れせたりするコードは何もないので、
メインスレッドが立ち上げたスレッドから値を受け取るのを待機していることがわかります。</p>
<!-- ### Creating Multiple Producers by Cloning the Transmitter -->
<a class="header" href="print.html#a転送機をクローンして複数の生成器を作成する" id="a転送機をクローンして複数の生成器を作成する"><h3>転送機をクローンして複数の生成器を作成する</h3></a>
<!-- Earlier we mentioned that `mpsc` was an acronym for *multiple producer, -->
<!-- single consumer*. Let’s put `mpsc` to use and expand the code in Listing 16-10 -->
<!-- to create multiple threads that all send values to the same receiver. We can do -->
<!-- so by cloning the transmitting half of the channel, as shown in Listing 16-11: -->
<p><code>mpsc</code>は、<em>mutiple producer, single consumer</em>の頭字語であると前述しました。
<code>mpsc</code>を使用に移し、リスト16-10のコードを拡張して全てが値を同じ受信機に送信する複数のスレッドを生成しましょう。
チャンネルの転送の片割れをクローンすることでそうすることができます。リスト16-11のようにですね:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::thread;
# use std::sync::mpsc;
# use std::time::Duration;
#
# fn main() {
// --snip--

let (tx, rx) = mpsc::channel();

let tx1 = mpsc::Sender::clone(&amp;tx);
thread::spawn(move || {
    let vals = vec![
        String::from(&quot;hi&quot;),
        String::from(&quot;from&quot;),
        String::from(&quot;the&quot;),
        String::from(&quot;thread&quot;),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    // 君のためにもっとメッセージを(more messages for you)
    let vals = vec![
        String::from(&quot;more&quot;),
        String::from(&quot;messages&quot;),
        String::from(&quot;for&quot;),
        String::from(&quot;you&quot;),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!(&quot;Got: {}&quot;, received);
}

// --snip--
# }
</code></pre></pre>
<!-- <span class="caption">Listing 16-11: Sending multiple messages from multiple -->
<!-- producers</span> -->
<p><span class="caption">リスト16-11: 複数の生成器から複数のメッセージを送信する</span></p>
<!-- This time, before we create the first spawned thread, we call `clone` on the -->
<!-- sending end of the channel. This will give us a new sending handle we can pass -->
<!-- to the first spawned thread. We pass the original sending end of the channel to -->
<!-- a second spawned thread. This gives us two threads, each sending different -->
<!-- messages to the receiving end of the channel. -->
<p>今回、最初のスレッドを立ち上げる前に、チャンネルの送信側に対して<code>clone</code>を呼び出しています。
これにより、最初に立ち上げたスレッドに渡せる新しい送信ハンドルが得られます。
元のチャンネルの送信側は、2番目に立ち上げたスレッドに渡します。これにより2つスレッドが得られ、
それぞれチャンネルの受信側に異なるメッセージを送信します。</p>
<!-- When you run the code, your output output should look something like this: -->
<p>コードを実行すると、出力は以下のようなものになるはずです:</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<!-- You might see the values in another order; it depends on your system. This is -->
<!-- what makes concurrency interesting as well as difficult. If you experiment with -->
<!-- `thread::sleep`, giving it various values in the different threads, each run -->
<!-- will be more nondeterministic and create different output each time. -->
<p>別の順番で値が出る可能性もあります; システム次第です。非同期処理が面白いと同時に難しい部分でもあります。
異なるスレッドで色々な値を与えて<code>thread::sleep</code>で実験をしたら、走らせるたびにより非決定的になり、
毎回異なる出力をするでしょう。</p>
<!-- Now that we’ve looked at how channels work, let’s look at a different method of -->
<!-- concurrency. -->
<p>チャンネルの動作方法を見たので、他の非同期処理に目を向けましょう。</p>
<!-- ## Shared-State Concurrency -->
<a class="header" href="print.html#a状態共有非同期処理" id="a状態共有非同期処理"><h2>状態共有非同期処理</h2></a>
<!-- Message passing is a fine way of handling concurrency, but it’s not the only -->
<!-- one. Consider this part of the slogan from the Go language documentation again: -->
<!-- “communicate by sharing memory.” -->
<p>メッセージ受け渡しは、非同期処理を扱う素晴らしい方法ですが、唯一の方法ではありません。
Go言語ドキュメンテーションのスローガンのこの部分を再び考えてください:
「メモリを共有することでやり取りする。」</p>
<!-- What would communicating by sharing memory look like? In addition, why would -->
<!-- message-passing enthusiasts not use it and do the opposite instead? -->
<p>メモリを共有することでやり取りするとはどんな感じなのでしょうか？さらに、
なぜメッセージ受け渡しに熱狂的な人は、それを使わず、代わりに全く反対のことをするのでしょうか？</p>
<!-- In a way, channels in any programming language are similar to single ownership, -->
<!-- because once you transfer a value down a channel, you should no longer use that -->
<!-- value. Shared memory concurrency is like multiple ownership: multiple threads -->
<!-- can access the same memory location at the same time. As you saw in Chapter 15, -->
<!-- where smart pointers made multiple ownership possible, multiple ownership can -->
<!-- add complexity because these different owners need managing. Rust’s type system -->
<!-- and ownership rules greatly assist in getting this management correct. For an -->
<!-- example, let’s look at mutexes, one of the more common concurrency primitives -->
<!-- for shared memory. -->
<p>ある意味では、どんなプログラミング言語のチャンネルも単独の所有権に類似しています。
一旦チャンネルに値を転送したら、その値は最早使用することがないからです。
メモリ共有非同期処理は、複数の所有権に似ています: 複数のスレッドが同時に同じメモリ位置にアクセスできるのです。
第15章でスマートポインタが複数の所有権を可能にするのを目の当たりにしたように、
異なる所有者を管理する必要があるので、複数の所有権は複雑度を増させます。
Rustの型システムと所有権ルールにより、この管理を正当に行う大きな助けになります。
例を挙げれば、メモリ共有を行うより一般的な非同期処理の基本型の一つであるミューテックスを見ましょう。</p>
<!-- ### Using Mutexes to Allow Access to Data from One Thread at a Time -->
<a class="header" href="print.html#aミューテックスを使用して一度に1つのスレッドからデータにアクセスすることを許可する" id="aミューテックスを使用して一度に1つのスレッドからデータにアクセスすることを許可する"><h3>ミューテックスを使用して一度に1つのスレッドからデータにアクセスすることを許可する</h3></a>
<!-- 1行目、as in,が肝だが、inの後は普通名詞に相当するものが来るはずだが、文になっている -->
<!-- *Mutex* is an abbreviation for “mutual exclusion,” as in, a mutex allows only -->
<!-- one thread to access some data at any given time. To access the data in a -->
<!-- mutex, a thread must first signal that it wants access by asking to acquire the -->
<!-- mutex's *lock*. The lock is a data structure that is part of the mutex that -->
<!-- keeps track of who currently has exclusive access to the data. Therefore, the -->
<!-- mutex is described as *guarding* the data it holds via the locking system. -->
<p>ミューテックスは、どんな時も1つのスレッドにしかなんらかのデータへのアクセスを許可しないというように、
&quot;mutual exclusion&quot;(相互排他)の省略形です。ミューテックスにあるデータにアクセスするには、
ミューテックスのロックを所望することでアクセスしたいことをまず、スレッドは通知しなければなりません。
ロックとは、現在誰がデータへの排他的アクセスを行なっているかを追跡するミューテックの一部をなすデータ構造です。
故に、ミューテックスはロックシステム経由で保持しているデータを<em>死守する</em>(guarding)と解説されます。</p>
<!-- Mutexes have a reputation for being difficult to use because you have to -->
<!-- remember two rules: -->
<p>ミューテックスは、2つの規則を覚えておく必要があるため、難しいという評判があります:</p>
<!-- * You must attempt to acquire the lock before using the data. -->
<!-- * When you’re done with the data that the mutex guards, you must unlock the -->
<!--   data so other threads can acquire the lock. -->
<ul>
<li>データを使用する前にロックの獲得を試みなければならない。</li>
<li>ミューテックスが死守しているデータの使用が終わったら、他のスレッドがロックを獲得できるように、
データをアンロックしなければならない。</li>
</ul>
<!-- For a real-world metaphor for a mutex, imagine a panel discussion at a -->
<!-- conference with only one microphone. Before a panelist can speak, they have to -->
<!-- ask or signal that they want to use the microphone. When they get the -->
<!-- microphone, they can talk for as long as they want to and then hand the -->
<!-- microphone to the next panelist who requests to speak. If a panelist forgets to -->
<!-- hand the microphone off when they’re finished with it, no one else is able to -->
<!-- speak. If management of the shared microphone goes wrong, the panel won’t work -->
<!-- as planned! -->
<p>ミューテックスを現実世界の物で例えるなら、マイクが1つしかない会議のパネルディスカッションを思い浮かべてください。
パネリストが発言できる前に、マイクを使用したいと申し出たり、通知しなければなりません。マイクを受け取ったら、
話したいだけ話し、それから次に発言を申し出たパネリストにマイクを手渡します。パネリストが発言し終わった時に、
マイクを手渡すのを忘れていたら、誰も他の人は発言できません。共有されているマイクの管理がうまくいかなければ、
パネルは予定通りに動かないでしょう！</p>
<!-- Management of mutexes can be incredibly tricky to get right, which is why so -->
<!-- many people are enthusiastic about channels. However, thanks to Rust’s type -->
<!-- system and ownership rules, you can’t get locking and unlocking wrong. -->
<p>ミューテックスの管理は、正しく行うのに著しく巧妙なことがあるので、多くの人がチャンネルに熱狂的になるわけです。
しかしながら、Rustの型システムと所有権ルールのおかげで、ロックとアンロックを間違えることはありません。</p>
<!-- #### The API of `Mutex<T>` -->
<a class="header" href="print.html#mutextのapi" id="mutextのapi"><h4><code>Mutex&lt;T&gt;</code>のAPI</h4></a>
<!-- As an example of how to use a mutex, let’s start by using a mutex in a -->
<!-- single-threaded context, as shown in Listing 16-12: -->
<p>ミューテックスの使用方法の例として、ミューテックスをシングルスレッドの文脈で使うことから始めましょう。
リスト16-12のようにですね:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<!-- <span class="caption">Listing 16-12: Exploring the API of `Mutex<T>` in a -->
<!-- single-threaded context for simplicity</span> -->
<p><span class="caption">リスト16-12: 簡潔性のために<code>Mutex&lt;T&gt;</code>のAPIをシングルスレッドの文脈で探求する</span></p>
<!-- As with many types, we create a `Mutex<T>` using the associated function `new`. -->
<!-- To access the data inside the mutex, we use the `lock` method to acquire the -->
<!-- lock. This call will block the current thread so it can’t do any work until -->
<!-- it’s our turn to have the lock. -->
<p>多くの型同様、<code>new</code>という関連関数を使用して<code>Mutex&lt;T&gt;</code>を生成します。ミューテックス内部のデータにアクセスするには、
<code>lock</code>メソッドを使用してロックを獲得します。この呼び出しは、現在のスレッドをブロックするので、
ロックを得られる順番が来るまで何も作業はできません。</p>
<!-- The call to `lock` would fail if another thread holding the lock panicked. In -->
<!-- that case, no one would ever be able to get the lock, so we’ve chosen to -->
<!-- `unwrap` and have this thread panic if we’re in that situation. -->
<p>ロックを保持している他のスレッドがパニックしたら、<code>lock</code>の呼び出しは失敗するでしょう。その場合、
誰もロックを取得することは叶わないので、<code>unwrap</code>すると決定し、そのような状況になったら、
このスレッドをパニックさせます。</p>
<!-- After we’ve acquired the lock, we can treat the return value, named `num` in -->
<!-- this case, as a mutable reference to the data inside. The type system ensures -->
<!-- that we acquire a lock before using the value in `m`: `Mutex<i32>` is not an -->
<!-- `i32`, so we *must* acquire the lock to be able to use the `i32` value. We -->
<!-- can’t forget; the type system won’t let us access the inner `i32` otherwise. -->
<p>ロックを獲得した後、今回の場合、<code>num</code>と名付けられていますが、戻り値を中に入っているデータへの可変参照として扱うことができます。
型システムにより、<code>m</code>の値を使用する前にロックを獲得していることが確認されます: <code>Mutex&lt;i32&gt;</code>は<code>i32</code>ではないので、
<code>i32</code>を使用できるようにするには、ロックを獲得し<em>なければならない</em>のです。忘れることはあり得ません;
型システムにより、それ以外の場合に内部の<code>i32</code>にアクセスすることは許されません。</p>
<!-- As you might suspect, `Mutex<T>` is a smart pointer. More accurately, the call -->
<!-- to `lock` *returns* a smart pointer called `MutexGuard`. This smart pointer -->
<!-- implements `Deref` to point at our inner data; the smart pointer also has a -->
<!-- `Drop` implementation that releases the lock automatically when a `MutexGuard` -->
<!-- goes out of scope, which happens at the end of the inner scope in Listing -->
<!-- 16-12. As a result, we don’t risk forgetting to release the lock and blocking -->
<!-- the mutex from being used by other threads because the lock release happens -->
<!-- automatically. -->
<p>疑っているかもしれませんが、<code>Mutex&lt;T&gt;</code>はスマートポインタです。より正確を期すなら、
<code>lock</code>の呼び出しが<code>MutexGuard</code>というスマートポインタを<em>返却</em>します。このスマートポインタが、
内部のデータを指す<code>Deref</code>を実装しています; このスマートポインタはさらに<code>MutexGuard</code>がスコープを外れた時に、
自動的にロックを解除する<code>Drop</code>実装もしていて、これがリスト16-12の内部スコープの終わりで発生します。
結果として、ロックの解除が自動的に行われるので、ロックの解除を忘れ、
ミューテックスが他のスレッドで使用されるのを阻害するリスクを負いません。</p>
<!-- After dropping the lock, we can print the mutex value and see that we were able -->
<!-- to change the inner `i32` to 6. -->
<p>ロックをドロップした後、ミューテックスの値を出力し、内部の<code>i32</code>の値を6に変更できたことが確かめられるのです。</p>
<!-- #### Sharing a `Mutex<T>` Between Multiple Threads -->
<a class="header" href="print.html#a複数のスレッド間でmutextを共有する" id="a複数のスレッド間でmutextを共有する"><h4>複数のスレッド間で<code>Mutex&lt;T&gt;</code>を共有する</h4></a>
<!-- Now, let’s try to share a value between multiple threads using `Mutex<T>`. -->
<!-- We’ll spin up 10 threads and have them each increment a counter value by 1, so -->
<!-- the counter goes from 0 to 10. Note that the next few examples will have -->
<!-- compiler errors, and we’ll use those errors to learn more about using -->
<!-- `Mutex<T>` and how Rust helps us use it correctly. Listing 16-13 has our -->
<!-- starting example: -->
<p>さて、<code>Mutex&lt;T&gt;</code>を使って複数のスレッド間で値を共有してみましょう。10個のスレッドを立ち上げ、
各々カウンタの値を1ずつインクリメントさせるので、カウンタは0から10まで上がります。
以下の数例は、コンパイルエラーになることに注意し、そのエラーを使用して<code>Mutex&lt;T&gt;</code>の使用法と、
コンパイラがそれを正しく活用する手助けをしてくれる方法について学びます。リスト16-13が最初の例です:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<!-- <span class="caption">Listing 16-13: Ten threads each increment a counter -->
<!-- guarded by a `Mutex<T>`</span> -->
<p><span class="caption">リスト16-13: <code>Mutex&lt;T&gt;</code>により死守されているカウンタを10個のスレッドがそれぞれインクリメントする</span></p>
<!-- We create a `counter` variable to hold an `i32` inside a `Mutex<T>`, as we -->
<!-- did in Listing 16-12. Next, we create 10 threads by mapping over a range -->
<!-- of numbers. We use `thread::spawn` and give all the threads the same closure, -->
<!-- one that moves the counter into the thread, acquires a lock on the `Mutex<T>` -->
<!-- by calling the `lock` method, and then adds 1 to the value in the mutex. When a -->
<!-- thread finishes running its closure, `num` will go out of scope and release the -->
<!-- lock so another thread can acquire it. -->
<p>リスト16-12のように、<code>counter</code>変数を生成して<code>Mutex&lt;T&gt;</code>の内部に<code>i32</code>を保持しています。
次に、数値の範囲をマッピングして10個のスレッドを生成しています。<code>thread::spawn</code>を使用して、
全スレッドに同じクロージャを与えています。このクロージャは、スレッド内にカウンタをムーブし、
<code>lock</code>メソッドを呼ぶことで<code>Mutex&lt;T&gt;</code>のロックを獲得し、それからミューテックスの値に1を足します。
スレッドがクロージャを実行し終わったら、<code>num</code>はスコープ外に出てロックを解除するので、
他のスレッドが獲得できるわけです。</p>
<!-- In the main thread, we collect all the join handles. Then, as we did in Listing -->
<!-- 16-2, we call `join` on each to make sure all the threads finish. At -->
<!-- that point, the main thread will acquire the lock and print the result of this -->
<!-- program. -->
<p>メインスレッドで全てのjoinハンドルを収集します。それからリスト16-2のように、各々に対して<code>join</code>を呼び出し、
全スレッドが終了するのを確かめています。その時点で、メインスレッドはロックを獲得し、このプログラムの結果を出力します。</p>
<!-- We hinted that this example wouldn’t compile. Now let’s find out why! -->
<p>この例はコンパイルできないでしょうと仄めかしました。では、理由を探りましょう！</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
(エラー: ムーブされた値をキャプチャしています: `counter`)
  --&gt; src/main.rs:10:27
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
10 |             let mut num = counter.lock().unwrap();
   |                           ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
(エラー: 前述の2つのエラーによりアボート)
</code></pre>
<!-- The error message states that the `counter` value is moved into the closure and -->
<!-- then captured when we call `lock`. That description sounds like what we wanted, -->
<!-- but it’s not allowed! -->
<p>エラーメッセージは、<code>counter</code>値はクロージャにムーブされ、それから<code>lock</code>を呼び出したときにキャプチャされていると述べています。
その説明は、所望した動作のように聞こえますが、許可されていないのです！</p>
<!-- Let’s figure this out by simplifying the program. Instead of making 10 threads -->
<!-- in a `for` loop, let’s just make two threads without a loop and see what -->
<!-- happens. Replace the first `for` loop in Listing 16-13 with this code instead: -->
<p>プログラムを単純化してこれを理解しましょう。<code>for</code>ループで10個スレッドを生成する代わりに、
ループなしで2つのスレッドを作るだけにしてどうなるか確認しましょう。
リスト16-13の最初の<code>for</code>ループを代わりにこのコードと置き換えてください:</p>
<pre><code class="language-rust ignore">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    let handle = thread::spawn(move || {
        let mut num = counter.lock().unwrap();

        *num += 1;
    });
    handles.push(handle);

    let handle2 = thread::spawn(move || {
        let mut num2 = counter.lock().unwrap();

        *num2 += 1;
    });
    handles.push(handle2);

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<!-- We make two threads and change the variable names used with the second thread -->
<!-- to `handle2` and `num2`. When we run the code this time, compiling gives us the -->
<!-- following: -->
<p>2つのスレッドを生成し、2番目のスレッドの変数名を<code>handle2</code>と<code>num2</code>に変更しています。
今回このコードを走らせると、コンパイラは以下の出力をします:</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:16:24
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
16 |         let mut num2 = counter.lock().unwrap();
   |                        ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:26:29
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
26 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<!-- Aha! The first error message indicates that `counter` is moved into the closure -->
<!-- for the thread associated with `handle`. That move is preventing us from -->
<!-- capturing `counter` when we try to call `lock` on it and store the result in -->
<!-- `num2` in the second thread! So Rust is telling us that we can’t move ownership -->
<!-- of `counter` into multiple threads. This was hard to see earlier because our -->
<!-- threads were in a loop, and Rust can’t point to different threads in different -->
<!-- iterations of the loop. Let’s fix the compiler error with a multiple-ownership -->
<!-- method we discussed in Chapter 15. -->
<p>なるほど！最初のメッセージは、<code>handle</code>に紐付けられたスレッドのクロージャに<code>counter</code>がムーブされていることを示唆しています。
そのムーブにより、それに対して<code>lock</code>を呼び出し、結果を2番目のスレッドの<code>num2</code>に保持しようとした時に、
<code>counter</code>をキャプチャすることを妨げています。ゆえに、コンパイラは、<code>counter</code>の所有権を複数のスレッドに移すことはできないと教えてくれています。
これは、以前では確認しづらかったことです。なぜなら、スレッドはループの中にあり、
ループの違う繰り返しにある違うスレッドをコンパイラは指し示せないからです。
第15章で議論した複数所有権メソッドによりコンパイルエラーを修正しましょう。</p>
<!-- #### Multiple Ownership with Multiple Threads -->
<a class="header" href="print.html#a複数のスレッドで複数の所有権" id="a複数のスレッドで複数の所有権"><h4>複数のスレッドで複数の所有権</h4></a>
<!-- In Chapter 15, we gave a value multiple owners by using the smart pointer -->
<!-- `Rc<T>` to create a reference counted value. Let’s do the same here and see -->
<!-- what happens. We’ll wrap the `Mutex<T>` in `Rc<T>` in Listing 16-14 and clone -->
<!-- the `Rc<T>` before moving ownership to the thread. Now that we’ve seen the -->
<!-- errors, we’ll also switch back to using the `for` loop, and we’ll keep the -->
<!-- `move` keyword with the closure. -->
<p>第15章で、スマートポインタの<code>Rc&lt;T&gt;</code>を使用して参照カウントの値を作ることで、1つの値に複数の所有者を与えました。
同じことをここでもして、どうなるか見ましょう。リスト16-14で<code>Rc&lt;T&gt;</code>に<code>Mutex&lt;T&gt;</code>を包含し、
所有権をスレッドに移す前に<code>Rc&lt;T&gt;</code>をクローンします。今やエラーを確認したので、
<code>for</code>ループの使用に立ち戻り、クロージャに<code>move</code>キーワードを使用し続けます。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<!-- <span class="caption">Listing 16-14: Attempting to use `Rc<T>` to allow -->
<!-- multiple threads to own the `Mutex<T>`</span> -->
<p><span class="caption">リスト16-14: <code>Rc&lt;T&gt;</code>を使用して複数のスレッドに<code>Mutex&lt;T&gt;</code>を所有させようとする</span></p>
<!-- Once again, we compile and get... different errors! The compiler is teaching us -->
<!-- a lot. -->
<p>再三、コンパイルし……別のエラーが出ました！コンパイラはいろんなことを教えてくれています。</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send` is not satisfied in `[closure@src/main.rs:11:36:
15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
(エラー: トレイト境界`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send`は`[closure@src/main.rs:11:36:15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`で満たされていません)
  --&gt; src/main.rs:11:22
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
cannot be sent between threads safely
                          (`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`は、スレッド間で安全に送信できません)
   |
   = help: within `[closure@src/main.rs:11:36: 15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is
not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
     (ヘルプ: `[closure@src/main.rs:11:36 15:10
     counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`内でトレイト`std::marker::Send`は、
     `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`に対して実装されていません)
   = note: required because it appears within the type
`[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
     (注釈: 型`[closure@src/main.rs:11:36 15:10
     counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`内に出現するので必要です)
   = note: required by `std::thread::spawn`
     (注釈: `std::thread::spawn`により必要とされています)
</code></pre>
<!-- Wow, that error message is very wordy! Here are some important parts to focus -->
<!-- on: the first inline error says `` `std::rc::Rc<std::sync::Mutex<i32>>` cannot -->
<!-- be sent between threads safely ``. The reason for this is in the next important -->
<!-- part to focus on, the error message. The distilled error message says `` the -->
<!-- trait bound `Send` is not satisfied ``. We’ll talk about `Send` in the next -->
<!-- section: it’s one of the traits that ensures the types we use with threads are -->
<!-- meant for use in concurrent situations. -->
<p>おお、このエラーメッセージはとても長ったらしいですね！こちらが、注目すべき重要な部分です:
最初のインラインエラーは<code>`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>と述べています。この理由は、次に注目すべき重要な部分、エラーメッセージにあります。
蒸留されたエラーメッセージは、<code>the trait bound `Send` is not satisfied</code>と述べています。
<code>Send</code>については、次の節で語ります:
スレッドとともに使用している型が並行な場面で使われることを意図したものであることを保証するトレイトの1つです。</p>
<!-- Unfortunately, `Rc<T>` is not safe to share across threads. When `Rc<T>` -->
<!-- manages the reference count, it adds to the count for each call to `clone` and -->
<!-- subtracts from the count when each clone is dropped. But it doesn’t use any -->
<!-- concurrency primitives to make sure that changes to the count can’t be -->
<!-- interrupted by another thread. This could lead to wrong counts—subtle bugs that -->
<!-- could in turn lead to memory leaks or a value being dropped before we’re done -->
<!-- with it. What we need is a type exactly like `Rc<T>` but one that makes changes -->
<!-- to the reference count in a thread-safe way. -->
<p>残念ながら、<code>Rc&lt;T&gt;</code>はスレッド間で共有するには安全ではないのです。<code>Rc&lt;T&gt;</code>が参照カウントを管理する際、
<code>clone</code>が呼び出されるたびにカウントを追加し、クローンがドロップされるたびにカウントを差し引きます。
しかし、非同期基本型を使用してカウントの変更が別のスレッドに妨害されないことを確認していないのです。
これは間違ったカウントにつながる可能性があり、今度はメモリリークや、使用し終わる前に値がドロップされることにつながる可能性のある潜在的なバグです。
必要なのは、全く<code>Rc&lt;T&gt;</code>のようだけれども、参照カウントへの変更をスレッドセーフに行うものです。</p>
<!-- #### Atomic Reference Counting with `Arc<T>` -->
<a class="header" href="print.html#arctで原子的な参照カウント" id="arctで原子的な参照カウント"><h4><code>Arc&lt;T&gt;</code>で原子的な参照カウント</h4></a>
<!-- Fortunately, `Arc<T>` *is* a type like `Rc<T>` that is safe to use in -->
<!-- concurrent situations. The *a* stands for *atomic*, meaning it’s an *atomically -->
<!-- reference counted* type. Atomics are an additional kind of concurrency -->
<!-- primitive that we won’t cover in detail here: see the standard library -->
<!-- documentation for `std::sync::atomic` for more details. At this point, you just -->
<!-- need to know that atomics work like primitive types but are safe to share -->
<!-- across threads. -->
<p>幸いなことに、<code>Arc&lt;T&gt;</code>は<code>Rc&lt;T&gt;</code>のような並行な状況で安全に使用できる型<em>です</em>。
<em>a</em>は<em>atomic</em>を表し、原子的に参照カウントする型を意味します。アトミックは、
ここでは詳しく講義しない非同期処理の別の基本型です: 詳細は、
<code>std::sync::atomic</code>の標準ライブラリドキュメンテーションを参照されたし。現時点では、
アトミックは、基本型のように動くけれども、スレッド間で共有しても安全なことだけ知っていればいいです。</p>
<!-- You might then wonder why all primitive types aren’t atomic and why standard -->
<!-- library types aren’t implemented to use `Arc<T>` by default. The reason is that -->
<!-- thread safety comes with a performance penalty that you only want to pay when -->
<!-- you really need to. If you’re just performing operations on values within a -->
<!-- single thread, your code can run faster if it doesn’t have to enforce the -->
<!-- guarantees atomics provide. -->
<p>そうしたら、なぜ全ての基本型がアトミックでなく、標準ライブラリの型も標準で<code>Arc&lt;T&gt;</code>を使って実装されていないのか疑問に思う可能性があります。
その理由は、本当に必要な時だけ支払いたいパフォーマンスの犠牲とともにスレッド安全性が得られるものだからです。
シングルスレッドで値に処理を施すだけなら、アトミックが提供する保証を強制する必要がなければコードはより速く走るのです。</p>
<!-- Let’s return to our example: `Arc<T>` and `Rc<T>` have the same API, so we fix -->
<!-- our program by changing the `use` line, the call to `new`, and the call to -->
<!-- `clone`. The code in Listing 16-15 will finally compile and run: -->
<p>例に回帰しましょう: <code>Arc&lt;T&gt;</code>と<code>Rc&lt;T&gt;</code>のAPIは同じなので、<code>use</code>行と<code>new</code>と<code>clone</code>の呼び出しを変更して、
プログラムを修正します。リスト16-15は、ようやくコンパイルでき、動作します:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<!-- <span class="caption">Listing 16-15: Using an `Arc<T>` to wrap the `Mutex<T>` -->
<!-- to be able to share ownership across multiple threads</span> -->
<p><span class="caption">リスト16-15: <code>Arc&lt;T&gt;</code>を使用して<code>Mutex&lt;T&gt;</code>をラップし、所有権を複数のスレッド間で共有できるようにする</span></p>
<!-- This code will print the following: -->
<p>このコードは、以下のように出力します:</p>
<pre><code class="language-text">Result: 10
</code></pre>
<!-- We did it! We counted from 0 to 10, which may not seem very impressive, but it -->
<!-- did teach us a lot about `Mutex<T>` and thread safety. You could also use this -->
<!-- program’s structure to do more complicated operations than just incrementing a -->
<!-- counter. Using this strategy, you can divide a calculation into independent -->
<!-- parts, split those parts across threads, and then use a `Mutex<T>` to have each -->
<!-- thread update the final result with its part. -->
<p>やりました！0から10まで数え上げました。これは、あまり印象的ではないように思えるかもしれませんが、
本当に<code>Mutex&lt;T&gt;</code>とスレッド安全性についていろんなことを教えてくれました。このプログラムの構造を使用して、
カウンタをインクリメントする以上の複雑な処理を行うこともできるでしょう。この手法を使えば、
計算を独立した部分に小分けにし、その部分をスレッドに分割し、それから<code>Mutex&lt;T&gt;</code>を使用して、
各スレッドに最終結果を更新させることができます。</p>
<!-- ### Similarities Between `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>` -->
<a class="header" href="print.html#refcelltrctとmutextarctの類似性" id="refcelltrctとmutextarctの類似性"><h3><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code>と<code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code>の類似性</h3></a>
<!-- You might have noticed that `counter` is immutable but we could get a mutable -->
<!-- reference to the value inside it; this means `Mutex<T>` provides interior -->
<!-- mutability, as the `Cell` family does. In the same way we used `RefCell<T>` in -->
<!-- Chapter 15 to allow us to mutate contents inside an `Rc<T>`, we use `Mutex<T>` -->
<!-- to mutate contents inside an `Arc<T>`. -->
<p><code>counter</code>は不変なのに、その内部にある値への可変参照を得ることができたことに気付いたでしょうか;
つまり、<code>Mutex&lt;T&gt;</code>は、<code>Cell</code>系のように内部可変性(interior mutability)を提供するわけです。
第15章で<code>RefCell&lt;T&gt;</code>を使用して<code>Rc&lt;T&gt;</code>の内容を可変化できるようにしたのと同様に、
<code>Mutex&lt;T&gt;</code>を使用して<code>Arc&lt;T&gt;</code>の内容を可変化しているのです。</p>
<!-- Another detail to note is that Rust can’t protect you from all kinds of logic -->
<!-- errors when you use `Mutex<T>`. Recall in Chapter 15 that using `Rc<T>` came -->
<!-- with the risk of creating reference cycles, where two `Rc<T>` values refer to -->
<!-- each other, causing memory leaks. Similarly, `Mutex<T>` comes with the risk of -->
<!-- creating *deadlocks*. These occur when an operation needs to lock two resources -->
<!-- and two threads have each acquired one of the locks, causing them to wait for -->
<!-- each other forever. If you’re interested in deadlocks, try creating a Rust -->
<!-- program that has a deadlock; then research deadlock mitigation strategies for -->
<!-- mutexes in any language and have a go at implementing them in Rust. The -->
<!-- standard library API documentation for `Mutex<T>` and `MutexGuard` offers -->
<!-- useful information. -->
<p>また、気付いておくべき別の詳細は、<code>Mutex&lt;T&gt;</code>を使用する際にあらゆる種類のロジックエラーからは、
コンパイラは保護してくれないということです。第15章で<code>Rc&lt;T&gt;</code>は、循環参照を生成してしまうリスクを伴い、
2つの<code>Rc&lt;T&gt;</code>の値がお互いを参照し合い、メモリリークを引き起こしてしまうことを思い出してください。
同様に、<code>Mutex&lt;T&gt;</code>は<em>デッドロック</em>を生成するリスクを伴っています。これは、処理が2つのリソースをロックする必要があり、
2つのスレッドがそれぞれにロックを1つ獲得して永久にお互いを待ちあってしまうときに起こります。
デッドロックに興味があるのなら、デッドロックのあるRustプログラムを組んでみてください;
それからどんな言語でもいいので、ミューテックスに対してデッドロックを緩和する方法を調べて、
Rustでそれを実装してみてください。<code>Mutex&lt;T&gt;</code>と<code>MutexGuard</code>に関する標準ライブラリのAPIドキュメンテーションは、
役に立つ情報を提供してくれます。</p>
<!-- We’ll round out this chapter by talking about the `Send` and `Sync` traits and -->
<!-- how we can use them with custom types. -->
<p><code>Send</code>と<code>Sync</code>トレイトと、それらを独自の型で使用する方法について語って、この章を締めくくります。</p>
<!-- ## Extensible Concurrency with the `Sync` and `Send` Traits -->
<a class="header" href="print.html#syncとsendトレイトで拡張可能な非同期" id="syncとsendトレイトで拡張可能な非同期"><h2><code>Sync</code>と<code>Send</code>トレイトで拡張可能な非同期</h2></a>
<!-- Interestingly, the Rust language has *very* few concurrency features. Almost -->
<!-- every concurrency feature we’ve talked about so far in this chapter has been -->
<!-- part of the standard library, not the language. Your options for handling -->
<!-- concurrency are not limited to the language or the standard library; you can -->
<!-- write your own concurrency features or use those written by others. -->
<p>面白いことに、Rust言語には、<em>寡</em>少な非同期機能があります。この章でここまでに語った非同期処理のほとんどは、
標準ライブラリの一部であり、言語ではありません。非同期を扱う選択肢は、言語や標準ライブラリに制限されません;
独自の非同期処理機能を書いたり、他人が書いたものを利用したりできるのです。</p>
<!-- However, two concurrency concepts are embedded in the language: the -->
<!-- `std::marker` traits `Sync` and `Send`. -->
<p>ですが、2つの非同期処理概念が言語に埋め込まれています: <code>std::marker</code>トレイトの<code>Sync</code>と<code>Send</code>です。</p>
<!-- ### Allowing Transference of Ownership Between Threads with `Send` -->
<a class="header" href="print.html#sendでスレッド間の所有権の転送を許可する" id="sendでスレッド間の所有権の転送を許可する"><h3><code>Send</code>でスレッド間の所有権の転送を許可する</h3></a>
<!-- 最後から2行目、single-threaded situationsのsituationsを環境と訳すのが自然なのでそうしている -->
<!-- The `Send` marker trait indicates that ownership of the type implementing -->
<!-- `Send` can be transferred between threads. Almost every Rust type is `Send`, -->
<!-- but there are some exceptions, including `Rc<T>`: this cannot be `Send` because -->
<!-- if you cloned an `Rc<T>` value and tried to transfer ownership of the clone to -->
<!-- another thread, both threads might update the reference count at the same time. -->
<!-- For this reason, `Rc<T>` is implemented for use in single-threaded situations -->
<!-- where you don’t want to pay the thread-safe performance penalty. -->
<p><code>Send</code>マーカートレイトは、<code>Send</code>を実装した型の所有権をスレッド間で転送できることを示唆します。
Rustのほとんどの型は<code>Send</code>ですが、<code>Rc&lt;T&gt;</code>を含めて一部例外があります: この型は、<code>Rc&lt;T&gt;</code>の値をクローンし、
クローンしたものの所有権を別のスレッドに転送しようとしたら、両方のスレッドが同時に参照カウントを更新できてしまうので、
<code>Send</code>になり得ません。このため、<code>Rc&lt;T&gt;</code>はスレッド安全性のためのパフォーマンスの犠牲を支払わなくても済む、
シングルスレッド環境で使用するために実装されているわけです。</p>
<!-- Therefore, Rust’s type system and trait bounds ensure that you can never -->
<!-- accidentally send an `Rc<T>` value across threads unsafely. When we tried to do -->
<!-- this in Listing 16-14, we got the error `the trait Send is not implemented for -->
<!-- Rc<Mutex<i32>>`. When we switched to `Arc<T>`, which is `Send`, the code -->
<!-- compiled. -->
<p>故に、Rustの型システムとトレイト境界により、<code>Rc&lt;T&gt;</code>の値を不安全にスレッド間で誤って送信することが絶対ないよう保証してくれるのです。
リスト16-14でこれを試みた時には、<code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>というエラーが出ました。
<code>Send</code>の<code>Arc&lt;T&gt;</code>に切り替えたら、コードはコンパイルできたわけです。</p>
<!-- Any type composed entirely of `Send` types is automatically marked as `Send` as -->
<!-- well. Almost all primitive types are `Send`, aside from raw pointers, which -->
<!-- we’ll discuss in Chapter 19. -->
<p>完全に<code>Send</code>の型からなる型も全て自動的に<code>Send</code>と印付けされます。生ポインタを除くほとんどの基本型も<code>Send</code>で、
生ポインタについては第19章で議論します。</p>
<!-- ### Allowing Access from Multiple Threads with `Sync` -->
<a class="header" href="print.html#syncで複数のスレッドからのアクセスを許可する" id="syncで複数のスレッドからのアクセスを許可する"><h3><code>Sync</code>で複数のスレッドからのアクセスを許可する</h3></a>
<!-- The `Sync` marker trait indicates that it is safe for the type implementing -->
<!-- `Sync` to be referenced from multiple threads. In other words, any type `T` is -->
<!-- `Sync` if `&T` (a reference to `T`) is `Send`, meaning the reference can be -->
<!-- sent safely to another thread. Similar to `Send`, primitive types are `Sync`, -->
<!-- and types composed entirely of types that are `Sync` are also `Sync`. -->
<p><code>Sync</code>マーカートレイトは、<code>Sync</code>を実装した型は、複数のスレッドから参照されても安全であることを示唆します。
言い換えると、<code>&amp;T</code>(<code>T</code>への参照)が<code>Send</code>なら、型<code>T</code>は<code>Sync</code>であり、参照が他のスレッドに安全に送信できることを意味します。
<code>Send</code>同様、基本型は<code>Sync</code>であり、<code>Sync</code>の型からのみ構成される型もまた<code>Sync</code>です。</p>
<!-- The smart pointer `Rc<T>` is also not `Sync` for the same reasons that it’s not -->
<!-- `Send`. The `RefCell<T>` type (which we talked about in Chapter 15) and the -->
<!-- family of related `Cell<T>` types are not `Sync`. The implementation of borrow -->
<!-- checking that `RefCell<T>` does at runtime is not thread-safe. The smart -->
<!-- pointer `Mutex<T>` is `Sync` and can be used to share access with multiple -->
<!-- threads as you saw in the “Sharing a `Mutex<T>` Between Multiple Threads” -->
<!-- section. -->
<p><code>Send</code>ではなかったのと同じ理由で、スマートポインタの<code>Rc&lt;T&gt;</code>もまた<code>Sync</code>ではありません。
<code>RefCell&lt;T&gt;</code>型(これについては第15章で話しました)と<code>Cell&lt;T&gt;</code>系についても<code>Sync</code>ではありません。
<code>RefCell&lt;T&gt;</code>が実行時に行う借用チェックの実装は、スレッド安全ではないのです。
スマートポインタの<code>Mutex&lt;T&gt;</code>は<code>Sync</code>で、「複数のスレッド間で<code>Mutex&lt;T&gt;</code>を共有する」節で見たように、
複数のスレッドでアクセスを共有するのに使用することができます。</p>
<!-- ### Implementing `Send` and `Sync` Manually Is Unsafe -->
<a class="header" href="print.html#sendとsyncを手動で実装するのは非安全である" id="sendとsyncを手動で実装するのは非安全である"><h3><code>Send</code>と<code>Sync</code>を手動で実装するのは非安全である</h3></a>
<!-- Because types that are made up of `Send` and `Sync` traits are automatically -->
<!-- also `Send` and `Sync`, we don’t have to implement those traits manually. As -->
<!-- marker traits, they don’t even have any methods to implement. They’re just -->
<!-- useful for enforcing invariants related to concurrency. -->
<p><code>Send</code>と<code>Sync</code>トレイトから構成される型は自動的に<code>Send</code>と<code>Sync</code>にもなるので、
それらのトレイトを手動で実装する必要はありません。マーカートレイトとして、
実装すべきメソッドさえも何もありません。非同期処理に関連する不変条件を強制することに有効なだけなのです。</p>
<!-- Manually implementing these traits involves implementing unsafe Rust code. -->
<!-- We’ll talk about using unsafe Rust code in Chapter 19; for now, the important -->
<!-- information is that building new concurrent types not made up of `Send` and -->
<!-- `Sync` parts requires careful thought to uphold the safety guarantees. -->
<!-- [The Rustonomicon] has more information about these guarantees and how to -->
<!-- uphold them. -->
<p>これらのトレイトを手動で実装すると、unsafeなRustコードを実装することが関わってきます。
unsafeなRustコードを使用することについては第19章で語ります; とりあえず、重要な情報は、
<code>Send</code>と<code>Sync</code>ではない部品からなる新しい並行な型を構成するには、安全性保証を保持するために、
注意深い思考が必要になるということです。<a href="https://doc.rust-lang.org/stable/nomicon/">The Rustonomicon</a>には、
これらの保証とそれを保持する方法についての情報がより多くあります。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-14" id="aまとめ-14"><h2>まとめ</h2></a>
<!-- This isn’t the last you’ll see of concurrency in this book: the project in -->
<!-- Chapter 20 will use the concepts in this chapter in a more realistic situation -->
<!-- than the smaller examples discussed here. -->
<p>この本において非同期処理を見かけるのは、これで最後ではありません: 第20章のプロジェクトでは、
この章の概念をここで議論した微小な例よりもより現実的な場面で使用するでしょう。</p>
<!-- 最後はmutithreaded situationsとなっているが、situationを環境と訳した方が自然なので、そうしている -->
<!-- As mentioned earlier, because very little of how Rust handles concurrency is -->
<!-- part of the language, many concurrency solutions are implemented as crates. -->
<!-- These evolve more quickly than the standard library, so be sure to search -->
<!-- online for the current, state-of-the-art crates to use in multithreaded -->
<!-- situations. -->
<p>前述のように、Rustが非同期処理を扱うごく一部が言語の一部なので、多くの非同期処理解決策は、
クレートとして実装されています。これらは標準ライブラリよりも迅速に進化するので、
確実にオンラインでマルチスレッド環境で使用する現在の最先端のクレートを検索してください。</p>
<!-- The Rust standard library provides channels for message passing and smart -->
<!-- pointer types, such as `Mutex<T>` and `Arc<T>`, that are safe to use in -->
<!-- concurrent contexts. The type system and the borrow checker ensure that the -->
<!-- code using these solutions won’t end up with data races or invalid references. -->
<!-- Once you get our code to compile, you can rest assured that it will happily -->
<!-- run on multiple threads without the kinds of hard-to-track-down bugs common in -->
<!-- other languages. Concurrent programming is no longer a concept to be afraid of: -->
<!-- go forth and make your programs concurrent, fearlessly! -->
<p>Rustの標準ライブラリは、メッセージ受け渡しにチャンネルを、並行の文脈で安全に使用できる、
<code>Mutex&lt;T&gt;</code>や<code>Arc&lt;T&gt;</code>などのスマートポインタ型を提供しています。型システムと借用精査機により、
これらの解決策を使用するコードがデータ競合や無効な参照に行き着かないことを保証してくれます。
一旦コードをコンパイルすることができたら、他の言語ではありふれている追跡困難なバグなしに、
複数のスレッドでも喜んで動くので安心できます。並行プログラミングは、もはや恐れるべき概念ではありません:
進んでプログラムを並行にして恐れないでください！</p>
<!-- Next, we’ll talk about idiomatic ways to model problems and structure solutions -->
<!-- as your Rust programs get bigger. In addition, we’ll discuss how Rust’s idioms -->
<!-- relate to those you might be familiar with from object oriented programming. -->
<p>次は、Rustプログラムが肥大化するにつれて問題をモデル化し、解決策を構造化する慣例的な方法について話します。
さらに、Rustのイディオムがオブジェクト指向プログラミングで馴染み深いかもしれないイディオムに関連する方法についても議論します。</p>
<!-- # Object-Oriented Programming Features of Rust -->
<a class="header" href="print.html#rustのオブジェクト指向プログラミング機能" id="rustのオブジェクト指向プログラミング機能"><h1>Rustのオブジェクト指向プログラミング機能</h1></a>
<!-- Object-oriented programming (OOP) is a way of modeling programs. Objects came -->
<!-- from Simula in the 1960s. Those objects influenced Alan Kay’s programming -->
<!-- architecture in which objects pass messages to each other. He coined the term -->
<!-- *object-oriented programming* in 1967 to describe this architecture. Many -->
<!-- competing definitions describe what OOP is; some definitions would classify -->
<!-- Rust as object oriented, but other definitions would not. In this chapter, -->
<!-- we'll explore certain characteristics that are commonly considered object -->
<!-- oriented and how those characteristics translate to idiomatic Rust. We’ll then -->
<!-- show you how to implement an object-oriented design pattern in Rust and discuss -->
<!-- the trade-offs of doing so versus implementing a solution using some of Rust’s -->
<!-- strengths instead. -->
<p>オブジェクト指向プログラミング(OOP)は、プログラムをモデル化する手段です。オブジェクトは、
1960年代のSimulaで導入されました。このオブジェクトは、
お互いにメッセージを渡し合うというアラン・ケイ(Alan Kay)のプログラミングアーキテクチャに影響を及ぼしました。
彼は、このアーキテクチャを解説するために、<em>オブジェクト指向プログラミング</em>という用語を造語しました。
多くの競合する定義がOOPが何かを解説しています; Rustをオブジェクト指向と区分する定義もありますし、
しない定義もあります。この章では、広くオブジェクト指向と捉えられる特定の特徴と、
それらの特徴がこなれたRustでどう表現されるかを探求します。それからオブジェクト指向のデザインパターンをRustで実装する方法を示し、
そうすることとRustの強みを活用して代わりの解決策を実装する方法の代償を議論します。</p>
<!-- ## Characteristics of Object-Oriented Languages -->
<a class="header" href="print.html#aオブジェクト指向言語の特徴" id="aオブジェクト指向言語の特徴"><h2>オブジェクト指向言語の特徴</h2></a>
<!-- There is no consensus in the programming community about what features a -->
<!-- language must have to be considered object oriented. Rust is influenced by many -->
<!-- programming paradigms, including OOP; for example, we explored the features -->
<!-- that came from functional programming in Chapter 13. Arguably, OOP languages -->
<!-- share certain common characteristics, namely objects, encapsulation, and -->
<!-- inheritance. Let’s look at what each of those characteristics mean and whether -->
<!-- Rust supports them. -->
<p>言語がオブジェクト指向と考えられるのになければならない機能について、プログラミングコミュニティ内での総意はありません。
RustはOOPを含めた多くのプログラミングパラダイムに影響を受けています; 例えば、
第13章で関数型プログラミングに由来する機能を探求しました。議論はあるかもしれないが、
OOP言語は特定の一般的な特徴を共有しています。具体的には、オブジェクトやカプセル化、
継承などです。それらの個々の特徴が意味するものとRustがサポートしているかを見ましょう。</p>
<!-- ### Objects Contain Data and Behavior -->
<a class="header" href="print.html#aオブジェクトはデータと振る舞いを含む" id="aオブジェクトはデータと振る舞いを含む"><h3>オブジェクトは、データと振る舞いを含む</h3></a>
<!-- The book *Design Patterns: Elements of Reusable Object-Oriented Software* by -->
<!-- Enoch Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wasley -->
<!-- Professional, 1994) colloquially referred to as *The Gang of Four book*, is a -->
<!-- catlog of object-oriented design patterns. It defines OOP this way: -->
<p>エーリヒ・ガンマ(Enoch Gamma)、リチャード・ヘルム(Richard Helm)、ラルフ・ジョンソン(Ralph Johnson)、
ジョン・ブリシディース(John Vlissides)(アディソン・ワズリー・プロ)により、
1994に書かれた<em>デザインパターン: 再利用可能なオブジェクト指向ソフトウェアの要素</em>という本は、
俗に<em>4人のギャングの本</em>(<code>訳注</code>: the Gang of Four book; GoFとよく略される)と呼ばれ、オブジェクト指向デザインパターンのカタログです。
そこでは、OOPは以下のように定義されています:</p>
<!-- > Object-oriented programs are made up of objects. An *object* packages both -->
<!-- > data and the procedures that operate on that data. The procedures are -->
<!-- > typically called *methods* or *operations*. -->
<blockquote>
<p>オブジェクト指向プログラムは、オブジェクトで構成される。オブジェクトは、
データとそのデータを処理するプロシージャを梱包している。このプロシージャは、
典型的に<em>メソッド</em>または<em>オペレーション</em>と呼ばれる。</p>
</blockquote>
<!-- Using this definition, Rust is object oriented: structs and enums have data, -->
<!-- and `impl` blocks provide methods on structs and enums. Even though structs and -->
<!-- enums with methods aren’t *called* objects, they provide the same -->
<!-- functionality, according to the Gang of Four’s definition of objects. -->
<p>この定義を使用すれば、Rustはオブジェクト指向です: 構造体とenumにはデータがありますし、
<code>impl</code>ブロックが構造体とenumにメソッドを提供します。メソッドのある構造体とenumは、
オブジェクトとは呼ばれないものの、GoFのオブジェクト定義によると、同じ機能を提供します。</p>
<!-- ### Encapsulation that Hides Implementation Details -->
<a class="header" href="print.html#aカプセル化は実装詳細を隠蔽する" id="aカプセル化は実装詳細を隠蔽する"><h3>カプセル化は、実装詳細を隠蔽する</h3></a>
<!-- Another aspect commonly associated with OOP is the idea of *encapsulation*, -->
<!-- which means that the implementation details of an object aren’t accessible to -->
<!-- code using that object. Therefore, the only way to interact with an object is -->
<!-- through its public API; code using the object shouldn’t be able to reach into -->
<!-- the object’s internals and change data or behavior directly. This enables the -->
<!-- programmer to change and refactor an object’s internals without needing to -->
<!-- change the code that uses the object. -->
<p>OOPとよく紐づけられる別の側面は、カプセル化の思想です。これは、オブジェクトの実装詳細は、
そのオブジェクトを使用するコードにはアクセスできないことを意味します。故に、
オブジェクトと相互作用する唯一の手段は、その公開APIを通してです; オブジェクトを使用するコードは、
オブジェクトの内部に到達して、データや振る舞いを直接変更できるべきではありません。
このために、プログラマはオブジェクトの内部をオブジェクトを使用するコードを変更する必要なく、
変更しリファクタリングできます。</p>
<!-- We discussed how to control encapsulation in Chapter 7: we can use the `pub` -->
<!-- keyword to decide which modules, types, functions, and methods in our code -->
<!-- should be public, and by default everything else is private. For example, we -->
<!-- can define a struct `AveragedCollection` that has a field containing a vector -->
<!-- of `i32` values. The struct can also have a field that contains the average of -->
<!-- the values in the vector, meaning the average doesn’t have to be computed -->
<!-- on demand whenever anyone needs it. In other words, `AveragedCollection` will -->
<!-- cache the calculated average for us. Listing 17-1 has the definition of the -->
<!-- `AveragedCollection` struct: -->
<p>カプセル化を制御する方法は、第7章で議論しました: <code>pub</code>キーワードを使用して、
自分のコードのどのモジュールや型、関数、メソッドを公開するか決められ、
規定ではそれ以外のものは全て非公開になります。例えば、
<code>i32</code>値のベクタを含むフィールドのある<code>AveragedCollection</code>という構造体を定義できます。
この構造体はさらに、ベクタの値の平均を含むフィールドを持てます。つまり、平均は誰かが必要とする度に、
オンデマンドで計算する必要はないということです。言い換えれば、<code>AveragedCollection</code>は、
計算した平均をキャッシュしてくれるわけです。リスト17-1には、<code>AveragedCollection</code>構造体の定義があります:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-1: An `AveragedCollection` struct that -->
<!-- maintains a list of integers and the average of the items in the -->
<!-- collection</span> -->
<p><span class="caption">リスト17-1: 整数のリストとコレクションの要素の平均を管理する<code>AveragedCollection</code>構造体</span></p>
<!-- The struct is marked `pub` so that other code can use it, but the fields within -->
<!-- the struct remain private. This is important in this case because we want to -->
<!-- ensure that whenever a value is added or removed from the list, the average is -->
<!-- also updated. We do this by implementing `add`, `remove`, and `average` methods -->
<!-- on the struct, as shown in Listing 17-2: -->
<p>構造体は、他のコードが使用できるように<code>pub</code>で印づけされていますが、構造体のフィールドは非公開のままです。
値が追加されたりリストから削除される度に、平均も更新されることを保証したいので、今回の場合重要です。
<code>add</code>や<code>remove</code>、<code>average</code>メソッドを構造体に実装することでこれをします。リスト17-2のようにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct AveragedCollection {
#     list: Vec&lt;i32&gt;,
#     average: f64,
# }
impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-2: Implementations of the public methods -->
<!-- `add`, `remove`, and `average` on `AveragedCollection`</span> -->
<p><span class="caption">リスト17-2: <code>AveragedCollection</code>の<code>add</code>、<code>remove</code>、<code>average</code>公開メソッドの実装</span></p>
<!-- The public methods `add`, `remove`, and `average` are the only ways to modify -->
<!-- an instance of `AveragedCollection`. When an item is added to `list` using the -->
<!-- `add` method or removed using the `remove` method, the implementations of each -->
<!-- call the private `update_average` method that handles updating the `average` -->
<!-- field as well. -->
<p><code>add</code>、<code>remove</code>、<code>average</code>の公開メソッドが<code>AveragedCollection</code>のインスタンスを変更する唯一の方法になります。
要素が<code>add</code>メソッドを使用して<code>list</code>に追加されたり、<code>remove</code>メソッドを使用して削除されたりすると、
各メソッドの実装が<code>average</code>フィールドの更新を扱う非公開の<code>update_average</code>メソッドも呼び出します。</p>
<!-- We leave the `list` and `average` fields private so there is no way for -->
<!-- external code to add or remove items to the `list` field directly; otherwise, -->
<!-- the `average` field might become out of sync when the `list` changes. The -->
<!-- `average` method returns the value in the `average` field, allowing external -->
<!-- code to read the `average` but not modify it. -->
<p><code>list</code>と<code>average</code>フィールドを非公開のままにしているので、外部コードが要素を<code>list</code>フィールドに直接追加したり削除したりする方法はありません;
そうでなければ、<code>average</code>フィールドは、<code>list</code>が変更された時に同期されなくなる可能性があります。
<code>average</code>メソッドは<code>average</code>フィールドの値を返し、外部コードに<code>average</code>を読ませるものの、
変更は許可しません。</p>
<!-- Because we’ve encapsulated the implementation details of the struct -->
<!-- `AveragedCollection`, we can easily change aspects, such as the data structure, -->
<!-- in the future. For instance, we could use a `HashSet<i32>` instead of a -->
<!-- `Vec<i32>` for the `list` field. As long as the signatures of the `add` -->
<!-- `remove`, and `average` public methods stay the same, code using -->
<!-- `AveragedCollection` wouldn’t need to change. If we made `list` public instead, -->
<!-- this wouldn’t necessarily be the case: `HashSet<i32>` and `Vec<i32>` have -->
<!-- different methods for adding and removing items, so the external code would -->
<!-- likely have to change if it were modifying `list` directly. -->
<p>構造体<code>AveragedCollection</code>の実装詳細をカプセル化したので、データ構造などの側面を将来容易に変更することができます。
例を挙げれば、<code>list</code>フィールドに<code>Vec&lt;i32&gt;</code>ではなく<code>HashSet&lt;i32&gt;</code>を使うこともできます。
<code>add</code>、<code>remove</code>、<code>average</code>公開メソッドのシグニチャが同じである限り、<code>AveragedCollection</code>を使用するコードは変更する必要がないでしょう。
代わりに<code>list</code>を公開にしたら、必ずしもこうはならないでしょう: <code>HashSet&lt;i32&gt;</code>と<code>Vec&lt;i32&gt;</code>は、
要素の追加と削除に異なるメソッドを持っているので、外部コードが直接<code>list</code>を変更しているなら、
外部コードも変更しなければならない可能性が高いでしょう。</p>
<!-- If encapsulation is a required aspect for a language to be considered object -->
<!-- oriented, then Rust meets that requirement. The option to use `pub` or not for -->
<!-- different parts of code enables encapsulation of implementation details. -->
<p>カプセル化が、言語がオブジェクト指向と考えられるのに必要な側面ならば、Rustはその条件を満たしています。
コードの異なる部分で<code>pub</code>を使用するかしないかという選択肢のおかげで、実装詳細をカプセル化することが可能になります。</p>
<!-- ### Inheritance as a Type System and as Code Sharing -->
<a class="header" href="print.html#a型システムおよびコード共有としての継承" id="a型システムおよびコード共有としての継承"><h3>型システム、およびコード共有としての継承</h3></a>
<!-- *Inheritance* is a mechanism whereby an object can inherit from another -->
<!-- object’s definition, thus gaining the parent object’s data and behavior without -->
<!-- you having to define them again. -->
<p><em>継承</em>は、それによってオブジェクトが他のオブジェクトの定義から受け継ぐことができる機構であり、
それ故に、再定義する必要なく、親オブジェクトのデータと振る舞いを得ます。</p>
<!-- If a language must have inheritance to be an object-oriented language, then -->
<!-- Rust is not one. There is no way to define a struct that inherits the parent -->
<!-- struct’s fields and method implementations. However, if you’re used to having -->
<!-- inheritance in your programming toolbox, you can use other solutions in Rust, -->
<!-- depending on your reason for reaching for inheritance in the first place. -->
<p>言語がオブジェクト指向言語であるために継承がなければならないのならば、Rustは違います。
親構造体のフィールドとメソッドの実装を受け継ぐ構造体を定義する方法はありません。しかしながら、
継承がプログラミング道具箱にあることに慣れていれば、そもそも継承に手を伸ばす理由によって、
Rustで他の解決策を使用することができます。</p>
<!-- You choose inheritance for two main reasons. One is for reuse of code: you can -->
<!-- implement particular behavior for one type, and inheritance enables you to -->
<!-- reuse that implementation for a different type. You can share Rust code using -->
<!-- default trait method implementations instead, which you saw in Listing 10-14 -->
<!-- when we added a default implementation of the `summarize` method on the -->
<!-- `Summary` trait. Any type implementing the `Summary` trait would have the -->
<!-- `summarize` method available on it without any further code. This is similar to -->
<!-- a parent class having an implementation of a method and an inheriting child -->
<!-- class also having the implementation of the method. We can also override the -->
<!-- default implementation of the `summarize` method when we implement the -->
<!-- `Summary` trait, which is similar to a child class overriding the -->
<!-- implementation of a method inherited from a parent class. -->
<p>継承を選択する理由は2つあります。1つ目は、コードの再利用です: ある型に特定の振る舞いを実装し、
継承により、その実装を他の型にも再利用できるわけです。デフォルトのトレイトメソッド実装を代わりに使用して、
Rustコードを共有でき、これは、リスト10-14で<code>Summary</code>トレイトに<code>summarize</code>メソッドのデフォルト実装を追加した時に見かけました。
<code>Summary</code>トレイトを実装する型は全て、追加のコードなく<code>summarize</code>メソッドが使用できます。
これは、親クラスにメソッドの実装があり、継承した子クラスにもそのメソッドの実装があることと似ています。
また、<code>Summary</code>トレイトを実装する時に、<code>summarize</code>メソッドのデフォルト実装を上書きすることもでき、
これは、親クラスから継承したメソッドの実装を子クラスが上書きすることに似ています。</p>
<!-- The other reason to use inheritance relates to the type system: to enable a -->
<!-- child type to be used in the same places as the parent type. This is also -->
<!-- called *polymorphism*, which means that you can substitute multiple objects for -->
<!-- each other at runtime if they share certain characteristics. -->
<p>継承を使用するもう1つの理由は、型システムに関連しています: 親の型と同じ箇所で子供の型を使用できるようにです。
これは、<em>多相性</em>(polymorphism)とも呼ばれ、複数のオブジェクトが特定の特徴を共有しているなら、
実行時にお互いに代用できることを意味します。</p>
<!-- > ### Polymorphism -->
<!-- > -->
<!-- > To many people, polymorphism is synonymous with inheritance. But it’s -->
<!-- > actually a more general concept that refers to code that can work with data -->
<!-- > of multiple types. For inheritance, those types are generally subclasses. -->
<!-- > -->
<!-- > Rust instead uses generics to abstract over different possible types and -->
<!-- > trait bounds to impose constraints on what those types must provide. This is -->
<!-- > sometimes called *bounded parametric polymorphism*. -->
<blockquote>
<a class="header" href="print.html#a多相性" id="a多相性"><h3>多相性</h3></a>
<p>多くの人にとって、多相性は、継承の同義語です。ですが、実際には複数の型のデータを取り扱えるコードを指すより一般的な概念です。
継承について言えば、それらの型は一般的にはサブクラスです。</p>
<p>Rustは代わりにジェネリクスを使用して様々な可能性のある型を抽象化し、トレイト境界を使用してそれらの型が提供するものに制約を課します。
これは時に、<em>パラメータ境界多相性</em>(bounded parametric polymorphism)と呼ばれます。</p>
</blockquote>
<!-- Inheritance has recently fallen out of favor as a programming design solution -->
<!-- in many programming languages because it’s often at risk of sharing more code -->
<!-- than necessary. Subclasses shouldn’t always share all characteristics of their -->
<!-- parent class but will do so with inheritance. This can make a program’s design -->
<!-- less flexible. It also introduces the possibility of calling methods on -->
<!-- subclasses that don’t make sense or that cause errors because the methods don’t -->
<!-- apply to the subclass. Some languages will also only allow a subclass -->
<!-- to inherit from one class, further restricting the flexibility of a program’s -->
<!-- design. -->
<p>継承は、最近、多くのプログラミング言語において、プログラムの設計解決策としては軽んじられています。
というのも、しばしば必要以上にコードを共有してしまう危険性があるからです。サブクラスは、
必ずしも親クラスの特徴を全て共有するべきではないのに、継承ではそうなってしまうのです。
これにより、プログラムの設計の柔軟性がなくなります。また道理に合わなかったり、メソッドがサブクラスには適用されないために、
エラーを発生させるサブクラスのメソッドの呼び出しを引き起こす可能性が出てくるのです。
さらに、サブクラスに1つのクラスからだけ継承させる言語もあり、さらにプログラムの設計の柔軟性が制限されます。</p>
<!-- For these reasons, Rust takes a different approach, using trait objects instead -->
<!-- of inheritance. Let’s look at how trait objects enable polymorphism in Rust. -->
<p>これらの理由により、継承ではなくトレイトオブジェクトを使用してRustは異なるアプローチを取っています。
Rustにおいて、トレイトオブジェクトがどう多相性を可能にするかを見ましょう。</p>
<!-- ## Using Trait Objects that Allow for Values of Different Types -->
<a class="header" href="print.html#aトレイトオブジェクトで異なる型の値を許可する" id="aトレイトオブジェクトで異なる型の値を許可する"><h2>トレイトオブジェクトで異なる型の値を許可する</h2></a>
<!-- In Chapter 8, we mentioned that one limitation of vectors is that they can -->
<!-- store elements of only one type. We created a workaround in Listing 8-10 where -->
<!-- we defined a `SpreadsheetCell` enum that had variants to hold integers, floats, -->
<!-- and text. This meant we could store different types of data in each cell and -->
<!-- still have a vector that represented a row of cells. This is a perfectly good -->
<!-- solution when our interchangeable items are a fixed set of types that we know -->
<!-- when our code is compiled. -->
<p>第8章で、ベクタの1つの制限は、たった1つの型の要素を保持することしかできないことだと述べました。
リスト8-10で整数、浮動小数点数、テキストを保持する列挙子のある<code>SpreadsheetCell</code> enumを定義して、
これを回避しました。つまり、各セルに異なる型のデータを格納しつつ、1行のセルを表すベクタを保持するということです。
コンパイル時にわかるある固定されたセットの型にしか取り替え可能な要素がならない場合には、
完璧な解決策です。</p>
<!-- However, sometimes we want our library user to be able to extend the set of -->
<!-- types that are valid in a particular situation. To show how we might achieve -->
<!-- this, we’ll create an example graphical user interface (GUI) tool that iterates -->
<!-- through a list of items, calling a `draw` method on each one to draw it to the -->
<!-- screen—a common technique for GUI tools. We’ll create a library crate called -->
<!-- `gui` that contains the structure of a GUI library. This crate might include -->
<!-- some types for people to use, such as `Button` or `TextField`. In addition, -->
<!-- `gui` users will want to create their own types that can be drawn: for -->
<!-- instance, one programmer might add an `Image` and another might add a -->
<!-- `SelectBox`. -->
<p>ところが、時として、ライブラリの使用者が特定の場面で有効になる型のセットを拡張できるようにしたくなることがあります。
これをどう実現する可能性があるか示すために、各アイテムに<code>draw</code>メソッドを呼び出してスクリーンに描画するという、
GUIツールで一般的なテクニックをしてあるリストの要素を走査する例のGUIツールを作ります。
GUIライブラリの構造を含む<code>gui</code>と呼ばれるライブラリクレートを作成します。
このクレートには、他人が使用できる<code>Button</code>や<code>TextField</code>などの型が包含される可能性があります。
さらに、<code>gui</code>の使用者は、描画可能な独自の型を作成したくなるでしょう: 例えば、
ある人は<code>Image</code>を追加し、別の人は<code>SelectBox</code>を追加する可能性があります。</p>
<!-- We won’t implement a fully fledged GUI library for this example but will show -->
<!-- how the pieces would fit together. At the time of writing the library, we can’t -->
<!-- know and define all the types other programmers might want to create. But we do -->
<!-- know that `gui` needs to keep track of many values of different types, and it -->
<!-- needs to call a `draw` method on each of these differently typed values. It -->
<!-- doesn’t need to know exactly what will happen when we call the `draw` method, -->
<!-- just that the value will have that method available for us to call. -->
<p>この例のために本格的なGUIライブラリは実装するつもりはありませんが、部品がどう組み合わさるかは示します。
ライブラリの記述時点では、他のプログラマが作成したくなる可能性のある型全てを知る由も、定義することもできません。
しかし、<code>gui</code>は異なる型の多くの値を追いかけ、この異なる型の値に対して<code>draw</code>メソッドを呼び出す必要があることは、
確かにわかっています。<code>draw</code>メソッドを呼び出した時に正確に何が起きるかを知っている必要はありません。
値にそのメソッドが呼び出せるようあることだけわかっていればいいのです。</p>
<!-- To do this in a language with inheritance, we might define a class named -->
<!-- `Component` that has a method named `draw` on it. The other classes, such as -->
<!-- `Button`, `Image`, and `SelectBox`, would inherit from `Component` and thus -->
<!-- inherit the `draw` method. They could each override the `draw` method to define -->
<!-- their custom behavior, but the framework could treat all of the types as if -->
<!-- they were `Component` instances and call `draw` on them. But because Rust -->
<!-- doesn’t have inheritance, we need another way to structure the `gui` library to -->
<!-- allow users to extend it with new types. -->
<p>継承のある言語でこれを行うには、<code>draw</code>という名前のメソッドがある<code>Component</code>というクラスを定義する可能性があります。
<code>Button</code>、<code>Image</code>、<code>SelectBox</code>などの他のクラスは、<code>Component</code>を継承し、故に<code>draw</code>メソッドを継承します。
個々に<code>draw</code>メソッドをオーバーライドして、独自の振る舞いを定義するものの、フレームワークは、
<code>Component</code>インスタンスであるかのようにその型全部を扱い、この型に対して<code>draw</code>を呼び出します。
ですが、Rustに継承は存在しないので、使用者に新しい型で拡張してもらうために<code>gui</code>ライブラリを構成する他の方法が必要です。</p>
<!-- ### Defining a Trait for Common Behavior -->
<a class="header" href="print.html#a一般的な振る舞いにトレイトを定義する" id="a一般的な振る舞いにトレイトを定義する"><h3>一般的な振る舞いにトレイトを定義する</h3></a>
<!-- To implement the behavior we want `gui` to have, we’ll define a trait named -->
<!-- `Draw` that will have one method named `draw`. Then we can define a vector that -->
<!-- takes a *trait object*. A trait object points to an instance of a type that -->
<!-- implements the trait we specify. We create a trait object by specifying some -->
<!-- sort of pointer, such as a `&` reference or a `Box<T>` smart pointer, and then -->
<!-- specifying the relevant trait. (we’ll talk about the reason trait objects must -->
<!-- use a pointer in Chapter 19 in the section “Dynamically Sized Types & Sized”.) -->
<!-- We can use trait objects in place of a generic or concrete type. Wherever we -->
<!-- use a trait object, Rust’s type system will ensure at compile time that any -->
<!-- value used in that context will implement the trait object’s trait. -->
<!-- Consequently, we don’t need to know all the possible types at compile time. -->
<p><code>gui</code>に欲しい振る舞いを実装するには、<code>draw</code>という1つのメソッドを持つ<code>Draw</code>というトレイトを定義します。
それから<em>トレイトオブジェクト</em>を取るベクタを定義できます。トレイトオブジェクトは、
指定したトレイトを実装するある型のインスタンスを指します。<code>&amp;</code>参照や<code>Box&lt;T&gt;</code>スマートポインタなどの、
何らかのポインタを指定し、それから関係のあるトレイトを指定する(トレイトオブジェクトがポインタを使用しなければならない理由については、
第19章の「動的サイズ型とSized」節で語ります)ことでトレイトオブジェクトを作成します。
ジェネリックまたは具体的な型があるところにトレイトオブジェクトは使用できます。どこでトレイトオブジェクトを使用しようと、
Rustの型システムは、コンパイル時にその文脈で使用されているあらゆる値がそのトレイトオブジェクトのトレイトを実装していることを保証します。
結果的にコンパイル時に可能性のある型を全て知る必要はなくなるのです。</p>
<!-- We’ve mentioned that in Rust, we refrain from calling structs and enums -->
<!-- “objects” to distinguish them from other languages’ objects. In a struct or -->
<!-- enum, the data in the struct fields and the behavior in `impl` blocks are -->
<!-- separated, whereas in other languages, the data and behavior combined into one -->
<!-- concept is often labeled an object. However, trait objects *are* more like -->
<!-- objects in other languages in the sense that they combine data and behavior. -->
<!-- But trait objects differ from traditional objects in that we can’t add data to -->
<!-- a trait object. Trait objects aren’t as generally useful as objects in other -->
<!-- languages: their specific purpose is to allow abstraction across common -->
<!-- behavior. -->
<p>Rustでは、構造体とenumを他の言語のオブジェクトと区別するために「オブジェクト」と呼ぶことを避けていることに触れましたね。
構造体やenumにおいて、構造体のフィールドのデータや<code>impl</code>ブロックの振る舞いは区分けされているものの、
他の言語では1つの概念に押し込められるデータと振る舞いにはしばしばオブジェクトと分類されます。
しかしながら、トレイトオブジェクトは、データと振る舞いをごちゃ混ぜにするという観点で他の言語のオブジェクトに近い<em>です</em>。
しかし、トレイトオブジェクトは、データを追加できないという点で伝統的なオブジェクトと異なっています。
トレイトオブジェクトは、他の言語のオブジェクトほど一般的に有用ではありません:
その目的は、共通の振る舞いに対して抽象化を行うことです。</p>
<!-- Listing 17-3 shows how to define a trait named `Draw` with one method named -->
<!-- `draw`: -->
<p>リスト17-3は、<code>draw</code>という1つのメソッドを持つ<code>Draw</code>というトレイトを定義する方法を示しています:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Draw {
    fn draw(&amp;self);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-3: Definition of the `Draw` trait</span> -->
<p><span class="caption">リスト17-3: <code>Draw</code>トレイトの定義</span></p>
<!-- This syntax should look familiar from our discussions on how to define traits -->
<!-- in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named -->
<!-- `Screen` that holds a vector named `components`. This vector is of type -->
<!-- `Box<Draw>`, which is a trait object; it’s a stand-in for any type inside a -->
<!-- `Box` that implements the `Draw` trait. -->
<p>この記法は、第10章のトレイトの定義方法に関する議論で馴染み深いはずです。その次は、新しい記法です:
リスト17-4では、<code>components</code>というベクタを保持する<code>Screen</code>という名前の構造体を定義しています。
このベクタの型は<code>Box&lt;Draw&gt;</code>で、これはトレイトオブジェクトです; <code>Draw</code>トレイトを実装する<code>Box</code>内部の任意の型に対する代役です。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen {
    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-4: Definition of the `Screen` struct with a -->
<!-- `components` field holding a vector of trait objects that implement the `Draw` -->
<!-- trait</span> -->
<p><span class="caption">リスト17-4: <code>Draw</code>トレイトを実装するトレイトオブジェクトのベクタを保持する<code>components</code>フィールドがある
<code>Screen</code>構造体の定義</span></p>
<!-- On the `Screen` struct, we’ll define a method named `run` that will call the -->
<!-- `draw` method on each of its `components`, as shown in Listing 17-5: -->
<p><code>Screen</code>構造体に、<code>components</code>の各要素に対して<code>draw</code>メソッドを呼び出す<code>run</code>というメソッドを定義します。
リスト17-5のようにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
# pub struct Screen {
#     pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
# }
#
impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-5: A `run` method on `Screen` that calls the -->
<!-- `draw` method on each component</span> -->
<p><span class="caption">リスト17-5: 各コンポーネントに対して<code>draw</code>メソッドを呼び出す<code>Screen</code>の<code>run</code>メソッド</span></p>
<!-- This works differently than defining a struct that uses a generic type -->
<!-- parameter with trait bounds. A generic type parameter can only be substituted -->
<!-- with one concrete type at a time, whereas trait objects allow for multiple -->
<!-- concrete types to fill in for the trait object at runtime. For example, we -->
<!-- could have defined the `Screen` struct using a generic type and a trait bound -->
<!-- as in Listing 17-6: -->
<p>これは、トレイト境界を含むジェネリックな型引数を使用する構造体を定義するのとは異なる動作をします。
ジェネリックな型引数は、一度に1つの具体型にしか置き換えられないのに対して、トレイトオブジェクトは、
実行時にトレイトオブジェクトに対して複数の具体型で埋めることができます。例として、
ジェネリックな型とトレイト境界を使用してリスト17-6のように<code>Screen</code>構造体を定義することもできました:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-6: An alternate implementation of the `Screen` -->
<!-- struct and its `run` method using generics and trait bounds</span> -->
<p><span class="caption">リスト17-6: ジェネリクスとトレイト境界を使用した<code>Screen</code>構造体と<code>run</code>メソッドの対立的な実装</span></p>
<!-- This restricts us to a `Screen` instance that has a list of components all of -->
<!-- type `Button` or all of type `TextField`. If you’ll only ever have homogeneous -->
<!-- collections, using generics and trait bounds is preferable because the -->
<!-- definitions will be monomorphized at compile time to use the concrete types. -->
<p>こうすると、全てのコンポーネントの型が<code>Button</code>だったり、<code>TextField</code>だったりする<code>Screen</code>のインスタンスに制限されてしまいます。
同種のコレクションしか持つ予定がないのなら、ジェネリクスとトレイト境界は、
定義がコンパイル時に具体的な型を使用するように単相化されるので、望ましいです。</p>
<!-- On the other hand, with the method using trait objects, one `Screen` instance -->
<!-- can hold a `Vec<T>` that contains a `Box<Button>` as well as a -->
<!-- `Box<TextField>`. Let’s look at how this works, and then we’ll talk about the -->
<!-- runtime performance implications. -->
<p>一方で、メソッドがトレイトオブジェクトを使用すると、1つの<code>Screen</code>インスタンスが、
<code>Box&lt;Button&gt;</code>と<code>Box&lt;TextField&gt;</code>を含む<code>Vec&lt;T&gt;</code>を保持できます。
この動作方法を見、それから実行時性能の裏の意味について語りましょう。</p>
<!-- ### Implementing the Trait -->
<a class="header" href="print.html#aトレイトを実装する" id="aトレイトを実装する"><h3>トレイトを実装する</h3></a>
<!-- Now we’ll add some types that implement the `Draw` trait. We’ll provide the -->
<!-- `Button` type. Again, actually implementing a GUI library is beyond the scope -->
<!-- of this book, so the `draw` method won’t have any useful implementation in its -->
<!-- body. To imagine what the implementation might look like, a `Button` struct -->
<!-- might have fields for `width`, `height`, and `label`, as shown in Listing 17-7: -->
<p>さて、<code>Draw</code>トレイトを実装する型を追加しましょう。<code>Button</code>型を提供します。ここも、実際にGUIライブラリを実装することは、
この本の範疇を超えているので、<code>draw</code>メソッドの本体は、何も有用な実装はしません。実装がどんな感じになるか想像するために、
<code>Button</code>構造体は、<code>width</code>、<code>height</code>、<code>label</code>フィールドを持っている可能性があります。
リスト17-7に示したようにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
        // 実際にボタンを描画するコード
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-7: A `Button` struct that implements the -->
<!-- `Draw` trait</span> -->
<p><span class="caption">リスト17-7: <code>Draw</code>トレイトを実装するある<code>Button</code>構造体</span></p>
<!-- The `width`, `height`, and `label` fields on `Button` will differ from the -->
<!-- fields on other components, such as a `TextField` type, that might have those -->
<!-- fields plus a `placeholder` field instead. Each of the types we want to draw on -->
<!-- the screen will implement the `Draw` trait but will use different code in the -->
<!-- `draw` method to define how to draw that particular type, as `Button` has here -->
<!-- (without the actual GUI code that is beyond the scope of this chapter). The -->
<!-- `Button` type, for instance, might have an additional `impl` block containing -->
<!-- methods related to what happens when a user clicks the button. These kinds of -->
<!-- methods won’t apply to types like `TextField`. -->
<p><code>Button</code>の<code>width</code>、<code>height</code>、<code>label</code>フィールドは、<code>TextField</code>型のように、
それらのフィールドプラス<code>placeholder</code>フィールドを代わりに持つ可能性のある他のコンポーネントのフィールドとは異なるでしょう。
スクリーンに描画したい型のコンポーネントはそれぞれ<code>Draw</code>トレイトを実装しますが、
<code>Button</code>がここでしているように、<code>draw</code>メソッドでは異なるコードを使用してその特定の型を描画する方法を定義しています(実際のGUIコードは、
この章の範疇を超えるのでありませんが)。例えば、<code>Button</code>には、ユーザがボタンをクリックした時に起こることに関連するメソッドを含む、
追加の<code>impl</code>ブロックがある可能性があります。この種のメソッドは、<code>TextField</code>のような型には適用されません。</p>
<!-- If someone using our library decides to implement a `SelectBox` struct that has -->
<!-- `width`, `height`, and `options` fields, they implement the `Draw` trait on the -->
<!-- `SelectBox` type as well, as shown in Listing 17-8: -->
<p>ライブラリの使用者が、<code>width</code>、<code>height</code>、<code>options</code>フィールドのある<code>SelectBox</code>構造体を実装しようと決めたら、
<code>SelectBox</code>型に<code>Draw</code>トレイトも実装します。リスト17-8のようにですね:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
        //セレクトボックスを実際に描画するコード
    }
}
</code></pre>
<!-- <span class="caption">Listing 17-8: Another crate using `gui` and implementing -->
<!-- the `Draw` trait on a `SelectBox` struct</span> -->
<p><span class="caption">リスト17-8: <code>gui</code>を使用し、<code>SelectBox</code>構造体に<code>Draw</code>トレイトを実装する別のクレート</span></p>
<!-- Our library’s user can now write their `main` function to create a `Screen` -->
<!-- instance. To the `Screen` instance, they can add a `SelectBox` and a `Button` -->
<!-- by putting each in a `Box<T>` to become a trait object. They can then call the -->
<!-- `run` method on the `Screen` instance, which will call `draw` on each of the -->
<!-- components. Listing 17-9 shows this implementation: -->
<p>ライブラリの使用者はもう、<code>main</code>関数を書き、<code>Screen</code>インスタンスを生成できます。<code>Screen</code>インスタンスには、
それぞれを<code>Box&lt;T&gt;</code>に放り込んでトレイトオブジェクト化して<code>SelectBox</code>と<code>Button</code>を追加できます。
それから<code>Screen</code>インスタンスに対して<code>run</code>メソッドを呼び出すことができ、そうすると各コンポーネントの<code>draw</code>が呼び出されます。
リスト17-9は、この実装を示しています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    // はい
                    String::from(&quot;Yes&quot;),
                    // 多分
                    String::from(&quot;Maybe&quot;),
                    // いいえ
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                // 了解
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<!-- <span class="caption">Listing 17-9: Using trait objects to store values of -->
<!-- different types that implement the same trait</span> -->
<p><span class="caption">リスト17-9: トレイトオブジェクトを使って同じトレイトを実装する異なる型の値を格納する</span></p>
<!-- When we wrote the library, we didn’t know that someone might add the -->
<!-- `SelectBox` type, but our `Screen` implementation was able to operate on the -->
<!-- new type and draw it because `SelectBox` implements the `Draw` type, which -->
<!-- means it implements the `draw` method. -->
<p>ライブラリを記述した時点では、誰かが<code>SelectBox</code>型を追加する可能性があるなんて知りませんでしたが、
<code>Screen</code>の実装は、新しい型を処理し、描画することができました。何故なら、<code>SelectBox</code>は<code>Draw</code>型、
つまり、<code>draw</code>メソッドを実装しているからです。</p>
<!-- This concept—of being concerned only with the messages a value responds to -->
<!-- rather than the value’s concrete type—is similar to the concept *duck typing* -->
<!-- in dynamically typed languages: if it walks like a duck and quacks like a duck, -->
<!-- then it must be a duck! In the implementation of `run` on `Screen` in Listing -->
<!-- 17-5, `run` doesn’t need to know what the concrete type of each component is. -->
<!-- It doesn’t check whether a component is an instance of a `Button` or a -->
<!-- `SelectBox`, it just calls the `draw` method on the component. By specifying -->
<!-- `Box<Draw>` as the type of the values in the `components` vector, we’ve defined -->
<!-- `Screen` to need values that we can call the `draw` method on. -->
<p>この値の具体的な型ではなく、値が応答したメッセージにのみ関係するという概念は、
動的型付け言語の<em>ダックタイピング</em>に似た概念です: アヒルのように歩き、鳴くならば、
アヒルに違いないのです！リスト17-5の<code>Screen</code>の<code>run</code>の実装では、<code>run</code>は、
各コンポーネントの実際の型がなんであるか知る必要はありません。コンポーネントが、
<code>Button</code>や<code>SelectBox</code>のインスタンスであるかを確認することはなく、コンポーネントの<code>draw</code>メソッドを呼び出すだけです。
<code>components</code>ベクタで<code>Box&lt;Draw&gt;</code>を値の型として指定することで、<code>Screen</code>を、
<code>draw</code>メソッドを呼び出せる値を必要とするように定義できたのです。</p>
<!-- The advantage of using trait objects and Rust’s type system to write code -->
<!-- similar to code using duck typing is that we never have to check whether a -->
<!-- value implements a particular method at runtime or worry about getting errors -->
<!-- if a value doesn’t implement a method but we call it anyway. Rust won’t compile -->
<!-- our code if the values don’t implement the traits that the trait objects need. -->
<p>トレイトオブジェクトとRustの型システムを使用してダックタイピングを活用したコードに似たコードを書くことの利点は、
実行時に値が特定のメソッドを実装しているか確認したり、値がメソッドを実装していない時にエラーになることを心配したりする必要は絶対になく、
とにかく呼び出せることです。コンパイラは、値が、トレイトオブジェクトが必要としているトレイトを実装していなければ、
コンパイルを通さないのです。</p>
<!-- For example, Listing 17-10 shows what happens if we try to create a `Screen` -->
<!-- with a `String` as a component: -->
<p>例えば、リスト17-10は、コンポーネントに<code>String</code>のある<code>Screen</code>を作成しようとした時に起こることを示しています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre>
<!-- <span class="caption">Listing 17-10: Attempting to use a type that doesn’t -->
<!-- implement the trait object’s trait</span> -->
<p><span class="caption">リスト17-10: トレイトオブジェクトのトレイトを実装しない型の使用を試みる</span></p>
<!-- We’ll get this error because `String` doesn’t implement the `Draw` trait: -->
<p><code>String</code>は<code>Draw</code>トレイトを実装していないので、このようなエラーが出ます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
  --&gt; src/main.rs:7:13
   |
 7 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait gui::Draw is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `gui::Draw`
</code></pre>
<!-- 2行目はandだが、順接の理由で訳している -->
<!-- This error lets us know that either we’re passing something to `Screen` we -->
<!-- didn’t mean to pass and we should pass a different type or we should implement -->
<!-- `Draw` on `String` so that `Screen` is able to call `draw` on it. -->
<p>このエラーは、渡すことを意図していないものを<code>Screen</code>に渡しているので、異なる型を渡すべきか、
<code>Screen</code>が<code>draw</code>を呼び出せるように<code>String</code>に<code>Draw</code>を実装するべきのどちらかであることを知らせてくれています。</p>
<!-- ### Trait Objects Perform Dynamic Dispatch -->
<a class="header" href="print.html#aトレイトオブジェクトはダイナミックディスパッチを行う" id="aトレイトオブジェクトはダイナミックディスパッチを行う"><h3>トレイトオブジェクトは、ダイナミックディスパッチを行う</h3></a>
<!-- Recall in the “Performance of Code Using Generics” section in Chapter 10 our -->
<!-- discussion on the monomorphization process performed by the compiler when we -->
<!-- use trait bounds on generics: the compiler generates nongeneric implementations -->
<!-- of functions and methods for each concrete type that we use in place of a -->
<!-- generic type parameter. The code that results from monomorphization is doing -->
<!-- *static dispatch*, which is when the compiler knows what method you’re calling -->
<!-- at compile time. This is opposed to *dynamic dispatch*, which is when the -->
<!-- compiler can’t tell at compile time which method you’re calling. In dynamic -->
<!-- dispatch cases, the compiler emits code that at runtime will figure out which -->
<!-- method to call. -->
<p>第10章の「ジェネリクスを使用したコードのパフォーマンス」節でジェネリクスに対してトレイト境界を使用した時に、
コンパイラが行う単相化過程の議論を思い出してください: コンパイラは、関数やメソッドのジェネリックでない実装を、
ジェネリックな型引数の箇所に使用している具体的な型に対して生成するんでした。単相化の結果吐かれるコードは、
<em>スタティックディスパッチ</em>を行い、これは、コンパイル時にコンパイラがどのメソッドを呼び出しているかわかる時のことです。
これは、<em>ダイナミックディスパッチ</em>とは対照的で、この時、コンパイラは、コンパイル時にどのメソッドを呼び出しているのかわかりません。
ダイナミックディスパッチの場合、コンパイラは、実行時にどのメソッドを呼び出すか弾き出すコードを生成します。</p>
<!-- When we use trait objects, Rust must use dynamic dispatch. The compiler doesn’t -->
<!-- know all the types that might be used with the code that is using trait -->
<!-- objects, so it doesn’t know which method implemented on which type to call. -->
<!-- Instead, at runtime, Rust uses the pointers inside the trait object to know -->
<!-- which method to call. There is a runtime cost when this lookup happens that -->
<!-- doesn’t occur with static dispatch. Dynamic dispatch also prevents the compiler -->
<!-- from choosing to inline a method’s code, which in turn prevents some -->
<!-- optimizations. However, we did get extra flexibility in the code that we wrote -->
<!-- in Listing 17-5 and were able to support in Listing 17-9, so it’s a trade-off -->
<!-- to consider. -->
<p>トレイトオブジェクトを使用すると、コンパイラはダイナミックディスパッチを使用しなければなりません。
コンパイラは、トレイトオブジェクトを使用しているコードで使用される可能性のある型全てを把握しないので、
どの型に実装されたどのメソッドを呼び出すかわからないのです。代わりに実行時に、トレイトオブジェクト内でポインタを使用して、
コンパイラは、どのメソッドを呼ぶか知ります。スタティックディスパッチでは行われないこの検索が起きる時には、
実行時コストがあります。また、ダイナミックディスパッチは、コンパイラがメソッドのコードをインライン化することも妨げ、
そのためある種の最適化が不可能になります。ですが、リスト17-5で記述し、
リスト17-9ではサポートできたコードで追加の柔軟性を確かに得られたので、考慮すべき代償です。</p>
<!-- ### Object Safety Is Required for Trait Objects -->
<a class="header" href="print.html#aトレイトオブジェクトにはオブジェクト安全性が必要" id="aトレイトオブジェクトにはオブジェクト安全性が必要"><h3>トレイトオブジェクトには、オブジェクト安全性が必要</h3></a>
<!-- You can only make *object-safe* traits into trait objects. Some complex rules -->
<!-- govern all the properties that make a trait object safe, but in practice, only -->
<!-- two rules are relevant. A trait is object safe if all the methods defined in -->
<!-- the trait have the following properties: -->
<p>トレイトオブジェクトには、<em>オブジェクト安全</em>なトレイトしか作成できません。
トレイトオブジェクトを安全にする特性全てを司る複雑な規則がありますが、実際には、2つの規則だけが関係があります。
トレイトは、トレイト内で定義されているメソッド全てに以下の特性があれば、オブジェクト安全になります。</p>
<!-- * The return type isn’t `Self`. -->
<!-- * There are no generic type parameters. -->
<ul>
<li>戻り値の型が<code>Self</code>でない。</li>
<li>ジェネリックな型引数がない。</li>
</ul>
<!-- The `Self` keyword is an alias for the type we’re implementing the traits or -->
<!-- methods on. Trait objects must be object safe because once you’ve used a trait -->
<!-- object, Rust no longer knows the concrete type that’s implementing that trait. -->
<!-- If a trait method returns the concrete `Self` type, but a trait object forgets -->
<!-- the exact type that `Self` is, there is no way the method can use the original -->
<!-- concrete type. The same is true of generic type parameters that are filled in -->
<!-- with concrete type parameters when the trait is used: the concrete types become -->
<!-- part of the type that implements the trait. When the type is forgotten through -->
<!-- the use of a trait object, there is no way to know what types to fill in the -->
<!-- generic type parameters with. -->
<p><code>Self</code>キーワードは、トレイトやメソッドを実装しようとしている型の別名です。トレイトオブジェクトは、
一旦、トレイトオブジェクトを使用したら、コンパイラにはそのトレイトを実装している具体的な型を知りようがないので、
オブジェクト安全でなければなりません。トレイトメソッドが具体的な<code>Self</code>型を返すのに、
トレイトオブジェクトが<code>Self</code>の具体的な型を忘れてしまったら、メソッドが元の具体的な型を使用できる手段はなくなってしまいます。
同じことがトレイトを使用する時に具体的な型引数で埋められるジェネリックな型引数に対しても言えます:
具体的な型がトレイトを実装する型の一部になるのです。トレイトオブジェクトの使用を通して型が忘却されたら、
そのジェネリックな型引数を埋める型がなんなのか知る術はないのです。</p>
<!-- An example of a trait whose methods are not object safe is the standard -->
<!-- library’s `Clone` trait. The signature for the `clone` method in the `Clone` -->
<!-- trait looks like this: -->
<p>メソッドがオブジェクト安全でないトレイトの例は、標準ライブラリの<code>Clone</code>トレイトです。
<code>Clone</code>トレイトの<code>clone</code>メソッドのシグニチャは以下のような感じです:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
#}</code></pre></pre>
<!-- The `String` type implements the `Clone` trait, and when we call the `clone` -->
<!-- method on an instance of `String` we get back an instance of `String`. -->
<!-- Similarly, if we call `clone` on an instance of `Vec<T>`, we get back an -->
<!-- instance of `Vec<T>`. The signature of `clone` needs to know what type will -->
<!-- stand in for `Self`, because that’s the return type. -->
<p><code>String</code>型は<code>Clone</code>トレイトを実装していて、<code>String</code>のインスタンスに対して<code>clone</code>メソッドを呼び出すと、
<code>String</code>のインスタンスが返ってきます。同様に、<code>Vec</code>のインスタンスに対して<code>clone</code>を呼び出すと、
<code>Vec</code>のインスタンスが返ってきます。<code>clone</code>のシグニチャは、<code>Self</code>の代わりに入る型を知る必要があります。
それが、戻り値の型になるからです。</p>
<!-- The compiler will indicate when you’re trying to do something that violates the -->
<!-- rules of object safety in regard to trait objects. For example, let’s say we -->
<!-- tried to implement the `Screen` struct in Listing 17-4 to hold types that -->
<!-- implement the `Clone` trait instead of the `Draw` trait, like this: -->
<p>コンパイラは、トレイトオブジェクトに関していつオブジェクト安全の規則を侵害するようなことを試みているかを示唆します。
例えば、リスト17-4で<code>Screen</code>構造体を実装して<code>Draw</code>トレイトではなく、
<code>Clone</code>トレイトを実装した型を保持しようとしたとしましょう。こんな感じで:</p>
<pre><code class="language-rust ignore">pub struct Screen {
    pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
}
</code></pre>
<!-- We would get this error: -->
<p>こんなエラーになります:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
(エラー: `std::clone::Clone`トレイトは、オブジェクトにすることはできません)
 --&gt; src/lib.rs:2:5
  |
2 |     pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
made into an object
  |
  = note: the trait cannot require that `Self : Sized`
  (注釈: このトレイトは、`Self : Sized`を満たせません)
</code></pre>
<!-- This error means you can’t use this trait as a trait object in this way. If -->
<!-- you’re interested in more details on object safety, see [Rust RFC 255]. -->
<p>このエラーは、このようにこのトレイトをトレイトオブジェクトとして使用することはできないことを意味しています。
オブジェクト安全性についてより詳しく興味があるのなら、<a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>を参照されたし。</p>
<!-- ## Implementing an Object-Oriented Design Pattern -->
<a class="header" href="print.html#aオブジェクト指向デザインパターンを実装する" id="aオブジェクト指向デザインパターンを実装する"><h2>オブジェクト指向デザインパターンを実装する</h2></a>
<!-- The *state pattern* is an object-oriented design pattern. The crux of the -->
<!-- pattern is that a value has some internal state, which is represented by a set -->
<!-- of *state objects*, and the value’s behavior changes based on the internal -->
<!-- state. The state objects share functionality: in Rust, of course, we use -->
<!-- structs and traits rather than objects and inheritance. Each state object is -->
<!-- responsible for its own behavior and for governing when it should change into -->
<!-- another state. The value that holds a state object knows nothing about the -->
<!-- different behavior of the states or when to transition between states. -->
<p>ステートパターンは、オブジェクト指向デザインパターンの1つです。このパターンの肝は、
値が一連の<em>ステートオブジェクト</em>で表されるなんらかの内部状態を持ち、
その内部の状態に基づいて値の振る舞いが変化するというものです。ステートオブジェクトは、
機能を共有します: Rustでは、もちろん、オブジェクトと継承ではなく、構造体とトレイトを使用します。
各ステートオブジェクトは、自身の振る舞いと別の状態に変化すべき時を司ることに責任を持ちます。
ステートオブジェクトを保持する値は、状態ごとの異なる振る舞いや、いつ状態が移行するかについては何も知りません。</p>
<!-- Using the state pattern means when the business requirements of the program -->
<!-- change, we won’t need to change the code of the value holding the state or the -->
<!-- code that uses the value. We’ll only need to update the code inside one of the -->
<!-- state objects to change its rules or perhaps add more state objects. Let’s look -->
<!-- at an example of the state design pattern and how to use it in Rust. -->
<p>ステートパターンを使用することは、プログラムの業務用件が変わる時、状態を保持する値のコードや、
値を使用するコードを変更する必要はないことを意味します。ステートオブジェクトの1つのコードを更新して、
規則を変更したり、あるいはおそらくステートオブジェクトを追加する必要しかないのです。
ステートデザインパターンの例と、そのRustでの使用方法を見ましょう。</p>
<!-- We’ll implement a blog post workflow in an incremental way. The blog’s final -->
<!-- functionality will look like this: -->
<p>ブログ記事のワークフローを少しずつ実装していきます。ブログの最終的な機能は以下のような感じになるでしょう:</p>
<!-- 1. A blog post starts as an empty draft. -->
<!-- 2. When the draft is done, a review of the post is requested. -->
<!-- 3. When the post is approved, it gets published. -->
<!-- 4. Only published blog posts return content to print, so unapproved posts can’t -->
<!--    accidentally be published. -->
<ol>
<li>ブログ記事は、空の草稿から始まる。</li>
<li>草稿ができたら、査読が要求される。</li>
<li>記事が承認されたら、公開される。</li>
<li>公開されたブログ記事だけが表示する内容を返すので、未承認の記事は、誤って公開されない。</li>
</ol>
<!-- Any other changes attempted on a post should have no effect. For example, if we -->
<!-- try to approve a draft blog post before we’ve requested a review, the post -->
<!-- should remain an unpublished draft. -->
<p>それ以外の記事に対する変更は、効果を持つべきではありません。例えば、査読を要求する前にブログ記事の草稿を承認しようとしたら、
記事は、非公開の草稿のままになるべきです。</p>
<!-- Listing 17-11 shows this workflow in code form: this is an example usage of the -->
<!-- API we’ll implement in a library crate named `blog`. This won’t compile yet -->
<!-- because we haven’t implemented the `blog` crate yet. -->
<p>リスト17-11は、このワークフローをコードの形で示しています: これは、
<code>blog</code>というライブラリクレートに実装するAPIの使用例です。まだ<code>blog</code>クレートを実装していないので、
コンパイルはできません。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    // 今日はお昼にサラダを食べた
    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<!-- <span class="caption">Listing 17-11: Code that demonstrates the desired -->
<!-- behavior we want our `blog` crate to have</span> -->
<p><span class="caption">リスト17-11: <code>blog</code>クレートに欲しい振る舞いをデモするコード</span></p>
<!-- We want to allow the user to create a new draft blog post with `Post::new`. -->
<!-- Then we want to allow text to be added to the blog post while it’s in the draft -->
<!-- state. If we try to get the post’s content immediately, before approval, -->
<!-- nothing should happen because the post is still a draft. We’ve added -->
<!-- `assert_eq!` in the code for demonstration purposes. An excellent unit test for -->
<!-- this would be to assert that a draft blog post returns an empty string from the -->
<!-- `content` method, but we’re not going to write tests for this example. -->
<p>ユーザが<code>Post::new</code>で新しいブログ記事の草稿を作成できるようにしたいです。それから、
草稿状態の間にブログ記事にテキストを追加できるようにしたいです。承認前に記事の内容を即座に得ようとしたら、
記事はまだ草稿なので、何も起きるべきではありません。デモするためにコードに<code>assert_eq!</code>を追加しました。
これに対する素晴らしい単体テストは、ブログ記事の草稿が<code>content</code>メソッドから空の文字列を返すことをアサートすることでしょうが、
この例に対してテストを書くつもりはありません。</p>
<!-- Next, we want to enable a request for a review of the post, and we want -->
<!-- `content` to return an empty string while waiting for the review. When the post -->
<!-- receives approval, it should get published, meaning the text of the post will -->
<!-- be returned when `content` is called. -->
<p>次に、記事の査読を要求できるようにしたく、また査読を待機している間は<code>content</code>に空の文字列を返してほしいです。
記事が承認を受けたら、公開されるべきです。つまり、<code>content</code>を呼んだ時に記事のテキストが返されるということです。</p>
<!-- Notice that the only type we’re interacting with from the crate is the `Post` -->
<!-- type. This type will use the state pattern and will hold a value that will be -->
<!-- one of three state objects representing the various states a post can be -->
<!-- in—draft, waiting for review, or published. Changing from one state to another -->
<!-- will be managed internally within the `Post` type. The states change in -->
<!-- response to the methods called by our library’s users on the `Post` instance, -->
<!-- but they don’t have to manage the state changes directly. Also, users can’t -->
<!-- make a mistake with the states, like publishing a post before it’s reviewed. -->
<p>クレートから相互作用している唯一の型は、<code>Post</code>だけであることに注意してください。
この型はステートパターンを使用し、記事がなり得る種々の状態を表す3つのステートオブジェクトのうちの1つになる値を保持します。
草稿、査読待ち、公開中です。1つの状態から別の状態への変更は、<code>Post</code>型内部で管理されます。
<code>Post</code>インスタンスのライブラリ使用者が呼び出すメソッドに呼応して状態は変化しますが、
状態の変化を直接管理する必要はありません。また、ユーザは、
査読前に記事を公開するなど状態を誤ることはありません。</p>
<!-- ### Defining `Post` and Creating a New Instance in the Draft State -->
<a class="header" href="print.html#postを定義し草稿状態で新しいインスタンスを生成する" id="postを定義し草稿状態で新しいインスタンスを生成する"><h3><code>Post</code>を定義し、草稿状態で新しいインスタンスを生成する</h3></a>
<!-- Let’s get started on the implementation of the library! We know we need a -->
<!-- public `Post` struct that holds some content, so we’ll start with the -->
<!-- definition of the struct and an associated public `new` function to create an -->
<!-- instance of `Post`, as shown in Listing 17-12. We’ll also make a private -->
<!-- `State` trait. Then `Post` will hold a trait object of `Box<State>` inside an -->
<!-- `Option` in a private field named `state`. You’ll see why the `Option` is -->
<!-- necessary in a bit. -->
<p>ライブラリの実装に取り掛かりましょう！なんらかの内容を保持する公開の<code>Post</code>構造体が必要なことはわかるので、
構造体の定義と、関連する公開の<code>Post</code>インスタンスを生成する<code>new</code>関数から始めましょう。リスト17-12のようにですね。
また、非公開の<code>State</code>トレイトも作成します。それから、<code>Post</code>は<code>state</code>という非公開のフィールドに、
<code>Option</code>で<code>Box&lt;State&gt;</code>のトレイトオブジェクトを保持します。<code>Option</code>が必要な理由はすぐわかります。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    state: Option&lt;Box&lt;State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-12: Definition of a `Post` struct and a `new` -->
<!-- function that creates a new `Post` instance, a `State` trait, and a `Draft` -->
<!-- struct</span> -->
<p><span class="caption">リスト17-12: <code>Post</code>構造体、新規<code>Post</code>インスタンスを生成する<code>new</code>関数、
<code>State</code>トレイト、<code>Draft</code>構造体の定義</span></p>
<!-- The `State` trait defines the behavior shared by different post states, and the -->
<!-- `Draft`, `PendingReview`, and `Published` states will all implement the `State` -->
<!-- trait. For now, the trait doesn’t have any methods, and we’ll start by defining -->
<!-- just the `Draft` state because that is the state we want a post to start in. -->
<p><code>State</code>トレイトは、異なる記事の状態で共有される振る舞いを定義し、<code>Draft</code>、<code>PendingReview</code>、<code>Published</code>状態は全て、
<code>State</code>トレイトを実装します。今は、トレイトにメソッドは何もなく、<code>Draft</code>が記事の初期状態にしたい状態なので、
その状態だけを定義することから始めます。</p>
<!-- When we create a new `Post`, we set its `state` field to a `Some` value that -->
<!-- holds a `Box`. This `Box` points to a new instance of the `Draft` struct. This -->
<!-- ensures whenever we create a new instance of `Post`, it will start out as a -->
<!-- draft. Because the `state` field of `Post` is private, there is no way to -->
<!-- create a `Post` in any other state! In the `Post::new` function, we set the -->
<!-- `content` field to a new, empty `String` -->
<p>新しい<code>Post</code>を作る時、<code>state</code>フィールドは、<code>Box</code>を保持する<code>Some</code>値にセットします。
この<code>Box</code>が<code>Draft</code>構造体の新しいインスタンスを指します。これにより、
新しい<code>Post</code>を作る度に、草稿から始まることが保証されます。<code>Post</code>の<code>state</code>フィールドは非公開なので、
<code>Post</code>を他の状態で作成する方法はないのです！<code>Post::new</code>関数では、<code>content</code>フィールドを新しい空の<code>String</code>にセットしています。</p>
<!-- ### Storing the Text of the Post Content -->
<a class="header" href="print.html#a記事の内容のテキストを格納する" id="a記事の内容のテキストを格納する"><h3>記事の内容のテキストを格納する</h3></a>
<!-- Listing 17-11 showed that we want to be able to call a method named -->
<!-- `add_text` and pass it a `&str` that is then added to the text content of the -->
<!-- blog post. We implement this as a method rather than exposing the `content` -->
<!-- field as `pub`. This means we can implement a method later that will control -->
<!-- how the `content` field’s data is read. The `add_text` method is pretty -->
<!-- straightforward, so let’s add the implementation in Listing 17-13 to the `impl -->
<!-- Post` block: -->
<p><code>Post::new</code>関数では、<code>content</code>フィールドを新しい空の<code>String</code>にセットしています。
リスト17-11は、<code>add_text</code>というメソッドを呼び出し、ブログ記事のテキスト内容に追加される<code>&amp;str</code>を渡せるようになりたいことを示しました。
これを<code>content</code>フィールドを<code>pub</code>にして晒すのではなく、メソッドとして実装しています。
これは、後ほど<code>content</code>フィールドデータの読まれ方を制御するメソッドを実装できることを意味しています。
<code>add_text</code>メソッドは非常に素直なので、リスト17-13の実装を<code>impl Post</code>ブロックに追加しましょう:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-13: Implementing the `add_text` method to add -->
<!-- text to a post’s `content`</span> -->
<p><span class="caption">リスト17-13: 記事の<code>content</code>にテキストを追加する<code>add_text</code>メソッドを実装する</span></p>
<!-- The `add_text` method takes a mutable reference to `self`, because we’re -->
<!-- changing the `Post` instance that we’re calling `add_text` on. We then call -->
<!-- `push_str` on the `String` in `content` and pass the `text` argument to add to -->
<!-- the saved `content`. This behavior doesn’t depend on the state the post is in, -->
<!-- so it’s not part of the state pattern. The `add_text` method doesn’t interact -->
<!-- with the `state` field at all, but it is part of the behavior we want to -->
<!-- support. -->
<p><code>add_text</code>メソッドは、<code>self</code>への可変参照を取ります。というのも、<code>add_text</code>を呼び出した<code>Post</code>インスタンスを変更しているからです。
それから<code>content</code>の<code>String</code>に対して<code>push_str</code>を呼び出し、<code>text</code>引数を渡して保存された<code>content</code>に追加しています。
この振る舞いは、記事の状態によらないので、ステートパターンの一部ではありません。<code>add_text</code>メソッドは、
<code>state</code>フィールドと全く相互作用しませんが、サポートしたい振る舞いの一部ではあります。</p>
<!-- ### Ensuring the Content of a Draft Post Is Empty -->
<a class="header" href="print.html#a草稿の記事の内容は空であることを保証する" id="a草稿の記事の内容は空であることを保証する"><h3>草稿の記事の内容は空であることを保証する</h3></a>
<!-- Even after we’ve called `add_text` and added some content to our post, we still -->
<!-- want the `content` method to return an empty string slice because the post is -->
<!-- still in the draft state, as shown on line 8 of Listing 17-11. For now, let’s -->
<!-- implement the `content` method with the simplest thing that will fulfill this -->
<!-- requirement: always returning an empty string slice. We’ll change this later -->
<!-- once we implement the ability to change a post’s state so it can be published. -->
<!-- So far, posts can only be in the draft state, so the post content should always -->
<!-- be empty. Listing 17-14 shows this placeholder implementation: -->
<p><code>add_text</code>を呼び出して記事に内容を追加して後でさえ、記事はまだ草稿状態なので、
それでも<code>content</code>メソッドには空の文字列スライスを返してほしいです。
リスト17-11の8行目で示したようにですね。とりあえず、この要求を実現する最も単純な方法で<code>content</code>メソッドを実装しましょう:
常に空の文字列スライスを返すことです。一旦、記事の状態を変更する能力を実装したら、公開できるように、
これを後ほど変更します。ここまで、記事は草稿状態にしかなり得ないので、記事の内容は常に空のはずです。
リスト17-14は、この仮の実装を表示しています:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-14: Adding a placeholder implementation for -->
<!-- the `content` method on `Post` that always returns an empty string slice</span> -->
<p><span class="caption">リスト17-14: <code>Post</code>に常に空の文字列スライスを返す<code>content</code>の仮の実装を追加する</span></p>
<!-- With this added `content` method, everything in Listing 17-11 up to line 8 -->
<!-- works as intended. -->
<p>この追加された<code>content</code>メソッドとともに、リスト17-11の8行目までのコードは、想定通り動きます。</p>
<!-- ### Requesting a Review of the Post Changes Its State -->
<a class="header" href="print.html#a記事の査読を要求すると状態が変化する" id="a記事の査読を要求すると状態が変化する"><h3>記事の査読を要求すると、状態が変化する</h3></a>
<!-- Next, we need to add functionality to request a review of a post, which should -->
<!-- change its state from `Draft` to `PendingReview`. Listing 17-15 shows this code: -->
<p>次に、記事の査読を要求する機能を追加する必要があり、これをすると、状態が<code>Draft</code>から<code>PendingReview</code>に変わるはずです。
リスト17-15はこのコードを示しています:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-15: Implementing `request_review` methods on -->
<!-- `Post` and the `State` trait</span> -->
<p><span class="caption">リスト17-15: <code>Post</code>と<code>State</code>トレイトに<code>request_review</code>メソッドを実装する</span></p>
<!-- We give `Post` a public method named `request_review` that will take a mutable -->
<!-- reference to `self`. Then we call an internal `request_review` method on the -->
<!-- current state of `Post`, and this second `request_review` method consumes the -->
<!-- current state and return a new state. -->
<p><code>Post</code>に<code>self</code>への可変参照を取る<code>request_review</code>という公開メソッドを与えます。それから、
<code>Post</code>の現在の状態に対して内部の<code>request_review</code>メソッドを呼び出し、
この2番目の<code>request_review</code>が現在の状態を消費し、新しい状態を返します。</p>
<!-- We’ve added the `request_review` method to the `State` trait; all types that -->
<!-- implement the trait will now need to implement the `request_review` method. -->
<!-- Note that rather than having `self`, `&self`, or `&mut self` as the first -->
<!-- parameter of the method, we have `self: Box<Self>`. This syntax means the -->
<!-- method is only valid when called on a `Box` holding the type. This syntax takes -->
<!-- ownership of `Box<Self>`, invalidating the old state so the state value of the -->
<!-- `Post` can transform into a new state. -->
<p><code>State</code>トレイトに<code>request_review</code>メソッドを追加しました; このトレイトを実装する型は全て、
これで<code>request_review</code>メソッドを実装する必要があります。メソッドの第1引数に<code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code>ではなく、
<code>self: Box&lt;Self&gt;</code>としていることに注意してください。この記法は、型を保持する<code>Box</code>に対して呼ばれた時、
このメソッドが有効のみになることを意味しています。この記法は、<code>Box&lt;Self&gt;</code>の所有権を奪い、古い状態を無効化するので、
<code>Post</code>の状態値は、新しい状態に変形できます。</p>
<!-- To consume the old state, the `request_review` method needs to take ownership -->
<!-- of the state value. This is where the `Option` in the `state` field of `Post` -->
<!-- comes in: we call the `take` method to take the `Some` value out of the `state` -->
<!-- field and leave a `None` in its place, because Rust doesn’t let us have -->
<!-- unpopulated fields in structs. This lets us move the `state` value out of -->
<!-- `Post` rather than borrowing it. Then we’ll set the post’s `state` value to the -->
<!-- result of this operation. -->
<p>古い状態を消費するために、<code>request_review</code>メソッドは、状態値の所有権を奪う必要があります。
ここで<code>Post</code>の<code>state</code>フィールドの<code>Option</code>が問題になるのです: <code>take</code>メソッドを呼び出して、
<code>state</code>フィールドから<code>Some</code>値を取り出し、その箇所に<code>None</code>を残します。なぜなら、Rustは、
構造体に未代入のフィールドを持たせてくれないからです。これにより、借用するのではなく、
<code>Post</code>の<code>state</code>値をムーブすることができます。それから、記事の<code>state</code>値をこの処理の結果にセットするのです。</p>
<!-- We need to set `state` to `None` temporarily rather than setting it directly -->
<!-- with code like `self.state = self.state.request_review();` to get ownership of -->
<!-- the `state` value. This ensures `Post` can’t use the old `state` value after -->
<!-- we’ve transformed it into a new state. -->
<p><code>self.state = self.state.request_review();</code>のようなコードで直接<code>state</code>値の所有権を得るよう設定するのではなく、
一時的に<code>None</code>に<code>state</code>をセットする必要があります。これにより、新しい状態に変形した後に、
<code>Post</code>が古い<code>state</code>値を使えないことが保証されるのです。</p>
<!-- The `request_review` method on `Draft` needs to return a new, boxed instance of -->
<!-- a new `PendingReview` struct, which represents the state when a post is waiting -->
<!-- for a review. The `PendingReview` struct also implements the `request_review` -->
<!-- method but doesn’t do any transformations. Rather, it returns itself, because -->
<!-- when we request a review on a post already in the `PendingReview` state, it -->
<!-- should stay in the `PendingReview` state. -->
<p><code>Draft</code>の<code>request_review</code>メソッドは、新しい<code>PendingReview</code>構造体の新しいボックスのインスタンスを返す必要があり、
これが、記事が査読待ちの時の状態を表します。<code>PendingReview</code>構造体も<code>request_review</code>メソッドを実装しますが、
何も変形はしません。むしろ、自身を返します。というのも、既に<code>PendingReview</code>状態にある記事の査読を要求したら、
<code>PendingReview</code>状態に留まるべきだからです。</p>
<!-- Now we can start seeing the advantages of the state pattern: the -->
<!-- `request_review` method on `Post` is the same no matter its `state` value. Each -->
<!-- state is responsible for its own rules. -->
<p>ようやくステートパターンの利点が見えてき始めました: <code>state</code>値が何であれ、<code>Post</code>の<code>request_review</code>メソッドは同じです。
各状態は、独自の規則にのみ責任を持ちます。</p>
<!-- We’ll leave the `content` method on `Post` as is, returning an empty string -->
<!-- slice. We can now have a `Post` in the `PendingReview` state as well as in the -->
<!-- `Draft` state, but we want the same behavior in the `PendingReview` state. -->
<!-- Listing 17-11 now works up to line 11! -->
<p><code>Post</code>の<code>content</code>メソッドを空の文字列スライスを返すというようにそのままにします。
これで<code>Post</code>は<code>PendingReview</code>と<code>Draft</code>状態になり得ますが、<code>PendingReview</code>状態でも、
同じ振る舞いが欲しいです。もうリスト17-11は11行目まで動くようになりました！</p>
<!-- ### Adding the `approve` Method that Changes the Behavior of `content` -->
<a class="header" href="print.html#contentの振る舞いを変化させるapproveメソッドを追加する" id="contentの振る舞いを変化させるapproveメソッドを追加する"><h3><code>content</code>の振る舞いを変化させる<code>approve</code>メソッドを追加する</h3></a>
<!-- The `approve` method will be similar to the `request_review` method: it will -->
<!-- set `state` to the value that the current state says it should have when that -->
<!-- state is approved, as shown in Listing 17-16: -->
<p><code>approve</code>メソッドは、<code>request_review</code>メソッドと類似するでしょう: 状態が承認された時に、
現在の状態があるべきと言う値に<code>state</code>をセットします。リスト17-16のようにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
#         Box::new(PendingReview {})
#     }
#
    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
#         self
#     }
#
    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-16: Implementing the `approve` method on -->
<!-- `Post` and the `State` trait</span> -->
<p><span class="caption">リスト17-16: <code>Post</code>と<code>State</code>トレイトに<code>approve</code>メソッドを実装する</span></p>
<!-- We add the `approve` method to the `State` trait and add a new struct that -->
<!-- implements `State`, the `Published` state. -->
<p><code>State</code>トレイトに<code>approve</code>メソッドを追加し、<code>Published</code>状態という<code>State</code>を実装する新しい構造体を追加します。</p>
<!-- Similar to `request_review`, if we call the `approve` method on a `Draft`, it -->
<!-- will have no effect because it will return `self`. When we call `approve` on -->
<!-- `PendingReview`, it returns a new, boxed instance of the `Published` struct. -->
<!-- The `Published` struct implements the `State` trait, and for both the -->
<!-- `request_review` method and the `approve` method, it returns itself, because -->
<!-- the post should stay in the `Published` state in those cases. -->
<p><code>request_review</code>のように、<code>Draft</code>に対して<code>approve</code>メソッドを呼び出したら、<code>self</code>を返すので、
何も効果はありません。<code>PendingReview</code>に対して<code>approve</code>を呼び出すと、
<code>Published</code>構造体の新しいボックス化されたインスタンスを返します。<code>Published</code>構造体は<code>State</code>トレイトを実装し、
<code>request_review</code>メソッドと<code>approve</code>メソッド両方に対して、自身を返します。
そのような場合には記事は、<code>Published</code>状態に留まるべきだからです。</p>
<!-- Now we need to update the `content` method on `Post`: if the state is -->
<!-- `Published`, we want to return the value in the post’s `content` field; -->
<!-- otherwise, we want to return an empty string slice, as shown in Listing 17-17: -->
<p>さて、<code>Post</code>の<code>content</code>メソッドを更新する必要が出てきました: 状態が<code>Published</code>なら、
記事の<code>content</code>フィールドの値を返したいのです; それ以外なら、空の文字列スライスを返したいです。
リスト17-17のようにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait State {
#     fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;
# }
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(&amp;self)
    }
    // --snip--
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-17: Updating the `content` method on `Post` to -->
<!-- delegate to a `content` method on `State`</span> -->
<p><span class="caption">リスト17-17: <code>Post</code>の<code>content</code>メソッドを更新して<code>State</code>の<code>content</code>メソッドに委譲する</span></p>
<!-- Because the goal is to keep all these rules inside the structs that implement -->
<!-- `State`, we call a `content` method on the value in `state` and pass the post -->
<!-- instance (that is, `self`) as an argument. Then we return the value that is -->
<!-- returned from using the `content` method on the `state` value. -->
<p>目的は、これらの規則全てを<code>State</code>を実装する構造体の内部に押し留めることなので、<code>state</code>の値に対して<code>content</code>メソッドを呼び出し、
記事のインスタンス(要するに、<code>self</code>)を引数として渡します。そして、<code>state</code>値の<code>content</code>メソッドを使用したことから返ってきた値を返します。</p>
<!-- We call the `as_ref` method on the `Option` because we want a reference to the -->
<!-- value inside the `Option` rather than ownership of the value. Because `state` -->
<!-- is an `Option<Box<State>>`, when we call `as_ref`, an `Option<&Box<State>>` is -->
<!-- returned. If we didn’t call `as_ref`, we would get an error because we can’t -->
<!-- move `state` out of the borrowed `&self` of the function parameter. -->
<p><code>Option</code>に対して<code>as_ref</code>メソッドを呼び出します。値の所有権ではなく、<code>Option</code>内部の値への参照が欲しいからです。
<code>state</code>は<code>Option&lt;Box&lt;State&gt;&gt;</code>なので、<code>as_ref</code>を呼び出すと、<code>Option&lt;&amp;Box&lt;State&gt;&gt;</code>が返ってきます。
<code>as_ref</code>を呼ばなければ、<code>state</code>を関数引数の借用した<code>&amp;self</code>からムーブできないので、エラーになるでしょう。</p>
<!-- We then call the `unwrap` method, which we know will never panic, because we -->
<!-- know the methods on `Post` ensure that `state` will always contain a `Some` -->
<!-- value when those methods are done. This is one of the cases we talked about in -->
<!-- the “Cases When You Have More Information Than the Compiler” section of Chapter -->
<!-- 9 when we know that a `None` value is never possible, even though the compiler -->
<!-- isn’t able to understand that. -->
<p>さらに<code>unwrap</code>メソッドを呼び出し、これは絶対にパニックしないことがわかっています。何故なら、
<code>Post</code>のメソッドが、それらのメソッドが完了した際に<code>state</code>は常に<code>Some</code>値を含んでいることを保証するからです。
これは、コンパイラには理解不能であるものの、
<code>None</code>値が絶対にあり得ないとわかる第9章の「コンパイラよりも情報を握っている場合」節で語った一例です。</p>
<!-- At this point, when we call `content` on the `&Box<State>`, deref coercion will -->
<!-- take effect on the `&` and the `Box` so the `content` method will ultimately be -->
<!-- called on the type that implements the `State` trait. That means we need to add -->
<!-- `content` to the `State` trait definition, and that is where we’ll put the -->
<!-- logic for what content to return depending on which state we have, as shown in -->
<!-- Listing 17-18: -->
<p>この時点で、<code>&amp;Box&lt;State&gt;</code>に対して<code>content</code>を呼び出すと、参照外し型強制が<code>&amp;</code>と<code>Box</code>に働くので、
究極的に<code>content</code>メソッドが<code>State</code>トレイトを実装する型に対して呼び出されることになります。
つまり、<code>content</code>を<code>State</code>トレイト定義に追加する必要があり、そこが現在の状態に応じてどの内容を返すべきかというロジックを配置する場所です。
リスト17-18のようにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String
# }
trait State {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-18: Adding the `content` method to the `State` -->
<!-- trait</span> -->
<p><span class="caption">リスト17-18: <code>State</code>トレイトに<code>content</code>メソッドを追加する</span></p>
<!-- We add a default implementation for the `content` method that returns an empty -->
<!-- string slice. That means we don’t need to implement `content` on the `Draft` -->
<!-- and `PendingReview` structs. The `Published` struct will override the `content` -->
<!-- method and return the value in `post.content`. -->
<p>空の文字列スライスを返すデフォルト実装を<code>content</code>メソッドに追加しています。これにより、
<code>Draft</code>と<code>PendingReview</code>構造体に<code>content</code>を実装する必要はありません。<code>Published</code>構造体は、
<code>content</code>メソッドをオーバーライドし、<code>post.content</code>の値を返します。</p>
<!-- Note that we need lifetime annotations on this method, as we discussed in -->
<!-- Chapter 10. We’re taking a reference to a `post` as an argument and returning a -->
<!-- reference to part of that `post`, so the lifetime of the returned reference is -->
<!-- related to the lifetime of the `post` argument. -->
<p>第10章で議論したように、このメソッドにはライフタイム注釈が必要なことに注意してください。
<code>post</code>への参照を引数として取り、その<code>post</code>の一部への参照を返しているので、
返却される参照のライフタイムは、<code>post</code>引数のライフタイムに関連します。</p>
<!-- And we’re done—all of Listing 17-11 now works! We’ve implemented the state -->
<!-- pattern with the rules of the blog post workflow. The logic related to the -->
<!-- rules lives in the state objects rather than being scattered throughout `Post`. -->
<p>出来上がりました。要するに、リスト17-11はもう動くようになったのです！ブログ記事ワークフローの規則でステートパターンを実装しました。
その規則に関連するロジックは、<code>Post</code>中に散乱するのではなく、ステートオブジェクトに息づいています。</p>
<!-- ### Trade-offs of the State Pattern -->
<a class="header" href="print.html#aステートパターンの代償" id="aステートパターンの代償"><h3>ステートパターンの代償</h3></a>
<!-- 3行目末尾、The wayと次の文、we onlyの繋がりがよく分からない。とりあえずandで繋いでるような感じで訳している -->
<!-- We’ve shown that Rust is capable of implementing the object-oriented state -->
<!-- pattern to encapsulate the different kinds of behavior a post should have in -->
<!-- each state. The methods on `Post` know nothing about the various behaviors. The -->
<!-- way we organized the code, we have to look in only one place to know the -->
<!-- different ways a published post can behave: the implementation of the `State` -->
<!-- trait on the `Published` struct. -->
<p>オブジェクト指向のステートパターンを実装して各状態の時に記事がなり得る異なる種類の振る舞いをカプセル化する能力が、
Rustにあることを示しました。<code>Post</code>のメソッドは、種々の振る舞いについては何も知りません。
コードを体系化した方法、公開された記事が振る舞うことのある様々な方法を知るには、1箇所のみを調べればいいのです:
<code>Published</code>構造体の<code>State</code>トレイトの実装です。</p>
<!-- 5行目末尾がよくわからない。The more ..., the more ...のような感じで訳し文脈には合ってそうだが、合ってる自信がない -->
<!-- つまり、This would only increase, the more states we addedのように訳している -->
<!-- If we were to create an alternative implementation that didn’t use the state -->
<!-- pattern, we might instead use `match` expressions in the methods on `Post` or -->
<!-- even in the `main` code that checks the state of the post and changes behavior -->
<!-- in those places. That would mean we would have to look in several places to -->
<!-- understand all the implications of a post being in the published state! This -->
<!-- would only increase the more states we added: each of those `match` expressions -->
<!-- would need another arm. -->
<p>ステートパターンを使用しない対立的な実装を作ることになったら、代わりに<code>Post</code>のメソッドか、
あるいは記事の状態を確認し、それらの箇所(<code>編注</code>: <code>Post</code>のメソッドのことか)の振る舞いを変更する<code>main</code>コードでさえ、
<code>match</code>式を使用したかもしれません。そうなると、複数個所を調べて記事が公開状態にあることの裏の意味全てを理解しなければならなくなります！
これは、追加した状態が増えれば、さらに上がるだけでしょう: 各<code>match</code>式には、別のアームが必要になるのです。</p>
<!-- With the state pattern, the `Post` methods and the places we use `Post` don’t -->
<!-- need `match` expressions, and to add a new state, we would only need to add a -->
<!-- new struct and implement the trait methods on that one struct. -->
<p>ステートパターンでは、<code>Post</code>のメソッドと<code>Post</code>を使用する箇所で、<code>match</code>式が必要になることはなく、
新しい状態を追加するのにも、新しい構造体を追加し、その1つの構造体にトレイトメソッドを実装するだけでいいわけです。</p>
<!-- The implementation using the state pattern is easy to extend to add more -->
<!-- functionality. To see the simplicity of maintaining code that uses the state -->
<!-- pattern, try a few of these suggestions: -->
<p>ステートパターンを使用した実装は、拡張して機能を増やすことが容易です。
ステートパターンを使用するコードの管理の単純さを確認するために、以下の提言を試してみてください:</p>
<!-- * Add a `reject` method that changes the post’s state from `PendingReview` back -->
<!--   to `Draft`. -->
<!-- * Require two calls to `approve` before the state can be changed to `Published`. -->
<!-- * Allow users to add text content only when a post is in the `Draft` state. -->
<!--   Hint: have the state object responsible for what might change about the -->
<!--   content but not responsible for modifying the `Post`. -->
<ul>
<li>記事の状態を<code>PendingReview</code>から<code>Draft</code>に戻す<code>reject</code>メソッドを追加する。</li>
<li>状態が<code>Published</code>に変化させられる前に<code>approve</code>を2回呼び出す必要があるようにする。</li>
<li>記事が<code>Draft</code>状態の時のみテキスト内容をユーザが追加できるようにする。
ヒント: ステートオブジェクトに内容について変わる可能性のあるものの責任を持たせつつも、
<code>Post</code>を変更することには責任を持たせない。</li>
</ul>
<!-- One downside of the state pattern is that, because the states implement the -->
<!-- transitions between states, some of the states are coupled to each other. If we -->
<!-- add another state between `PendingReview` and `Published`, such as `Scheduled`, -->
<!-- we would have to change the code in `PendingReview` to transition to -->
<!-- `Scheduled` instead. It would be less work if `PendingReview` didn’t need to -->
<!-- change with the addition of a new state, but that would mean switching to -->
<!-- another design pattern. -->
<p>ステートパターンの欠点の1つは、状態が状態間の遷移を実装しているので、状態の一部が密に結合した状態になってしまうことです。
<code>PendingReview</code>と<code>Published</code>の間に、<code>Scheduled</code>のような別の状態を追加したら、
代わりに<code>PendingReview</code>のコードを<code>Scheduled</code>に遷移するように変更しなければならないでしょう。
状態が追加されても<code>PendingReview</code>を変更する必要がなければ、作業が減りますが、
そうすれば別のデザインパターンに切り替えることになります。</p>
<!-- Another downside is that we’ve duplicated some logic. To eliminate some of the -->
<!-- duplication, we might try to make default implementations for the -->
<!-- `request_review` and `approve` methods on the `State` trait that return `self`; -->
<!-- however, this would violate object safety, because the trait doesn’t know what -->
<!-- the concrete `self` will be exactly. We want to be able to use `State` as a -->
<!-- trait object, so we need its methods to be object safe. -->
<p>別の欠点は、ロジックの一部を重複させてしまうことです。重複を除くためには、
<code>State</code>トレイトの<code>request_review</code>と<code>approve</code>メソッドに<code>self</code>を返すデフォルト実装を試みる可能性があります;
ですが、これはオブジェクト安全性を侵害するでしょう。というのも、具体的な<code>self</code>が一体なんなのかトレイトには知りようがないからです。
<code>State</code>をトレイトオブジェクトとして使用できるようにしたいので、メソッドにはオブジェクト安全になってもらう必要があるのです。</p>
<!-- Other duplication includes the similar implementations of the `request_review` -->
<!-- and `approve` methods on `Post`. Both methods delegate to the implementation of -->
<!-- the same method on the value in the `state` field of `Option` and set the new -->
<!-- value of the `state` field to the result. If we had a lot of methods on `Post` -->
<!-- that followed this pattern, we might consider defining a macro to eliminate the -->
<!-- repetition (see Appendix D for more on Macros). -->
<p>他の重複には、<code>Post</code>の<code>request_review</code>と<code>approve</code>メソッドの実装が似ていることが含まれます。
両メソッドは<code>Option</code>の<code>state</code>の値に対する同じメソッドの実装に委譲していて、<code>state</code>フィールドの新しい値を結果にセットします。
このパターンに従う<code>Post</code>のメソッドが多くあれば、マクロを定義して繰り返しを排除することも考える可能性があります(マクロについては付録Dを参照)。</p>
<!-- By implementing the state pattern exactly as it’s defined for object-oriented -->
<!-- languages, we’re not taking as full advantage of Rust’s strengths as we could. -->
<!-- Let’s look at some changes we can make to the `blog` crate that can make -->
<!-- invalid states and transitions into compile time errors. -->
<p>オブジェクト指向言語で定義されている通り忠実にステートパターンを実装することで、
Rustの強みをできるだけ発揮していません。<code>blog</code>クレートに対して行える無効な状態と遷移をコンパイルエラーにできる変更に目を向けましょう。</p>
<!-- #### Encoding States and Behavior as Types -->
<a class="header" href="print.html#a状態と振る舞いを型としてコード化する" id="a状態と振る舞いを型としてコード化する"><h4>状態と振る舞いを型としてコード化する</h4></a>
<!-- We’ll show you how to rethink the state pattern to get a different set of -->
<!-- trade-offs. Rather than encapsulating the states and transitions completely so -->
<!-- outside code has no knowledge of them, we’ll encode the states into different -->
<!-- types. Consequently, Rust’s type checking system will prevent attempts to use -->
<!-- draft posts where only published posts are allowed by issuing a compiler error. -->
<p>ステートパターンを再考して別の代償を得る方法をお見せします。状態と遷移を完全にカプセル化して、
外部のコードに知らせないようにするよりも、状態を異なる型にコード化します。結果的に、
Rustの型検査システムが、公開記事のみが許可される箇所で草稿記事の使用を試みることをコンパイルエラーを発して阻止します。</p>
<!-- Let’s consider the first part of `main` in Listing 17-11: -->
<p>リスト17-11の<code>main</code>の最初の部分を考えましょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
}
</code></pre>
<!-- We still enable the creation of new posts in the draft state using `Post::new` -->
<!-- and the ability to add text to the post’s content. But instead of having a -->
<!-- `content` method on a draft post that returns an empty string, we’ll make it so -->
<!-- draft posts don’t have the `content` method at all. That way, if we try to get -->
<!-- a draft post’s content, we’ll get a compiler error telling us the method -->
<!-- doesn’t exist. As a result, it will be impossible for us to accidentally -->
<!-- display draft post content in production, because that code won’t even compile. -->
<!-- Listing 17-19 shows the definition of a `Post` struct and a `DraftPost` struct, -->
<!-- as well as methods on each: -->
<p>それでも、<code>Post::new</code>で草稿状態の新しい記事を生成することと記事の内容にテキストを追加する能力は可能にします。
しかし、空の文字列を返す草稿記事の<code>content</code>メソッドを保持する代わりに、草稿記事は、
<code>content</code>メソッドを全く持たないようにします。そうすると、草稿記事の内容を得ようとしたら、
メソッドが存在しないというコンパイルエラーになるでしょう。その結果、
誤ってプロダクションコードで草稿記事の内容を表示することが不可能になります。
そのようなコードは、コンパイルさえできないからです。リスト17-19は<code>Post</code>構造体、<code>DraftPost</code>構造体、
さらにメソッドの定義を示しています:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-19: A `Post` with a `content` method and a -->
<!-- `DraftPost` without a `content` method</span> -->
<p><span class="caption">リスト17-19: <code>content</code>メソッドのある<code>Post</code>と<code>content</code>メソッドのない<code>DraftPost</code></span></p>
<!-- Both the `Post` and `DraftPost` structs have a private `content` field that -->
<!-- stores the blog post text. The structs no longer have the `state` field because -->
<!-- we’re moving the encoding of the state to the types of the structs. The `Post` -->
<!-- struct will represent a published post, and it has a `content` method that -->
<!-- returns the `content`. -->
<p><code>Post</code>と<code>DraftPost</code>構造体どちらにもブログ記事のテキストを格納する非公開の<code>content</code>フィールドがあります。
状態のコード化を構造体の型に移動したので、この構造体は最早<code>state</code>フィールドを持ちません。
<code>Post</code>は公開された記事を表し、<code>content</code>を返す<code>content</code>メソッドがあります。</p>
<!-- We still have a `Post::new` function, but instead of returning an instance of -->
<!-- `Post`, it returns an instance of `DraftPost`. Because `content` is private -->
<!-- and there aren’t any functions that return `Post`, it’s not possible to create -->
<!-- an instance of `Post` right now. -->
<p>それでも<code>Post::new</code>関数はありますが、<code>Post</code>のインスタンスを返すのではなく、<code>DraftPost</code>のインスタンスを返します。
<code>content</code>は非公開であり、<code>Post</code>を返す関数も存在しないので、現状<code>Post</code>のインスタンスを生成することは不可能です。</p>
<!-- The `DraftPost` struct has an `add_text` method, so we can add text to  -->
<!-- `content` as before, but note that `DraftPost` does not have a `content` method -->
<!-- defined! So now the program ensures all posts start as draft posts, and draft -->
<!-- posts don’t have their content available for display. Any attempt to get around -->
<!-- these constraints will result in a compiler error. -->
<p><code>DraftPost</code>構造体には、以前のようにテキストを<code>content</code>に追加できるよう<code>add_text</code>メソッドがありますが、
<code>DraftPost</code>には<code>content</code>メソッドが定義されていないことに注目してください！
従って、これでプログラムは、全ての記事が草稿記事から始まり、草稿記事は表示できる内容がないことを保証します。
この制限をかいくぐる試みは、全てコンパイルエラーに落ち着くでしょう。</p>
<!-- #### Implementing Transitions as Transformations into Different Types -->
<a class="header" href="print.html#a遷移を異なる型への変形として実装する" id="a遷移を異なる型への変形として実装する"><h4>遷移を異なる型への変形として実装する</h4></a>
<!-- 1行目the rule thatは同格で訳しているが、the rule that a draft post has (the rule) to be...でも意味は通りそう -->
<!-- So how do we get a published post? We want to enforce the rule that a draft -->
<!-- post has to be reviewed and approved before it can be published. A post in the -->
<!-- pending review state should still not display any content. Let’s implement -->
<!-- these constraints by adding another struct, `PendingReviewPost`, defining the -->
<!-- `request_review` method on `DraftPost` to return a `PendingReviewPost`, and -->
<!-- defining an `approve` method on `PendingReviewPost` to return a `Post`, as -->
<!-- shown in Listing 17-20: -->
<p>では、どうやって公開された記事を得るのでしょうか？公開される前に草稿記事は査読され、
承認されなければならないという規則を強制したいです。査読待ち状態の記事は、それでも内容を表示するべきではありません。
別の構造体<code>PendingReviewPost</code>を追加し、<code>DraftPost</code>に<code>PendingReviewPost</code>を返す<code>request_review</code>メソッドを定義し、
<code>PendingReviewPost</code>に<code>Post</code>を返す<code>approve</code>メソッドを定義してこれらの制限を実装しましょう。リスト17-20のようにですね:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
# pub struct DraftPost {
#     content: String,
# }
#
impl DraftPost {
    // --snip--

    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 17-20: A `PendingReviewPost` that gets created by -->
<!-- calling `request_review` on `DraftPost` and an `approve` method that turns a -->
<!-- `PendingReviewPost` into a published `Post`</span> -->
<p><span class="caption">リスト17-20: <code>DraftPost</code>の<code>request_review</code>を呼び出すことで生成される<code>PendingReviewPost</code>と、
<code>PendingReviewPost</code>を公開された<code>Post</code>に変換する<code>approve</code>メソッド</span></p>
<!-- The `request_review` and `approve` methods take ownership of `self`, thus -->
<!-- consuming the `DraftPost` and `PendingReviewPost` instances and transforming -->
<!-- them into a `PendingReviewPost` and a published `Post`, respectively. This way, -->
<!-- we won’t have any lingering `DraftPost` instances after we’ve called -->
<!-- `request_review` on them, and so forth. The `PendingReviewPost` struct doesn’t -->
<!-- have a `content` method defined on it, so attempting to read its content -->
<!-- results in a compiler error, as with `DraftPost`. Because the only way to get a -->
<!-- published `Post` instance that does have a `content` method defined is to call -->
<!-- the `approve` method on a `PendingReviewPost`, and the only way to get a -->
<!-- `PendingReviewPost` is to call the `request_review` method on a `DraftPost`, -->
<!-- we’ve now encoded the blog post workflow into the type system. -->
<p><code>request_review</code>と<code>approve</code>メソッドは<code>self</code>の所有権を奪い、故に<code>DraftPost</code>と<code>PendingReviewPost</code>インスタンスを消費し、
それぞれ<code>PendingReviewPost</code>と公開された<code>Post</code>に変形します。このように、
<code>DraftPost</code>インスタンスに<code>request_review</code>を呼んだ後には、<code>DraftPost</code>インスタンスは生きながらえず、
以下同様です。<code>PendingReviewPost</code>構造体には、<code>content</code>メソッドが定義されていないので、
<code>DraftPost</code>同様に、その内容を読もうとするとコンパイルエラーに落ち着きます。
<code>content</code>メソッドが確かに定義された公開された<code>Post</code>インスタンスを得る唯一の方法が、
<code>PendingReviewPost</code>に対して<code>approve</code>を呼び出すことであり、<code>PendingReviewPost</code>を得る唯一の方法が、
<code>DraftPost</code>に<code>request_review</code>を呼び出すことなので、これでブログ記事のワークフローを型システムにコード化しました。</p>
<!-- But we also have to make some small changes to `main`. The `request_review` and -->
<!-- `approve` methods return new instances rather than modifying the struct they’re -->
<!-- called on, so we need to add more `let post =` shadowing assignments to save -->
<!-- the returned instances. We also can’t have the assertions about the draft and -->
<!-- pending review post’s contents be empty strings, nor do we need them: we can’t -->
<!-- compile code that tries to use the content of posts in those states any longer. -->
<!-- The updated code in `main` is shown in Listing 17-21: -->
<p>ですが、さらに<code>main</code>にも多少小さな変更を行わなければなりません。<code>request_review</code>と<code>approve</code>メソッドは、
呼ばれた構造体を変更するのではなく、新しいインスタンスを返すので、<code>let post =</code>という上書き代入をもっと追加し、
返却されたインスタンスを保存する必要があります。また、草稿と査読待ち記事の内容を空の文字列でアサートすることも、
する必要もありません: 最早、その状態にある記事の内容を使用しようとするコードはコンパイル不可能だからです。
<code>main</code>の更新されたコードは、リスト17-21に示されています:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<!-- <span class="caption">Listing 17-21: Modifications to `main` to use the new -->
<!-- implementation of the blog post workflow</span> -->
<p><span class="caption">リスト17-21: ブログ記事ワークフローの新しい実装を使う<code>main</code>の変更</span></p>
<!-- The changes we needed to make to `main` to reassign `post` mean that this -->
<!-- implementation doesn’t quite follow the object-oriented state pattern anymore: -->
<!-- the transformations between the states are no longer encapsulated entirely -->
<!-- within the `Post` implementation. However, our gain is that invalid states are -->
<!-- now impossible because of the type system and the type checking that happens at -->
<!-- compile time! This ensures that certain bugs, such as display of the content of -->
<!-- an unpublished post, will be discovered before they make it to production. -->
<p><code>post</code>を再代入するために<code>main</code>に行う必要のあった変更は、この実装が最早、
全くオブジェクト指向のステートパターンに沿っていないことを意味します:
状態間の変形は最早、<code>Post</code>実装内に完全にカプセル化されていません。
ですが、型システムとコンパイル時に起きる型チェックのおかげでもう無効な状態があり得なくなりました。
これにより、未公開の記事の内容が表示されるなどの特定のバグが、プロダクションコードに移る前に発見されることが保証されます。</p>
<!-- 特に2行目中盤、as it is afterがよくわからない -->
<!-- as it is, afterで訳した -->
<!-- Try the tasks suggested for additional requirements that we mentioned at the -->
<!-- start of this section on the `blog` crate as it is after Listing 17-20 to see -->
<!-- what you think about the design of this version of the code. Note that some of -->
<!-- the tasks might be completed already in this design. -->
<p><code>blog</code>クレートに関してこの節の冒頭で触れた追加の要求に提言される作業をそのままリスト17-20の後に試してみて、
このバージョンのコードについてどう思うか確かめてください。この設計では、
既に作業の一部が達成されている可能性があることに注意してください。</p>
<!-- We’ve seen that even though Rust is capable of implementing object-oriented -->
<!-- design patterns, other patterns, such as encoding state into the type system, -->
<!-- are also available in Rust. These patterns have different trade-offs. Although -->
<!-- you might be very familiar with object-oriented patterns, rethinking the -->
<!-- problem to take advantage of Rust’s features can provide benefits, such as -->
<!-- preventing some bugs at compile time. Object-oriented patterns won’t always be -->
<!-- the best solution in Rust due to certain features, like ownership, that -->
<!-- object-oriented languages don’t have. -->
<p>Rustは、オブジェクト指向のデザインパターンを実装する能力があるものの、状態を型システムにコード化するなどの他のパターンも、
Rustでは利用可能なことを確かめました。これらのパターンには、異なる代償があります。
オブジェクト指向のパターンには馴染み深い可能性があるものの、問題を再考してRustの機能の強みを活かすと、
コンパイル時に一部のバグを回避できるなどの利益が得られることもあります。オブジェクト指向のパターンは、
オブジェクト指向言語にはない所有権などの特定の機能によりRustでは、必ずしも最善の解決策ではないでしょう。</p>
<!-- ## Summary -->
<a class="header" href="print.html#a総括-1" id="a総括-1"><h2>総括</h2></a>
<!-- No matter whether or not you think Rust is an object-oriented language after -->
<!-- reading this chapter, you now know that you can use trait objects to get some -->
<!-- object-oriented features in Rust. Dynamic dispatch can give your code some -->
<!-- flexibility in exchange for a bit of runtime performance. You can use this -->
<!-- flexibility to implement object-oriented patterns that can help your code’s -->
<!-- maintainability. Rust also has other features, like ownership, that -->
<!-- object-oriented languages don’t have. An object-oriented pattern won’t always -->
<!-- be the best way to take advantage of Rust’s strengths, but is an available -->
<!-- option. -->
<p>この章読了後に、あなたがRustはオブジェクト指向言語であるか考えるかどうかに関わらず、
もうトレイトオブジェクトを使用してRustでオブジェクト指向の機能の一部を得ることができると知っています。
ダイナミックディスパッチは、多少の実行時性能と引き換えにコードに柔軟性を<ruby>齎<rp>(</rp><rt>もたら</rt><rp>)</rp></ruby>してくれます。
この柔軟性を利用してコードのメンテナンス性に寄与するオブジェクト指向パターンを実装することができます。
Rustにはまた、オブジェクト指向言語にはない所有権などの他の機能もあります。オブジェクト指向パターンは、
必ずしもRustの強みを活かす最善の方法にはなりませんが、選択肢の1つではあります。</p>
<!-- Next, we’ll look at patterns, which are another of Rust’s features that enable -->
<!-- lots of flexibility. We’ve looked at them briefly throughout the book but -->
<!-- haven’t seen their full capability yet. Let’s go! -->
<p>次は、パターンを見ます。パターンも多くの柔軟性を可能にするRustの別の機能です。
本全体を通して僅かに見かけましたが、まだその全能力は目の当たりにしていません。さあ、行きましょう！</p>
<!-- # Patterns and Matching -->
<a class="header" href="print.html#aパターンとマッチング" id="aパターンとマッチング"><h1>パターンとマッチング</h1></a>
<!-- Patterns are a special syntax in Rust for matching against the structure of -->
<!-- types, both complex and simple. Using patterns in conjunction with `match` -->
<!-- expressions and other constructs gives you more control over a program’s -->
<!-- control flow. A pattern consists of some combination of the following: -->
<p>パターンは、Rustで複雑であれ、単純であれ、型の構造に一致する特別な記法です。<code>match</code>式や他の構文と組み合わせてパターンを使用すると、
プログラムの制御フローをよりコントロールできます。パターンは、以下の組み合わせで構成されます:</p>
<!-- * Literals -->
<!-- * Destructured arrays, enums, structs, or tuples -->
<!-- * Variables -->
<!-- * Wildcards -->
<!-- * Placeholders -->
<ul>
<li>リテラル</li>
<li>分解された配列、enum、構造体、タプル</li>
<li>変数</li>
<li>ワイルドカード</li>
<li>プレースホルダー</li>
</ul>
<!-- These components describe the shape of the data we’re working with, which we -->
<!-- then match against values to determine whether our program has the correct data -->
<!-- to continue running a particular piece of code. -->
<p>これらの要素が取り組んでいるデータの形を説明し、それから値に対してマッチを行い、
プログラムに正しい値があって特定のコードを実行し続けられるかどうかを決定します。</p>
<!-- To use a pattern, we compare it to some value. If the pattern matches the -->
<!-- value, we use the value parts in our code. Recall the `match` expressions in -->
<!-- Chapter 6 that used patterns, such as the coin-sorting machine example. If the -->
<!-- value fits the shape of the pattern, we can use the named pieces. If it -->
<!-- doesn’t, the code associated with the pattern won’t run. -->
<p>パターンを使用するには、なんらかの値と比較します。パターンが値に合致したら、コードで値の部分を使用します。
コイン並び替えマシンの例のような第6章でパターンを使用した<code>match</code>式を思い出してください。
値がパターンの形に当てはまったら、名前のある部品を使用できます。当てはまらなければ、
パターンに紐付いたコードは実行されません。</p>
<!-- This chapter is a reference on all things related to patterns. We’ll cover the -->
<!-- valid places to use patterns, the difference between refutable and irrefutable -->
<!-- patterns, and the different kinds of pattern syntax that you might see. By the -->
<!-- end of the chapter, you’ll know how to use patterns to express many concepts in -->
<!-- a clear way. -->
<p>この章は、パターンに関連するあらゆるものの参照です。パターンを使用するのが合法な箇所、
<ruby>論駁<rp>(</rp><rt>ろんばく</rt><rp>)</rp></ruby>可能と論駁不可能なパターンの違い、
目撃する可能性のある色々な種類のパターン記法を講義します。章の終わりまでに、
パターンを使用して多くの概念をはっきり表現する方法を知るでしょう。</p>
<!-- ## All the Places Patterns Can Be Used -->
<a class="header" href="print.html#aパターンが使用されることのある箇所全部" id="aパターンが使用されることのある箇所全部"><h2>パターンが使用されることのある箇所全部</h2></a>
<!-- Patterns pop up in a number of places in Rust, and you’ve been using them a lot -->
<!-- without realizing it! This section dicusses all the places where patterns are -->
<!-- valid. -->
<p>Rustにおいて、パターンはいろんな箇所に出現し、そうと気づかないうちにたくさん使用してきました！
この節は、パターンが合法な箇所全部を議論します。</p>
<!-- ### `match` Arms -->
<a class="header" href="print.html#matchアーム" id="matchアーム"><h3><code>match</code>アーム</h3></a>
<!-- As discussed in Chapter 6, we use patterns in the arms of `match` expressions. -->
<!-- Formally, `match` expressions are defined as the keyword `match`, a value to -->
<!-- match on, and one or more match arms that consist of a pattern and an -->
<!-- expression to run if the value matches that arm’s pattern, like this: -->
<p>第6章で議論したように、パターンを<code>match</code>式のアームで使います。正式には、<code>match</code>式はキーワード<code>match</code>、
マッチ対象の値、パターンとそのアームのパターンに値が合致したら実行される式からなる1つ以上のマッチアームとして定義されます。
以下のように:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<!-- One requirement for `match` expressions is that they need to be *exhaustive* in -->
<!-- the sense that all possibilities for the value in the `match` expression must -->
<!-- be accounted for. One way to ensure you’ve covered every possibility is to have -->
<!-- a catchall pattern for the last arm: for example, a variable name matching any -->
<!-- value can never fail and thus covers every remaining case. -->
<p><code>match</code>式の必須事項の1つは、<code>match</code>式の値の可能性全てが考慮されなければならないという意味で<em>網羅的</em>である必要があることです。
全可能性をカバーしていると保証する1つの手段は、最後のアームに包括的なパターンを入れることです:
例えば、どんな値にも合致する変数名は失敗することがあり得ないので、故に残りの全ケースをカバーできます。</p>
<!-- A particular pattern `_` will match anything, but it never binds to a variable, -->
<!-- so it’s often used in the last match arm. The `_` pattern can be useful when -->
<!-- you want to ignore any value not specified, for example. We’ll cover the `_` -->
<!-- pattern in more detail in the “Ignoring Values in a Pattern” section later in -->
<!-- this chapter. -->
<p><code>_</code>という特定のパターンは何にでもマッチしますが、変数には束縛されないので、よく最後のマッチアームに使用されます。
例えば、<code>_</code>パターンは、指定されていないあらゆる値を無視したい時に有用です。
<code>_</code>パターンについて詳しくは、この章の後ほど、「パターンで値を無視する」節で講義します。</p>
<!-- ### Conditional `if let` Expressions -->
<a class="header" href="print.html#a条件分岐if-let式" id="a条件分岐if-let式"><h3>条件分岐<code>if let</code>式</h3></a>
<!-- In Chapter 6 we discussed how to use `if let` expressions mainly as a shorter -->
<!-- way to write the equivalent of a `match` that only matches one case. -->
<!-- Optionally, `if let` can have a corresponding `else` containing code to run if -->
<!-- the pattern in the `if let` doesn’t match. -->
<p>第6章で主に<code>if let</code>式を1つの場合にしか合致しない<code>match</code>と同様のものを書く省略法として使用する方法を議論しました。
オプションとして、<code>if let</code>には<code>if let</code>のパターンが合致しない時に走るコードを含む対応する<code>else</code>も用意できます。</p>
<!-- Listing 18-1 shows that it’s also possible to mix and match `if let`, `else -->
<!-- if`, and `else if let` expressions. Doing so gives us more flexibility than a -->
<!-- `match` expression in which we can only express one value to compare with the -->
<!-- patterns. Also, the conditions in a series of `if let`, `else if`, `else if -->
<!-- let` arms aren’t required to relate to each other. -->
<p>リスト18-1は、<code>if let</code>、<code>else if</code>、<code>else if let</code>式を混ぜて合致させることもできることを示しています。
そうすると、パターンと1つの値しか比較することを表現できない<code>match</code>式よりも柔軟性が高くなります。
また、一連の<code>if let</code>、<code>else if</code>、<code>else if let</code>アームの条件は、お互いに関連している必要はありません。</p>
<!-- The code in Listing 18-1 shows a series of checks for several conditions that -->
<!-- decide what the background color should be. For this example, we've created -->
<!-- variables with hardcoded values that a real program might receive from user -->
<!-- input. -->
<p>リスト18-1のコードは、背景色が何になるべきかを決定するいくつかの異なる条件を連なって確認するところを示しています。
この例には、実際のプログラムではユーザ入力を受け付ける可能性のある変数をハードコードされた値で生成しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        // あなたのお気に入りの色、{}を背景色に使用します
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        // 火曜日は緑の日！
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            // 紫を背景色に使用します
            println!(&quot;Using purple as the background color&quot;);
        } else {
            // オレンジを背景色に使用します
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        // 青を背景色に使用します
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-1: Mixing `if let`, `else if`, `else if let`, -->
<!-- and `else`</span> -->
<p><span class="caption">リスト18-1: <code>if let</code>、<code>else if</code>、<code>else if let</code>、<code>else</code>を混ぜる</span></p>
<!-- If the user specifies a favorite color, that color is the background color. If -->
<!-- today is Tuesday, the background color is green. If the user specifies -->
<!-- their age as a string and we can parse it as a number successfully, the color -->
<!-- is either purple or orange depending on the value of the number. If none of -->
<!-- these conditions apply, the background color is blue: -->
<p>ユーザがお気に入りの色を指定したら、その色が背景色になります。今日が火曜日なら、背景色は緑です。
ユーザが年齢を文字列で指定し、数値として解析することができたら、背景色は、その数値の値によって紫かオレンジになります。
どの条件も適用できなければ、背景色は青になります:</p>
<!-- This conditional structure lets us support complex requirements. With the -->
<!-- hardcoded values we have here, this example will print `Using purple as the -->
<!-- background color`. -->
<p>この条件分岐構造により、複雑な要件をサポートさせてくれます。ここにあるハードコードされた値では、
この例は<code>Using purple as the background color</code>と出力するでしょう。</p>
<!-- You can see that `if let` can also introduce shadowed variables in the same way -->
<!-- that `match` arms can: the line `if let Ok(age) = age` introduces a new -->
<!-- shadowed `age` variable that contains the value inside the `Ok` variant. This -->
<!-- means we need to place the `if age > 30` condition within that block: we can’t -->
<!-- combine these two conditions into `if let Ok(age) = age && age > 30`. The -->
<!-- shadowed `age` we want to compare to 30 isn’t valid until the new scope starts -->
<!-- with the curly bracket. -->
<p><code>match</code>アームのように<code>if let</code>もシャドウイングされた変数を導入できることがわかります:
<code>if let Ok(age) = age</code>の行は、<code>Ok</code>列挙子の中の値を含むシャドウイングされた新しい<code>age</code>変数を導入します。
つまり、<code>if age &gt; 30</code>という条件は、そのブロック内に配置する必要があります: これら2つの条件を組み合わせて、
<code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>とすることはできません。30と比較したいシャドウイングされた<code>age</code>は、
波括弧で新しいスコープが始まるまで有効にならないのです。</p>
<!-- The downside of using `if let` expressions is that the compiler doesn’t check -->
<!-- exhaustiveness, whereas with `match` expressions it does. If we omitted the -->
<!-- last `else` block and therefore missed handling some cases, the compiler would -->
<!-- not alert us to the possible logic bug. -->
<p><code>if let</code>式を使うことの欠点は、コンパイラが網羅性を確認してくれないことです。一方で<code>match</code>式ではしてくれます。
最後の<code>else</code>ブロックを省略して故に、扱い忘れたケースがあっても、コンパイラは、ロジックバグの可能性を指摘してくれないでしょう。</p>
<!-- ### `while let` Conditional Loops -->
<a class="header" href="print.html#while-let条件分岐ループ" id="while-let条件分岐ループ"><h3><code>while let</code>条件分岐ループ</h3></a>
<!-- Similar in construction to `if let`, the `while let` conditional loop allows a -->
<!-- `while` loop to run for as long as a pattern continues to match. The example in -->
<!-- Listing 18-2 shows a `while let` loop that uses a vector as a stack and prints -->
<!-- the values in the vector in the opposite order in which they were pushed: -->
<p><code>if let</code>と構成が似て、<code>while let</code>条件分岐ループは、パターンが合致し続ける限り、<code>while</code>ループを走らせます。
リスト18-2の例は、ベクタをスタックとして使用する<code>while let</code>ループを示し、
ベクタの値をプッシュしたのとは逆順に出力します:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-2: Using a `while let` loop to print values -->
<!-- for as long as `stack.pop()` returns `Some`</span> -->
<p><span class="caption">リスト18-2: <code>while let</code>ループを使って<code>stack.pop()</code>が<code>Some</code>を返す限り値を出力する</span></p>
<!-- This example prints 3, 2, and then 1. The `pop` method takes the last element -->
<!-- out of the vector and returns `Some(value)`. If the vector is empty, `pop` -->
<!-- returns `None`. The `while` loop continues running the code in its block as -->
<!-- long as `pop` returns `Some`. When `pop` returns `None`, the loop stops. We can -->
<!-- use `while let` to pop every element off our stack. -->
<p>この例は、3, 2, そして1と出力します。<code>pop</code>メソッドはベクタの最後の要素を取り出して<code>Some(value)</code>を返します。
ベクタが空なら、<code>pop</code>は<code>None</code>を返します。<code>while</code>ループは<code>pop</code>が<code>Some</code>を返す限り、ブロックのコードを実行し続けます。
<code>pop</code>が<code>None</code>を返すと、ループは停止します。<code>while let</code>を使用してスタックから全ての要素を取り出せるのです。</p>
<!-- ### `for` Loops -->
<a class="header" href="print.html#forループ" id="forループ"><h3><code>for</code>ループ</h3></a>
<!-- In Chapter 3, we mentioned that the `for` loop is the most common loop -->
<!-- construction in Rust code, but we haven’t yet discussed the pattern that `for` -->
<!-- takes. In a `for` loop, the pattern is the value that directly follows the -->
<!-- keyword `for`, so in `for x in y` the `x` is the pattern. -->
<p>第3章で、Rustコードにおいては、<code>for</code>ループが最もよく使われるループ構造だと述べましたが、
<code>for</code>が取るパターンについてはまだ議論してませんでした。<code>for</code>ループにおいて、
直接キーワード<code>for</code>に続く値がパターンなので、<code>for x in y</code>では、<code>x</code>がパターンになります。</p>
<!-- Listing 18-3 demonstrates how to use a pattern in a `for` loop to destructure, -->
<!-- or break apart, a tuple as part of the `for` loop. -->
<p>リスト18-3は<code>for</code>ループでパターンを使用して<code>for</code>ループの一部としてタプルを分解あるいは、分離する方法をデモしています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-3: Using a pattern in a `for` loop to -->
<!-- destructure a tuple</span> -->
<p><span class="caption">リスト18-3: <code>for</code>ループでパターンを使用してタプルを分解する</span></p>
<!-- The code in Listing 18-3 will print the following: -->
<p>リスト18-3のコードは、以下のように出力するでしょう:</p>
<pre><code class="language-text">a is at index 0
b is at index 1
c is at index 2
</code></pre>
<!-- We use the `enumerate` method to adapt an iterator to produce a value and that -->
<!-- value’s index in the iterator, placed into a tuple. The first call to -->
<!-- `enumerate` produces the tuple `(0, 'a')`. When this value is matched to the -->
<!-- pattern `(index, value)`, `index` will be `0` and `value` will be `'a'`, -->
<!-- printing the first line of the output. -->
<p><code>enumerate</code>メソッドを使用してイテレータを改造し、値とその値のイテレータでの番号をタプルに配置して生成しています。
<code>enumerate</code>の最初の呼び出しは、タプル<code>(0, 'a')</code>を生成します。この値がパターン<code>(index, value)</code>とマッチさせられると、
<code>index</code>は<code>0</code>、<code>value</code>は<code>'a'</code>になり、出力の最初の行を出力するのです。</p>
<!-- ### `let` Statements -->
<a class="header" href="print.html#let文" id="let文"><h3><code>let</code>文</h3></a>
<!-- Prior to this chapter, we had only explicitly discussed using patterns with -->
<!-- `match` and `if let`, but in fact, we’ve used patterns in other places as well, -->
<!-- including in `let` statements. For example, consider this straightforward -->
<!-- variable assignment with `let`: -->
<p>この章に先駆けて、<code>match</code>と<code>if let</code>でパターンを使用することだけ明示的に議論してきましたが、
実は<code>let</code>文を含む他の箇所でもパターンを使用してきたのです。例として、この<code>let</code>での率直な変数代入を考えてください:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<!-- Throughout this book, we’ve used `let` like this hundreds of times, and -->
<!-- although you might not have realized it, you were using patterns! More -->
<!-- formally, a `let` statement looks like this: -->
<p>この本を通してこのような<code>let</code>を何百回も使用してきて、お気付きではなかったかもしれませんが、
パターンを使用していたのです！より正式には、<code>let</code>文はこんな見た目をしています:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<!-- In statements like `let x = 5;` with a variable name in the `PATTERN` slot, the -->
<!-- variable name is just a particularly simple form of a pattern. Rust compares -->
<!-- the expression against the pattern and assigns any names it finds. So in the -->
<!-- `let x = 5;` example, `x` is a pattern that means “bind what matches here to -->
<!-- the variable `x`.” Because the name `x` is the whole pattern, this pattern -->
<!-- effectively means “bind everything to the variable `x`, whatever the value is.” -->
<p><code>let x = 5;</code>のような変数名が<code>PATTERN</code>スロットにある文で、変数名は、ただ特に単純な形態のパターンなのです。
Rustは式をパターンと比較し、見つかったあらゆる名前を代入します。故に、<code>let x = 5;</code>の例では、
<code>x</code>は「ここでマッチしたものを変数<code>x</code>に束縛する」ことを意味するパターンです。
名前<code>x</code>がパターンの全容なので、このパターンは実質的に「値が何であれ、全てを変数<code>x</code>に束縛しろ」を意味します。</p>
<!-- To see the pattern matching aspect of `let` more clearly, consider Listing -->
<!-- 18-4, which uses a pattern with `let` to destructure a tuple. -->
<p><code>let</code>のパターンマッチングの観点をよりはっきり確認するためにリスト18-4を考えてください。
これは<code>let</code>でパターンを使用し、タプルを分解します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (x, y, z) = (1, 2, 3);
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-4: Using a pattern to destructure a tuple and -->
<!-- create three variables at once</span> -->
<p><span class="caption">リスト18-4: パターンを使用してタプルを分解し、3つの変数を一度に生成する</span></p>
<!-- Here, we match a tuple against a pattern. Rust compares the value `(1, 2, 3)` -->
<!-- to the pattern `(x, y, z)` and sees that the value matches the pattern, so Rust -->
<!-- binds `1` to `x`, `2` to `y`, and `3` to `z`. You can think of this tuple -->
<!-- pattern as nesting three individual variable patterns inside it. -->
<p>ここでタプルに対してパターンをマッチさせています。Rustは値<code>(1, 2, 3)</code>をパターン<code>(x, y, z)</code>と比較し、
値がパターンに合致すると確認するので、<code>1</code>を<code>x</code>に、<code>2</code>を<code>y</code>に、<code>3</code>を<code>z</code>に束縛します。
このタプルパターンを個別の3つの変数パターンが内部にネストされていると考えることもできます。</p>
<!-- If the number of elements in the pattern doesn’t match the number of elements -->
<!-- in the tuple, the overall type won’t match and we’ll get a compiler error. For -->
<!-- example, Listing 18-5 shows an attempt to destructure a tuple with three -->
<!-- elements into two variables, which won’t work. -->
<p>パターンの要素数がタプルの要素数と一致しない場合、全体の型が一致せず、コンパイルエラーになるでしょう。
例えば、リスト18-5は、3要素のタプルを2つの変数に分解しようとしているところを表示していて、動きません。</p>
<pre><code class="language-rust ignore">let (x, y) = (1, 2, 3);
</code></pre>
<!-- <span class="caption">Listing 18-5: Incorrectly constructing a pattern whose -->
<!-- variables don’t match the number of elements in the tuple</span> -->
<p><span class="caption">リスト18-5: 変数がタプルの要素数と一致しないパターンを間違って構成する</span></p>
<!-- Attempting to compile this code results in this type error: -->
<p>このコードのコンパイルを試みると、このような型エラーに落ち着きます:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected type `({integer}, {integer}, {integer})`
             found type `(_, _)`
</code></pre>
<!-- If we wanted to ignore one or more of the values in the tuple, we could use `_` -->
<!-- or `..`, as you’ll see in the “Ignoring Values in a Pattern” section. If the -->
<!-- problem is that we have too many variables in the pattern, the solution is to -->
<!-- make the types match by removing variables so the number of variables equals -->
<!-- the number of elements in the tuple. -->
<p>タプルの値のうち1つ以上を無視したかったら、「パターンで値を無視する」節で見かけるように、
<code>_</code>か<code>..</code>を使用できるでしょう。パターンに変数が多すぎるというのが問題なら、変数の数がタプルの要素数と一致するように変数を減らすことで、
型を一致させることが解決策です。</p>
<!-- ### Function Parameters -->
<a class="header" href="print.html#a関数の引数-1" id="a関数の引数-1"><h3>関数の引数</h3></a>
<!-- Function parameters can also be patterns. The code in Listing 18-6, which -->
<!-- declares a function named `foo` that takes one parameter named `x` of type -->
<!-- `i32`, should by now look familiar. -->
<p>関数の引数もパターンにできます。リスト18-6のコードは、型<code>i32</code>の<code>x</code>という引数1つを取る<code>foo</code>という関数を宣言していますが、
これまでに馴染み深くなっているはずです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) {
    // コードがここに来る
    // code goes here
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-6: A function signature uses patterns in the -->
<!-- parameters</span> -->
<p><span class="caption">リスト18-6: 関数シグニチャが引数にパターンを使用している</span></p>
<!-- The `x` part is a pattern! As we did with `let`, we could match a tuple in a -->
<!-- function’s arguments to the pattern. Listing 18-7 splits the values in a tuple -->
<!-- as we pass it to a function. -->
<p><code>x</code>の部分がパターンです！<code>let</code>のように、関数の引数でパターンにタプルを合致させられるでしょう。
リスト18-7では、タプルを関数に渡したのでその中の値を分離しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    // 現在の位置: ({}, {})
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-7: A function with parameters that destructure -->
<!-- a tuple</span> -->
<p><span class="caption">リスト18-7: タプルを分解する引数を伴う関数</span></p>
<!-- This code prints `Current location: (3, 5)`. The values `&(3, 5)` match the -->
<!-- pattern `&(x, y)`, so `x` is the value `3` and `y` is the value `5`. -->
<p>このコードは<code>Current location: (3, 5)</code>と出力します。値<code>&amp;(3, 5)</code>はパターン<code>&amp;(x, y)</code>と合致するので、
<code>x</code>は値3、<code>y</code>は値<code>5</code>になります。</p>
<!-- We can also use patterns in closure parameter lists in the same way as in -->
<!-- function parameter lists, because closures are similar to functions, as -->
<!-- discussed in Chapter 13. -->
<p>また、クロージャの引数リストでも、関数の引数リストのようにパターンを使用することができます。
第13章で議論したように、クロージャは関数に似ているからです。</p>
<!-- At this point, you’ve seen several ways of using patterns, but patterns don’t -->
<!-- work the same in every place we can use them. In some places, the patterns must -->
<!-- be irrefutable; In other circumstances, they can be refutable. We'll discuss -->
<!-- these two concepts next. -->
<p>この時点で、パターンを使用する方法をいくつか見てきましたが、パターンを使用できる箇所全部で同じ動作をするわけではありません。
パターンが論駁不可能でなければならない箇所もあります。他の状況では、論駁可能にもなり得ます。この2つの概念を次に議論します。</p>
<!-- ## Refutability: Whether a Pattern Might Fail to Match -->
<a class="header" href="print.html#a論駁可能性-パターンが合致しないか" id="a論駁可能性-パターンが合致しないか"><h2>論駁可能性: パターンが合致しないか</h2></a>
<!-- Patterns come in two forms: refutable and irrefutable. Patterns that will match -->
<!-- for any possible value passed are *irrefutable*. An example would be `x` in the -->
<!-- statement `let x = 5;` because `x` matches anything and therefore cannot fail -->
<!-- to match. Patterns that can fail to match for some possible value are -->
<!-- *refutable*. An example would be `Some(x)` in the expression `if let Some(x) = -->
<!-- a_value`; because if the value in `a_value` variable is `None` rather than -->
<!-- `Some`, the `Some(x)` pattern will not match. -->
<p>パターンには2つの形態があります: 論駁可能なものと論駁不可能なものです。渡される可能性のあるあらゆる値に合致するパターンは、
<em>論駁不可能</em>なものです。<code>x</code>は何にでも合致し、故に合致に失敗することがあり得ないので、文<code>let x = 5;</code>の<code>x</code>は一例です。
なんらかの可能性のある値に対して合致しないことがあるパターンは、<em>論駁可能</em>なものです。
一例は、式<code>if let Some(x) = a_value</code>の<code>Some(x)</code>になるでしょう; <code>a_value</code>変数の値が<code>Some</code>ではなく、
<code>None</code>なら、<code>Some(x)</code>パターンは合致しないでしょうから。</p>
<!-- Function parameters, `let` statements, and `for` loops can only accept -->
<!-- irrefutable patterns, because the program cannot do anything meaningful when -->
<!-- values don’t match. The `if let` and `while let` expressions only accept -->
<!-- refutable patterns, because by definition they’re intended to handle possible -->
<!-- failure: the functionality of a conditional is in its ability to perform -->
<!-- differently depending on success or failure. -->
<p>関数の引数、<code>let</code>文、<code>for</code>ループは、値が合致しなかったら何も意味のあることをプログラムが実行できないので、
論駁不可能なパターンしか受け付けられません。<code>if let</code>と<code>while let</code>式は、定義により失敗する可能性を処理することを意図したものなので、
論駁可能なパターンのみを受け付けます: 条件式の機能は、成功か失敗によって異なる振る舞いをする能力にあるのです。</p>
<!-- In general, you shouldn’t have to worry about the distinction between refutable -->
<!-- and irrefutable patterns; however, you do need to be familiar with the concept -->
<!-- of refutability so you can respond when you see it in an error message. In -->
<!-- those cases, you’ll need to change either the pattern or the construct you’re -->
<!-- using the pattern with, depending on the intended behavior of the code. -->
<p>一般的に、論駁可能と論駁不可能なパターンの差異について心配しなくてもいいはずです; しかしながら、
エラーメッセージで見かけた際に対応できるように、論駁可能性の概念に確かに慣れておく必要があります。
そのような場合には、コードの意図した振る舞いに応じて、パターンかパターンを使用している構文を変える必要があるでしょう。</p>
<!-- Let’s look at an example of what happens when we try to use a refutable pattern -->
<!-- where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a -->
<!-- `let` statement, but for the pattern we’ve specified `Some(x)`, a refutable -->
<!-- pattern. As you might expect, this code will not compile. -->
<p>コンパイラが論駁不可能なパターンを必要とする箇所で論駁可能なパターンを使用しようとしたら、何が起きるかとその逆の例を見ましょう。
リスト18-8は<code>let</code>文を示していますが、パターンには<code>Some(x)</code>と指定し、論駁可能なパターンです。
予想しているかもしれませんが、このコードはコンパイルできません。</p>
<pre><code class="language-rust ignore">let Some(x) = some_option_value;
</code></pre>
<!-- <span class="caption">Listing 18-8: Attempting to use a refutable pattern with -->
<!-- `let`</span> -->
<p><span class="caption">リスト18-8: <code>let</code>で論駁可能なパターンを使用しようとする</span></p>
<!-- If `some_option_value` was a `None` value, it would fail to match the pattern -->
<!-- `Some(x)`, meaning the pattern is refutable. However, the `let` statement can -->
<!-- only accept an irrefutable pattern because there is nothing valid the code can -->
<!-- do with a `None` value. At compile time, Rust will complain that we’ve tried to -->
<!-- use a refutable pattern where an irrefutable pattern is required: -->
<p><code>some_option_value</code>が<code>None</code>値だったなら、パターン<code>Some(x)</code>に合致しないことになり、パターンが論駁可能であることを意味します。
ですが、<code>let</code>文は論駁不可能なパターンしか受け付けられません。<code>None</code>値に対してコードができる合法なことは何もないからです。
コンパイル時にコンパイラは、論駁不可能なパターンが必要な箇所に論駁可能なパターンを使用しようとしたと文句を言うでしょう:</p>
<pre><code class="language-text">error[E0005]: refutable pattern in local binding: `None` not covered
(エラー: ローカル束縛に論駁可能なパターン: `None`がカバーされていません)
 --&gt;
  |
3 | let Some(x) = some_option_value;
  |     ^^^^^^^ pattern `None` not covered
</code></pre>
<!-- Because we didn’t cover (and couldn’t cover!) every valid value with the -->
<!-- pattern `Some(x)`, Rust rightfully produces a compiler error. -->
<p>パターン<code>Some(x)</code>で全ての合法な値をカバーしなかった(できません！)ので、
コンパイラは当然、コンパイルエラーを生成します。</p>
<!-- To fix the problem where we have a refutable pattern where an irrefutable -->
<!-- pattern is needed, we can change the code that uses the pattern: instead of -->
<!-- using `let`, we can use `if let`. Then if the pattern doesn’t match, the code -->
<!-- will just skip the code in the curly brackets, giving it a way to continue -->
<!-- validly. Listing 18-9 shows how to fix the code in Listing 18-8. -->
<p>論駁不可能なパターンが必要な箇所に論駁可能なパターンがある問題を修正するには、パターンを使用するコードを変えればいいのです:
<code>let</code>の代わりに<code>if let</code>を使用できます。そして、パターンが合致しなかったら、コードは合法に継続する手段を残して、
波括弧内のコードを飛ばすだけでしょう。リスト18-9は、リスト18-8のコードの修正方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_option_value: Option&lt;i32&gt; = None;
if let Some(x) = some_option_value {
    println!(&quot;{}&quot;, x);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-9: Using `if let` and a block with refutable -->
<!-- patterns instead of `let`</span> -->
<p><span class="caption">リスト18-9: <code>let</code>ではなく、<code>if let</code>と論駁可能なパターンを含むブロックを使用する</span></p>
<!-- We’ve given the code an out! This code is perfectly valid, although it means we -->
<!-- cannot use an irrefutable pattern without receiving an error. If we give `if -->
<!-- let` a pattern that will always match, such as `x`, as shown in Listing 18-10, -->
<!-- it will not compile. -->
<p>コードに逃げ道を与えました！このコードは完全に合法ですが、エラーを受け取らないで論駁不可能なパターンを使用することはできないことを意味します。
リスト18-10のように、<code>x</code>のような常にマッチするパターンを<code>if let</code>に与えたら、コンパイルできないでしょう。</p>
<pre><code class="language-rust ignore">if let x = 5 {
    println!(&quot;{}&quot;, x);
};
</code></pre>
<!-- <span class="caption">Listing 18-10: Attempting to use an irrefutable pattern -->
<!-- with `if let`</span> -->
<p><span class="caption">リスト18-10: <code>if let</code>で論駁不可能なパターンを使用してみる</span></p>
<!-- Rust complains that it doesn’t make sense to use `if let` with an irrefutable -->
<!-- pattern: -->
<p>コンパイラは、論駁不可能なパターンと<code>if let</code>を使用するなんて道理が通らないと文句を言います:</p>
<pre><code class="language-text">error[E0162]: irrefutable if-let pattern
(エラー: 論駁不可能なif-letパターン)
 --&gt; &lt;anon&gt;:2:8
  |
2 | if let x = 5 {
  |        ^ irrefutable pattern
</code></pre>
<!-- For this reason, match arms must use refutable patterns, except for the last -->
<!-- arm, which should match any remaining values with an irrefutable pattern. Rust -->
<!-- allows us to use an irrefutable pattern in a `match` with only one arm, but -->
<!-- this syntax isn’t particularly useful and could be replaced with a simpler -->
<!-- `let` statement. -->
<p>このため、マッチアームは、論駁不可能なパターンで残りのあらゆる値に合致すべき最後のアームを除いて、
論駁可能なパターンを使用しなければなりません。コンパイラは、たった1つしかアームのない<code>match</code>で論駁不可能なパターンを使用させてくれますが、
この記法は特別有用なわけではなく、より単純な<code>let</code>文に置き換えることもできるでしょう。</p>
<!-- Now that you know where to use patterns and the difference between refutable -->
<!-- and irrefutable patterns, let’s cover all the syntax we can use to create -->
<!-- patterns. -->
<p>今やパターンを使用すべき箇所と論駁可能と論駁不可能なパターンの違いを知ったので、
パターンを生成するために使用できる全ての記法を講義しましょう。</p>
<!-- ## Pattern Syntax -->
<a class="header" href="print.html#aパターン記法" id="aパターン記法"><h2>パターン記法</h2></a>
<!-- Throughout the book, you’ve seen examples of many kinds of patterns. In this -->
<!-- section, we gather all the syntax valid in patterns and discuss why you might -->
<!-- want to use each of them. -->
<p>本全体で、多くの種類のパターンの例を見かけてきました。この節では、パターンで合法な記法全てを集め、
それぞれを使用したくなる可能性がある理由について議論します。</p>
<!-- ### Matching Literals -->
<a class="header" href="print.html#aリテラルにマッチする" id="aリテラルにマッチする"><h3>リテラルにマッチする</h3></a>
<!-- As you saw in Chapter 6, you can match patterns against literals directly. The -->
<!-- following code gives some examples: -->
<p>第6章で目撃したように、パターンを直接リテラルに合致させられます。以下のコードが例を挙げています:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),       // 1
    2 =&gt; println!(&quot;two&quot;),       // 2
    3 =&gt; println!(&quot;three&quot;),     // 3
    _ =&gt; println!(&quot;anything&quot;),  // なんでも
}
#}</code></pre></pre>
<!-- This code prints `one` because the value in `x` is 1. This syntax is useful -->
<!-- when you want your code to take an action if it gets a particular concrete -->
<!-- value. -->
<p>このコードは、<code>x</code>の値が1なので、<code>one</code>を出力します。この記法は、コードが特定の具体的な値を得た時に行動を起こしてほしい時に有用です。</p>
<!-- ### Matching Named Variables -->
<a class="header" href="print.html#a名前付き変数にマッチする" id="a名前付き変数にマッチする"><h3>名前付き変数にマッチする</h3></a>
<!-- Named variables are irrefutable patterns that match any value, and we’ve used -->
<!-- them many times in the book. However, there is a complication when you use -->
<!-- named variables in `match` expressions. Because `match` starts a new scope, -->
<!-- variables declared as part of a pattern inside the `match` expression will -->
<!-- shadow those with the same name outside the `match` construct, as is the case -->
<!-- with all variables. In Listing 18-11, we declare a variable named `x` with the -->
<!-- value `Some(5)` and a variable `y` with the value `10`. We then create a -->
<!-- `match` expression on the value `x`. Look at the patterns in the match arms and -->
<!-- `println!` at the end, and try to figure out what the code will print before -->
<!-- running this code or reading further. -->
<p>名前付き変数はどんな値にも合致する論駁不可能なパターンであり、この本の中で何度も使用してきました。
ですが、名前付き変数を<code>match</code>式で使うと、厄介な問題があります。<code>match</code>は新しいスコープを開始するので、
<code>match</code>式内のパターンの一部として宣言された変数は、あらゆる変数同様に<code>match</code>構文外部の同じ名前の変数を覆い隠します。
リスト18-11で、値<code>Some(5)</code>の<code>x</code>という変数と値<code>10</code>の変数<code>y</code>を宣言しています。それから値<code>x</code>に対して<code>match</code>式を生成します。
マッチアームのパターンと最後の<code>println!</code>を見て、このコードを実行したり、先まで読み進める前にこのコードが何を出力するか推測してみてください。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        // 50だったよ
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        // マッチしたよ
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        // 規定のケース
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    // 最後にはx = {}, y = {}
    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-11: A `match` expression with an arm that -->
<!-- introduces a shadowed variable `y`</span> -->
<p><span class="caption">リスト18-11: シャドウイングされた変数<code>y</code>を導入するアームのある<code>match</code>式</span></p>
<!-- Let’s walk through what happens when the `match` expression runs. The pattern -->
<!-- in the first match arm doesn’t match the defined value of `x`, so the code -->
<!-- continues. -->
<p><code>match</code>式を実行した時に起こることを見ていきましょう。最初のマッチアームのパターンは、<code>x</code>の定義された値に合致しないので、
コードは継続します。</p>
<!-- The pattern in the second match arm introduces a new variable named `y` that -->
<!-- will match any value inside a `Some` value. Because we’re in a new scope inside -->
<!-- the `match` expression, this is a new `y` variable, not the `y` we declared at -->
<!-- the beginning with the value 10. This new `y` binding will match any value -->
<!-- inside a `Some`, which is what we have in `x`. Therefore, this new `y` binds to -->
<!-- the inner value of the `Some` in `x`. That value is `5`, so the expression for -->
<!-- that arm executes and prints `Matched, y = 5`. -->
<p>2番目のマッチアームのパターンは、<code>Some</code>値内部のあらゆる値に合致する新しい<code>y</code>という変数を導入します。
<code>match</code>式内の新しいスコープ内にいるので、これは新しい<code>y</code>変数であり、最初に値10で宣言した<code>y</code>ではありません。
この新しい<code>y</code>束縛は、<code>Some</code>内のあらゆる値に合致し、<code>x</code>にあるものはこれです。故に、この新しい<code>y</code>は、
<code>x</code>の中身の値に束縛されます。その値は<code>5</code>なので、そのアームの式が実行され、<code>Matched, y = 5</code>と出力されます。</p>
<!-- If `x` had been a `None` value instead of `Some(5)`, the patterns in the first -->
<!-- two arms wouldn’t have matched, so the value would have matched to the -->
<!-- underscore. We didn’t introduce the `x` variable in the pattern of the -->
<!-- underscore arm, so the `x` in the expression is still the outer `x` that hasn’t -->
<!-- been shadowed. In this hypothetical case, the `match` would print `Default -->
<!-- case, x = None`. -->
<p><code>x</code>が<code>Some(5)</code>ではなく<code>None</code>値だったなら、最初の2つのアームのパターンはマッチしなかったので、
値はアンダースコアに合致したでしょう。アンダースコアのアームのパターンでは<code>x</code>変数を導入しなかったので、
その式の<code>x</code>は、まだシャドウイングされない外側の<code>x</code>のままです。この架空の場合、
<code>match</code>は<code>Default case, x = None</code>と出力するでしょう。</p>
<!-- When the `match` expression is done, its scope ends, and so does the scope of -->
<!-- the inner `y`. The last `println!` produces `at the end: x = Some(5), y = 10`. -->
<p><code>match</code>式が完了すると、スコープが終わるので、中の<code>y</code>のスコープも終わります。
最後の<code>println!</code>は<code>at the end: x = Some(5), y = 10</code>を生成します。</p>
<!-- To create a `match` expression that compares the values of the outer `x` and -->
<!-- `y`, rather than introducing a shadowed variable, we would need to use a match -->
<!-- guard conditional instead. We’ll talk about match guards later in the “Extra -->
<!-- Conditionals with Match Guards” section. -->
<p>シャドウイングされた変数を導入するのではなく、外側の<code>x</code>と<code>y</code>の値を比較する<code>match</code>式を生成するには、
代わりにマッチガード条件式を使用する必要があるでしょう。マッチガードについては、後ほど、
「マッチガードで追加の条件式」節で語ります。</p>
<!-- ### Multiple Patterns -->
<a class="header" href="print.html#a複数のパターン" id="a複数のパターン"><h3>複数のパターン</h3></a>
<!-- In `match` expressions, you can match multiple patterns using the `|` syntax, -->
<!-- which means *or*. For example, the following code matches the value of `x` -->
<!-- against the match arms, the first of which has an *or* option, meaning if the -->
<!-- value of `x` matches either of the values in that arm, that arm’s code will -->
<!-- run: -->
<p><code>match</code>式で<code>|</code>記法で複数のパターンに合致させることができ、これは<em>or</em>を意味します。例えば、以下のコードは<code>x</code>の値をマッチアームに合致させ、
最初のマッチアームには<em>or</em>選択肢があり、<code>x</code>の値がそのアームのどちらかの値に合致したら、そのアームのコードが走ることを意味します:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    // 1か2
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    // 3
    3 =&gt; println!(&quot;three&quot;),
    // なんでも
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<!-- This code prints `one or two`. -->
<p>このコードは、<code>one or two</code>を出力します。</p>
<!-- ### Matching Ranges of Values with `...` -->
<a class="header" href="print.html#aで値の範囲に合致させる" id="aで値の範囲に合致させる"><h3><code>...</code>で値の範囲に合致させる</h3></a>
<!-- The `...` syntax allows us to match to an inclusive range of values. In the -->
<!-- following code, when a pattern matches any of the values within the range, that -->
<!-- arm will execute: -->
<p><code>...</code>記法により、限度値を含む値の範囲にマッチさせることができます。以下のコードでは、
パターンが範囲内のどれかの値に合致すると、そのアームが実行されます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

match x {
    // 1から5まで
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    // それ以外
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<!-- If `x` is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more -->
<!-- convenient than using the `|` operator to express the same idea; instead of `1 -->
<!-- ... 5`, we would have to specify `1 | 2 | 3 | 4 | 5` if we used `|`. Specifying -->
<!-- a range is much shorter, especially if we want to match, say, any number -->
<!-- between 1 and 1,000! -->
<p><code>x</code>が1、2、3、4か5なら、最初のアームが合致します。この記法は、<code>|</code>演算子を使用して同じ考えを表現するより便利です;
<code>1 ... 5</code>ではなく、<code>|</code>を使用したら、<code>1 | 2 | 3 | 4 | 5</code>と指定しなければならないでしょう。
範囲を指定する方が遥かに短いです。特に1から1000までの値と合致させたいとかなら！</p>
<!-- Ranges are only allowed with numeric values or `char` values, because the -->
<!-- compiler checks that the range isn’t empty at compile time. The only types for -->
<!-- which Rust can tell if a range is empty or not are `char` and numeric values. -->
<p>範囲は、数値か<code>char</code>値でのみ許可されます。コンパイラがコンパイル時に範囲が空でないことを確認しているからです。
範囲が空かそうでないかコンパイラにわかる唯一の型が<code>char</code>か数値なのです。</p>
<!-- Here is an example using ranges of `char` values: -->
<p>こちらは、<code>char</code>値の範囲を使用する例です:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 'c';

match x {
    // ASCII文字前半
    'a' ... 'j' =&gt; println!(&quot;early ASCII letter&quot;),
    // ASCII文字後半
    'k' ... 'z' =&gt; println!(&quot;late ASCII letter&quot;),
    // それ以外
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<!-- Rust can tell that `c` is within the first pattern’s range and prints `early -->
<!-- ASCII letter`. -->
<p>コンパイラには<code>c</code>が最初のパターンの範囲にあることがわかり、<code>early ASCII letter</code>と出力されます。</p>
<!-- ### Destructuring to Break Apart Values -->
<a class="header" href="print.html#a分解して値を分離する" id="a分解して値を分離する"><h3>分解して値を分離する</h3></a>
<!-- We can also use patterns to destructure structs, enums, tuples, and references -->
<!-- to use different parts of these values. Let’s walk through each value. -->
<p>またパターンを使用して構造体、enum、タプル、参照を分解しこれらの値の異なる部分を使用することもできます。
各値を見ていきましょう。</p>
<!-- #### Destructuring Structs -->
<a class="header" href="print.html#a構造体を分解する" id="a構造体を分解する"><h4>構造体を分解する</h4></a>
<!-- Listing 18-12 shows a `Point` struct with two fields, `x` and `y`, that we can -->
<!-- break apart using a pattern with a `let` statement. -->
<p>リスト18-12は、<code>let</code>文でパターンを使用して分離できる2つのフィールド<code>x</code>と<code>y</code>のある<code>Point</code>構造体を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-12: Destructuring a struct’s fields into -->
<!-- separate variables</span> -->
<p><span class="caption">リスト18-12: 構造体のフィールドを個別の変数に分解する</span></p>
<!-- This code creates the variables `a` and `b` that match the values of the `x` -->
<!-- and `y` fields of the `p` variable. This example shows that the names of the -->
<!-- variables in the pattern don’t have to match the field names of the struct. But -->
<!-- it’s common to want the variable names to match the field names to make it -->
<!-- easier to remember which variables came from which fields. -->
<p>このコードは、<code>p</code>変数の<code>x</code>と<code>y</code>フィールドの値に合致する変数<code>a</code>と<code>b</code>を生成します。この例は、
パターンの変数の名前は、構造体のフィールド名と合致する必要はないことを示しています。しかし、
変数名をフィールド名と一致させてどの変数がどのフィールド由来のものなのか覚えやすくしたくなることは一般的なことです。</p>
<!-- Because having variable names match the fields is common and because writing -->
<!-- `let Point { x: x, y: y } = p;` contains a lot of duplication, there is a -->
<!-- shorthand for patterns that match struct fields: you only need to list the name -->
<!-- of the struct field, and the variables created from the pattern will have the -->
<!-- same names. Listing 18-13 shows code that behaves in the same way as the code -->
<!-- in Listing 18-12, but the variables created in the `let` pattern are `x` and -->
<!-- `y` instead of `a` and `b`. -->
<p>変数名をフィールドに一致させることは一般的であり、<code>let Point{ x: x, y: y } = p;</code>と書くことは多くの重複を含むので、
構造体のフィールドと一致するパターンには省略法があります: 構造体のフィールドの名前を列挙するだけで、
パターンから生成される変数は同じ名前になるのです。リスト18-13は、リスト18-12と同じ振る舞いをするコードを表示していますが、
<code>let</code>パターンで生成される変数は<code>a</code>と<code>b</code>ではなく、<code>x</code>と<code>y</code>です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-13: Destructuring struct fields using struct -->
<!-- field shorthand</span> -->
<p><span class="caption">リスト18-13: 構造体フィールド省略法で構造体のフィールドを分解する</span></p>
<!-- This code creates the variables `x` and `y` that match the `x` and `y` fields -->
<!-- of the `p` variable. The outcome is that the variables `x` and `y` contain the -->
<!-- values from the `p` struct. -->
<p>このコードは、<code>p</code>変数の<code>x</code>と<code>y</code>フィールドに一致する変数<code>x</code>と<code>y</code>を生成します。
結果は、変数<code>x</code>と<code>y</code>が<code>p</code>構造体の値を含むというものです。</p>
<!-- We can also destructure with literal values as part of the struct pattern -->
<!-- rather than creating variables for all the fields. Doing so allows us to test -->
<!-- some of the fields for particular values while creating variables to -->
<!-- destructure the other fields. -->
<p>また全フィールドに対して変数を生成するのではなく、リテラル値を構造体パターンの一部にして分解することもできます。
そうすることで他のフィールドは分解して変数を生成しつつ、一部のフィールドは特定の値と一致するか確認できます。</p>
<!-- Listing 18-14 shows a `match` expression that separates `Point` values into -->
<!-- three cases: points that lie directly on the `x` axis (which is true when `y = -->
<!-- 0`), on the `y` axis (`x = 0`), or neither. -->
<p>リスト18-14は、<code>Point</code>値を3つの場合に区別する<code>match</code>式を表示しています: <code>x</code>軸上の点(<code>y = 0</code>ならそうなる)、
<code>y</code>軸上の点(<code>x = 0</code>)、あるいはどちらでもありません。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># struct Point {
#     x: i32,
#     y: i32,
# }
#
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        // x軸上の{}
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        // y軸上の{}
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        // どちらの軸上でもない: ({}, {})
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-14: Destructuring and matching literal values -->
<!-- in one pattern</span> -->
<p><span class="caption">リスト18-14: 分解とリテラル値との一致を1つのパターンで</span></p>
<!-- The first arm will match any point that lies on the `x` axis by specifying that -->
<!-- the `y` field matches if its value matches the literal `0`. The pattern still -->
<!-- creates an `x` variable that we can use in the code for this arm. -->
<p>最初のアームは、<code>y</code>フィールドの値がリテラル<code>0</code>と一致するならマッチすると指定することで、<code>x</code>軸上にあるどんな点とも一致します。
このパターンはそれでも、このアームのコードで使用できる<code>x</code>変数を生成します。</p>
<!-- Similarly, the second arm matches any point on the `y` axis by specifying that -->
<!-- the `x` field matches if its value is `0` and creates a variable `y` for the -->
<!-- value of the `y` field. The third arm doesn’t specify any literals, so it -->
<!-- matches any other `Point` and creates variables for both the `x` and `y` fields. -->
<p>同様に、2番目のアームは、<code>x</code>フィールドが<code>0</code>ならマッチすると指定することで<code>y</code>軸上のどんな点とも一致し、
<code>y</code>フィールドの値には変数<code>y</code>を生成します。3番目のアームは何もリテラルを指定しないので、
それ以外のあらゆる<code>Point</code>に合致し、<code>x</code>と<code>y</code>フィールド両方に変数を生成します。</p>
<!-- In this example, the value `p` matches the second arm by virtue of `x` -->
<!-- containing a 0, so this code will print `On the y axis at 7`. -->
<p>この例で、値<code>p</code>は0を含む<code>x</code>の力で2番目のアームに一致するので、このコードは<code>On the y axis at 7</code>と出力します。</p>
<!-- #### Destructuring Enums -->
<a class="header" href="print.html#enumを分解する" id="enumを分解する"><h4>enumを分解する</h4></a>
<!-- We’ve destructured enums earlier in this book, for example, when we -->
<!-- destructured `Option<i32>` in Listing 6-5 in Chapter 6. One detail we haven’t -->
<!-- mentioned explicitly is that the pattern to destructure an enum should -->
<!-- correspond to the way the data stored within the enum is defined. As an -->
<!-- example, in Listing 18-15 we use the `Message` enum from Listing 6-2 and write -->
<!-- a `match` with patterns that will destructure each inner value. -->
<p>例えば、第6章のリスト6-5で<code>Option&lt;i32&gt;</code>を分解するなどこの本の前半でenumを分解しました。
明示的に触れなかった詳細の1つは、enumを分解するパターンは、enum内に格納されているデータが定義されている手段に対応すべきということです。
例として、リスト18-15では、リスト6-2から<code>Message</code> enumを使用し、内部の値それぞれを分解するパターンを伴う<code>match</code>を書いています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            // Quit列挙子には分解すべきデータがない
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        },
        Message::Move { x, y } =&gt; {
            println!(
                // x方向に{}、y方向に{}だけ動く
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        // テキストメッセージ: {}
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                // 色を(R, G, B) = ({}, {}, {})に変更
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-15: Destructuring enum variants that hold -->
<!-- different kinds of values</span> -->
<p><span class="caption">リスト18-15: 異なる種類の値を保持するenumの列挙子を分解する</span></p>
<!-- This code will print `Change the color to red 0, green 160, and blue 255`. Try -->
<!-- changing the value of `msg` to see the code from the other arms run. -->
<p>このコードは、<code>Change the color to red 0, green 160, blue 255</code>と出力します。
試しに<code>msg</code>の値を変更して、他のアームのコードが走るところを確認してください。</p>
<!-- For enum variants without any data, like `Message::Quit`, we can’t destructure -->
<!-- the value any further. We can only match on the literal `Message::Quit` value, -->
<!-- and no variables are in that pattern. -->
<p><code>Message::Quit</code>のようなデータのないenum列挙子については、それ以上値を分解することができません。
リテラル<code>Message::Quit</code>値にマッチするだけで、変数はそのパターンに存在しません。</p>
<!-- For struct-like enum variants, such as `Message::Move`, we can use a pattern -->
<!-- similar to the pattern we specify to match structs. After the variant name, we -->
<!-- place curly brackets and then list the fields with variables so we break apart -->
<!-- the pieces to use in the code for this arm. Here we use the shorthand form as -->
<!-- we did in Listing 18-13. -->
<p><code>Message::Move</code>のような構造体に似たenumの列挙子については、構造体と一致させるために指定するパターンと似たパターンを使用できます。
列挙子の名前の後に波括弧を配置し、それから変数とともにフィールドを列挙するので、部品を分離してこのアームのコードで使用します。
ここでは、リスト18-13のように省略形態を使用しています。</p>
<!-- For tuple-like enum variants, like `Message::Write` that holds a tuple with one -->
<!-- element and `Message::ChangeColor` that holds a tuple with three elements, the -->
<!-- pattern is similar to the pattern we specify to match tuples. The number of -->
<!-- variables in the pattern must match the number of elements in the variant we’re -->
<!-- matching. -->
<p>1要素タプルを保持する<code>Message::Write</code>や、3要素タプルを保持する<code>Message::ChangeColor</code>のようなタプルに似たenumの列挙子について、
パターンは、タプルと一致させるために指定するパターンと類似しています。パターンの変数の数は、
マッチ対象の列挙子の要素数と一致しなければなりません。</p>
<!-- #### Destructuring References -->
<a class="header" href="print.html#a参照を分解する" id="a参照を分解する"><h4>参照を分解する</h4></a>
<!-- When the value we’re matching to our pattern contains a reference, we need to -->
<!-- destructure the reference from the value, which we can do by specifying a `&` -->
<!-- in the pattern. Doing so lets us get a variable holding the value that the -->
<!-- reference points to rather than getting a variable that holds the reference. -->
<!-- This technique is especially useful in closures where we have iterators that -->
<!-- iterate over references, but we want to use the values in the closure rather -->
<!-- than the references. -->
<p>パターンとマッチさせている値に参照が含まれる場合、値から参照を分解する必要があり、
パターンに<code>&amp;</code>を指定することでそうすることができます。そうすることで参照を保持する変数を得るのではなく、
参照が指している値を保持する変数が得られます。このテクニックは特に、参照を走査するイテレータがあるけれども、
参照ではなく、クロージャで値を使用したいクロージャで特に役に立ちます。</p>
<!-- The example in Listing 18-16 iterates over references to `Point` instances in a -->
<!-- vector, destructuring the reference and the struct so we can perform -->
<!-- calculations on the `x` and `y` values easily. -->
<p>リスト18-16の例は、ベクタの<code>Point</code>インスタンスへの参照を走査し、<code>x</code>と<code>y</code>値に簡単に計算を行えるように、
参照と構造体を分解します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let points = vec![
    Point { x: 0, y: 0 },
    Point { x: 1, y: 5 },
    Point { x: 10, y: -3 },
];

let sum_of_squares: i32 = points
    .iter()
    .map(|&amp;Point { x, y }| x * x + y * y)
    .sum();
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-16: Destructuring a reference to a struct into -->
<!-- the struct field values</span> -->
<p><span class="caption">リスト18-16: 構造体への参照を構造体のフィールド値に分解する</span></p>
<!-- This code gives us the variable `sum_of_squares` holding the value 135, which -->
<!-- is the result of squaring the `x` value and the `y` value, adding those -->
<!-- together, and then adding the result for each `Point` in the `points` vector to -->
<!-- get one number. -->
<p>このコードは、値135を保持する変数<code>sum_of_squares</code>を返してきて、これは、<code>x</code>値と<code>y</code>値を2乗し、足し合わせ、
<code>points</code>ベクタの<code>Point</code>それぞれの結果を足して1つの数値にした結果です。</p>
<!-- If we had not included the `&` in `&Point { x, y }`, we’d get a type mismatch -->
<!-- error, because `iter` would then iterate over references to the items in the -->
<!-- vector rather than the actual values. The error would look like this: -->
<p><code>&amp;Point { x, y }</code>に<code>&amp;</code>が含まれていなかったら、型不一致エラーが発生していたでしょう。
<code>iter</code>はそうして、実際の値ではなく、ベクタの要素への参照を走査するからです。そのエラーはこんな見た目でしょう:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt;
   |
14 |         .map(|Point { x, y }| x * x + y * y)
   |               ^^^^^^^^^^^^ expected &amp;Point, found struct `Point`
   |
   = note: expected type `&amp;Point`
              found type `Point`
</code></pre>
<!-- This error indicates that Rust was expecting our closure to match `&Point`, but -->
<!-- we tried to match directly to a `Point` value, not a reference to a `Point`. -->
<p>このエラーは、コンパイラがクロージャに<code>&amp;Point</code>と一致することを期待しているのに、
<code>Point</code>への参照ではなく、<code>Point</code>値に直接一致させようとしたことを示唆しています。</p>
<!-- #### Destructuring Structs and Tuples -->
<a class="header" href="print.html#a構造体とタプルを分解する" id="a構造体とタプルを分解する"><h4>構造体とタプルを分解する</h4></a>
<!-- We can mix, match, and nest destructuring patterns in even more complex ways. -->
<!-- The following example shows a complicated destructure where we nest structs and -->
<!-- tuples inside a tuple and destructure all the primitive values out: -->
<p>分解パターンをさらに複雑な方法で混ぜて一致させ、ネストすることができます。以下の例は、
構造体とタプルをタプルにネストし、全ての基本的な値を取り出している複雑な分解を表示しています:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
#}</code></pre></pre>
<!-- This code lets us break complex types into their component parts so we can use -->
<!-- the values we’re interested in separately. -->
<p>このコードは、複雑な型を構成する部品に分解させてくれるので、興味のある値を個別に使用できます。</p>
<!-- Destructuring with patterns is a convenient way to use pieces of values, such -->
<!-- as the value from each field in a struct, separately from each other. -->
<p>パターンで分解することは、構造体の各フィールドからの値のように、一部の値を他と区別して使用する便利な方法です。</p>
<!-- ### Ignoring Values in a Pattern -->
<a class="header" href="print.html#aパターンの値を無視する" id="aパターンの値を無視する"><h3>パターンの値を無視する</h3></a>
<!-- You’ve seen that it’s sometimes useful to ignore values in a pattern, such as -->
<!-- in the last arm of a `match`, to get a catchall that doesn’t actually do -->
<!-- anything but does account for all remaining possible values. There are a few -->
<!-- ways to ignore entire values or parts of values in a pattern: using the `_` -->
<!-- pattern (which you’ve seen), using the `_` pattern within another pattern, -->
<!-- using a name that starts with an underscore, or using `..` to ignore remaining -->
<!-- parts of a value. Let’s explore how and why to use each of these patterns. -->
<p><code>match</code>の最後のアームのように、パターンの値を無視して実際には何もしないけれども、
残りの全ての値の可能性を考慮する包括的なものを得ることは時として有用であると認識しましたね。
値全体やパターンの一部の値を無視する方法はいくつかあります: <code>_</code>パターンを使用すること(もう見かけました)、
他のパターン内で<code>_</code>パターンを使用すること、アンダースコアで始まる名前を使用すること、<code>..</code>を使用して値の残りの部分を無視することです。
これらのパターンそれぞれを使用する方法と理由を探求しましょう。</p>
<!-- #### Ignoring an Entire Value with `_` -->
<a class="header" href="print.html#a_で値全体を無視する" id="a_で値全体を無視する"><h4><code>_</code>で値全体を無視する</h4></a>
<!-- We’ve used the underscore (`_`) as a wildcard pattern that will match any value -->
<!-- but not bind to the value. Although the underscore `_` pattern is especially -->
<!-- useful as the last arm in a `match` expression, we can use it in any pattern, -->
<!-- including function parameters, as shown in Listing 18-17. -->
<p>どんな値にも一致するけれども、値を束縛しないワイルドカードパターンとしてアンダースコア、<code>_</code>を使用しました。
アンダースコア、<code>_</code>パターンは特に<code>match</code>式の最後のアームとして役に立ちますが、
関数の引数も含めてあらゆるパターンで使えます。リスト18-17に示したようにですね。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn foo(_: i32, y: i32) {
    // このコードは、y引数を使うだけです: {}
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-17: Using `_` in a function signature</span> -->
<p><span class="caption">リスト18-17: 関数シグニチャで<code>_</code>を使用する</span></p>
<!-- This code will completely ignore the value passed as the first argument, `3`, -->
<!-- and will print `This code only uses the y parameter: 4`. -->
<p>このコードは、最初の引数として渡された値<code>3</code>を完全に無視し、<code>This code only uses the y parameter: 4</code>と出力します。</p>
<!-- In most cases when you no longer need a particular function parameter, you -->
<!-- would change the signature so it doesn’t include the unused parameter. Ignoring -->
<!-- a function parameter can be especially useful in some cases, for example, when -->
<!-- implementing a trait when you need a certain type signature but the function -->
<!-- body in your implementation doesn’t need one of the parameters. The compiler -->
<!-- will then not warn about unused function parameters, as it would if you used a -->
<!-- name instead. -->
<p>特定の関数の引数が最早必要ないほとんどの場合、未使用の引数が含まれないようにシグニチャを変更するでしょう。
関数の引数を無視することが特に有用なケースもあり、例えば、トレイトを実装する際、
特定の型シグニチャが必要だけれども、自分の実装の関数本体では引数の1つが必要ない時などです。
そうすれば、代わりに名前を使った場合のようには、未使用関数引数についてコンパイラが警告することはないでしょう。</p>
<!-- #### Ignoring Parts of a Value with a Nested `_` -->
<a class="header" href="print.html#aネストされた_で値の一部を無視する" id="aネストされた_で値の一部を無視する"><h4>ネストされた<code>_</code>で値の一部を無視する</h4></a>
<!-- We can also use `_` inside another pattern to ignore just part of a value, for -->
<!-- example, when we want to test for only part of a value but have no use for the -->
<!-- other parts in the corresponding code we want to run. Listing 18-18 shows code -->
<!-- responsible for managing a setting’s value. The business requirements are that -->
<!-- the user should not be allowed to overwrite an existing customization of a -->
<!-- setting but can unset the setting and can give the setting a value if it is -->
<!-- currently unset. -->
<p>また、他のパターンの内部で<code>_</code>を使用して、値の一部だけを無視することもでき、例えば、
値の一部だけを確認したいけれども、走らせたい対応するコードでは他の部分を使用することがない時などです。
リスト18-18は、設定の値を管理する責任を負ったコードを示しています。業務要件は、
ユーザが既存の設定の変更を上書きすることはできないべきだけれども、設定をリセットし、
現在設定がされてなければ設定に値を与えられるというものです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        // 既存の値の変更を上書きできません
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

// 設定は{:?}です
println!(&quot;setting is {:?}&quot;, setting_value);
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-18: Using an underscore within patterns that -->
<!-- match `Some` variants when we don’t need to use the value inside the -->
<!-- `Some`</span> -->
<p><span class="caption">リスト18-18: <code>Some</code>内の値を使用する必要がない時に<code>Some</code>列挙子と合致するパターンでアンダースコアを使用する</span></p>
<!-- This code will print `Can't overwrite an existing customized value` and then -->
<!-- `setting is Some(5)`. In the first match arm, we don’t need to match on or use -->
<!-- the values inside either `Some` variant, but we do need to test for the case -->
<!-- when `setting_value` and `new_setting_value` are the `Some` variant. In that -->
<!-- case, we print why we’re not changing `setting_value`, and it doesn’t get -->
<!-- changed. -->
<p>このコードは、<code>Can't overwrite an existing customized value</code>、そして<code>setting is Some(5)</code>と出力するでしょう。
最初のマッチアームで、どちらの<code>Some</code>列挙子内部の値にも合致させたり、使用する必要はありませんが、
<code>setting_value</code>と<code>new_setting_value</code>が<code>Some</code>列挙子の場合を確かに確認する必要があります。
その場合、何故<code>setting_value</code>を変更しないかを出力し、変更しません。</p>
<!-- In all other cases (if either `setting_value` or `new_setting_value` are -->
<!-- `None`) expressed by the `_` pattern in the second arm, we want to allow -->
<!-- `new_setting_value` to become `setting_value`. -->
<p>2番目のアームの<code>_</code>パターンで表現される他のあらゆる場合(<code>setting_value</code>と<code>new_setting_value</code>どちらかが<code>None</code>なら)には、
<code>new_setting_value</code>には<code>setting_value</code>になってほしいです。</p>
<!-- We can also use underscores in multiple places within one pattern to ignore -->
<!-- particular values. Listing 18-19 shows an example of ignoring the second and -->
<!-- fourth values in a tuple of five items. -->
<p>また、1つのパターンの複数箇所でアンダースコアを使用して特定の値を無視することもできます。
リスト18-19は、5要素のタプルで2番目と4番目の値を無視する例です。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        // 何かの数値: {}, {}, {}
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span> -->
<p><span class="caption">リスト18-19: タプルの複数の部分を無視する</span></p>
<!-- This code will print `Some numbers: 2, 8, 32`, and the values 4 and 16 will be -->
<!-- ignored. -->
<p>このコードは、<code>Some numbers: 2, 8, 32</code>と出力し、値4と16は無視されます。</p>
<!-- #### Ignoring an Unused Variable by Starting Its Name with `_` -->
<a class="header" href="print.html#a名前を_で始めて未使用の変数を無視する" id="a名前を_で始めて未使用の変数を無視する"><h4>名前を<code>_</code>で始めて未使用の変数を無視する</h4></a>
<!-- If you create a variable but don’t use it anywhere, Rust will usually issue a -->
<!-- warning because that could be a bug. But sometimes it’s useful to create a -->
<!-- variable you won’t use yet, such as when you’re prototyping or just starting a -->
<!-- project. In this situation, you can tell Rust not to warn you about the unused -->
<!-- variable by starting the name of the variable with an underscore. In Listing -->
<!-- 18-20, we create two unused variables, but when we run this code, we should -->
<!-- only get a warning about one of them. -->
<p>変数を作っているのにどこでも使用していなければ、バグかもしれないのでコンパイラは通常、警告を発します。
しかし時として、まだ使用しない変数を作るのが有用なこともあります。プロトタイプを開発したり、
プロジェクトを始めた直後だったりなどです。このような場面では、変数名をアンダースコアで始めることで、
コンパイラに未使用変数について警告しないよう指示することができます。リスト18-20で2つの未使用変数を生成していますが、
このコードを実行すると、そのうちの1つにしか警告が出ないはずです。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-20: Starting a variable name with an -->
<!-- underscore to avoid getting unused variable warnings</span> -->
<p><span class="caption">リスト18-20: アンダースコアで変数名を始めて未使用変数警告が出るのを回避する</span></p>
<!-- Here we get a warning about not using the variable `y`, but we don’t get a -->
<!-- warning about not using the variable preceded by the underscore. -->
<p>ここで、変数<code>y</code>を使用していないことに対して警告が出ていますが、アンダースコアが接頭辞になっている変数には、
使用していないという警告が出ていません。</p>
<!-- Note that there is a subtle difference between using only `_` and using a name -->
<!-- that starts with an underscore. The syntax `_x` still binds the value to the -->
<!-- variable, whereas `_` doesn’t bind at all. To show a case where this -->
<!-- distinction matters, Listing 18-21 will provide us with an error. -->
<p><code>_</code>だけを使うのとアンダースコアで始まる名前を使うことには微妙な違いがあることに注意してください。
<code>_x</code>記法はそれでも、値を変数に束縛する一方で、<code>_</code>は全く束縛しません。この差異が問題になる場合を示すために、
リスト18-21はエラーを提示するでしょう。</p>
<pre><code class="language-rust ignore">// やあ！
let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    // 文字列が見つかりました
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
</code></pre>
<!-- <span class="caption">Listing 18-21: An unused variable starting with an -->
<!-- underscore still binds the value, which might take ownership of the value</span> -->
<p><span class="caption">リスト18-21: それでも、アンダースコアで始まる未使用の変数は値を束縛し、値の所有権を奪う可能性がある</span></p>
<!-- We’ll receive an error because the `s` value will still be moved into `_s`, -->
<!-- which prevents us from using `s` again. However, using the underscore by itself -->
<!-- doesn’t ever bind to the value. Listing 18-22 will compile without any errors -->
<!-- because `s` doesn’t get moved into `_`. -->
<p>それでも<code>s</code>値は<code>_s</code>にムーブされ、再度<code>s</code>を使用できなくするので、エラーを受け取るでしょう。ですが、
アンダースコアを単独で使用すれば、値を束縛することは全くありません。
<code>s</code>が<code>_</code>にムーブされないので、リスト18-22はエラーなくコンパイルできます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-22: Using an underscore does not bind the -->
<!-- value</span> -->
<p><span class="caption">リスト18-22: アンダースコアを使用すると、値を束縛しない</span></p>
<!-- This code works just fine because we never bind `s` to anything; it isn’t moved. -->
<p>このコードは、<code>s</code>を何にも束縛しないので、ただ単に上手く動きます。つまり、ムーブされないのです。</p>
<!-- #### Ignoring Remaining Parts of a Value with `..` -->
<a class="header" href="print.html#aで値の残りの部分を無視する" id="aで値の残りの部分を無視する"><h4><code>..</code>で値の残りの部分を無視する</h4></a>
<!-- With values that have many parts, we can use the `..` syntax to use only a few -->
<!-- parts and ignore the rest, avoiding the need to list underscores for each -->
<!-- ignored value. The `..` pattern ignores any parts of a value that we haven’t -->
<!-- explicitly matched in the rest of the pattern. In Listing 18-23, we have a -->
<!-- `Point` struct that holds a coordinate in three-dimensional space. In the -->
<!-- `match` expression, we want to operate only on the `x` coordinate and ignore -->
<!-- the values in the `y` and `z` fields. -->
<p>多くの部分がある値では、<code>..</code>記法を使用していくつかの部分だけを使用して残りを無視し、
無視する値それぞれにアンダースコアを列挙する必要性を回避できます。<code>..</code>パターンは、
パターンの残りで明示的にマッチさせていない値のどんな部分も無視します。リスト18-23では、
3次元空間で座標を保持する<code>Point</code>構造体があります。<code>match</code>式で<code>x</code>座標のみ処理し、
<code>y</code>と<code>z</code>フィールドの値は無視したいです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-23: Ignoring all fields of a `Point` except -->
<!-- for `x` by using `..`</span> -->
<p><span class="caption">リスト18-23: <code>..</code>で<code>x</code>以外の<code>Point</code>のフィールド全てを無視する</span></p>
<!-- We list the `x` value and then just include the `..` pattern. This is quicker -->
<!-- than having to list `y: _` and `z: _`, particularly when we’re working with -->
<!-- structs that have lots of fields in situations where only one or two fields are -->
<!-- relevant. -->
<p><code>x</code>値を列挙し、それから<code>..</code>パターンを含んでいるだけです。これは、<code>y: _</code>や<code>z: _</code>と列挙しなければいけないのに比べて、
手っ取り早いです。特に1つや2つのフィールドのみが関連する場面で多くのフィールドがある構造体に取り掛かっている時には。</p>
<!-- The syntax `..` will expand to as many values as it needs to be. Listing 18-24 -->
<!-- shows how to use `..` with a tuple. -->
<p><code>..</code>記法は、必要な数だけ値に展開されます。リスト18-24は、タプルで<code>..</code>を使用する方法を表示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-24: Matching only the first and last values in -->
<!-- a tuple and ignoring all other values</span> -->
<p><span class="caption">リスト18-24: タプルの最初と最後の値にだけ合致し、他の値を無視する</span></p>
<!-- In this code, the first and last value are matched with `first` and `last`. The -->
<!-- `..` will match and ignore everything in the middle. -->
<p>このコードにおいて、最初と最後の値は<code>first</code>と<code>last</code>に合致します。<code>..</code>は、
途中のもの全部に合致し、無視します。</p>
<!-- However, using `..` must be unambiguous. If it is unclear which values are -->
<!-- intended for matching and which should be ignored, Rust will give us an error. -->
<!-- Listing 18-25 shows an example of using `..` ambiguously, so it will not -->
<!-- compile. -->
<p>しかしながら、<code>..</code>を使うのは明確でなければなりません。どの値がマッチしてどの値が無視されるべきかが不明瞭なら、
コンパイラはエラーを出します。リスト18-25は、<code>..</code>を曖昧に使用する例なので、コンパイルできません。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<!-- <span class="caption">Listing 18-25: An attempt to use `..` in an ambiguous -->
<!-- way</span> -->
<p><span class="caption">リスト18-25: <code>..</code>を曖昧に使用しようとする試み</span></p>
<!-- When we compile this example, we get this error: -->
<p>この例をコンパイルすると、こんなエラーが出ます:</p>
<pre><code class="language-text">error: `..` can only be used once per tuple or tuple struct pattern
(エラー: `..`は、タプルやタプル構造体パターン1つにつき、1回しか使用できません)
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |                      ^^
</code></pre>
<!-- It’s impossible for Rust to determine how many values in the tuple to ignore -->
<!-- before matching a value with `second` and then how many further values to -->
<!-- ignore thereafter. This code could mean that we want to ignore `2`, bind -->
<!-- `second` to `4`, and then ignore `8`, `16`, and `32`; or that we want to ignore -->
<!-- `2` and `4`, bind `second` to `8`, and then ignore `16` and `32`; and so forth. -->
<!-- The variable name `second` doesn’t mean anything special to Rust, so we get a -->
<!-- compiler error because using `..` in two places like this is ambiguous. -->
<p>コンパイラが、<code>second</code>の値に合致する前にタプルの幾つの値を無視し、それからそれによってさらに幾つの値を無視するかを決めることは不可能です。
このコードは、<code>2</code>を無視し、<code>second</code>に<code>4</code>を束縛し、それから<code>8</code>、<code>16</code>、<code>32</code>を無視したり、
<code>2</code>と<code>4</code>を無視して<code>second</code>に<code>8</code>を束縛し、それから<code>16</code>と<code>32</code>を無視するなどを意味することもあるでしょう。
変数名の<code>second</code>は、コンパイラにとってなんの特別な意味もないため、このように2箇所で<code>..</code>を使うのは曖昧なので、
コンパイルエラーになります。</p>
<!-- ### Creating References in Patterns with `ref` and `ref mut`-->
<a class="header" href="print.html#refとref-mutでパターンで参照を生成する" id="refとref-mutでパターンで参照を生成する"><h3><code>ref</code>と<code>ref mut</code>でパターンで参照を生成する</h3></a>
<!-- Let’s look at using `ref` to make references so ownership of the values isn’t -->
<!-- moved to variables in the pattern. Usually, when you match against a pattern, -->
<!-- the variables introduced by the pattern are bound to a value. Rust’s ownership -->
<!-- rules mean the value will be moved into the `match` or wherever you’re using -->
<!-- the pattern. Listing 18-26 shows an example of a `match` that has a pattern -->
<!-- with a variable and then usage of the entire value in the `println!` statement -->
<!-- later, after the `match`. This code will fail to compile because ownership of -->
<!-- part of the `robot_name` value is transferred to the `name` variable in the -->
<!-- pattern of the first `match` arm. -->
<p><code>ref</code>を使用して値の所有権がパターンの変数にムーブされないように、参照を生成することに目を向けましょう。
通常、パターンにマッチさせると、パターンで導入された変数は値に束縛されます。Rustの所有権規則は、
その値が<code>match</code>などパターンを使用しているあらゆる場所にムーブされることを意味します。
リスト18-26は、変数があるパターンとそれから<code>match</code>の後に値全体を<code>println!</code>文で後ほど使用する<code>match</code>の例を示しています。
このコードはコンパイルに失敗します。<code>robot_name</code>値の一部の所有権が、
最初の<code>match</code>アームのパターンの<code>name</code>変数に移るからです。</p>
<pre><code class="language-rust ignore">let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    // 名前が見つかりました: {}
    Some(name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

// robot_nameは: {:?}
println!(&quot;robot_name is: {:?}&quot;, robot_name);
</code></pre>
<!-- <span class="caption">Listing 18-26: Creating a variable in a `match` arm -->
<!-- pattern takes ownership of the value</span> -->
<p><span class="caption">リスト18-26: <code>match</code>アームパターンで変数を生成すると、値の所有権が奪われる</span></p>
<!-- Because ownership of part of `robot_name` has been moved to `name`, we can no -->
<!-- longer use `robot_name` in the `println!` after the `match` because -->
<!-- `robot_name` no longer has ownership. -->
<p><code>robot_name</code>の一部の所有権が<code>name</code>にムーブされたので、<code>robot_name</code>に最早所有権がないために、
<code>match</code>の後に<code>println!</code>で最早<code>robot_name</code>を使用することは叶いません。</p>
<!-- To fix this code, we want to make the `Some(name)` pattern *borrow* that part -->
<!-- of `robot_name` rather than taking ownership. You’ve already seen that, outside -->
<!-- of patterns, the way to borrow a value is to create a reference using `&`, so -->
<!-- you might think the solution is changing `Some(name)` to `Some(&name)`. -->
<p>このコードを修正するために、<code>Some(name)</code>パターンに所有権を奪わせるのではなく、
<code>robot_name</code>のその部分を借用させたいです。パターンの外なら、値を借用する手段は、
<code>&amp;</code>で参照を生成することだと既にご認識でしょうから、解決策は<code>Some(name)</code>を<code>Some(&amp;name)</code>に変えることだとお考えかもしれませんね。</p>
<!-- However, as you saw in the “Destructuring to Break Apart Values” section, the -->
<!-- syntax `&` in patterns does not *create* a reference but *matches* an existing -->
<!-- reference in the value. Because `&` already has that meaning in patterns, we -->
<!-- can’t use `&` to create a reference in a pattern. -->
<p>しかしながら、「分解して値を分離する」節で見かけたように、パターンにおける<code>&amp;</code>記法は参照を<em>生成</em>せず、
値の既存の参照に<em>マッチ</em>します。パターンにおいて<code>&amp;</code>には既にその意味があるので、
<code>&amp;</code>を使用してパターンで参照を生成することはできません。</p>
<!-- Instead, to create a reference in a pattern, we use the `ref` keyword before -->
<!-- the new variable, as shown in Listing 18-27. -->
<p>その代わりに、パターンで参照を生成するには、リスト18-27のように、新しい変数の前に<code>ref</code>キーワードを使用します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-27: Creating a reference so a pattern variable -->
<!-- does not take ownership of a value</span> -->
<p><span class="caption">リスト18-27: パターンの変数が値の所有権を奪わないように参照を生成する</span></p>
<!-- This example will compile because the value in the `Some` variant in -->
<!-- `robot_name` is not moved into the `match`; the `match` only took a reference -->
<!-- to the data in `robot_name` rather than moving it. -->
<p><code>robot_name</code>の<code>Some</code>列挙子の値が<code>match</code>にムーブされないので、この例はコンパイルできます;
<code>match</code>はムーブするのではなく、<code>robot_name</code>のデータへの参照を取っただけなのです。</p>
<!-- To create a mutable reference so we’re able to mutate a value matched in a -->
<!-- pattern, we use `ref mut` instead of `&mut`. The reason is, again, that in -->
<!-- patterns, the latter is for matching existing mutable references, not creating -->
<!-- new ones. Listing 18-28 shows an example of a pattern creating a mutable -->
<!-- reference. -->
<p>パターンで合致した値を可変化できるように可変参照を生成するには、<code>&amp;mut</code>の代わりに<code>ref mut</code>を使用します。
理由は今度も、パターンにおいて、前者は既存の可変参照にマッチするためにあり、新しい参照を生成しないからです。
リスト18-28は、可変参照を生成するパターンの例です。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    // 別の名前
    Some(ref mut name) =&gt; *name = String::from(&quot;Another name&quot;),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-28: Creating a mutable reference to a value as -->
<!-- part of a pattern using `ref mut`</span> -->
<p><span class="caption">リスト18-28: <code>ref mut</code>を使用してパターンの一部として値への可変参照を生成する</span></p>
<!-- This example will compile and print `robot_name is: Some("Another name")`. -->
<!-- Because `name` is a mutable reference, we need to dereference within the match -->
<!-- arm code using the `*` operator to mutate the value. -->
<p>この例はコンパイルが通り、<code>robot_name is: Some(&quot;Another name&quot;)</code>と出力するでしょう。
<code>name</code>は可変参照なので、マッチアーム内で<code>*</code>演算子を使用して値を可変化するために参照外しする必要があります。</p>
<!-- ### Extra Conditionals with Match Guards -->
<a class="header" href="print.html#aマッチガードで追加の条件式" id="aマッチガードで追加の条件式"><h3>マッチガードで追加の条件式</h3></a>
<!-- A *match guard* is an additional `if` condition specified after the pattern in -->
<!-- a `match` arm that must also match, along with the pattern matching, for that -->
<!-- arm to be chosen. Match guards are useful for expressing more complex ideas -->
<!-- than a pattern alone allows. -->
<p><em>マッチガード</em>は、<code>match</code>アームのパターンの後に指定されるパターンマッチングとともに、
そのアームが選択されるのにマッチしなければならない追加の<code>if</code>条件です。マッチガードは、
1つのパターン単独でできるよりも複雑な考えを表現するのに役に立ちます。</p>
<!-- The condition can use variables created in the pattern. Listing 18-29 shows a -->
<!-- `match` where the first arm has the pattern `Some(x)` and also has a match -->
<!-- guard of `if x < 5`. -->
<p>この条件は、パターンで生成された変数を使用できます。リスト18-29は、
最初のアームにパターン<code>Some(x)</code>と<code>if x &lt; 5</code>というマッチガードもある<code>match</code>を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = Some(4);

match num {
    // 5未満です: {}
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-29: Adding a match guard to a pattern</span> -->
<p><span class="caption">リスト18-29: パターンにマッチガードを追記する</span></p>
<!-- This example will print `less than five: 4`. When `num` is compared to the -->
<!-- pattern in the first arm, it matches, because `Some(4)` matches `Some(x)`. Then -->
<!-- the match guard checks whether the value in `x` is less than `5`, and because -->
<!-- it is, the first arm is selected. -->
<p>この例は、<code>less than five: 4</code>と出力します。<code>num</code>が最初のアームのパターンと比較されると、
<code>Some(4)</code>は<code>Some(x)</code>に一致するので、マッチします。そして、マッチガードが<code>x</code>の値が<code>5</code>未満か確認し、
そうなっているので、最初のアームが選択されます。</p>
<!-- If `num` had been `Some(10)` instead, the match guard in the first arm would -->
<!-- have been false because 10 is not less than 5. Rust would then go to the second -->
<!-- arm, which would match because the second arm doesn’t have a match guard and -->
<!-- therefore matches any `Some` variant. -->
<p>代わりに<code>num</code>が<code>Some(10)</code>だったなら、最初のアームのマッチガードは偽になったでしょう。
10は5未満ではないからです。Rustはそうしたら2番目のアームに移動し、マッチするでしょう。
2番目のアームにはマッチガードがなく、それ故にあらゆる<code>Some</code>列挙子に一致するからです。</p>
<!-- There is no way to express the `if x < 5` condition within a pattern, so the -->
<!-- match guard gives us the ability to express this logic. -->
<p>パターン内で<code>if x &lt; 5</code>という条件を表現する方法はありませんので、マッチガードにより、
この論理を表現する能力が得られるのです。</p>
<!-- In Listing 18-11, we mentioned that we could use match guards to solve our -->
<!-- pattern-shadowing problem. Recall that a new variable was created inside the -->
<!-- pattern in the `match` expression instead of using the variable outside the -->
<!-- `match`. That new variable meant we couldn’t test against the value of the -->
<!-- outer variable. Listing 18-30 shows how we can use a match guard to fix this -->
<!-- problem. -->
<p>リスト18-11において、マッチガードを使用すれば、パターンがシャドウイングする問題を解決できると述べました。
<code>match</code>の外側の変数を使用するのではなく、<code>match</code>式のパターン内部では新しい変数が作られることを思い出してください。
その新しい変数は、外側の変数の値と比較することができないことを意味しました。リスト18-30は、
マッチガードを使ってこの問題を修正する方法を表示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {:?}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<!-- <span class="caption">Listing 18-30: Using a match guard to test for equality -->
<!-- with an outer variable</span> -->
<p><span class="caption">リスト18-30: マッチガードを使用して外側の変数と等しいか確認する</span></p>
<!-- This code will now print `Default case, x = Some(5)`. The pattern in the second -->
<!-- match arm doesn’t introduce a new variable `y` that would shadow the outer `y`, -->
<!-- meaning we can use the outer `y` in the match guard. Instead of specifying the -->
<!-- pattern as `Some(y)`, which would have shadowed the outer `y`, we specify -->
<!-- `Some(n)`. This creates a new variable `n` that doesn’t shadow anything because -->
<!-- there is no `n` variable outside the `match`. -->
<p>このコードは今度は、<code>Default case, x = Some(5)</code>と出力するでしょう。2番目のマッチアームのパターンは、
外側の<code>y</code>を覆い隠してしまう新しい変数<code>y</code>を導入せず、マッチガード内で外側の<code>y</code>を使用できることを意味します。
外側の<code>y</code>を覆い隠してしまう<code>Some(y)</code>としてパターンを指定するのではなく、<code>Some(n)</code>を指定しています。
これにより、何も覆い隠さない新しい変数<code>n</code>が生成されます。<code>match</code>の外側には<code>n</code>変数は存在しないからです。</p>
<!-- The match guard `if n == y` is not a pattern and therefore doesn’t introduce -->
<!-- new variables. This `y` *is* the outer `y` rather than a new shadowed `y`, and -->
<!-- we can look for a value that has the same value as the outer `y` by comparing -->
<!-- `n` to `y`. -->
<p>マッチガードの<code>if n == y</code>はパターンではなく、故に新しい変数を導入しません。この<code>y</code>は、
新しいシャドウイングされた<code>y</code>ではなく、外側の<code>y</code><em>であり</em>、<code>n</code>と<code>y</code>を比較することで、
外側の<code>y</code>と同じ値を探すことができます。</p>
<!-- You can also use the *or* operator `|` in a match guard to specify multiple -->
<!-- patterns; the match guard condition will apply to all the patterns. Listing -->
<!-- 18-31 shows the precedence of combining a match guard with a pattern that uses -->
<!-- `|`. The important part of this example is that the `if y` match guard applies -->
<!-- to `4`, `5`, *and* `6`, even though it might look like `if y` only applies to -->
<!-- `6`. -->
<p>また、マッチガードで<em>or</em>演算子の<code>|</code>を使用して複数のパターンを指定することもできます;
マッチガードの条件は全てのパターンに適用されます。リスト18-31は、
<code>|</code>を使用するパターンとマッチガードを組み合わせる優先度を示しています。この例で重要な部分は、
<code>if y</code>は<code>6</code>にしか適用されないように見えるのに、<code>if y</code>マッチガードが<code>4</code>、<code>5</code>、<em>そして</em><code>6</code>に適用されることです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 4;
let y = false;

match x {
    // はい
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    // いいえ
    _ =&gt; println!(&quot;no&quot;),
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-31: Combining multiple patterns with a match -->
<!-- guard</span> -->
<p><span class="caption">リスト18-31: 複数のパターンとマッチガードを組み合わせる</span></p>
<!-- The match condition states that the arm only matches if the value of `x` is -->
<!-- equal to `4`, `5`, or `6` *and* if `y` is `true`. When this code runs, the -->
<!-- pattern of the first arm matches because `x` is `4`, but the match guard `if y` -->
<!-- is false, so the first arm is not chosen. The code moves on to the second arm, -->
<!-- which does match, and this program prints `no`. The reason is that the `if` -->
<!-- condition applies to the whole pattern `4 | 5 | 6`, not only to the last value -->
<!-- `6`. In other words, the precedence of a match guard in relation to a pattern -->
<!-- behaves like this: -->
<p>マッチの条件は、<code>x</code>の値が<code>4</code>、<code>5</code>、<code>6</code>に等しく<em>かつ</em><code>y</code>が<code>true</code>の場合だけにアームがマッチすると宣言しています。
このコードが走ると、最初のアームのパターンは<code>x</code>が<code>4</code>なので、合致しますが、マッチガード<code>if y</code>は偽なので、
最初のアームは選ばれません。コードは2番目のアームに移動し、これがマッチし、このプログラムは<code>no</code>と出力します。
理由は、<code>if</code>条件が最後の値の<code>6</code>だけでなく、パターン全体<code>4 | 5 | 6</code>に適用されるからです。
言い換えると、パターンと関わるマッチガードの優先度は、以下のように振る舞います:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<!-- rather than this: -->
<p>以下のようにではありません:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<!-- After running the code, the precedence behavior is evident: if the match guard -->
<!-- ware applied only to the final value in the list of values specified using the -->
<!-- `|` operator, the arm would have matched and the program would have printed -->
<!-- `yes`. -->
<p>コードを実行後には、優先度の動作は明らかになります: マッチガードが<code>|</code>演算子で指定される値のリストの最後の値にしか適用されないなら、
アームはマッチし、プログラムは<code>yes</code>と出力したでしょう。</p>
<!-- ### `@` Bindings -->
<a class="header" href="print.html#a束縛" id="a束縛"><h3><code>@</code>束縛</h3></a>
<!-- The *at* operator (`@`) lets us create a variable that holds a value at the -->
<!-- same time we’re testing that value to see whether it matches a pattern. Listing -->
<!-- 18-32 shows an example where we want to test that a `Message::Hello` `id` field -->
<!-- is within the range `3...7`. But we also want to bind the value to the variable -->
<!-- `id_variable` so we can use it in the code associated with the arm. We could -->
<!-- name this variable `id`, the same as the field, but for this example we’ll use -->
<!-- a different name. -->
<p><em>at</em>演算子(<code>@</code>)により、値を保持する変数を生成するのと同時にその値がパターンに一致するかを調べることができます。
リスト18-32は、<code>Message::Hello</code>の<code>id</code>フィールドが範囲<code>3...7</code>にあるかを確かめたいという例です。
しかし、アームに紐付いたコードで使用できるように変数<code>id_variable</code>に値を束縛もしたいです。この変数をフィールドと同じ、
<code>id</code>と名付けることもできますが、この例では異なる名前にします。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3...7 } =&gt; {
        // 範囲内のidが見つかりました: {}
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10...12 } =&gt; {
        // 別の範囲内のidが見つかりました
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        // それ以外のidが見つかりました
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 18-32: Using `@` to bind to a value in a pattern -->
<!-- while also testing it</span> -->
<p><span class="caption"><code>@</code>を使用してテストしつつパターンの値に束縛する</span></p>
<!-- This example will print `Found an id in range: 5`. By specifying `id_variable -->
<!-- @` before the range `3...7`, we’re capturing whatever value matched the range -->
<!-- while also testing that the value matched the range pattern. -->
<p>この例は、<code>Found an id in range: 5</code>と出力します。範囲<code>3...7</code>の前に<code>id_variable @</code>と指定することで、
値が範囲パターンに一致することを確認しつつ、範囲にマッチしたどんな値も捕捉しています。</p>
<!-- In the second arm, where we only have a range specified in the pattern, the code -->
<!-- associated with the arm doesn’t have a variable that contains the actual value -->
<!-- of the `id` field. The `id` field’s value could have been 10, 11, or 12, but -->
<!-- the code that goes with that pattern doesn’t know which it is. The pattern code -->
<!-- isn’t able to use the value from the `id` field, because we haven’t saved the -->
<!-- `id` value in a variable. -->
<p>パターンで範囲しか指定していない2番目のアームでは、アームに紐付いたコードに<code>id</code>フィールドの実際の値を含む変数はありません。
<code>id</code>フィールドの値は10、11、12だった可能性もありますが、そのパターンに当てはまるコードは、
どれなのかわかりません。パターンのコードは<code>id</code>フィールドの値を使用することは叶いません。
<code>id</code>の値を変数に保存していないからです。</p>
<!-- In the last arm, where we’ve specified a variable without a range, we do have -->
<!-- the value available to use in the arm’s code in a variable named `id`. The -->
<!-- reason is that we’ve used the struct field shorthand syntax. But we haven’t -->
<!-- applied any test to the value in the `id` field in this arm, as we did with the -->
<!-- first two arms: any value would match this pattern. -->
<p>範囲なしに変数を指定している最後のアームでは、確かにアームのコードで使用可能な値が<code>id</code>という変数にあります。
理由は、構造体フィールド省略記法を使ったからです。しかし、このアームで<code>id</code>フィールドの値に対して、
最初の2つのアームのようには、確認を行っていません: どんな値でも、このパターンに一致するでしょう。</p>
<!-- Using `@` lets us test a value and save it in a variable within one pattern. -->
<p><code>@</code>を使用することで、値を調べつつ、1つのパターン内で変数に保存させてくれるのです。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-15" id="aまとめ-15"><h2>まとめ</h2></a>
<!-- Rust’s patterns are very useful in that they help distinguish between different -->
<!-- kinds of data. When used in `match` expressions, Rust ensures your patterns -->
<!-- cover every possible value, or your program won’t compile. Patterns in `let` -->
<!-- statements and function parameters make those constructs more useful, enabling -->
<!-- the destructuring of values into smaller parts at the same time as assigning to -->
<!-- variables. We can create simple or complex patterns to suit our needs. -->
<p>Rustのパターンは、異なる種類のデータを区別するのに役立つという点でとても有用です。<code>match</code>式で使用されると、
コンパイラはパターンが全ての可能性を網羅しているか保証し、そうでなければプログラムはコンパイルできません。
<code>let</code>文や関数の引数のパターンは、その構文をより有用にし、値を分解して小さな部品にすると同時に変数に代入できるようにしてくれます。
単純だったり複雑だったするパターンを生成してニーズに合わせることができます。</p>
<!-- Next, for the penultimate chapter of the book, we’ll look at some advanced -->
<!-- aspects of a variety of Rust’s features. -->
<p>次の本の末尾から2番目の章では、Rustのいろんな機能の高度な視点に目を向けます。</p>
<!-- # Advanced Features -->
<a class="header" href="print.html#a高度な機能" id="a高度な機能"><h1>高度な機能</h1></a>
<!-- By now, you’ve learned the most commonly used parts of the Rust programming -->
<!-- language. Before we do one more project in Chapter 20, we’ll look at a few -->
<!-- aspects of the language you might run into every once in a while. You can use -->
<!-- this chapter as a reference for when you encounter any unknowns when using -->
<!-- Rust. The features you’ll learn to use in this chapter are useful in very -->
<!-- specific situations. Although you might not reach for them often, we want to -->
<!-- make sure you have a grasp of all the features Rust has to offer. -->
<p>今までに、Rustプログラミング言語の最もよく使われる部分を学んできました。第20章でもう1つ別のプロジェクトを行う前に、
時折遭遇する言語の側面をいくつか見ましょう。この章は、Rustを使用する際に知らないことに遭遇した時に参考にすることができます。
この章で使用することを学ぶ機能は、かなり限定的な場面でしか役に立ちません。あまり頻繁には手を伸ばすことがない可能性はありますが、
Rustが提供しなければならない機能全ての概要を確かに把握していただきたいのです。</p>
<!-- In this chapter, we’ll cover: -->
<p>この章で講義するのは:</p>
<!-- * Unsafe Rust: how to opt out of some of Rust’s guarantees and take -->
<!--   responsibility for manually upholding those guarantees -->
<!-- * Advanced lifetimes: syntax for complex lifetime situations -->
<!-- * Advanced traits: associated types, default type parameters, fully qualified -->
<!--   syntax, supertraits, and the newtype pattern in relation to traits -->
<!-- * Advanced types: more about the newtype pattern, type aliases, the never type, -->
<!--   and dynamically sized types -->
<!-- * Advanced functions and closures: function pointers and returning closures -->
<ul>
<li>Unsafe Rust: Rustの保証の一部を抜けてその保証を手動で保持する責任を負う方法</li>
<li>高度なライフタイム: 複雑なライフタイムの記法</li>
<li>高度なトレイト: 関連型、デフォルト型引数、フルパス記法、スーパートレイト、トレイトに関連するニュータイプパターン</li>
<li>高度な型: ニュータイプパターンについてもっと、型エイリアス、never型、動的サイズ型</li>
<li>高度な関数とクロージャ: 関数ポインタとクロージャの返却</li>
</ul>
<!-- It’s a panoply of Rust features with something for everyone! Let’s dive in! -->
<p>皆さんのための何かがあるRustの機能の盛大な儀式です！さあ、飛び込みましょう！</p>
<!-- ## Unsafe Rust -->
<a class="header" href="print.html#unsafe-rust" id="unsafe-rust"><h2>Unsafe Rust</h2></a>
<!-- All the code we’ve discussed so far has had Rust’s memory safety guarantees -->
<!-- enforced at compile time. However, Rust has a second language hidden inside it -->
<!-- that doesn’t enforce these memory safety guarantees: it’s called *unsafe Rust* -->
<!-- and works just like regular Rust, but gives us extra superpowers. -->
<p>ここまでに議論してきたコードは全て、Rustのメモリ安全保証がコンパイル時に強制されていました。しかしながら、
Rustには、これらのメモリ安全保証を強制しない第2の言語が中に隠されています: それは<em>unsafe Rust</em>と呼ばれ、
普通のRustのように動きますが、おまけの強大な力を与えてくれます。</p>
<!-- Unsafe Rust exists because, by nature, static analysis is conservative. When -->
<!-- the compiler tries to determine whether or not code upholds the guarantees, -->
<!-- it’s better for it to reject some valid programs rather than accept some -->
<!-- invalid programs. Although the code might be okay, as far as Rust is able to -->
<!-- tell, it’s not! In these cases, you can use unsafe code to tell the compiler, -->
<!-- “Trust me, I know what I’m doing.” The downside is that you use it at our own -->
<!-- risk: if you use unsafe code incorrectly, problems due to memory unsafety, such -->
<!-- as null pointer dereferencing, can occur. -->
<p>静的解析は原理的に保守的なので、unsafe Rustが存在します。コードが保証を保持しているかコンパイラが決定しようとする際、
なんらかの不正なプログラムを受け入れるよりも有効なプログラムを拒否したほうがいいのです。コードは大丈夫かもしれないけれど、
コンパイラにわかる範囲ではダメなのです！このような場合、unsafeコードを使用してコンパイラに「信じて！何をしているかわかってるよ」と教えられます。
欠点は、自らのリスクで使用することです: unsafeコードを誤って使用したら、
nullポインタ参照外しなどのメモリ非安全に起因する問題が起こることもあるのです。</p>
<!-- Another reason Rust has an unsafe alter ego is that the underlying computer -->
<!-- hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you -->
<!-- couldn’t do certain tasks. Rust needs to allow you to do low-level systems -->
<!-- programming, such as directly interacting with the operating system or even -->
<!-- writing your own operating system. Working with low-level systems programming -->
<!-- is one of the goals of the language. Let’s explore what we can do with unsafe -->
<!-- Rust and how to do it. -->
<p>Rustにunsafeな分身がある別の理由は、根本にあるコンピュータのハードウェアが本質的にunsafeだからです。
Rustがunsafeな処理を行わせてくれなかったら、特定の仕事を行えないでしょう。Rustは、低レベルなシステムプログラミングを許可する必要があります。
直接OSと相互作用したり、独自のOSを書くことさえもそうです。低レベルなシステムプログラミングに取り組むことは、
言語の目標の1つなのです。unsafe Rustでできることとその方法を探求しましょう。</p>
<!-- ### Unsafe Superpowers -->
<a class="header" href="print.html#unsafeの強大な力" id="unsafeの強大な力"><h3>unsafeの強大な力</h3></a>
<!-- To switch to unsafe Rust, use the `unsafe` keyword and then start a new block -->
<!-- that holds the unsafe code. You can take four actions in unsafe Rust, called -->
<!-- *unsafe superpowers*, that you can’t in safe Rust. Those superpowers include -->
<!-- the ability to: -->
<p>unsafe Rustに切り替えるには、<code>unsafe</code>キーワードを使用し、それからunsafeコードを保持する新しいブロックを開始してください。
safe Rustでは行えない4つの行動をunsafe Rustでは行え、これは<em>unsafe superpowers</em>と呼ばれます。
そのsuperpowerには、以下の能力が含まれています:</p>
<!-- * Dereference a raw pointer -->
<!-- * Call an unsafe function or method -->
<!-- * Access or modify a mutable static variable -->
<!-- * Implement an unsafe trait -->
<ul>
<li>生ポインタを参照外しすること</li>
<li>unsafeな関数やメソッドを呼ぶこと</li>
<li>可変で静的な変数にアクセスしたり変更すること</li>
<li>unsafeなトレイトを実装すること</li>
</ul>
<!-- It’s important to understand that `unsafe` doesn’t turn off the borrow checker -->
<!-- or disable any other of Rust’s safety checks: if you use a reference in unsafe -->
<!-- code, it will still be checked. The `unsafe` keyword only gives you access to -->
<!-- these four features that are then not checked by the compiler for memory -->
<!-- safety. You'll still get some degree of safety inside of an unsafe block. -->
<p><code>unsafe</code>は、借用精査機や他のRustの安全性チェックを無効にしないことを理解するのは重要なことです:
unsafeコードで参照を使用しても、チェックはされます。<code>unsafe</code>キーワードにより、これら4つの機能にアクセスできるようになり、
その場合、コンパイラによってこれらのメモリ安全性は確認されないのです。unsafeブロック内でも、ある程度の安全性は得られます。</p>
<!-- In addition, `unsafe` does not mean the code inside the block is necessarily -->
<!-- dangerous or that it will definitely have memory safety problems: the intent is -->
<!-- that as the programmer, you’ll ensure the code inside an `unsafe` block will -->
<!-- access memory in a valid way. -->
<p>また、unsafeは、そのブロックが必ずしも危険だったり、絶対メモリ安全上の問題を抱えていることを意味するものではありません:
その意図は、プログラマとして<code>unsafe</code>ブロック内のコードがメモリに合法的にアクセスすることを保証することです。</p>
<!-- People are fallible, and mistakes will happen, but by requiring these four -->
<!-- unsafe operations to be inside blocks annotated with `unsafe` you’ll know that -->
<!-- any errors related to memory safety must be within an `unsafe` block. Keep -->
<!-- `unsafe` blocks small; you’ll be thankful later when you investigate memory -->
<!-- bugs. -->
<p>人間は失敗をするもので、間違いも起きますが、これら4つのunsafeな処理を<code>unsafe</code>で注釈されたブロックに入れる必要があることで、
メモリ安全性に関するどんなエラーも<code>unsafe</code>ブロック内にあるに違いないと知ります。<code>unsafe</code>ブロックは小さくしてください;
メモリのバグを調査するときに感謝することになるでしょう。</p>
<!-- To isolate unsafe code as much as possible, it’s best to enclose unsafe code -->
<!-- within a safe abstraction and provide a safe API, which we’ll discuss later in -->
<!-- the chapter when we examine unsafe functions and methods. Parts of the standard -->
<!-- library are implemented as safe abstractions over unsafe code that has been -->
<!-- audited. Wrapping unsafe code in a safe abstraction prevents uses of `unsafe` -->
<!-- from leaking out into all the places that you or your users might want to use -->
<!-- the functionality implemented with `unsafe` code, because using a safe -->
<!-- abstraction is safe. -->
<p>unsafeなコードをできるだけ分離するために、unsafeなコードを安全な抽象の中に閉じ込め、安全なAPIを提供するのが最善です。
これについては、後ほどunsafeな関数とメソッドを調査する際に議論します。標準ライブラリの一部は、
検査されたunsafeコードの安全な抽象として実装されています。安全な抽象にunsafeなコードを包むことで、
<code>unsafe</code>があなたやあなたのユーザが<code>unsafe</code>コードで実装された機能を使いたがる可能性のある箇所全部に漏れ出ることを防ぎます。
安全な抽象を使用することは、安全だからです。</p>
<!-- Let’s look at each of the four unsafe superpowers in turn. We’ll also look at -->
<!-- some abstractions that provide a safe interface to unsafe code. -->
<p>4つのunsafeなsuperpowerを順に見ていきましょう。unsafeなコードへの安全なインターフェイスを提供する一部の抽象化にも目を向けます。</p>
<!-- ### Dereferencing a Raw Pointer -->
<a class="header" href="print.html#a生ポインタを参照外しする" id="a生ポインタを参照外しする"><h3>生ポインタを参照外しする</h3></a>
<!-- In Chapter 4, in the “Dangling References” section, we mentioned that the -->
<!-- compiler ensures references are always valid. Unsafe Rust has two new types -->
<!-- called *raw pointers* that are similar to references. As with references, raw -->
<!-- pointers can be immutable or mutable and are written as `*const T` and `*mut -->
<!-- T`, respectively. The asterisk isn’t the dereference operator; it’s part of the -->
<!-- type name. In the context of raw pointers, *immutable* means that the pointer -->
<!-- can’t be directly assigned to after being dereferenced. -->
<p>第4章の「ダングリング参照」節で、コンパイラは、参照が常に有効であることを保証することに触れました。
unsafe Rustには参照に類似した<em>生ポインタ</em>と呼ばれる2つの新しい型があります。参照同様、
生ポインタも不変や可変になり得て、それぞれ<code>*const T</code>と<code>*mut T</code>と表記されます。このアスタリスクは、参照外し演算子ではありません;
型名の一部です。生ポインタの文脈では、<em>不変</em>は、参照外し後に直接ポインタに代入できないことを意味します。</p>
<!-- Different from references and smart pointers, raw pointers: -->
<p>参照やスマートポインタと異なり、生ポインタは:</p>
<!-- * Are allowed to ignore the borrowing rules by having both immutable and -->
<!--   mutable pointers or multiple mutable pointers to the same location -->
<!-- * Aren’t guaranteed to point to valid memory -->
<!-- * Are allowed to be null -->
<!-- * Don’t implement any automatic cleanup -->
<ul>
<li>同じ場所への不変と可変なポインタや複数の可変なポインタが存在することで借用規則を無視できる</li>
<li>有効なメモリを指しているとは保証されない</li>
<li>nullの可能性がある</li>
<li>自動的な片付けは実装されていない</li>
</ul>
<!-- By opting out of having Rust enforce these guarantees, you can give up -->
<!-- the guaranteed safety in exchange ofor greater performance or the ability to -->
<!-- interface with another language or hardware where Rust’s guarantees don’t apply. -->
<p>これらの保証をコンパイラに強制させることから抜けることで、保証された安全性を諦めてパフォーマンスを向上させたり、
Rustの保証が適用されない他の言語やハードウェアとのインターフェイスの能力を得ることができます。</p>
<!-- Listing 19-1 shows how to create an immutable and a mutable raw pointer from -->
<!-- references. -->
<p>リスト19-1は、参照から不変と可変な生ポインタを生成する方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-1: Creating raw pointers from references</span> -->
<p><span class="caption">リスト19-1: 参照から生ポインタを生成する</span></p>
<!-- Notice that we don’t include the `unsafe` keyword in this code. We can create -->
<!-- raw pointers in safe code; we just can’t dereference raw pointers outside an -->
<!-- unsafe block, as you’ll see in a bit. -->
<p>このコードには<code>unsafe</code>キーワードを含めていないことに気付いてください。safeコードで生ポインタを生成できます;
もうすぐわかるように、unsafeブロックの外では、生ポインタを参照外しできないだけなのです。</p>
<!-- We’ve created raw pointers by using `as` to cast an immutable and a mutable -->
<!-- reference into their corresponding raw pointer types. Because we created them -->
<!-- directly from references guaranteed to be valid, we know these particular raw -->
<!-- pointers are valid, but we can’t make that assumption about just any raw -->
<!-- pointer. -->
<p><code>as</code>を使って不変と可変な参照を対応する生ポインタの型にキャストして生ポインタを生成しました。
有効であることが保証される参照から直接生ポインタを生成したので、これらの特定の生ポインタは有効であることがわかりますが、
その前提をあらゆる生ポインタに敷くことはできません。</p>
<!-- Next, we’ll create a raw pointer whose validity we can’t be so certain of. -->
<!-- Listing 19-2 shows how to create a raw pointer to an arbitrary location in -->
<!-- memory. Trying to use arbitrary memory is undefined: there might be data at -->
<!-- that address or there might not, the compiler might optimize the code so there -->
<!-- is no memory access, or the program might error with a segmentation fault. -->
<!-- Usually, there is no good reason to write code like this, but it is possible. -->
<p>次に、有効であることが確信できない生ポインタを生成します。リスト19-2は、メモリの任意の箇所を指す生ポインタの生成法を示しています。
任意のメモリを使用しようとすることは未定義です: そのアドレスにデータがある可能性もあるし、ない可能性もあり、
コンパイラがコードを最適化してメモリアクセスがなくなる可能性もあるし、プログラムがセグメンテーションフォールトでエラーになる可能性もあります。
通常、このようなコードを書くいい理由はありませんが、可能ではあります。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let address = 0x012345usize;
let r = address as *const i32;
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary -->
<!-- memory address</span> -->
<p><span class="caption">リスト19-2: 任意のメモリアドレスへの生ポインタを生成する</span></p>
<!-- Recall that we can create raw pointers in safe code, but we can’t *dereference* -->
<!-- raw pointers and read the data being pointed to. In Listing 19-3, we use the -->
<!-- dereference operator `*` on a raw pointer that requires an `unsafe` block. -->
<p>safeコードで生ポインタを生成できるけれども、生ポインタを<em>参照外し</em>して指しているデータを読むことはできないことを思い出してください。
リスト19-3では、<code>unsafe</code>ブロックが必要になる参照外し演算子の<code>*</code>を生ポインタに使っています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-3: Dereferencing raw pointers within an -->
<!-- `unsafe` block</span> -->
<p><span class="caption">リスト19-3: <code>unsafe</code>ブロック内で生ポインタを参照外しする</span></p>
<!-- Creating a pointer does no harm; it’s only when we try to access the value that -->
<!-- it points at that we might end up dealing with an invalid value. -->
<p>ポインタの生成は害を及ぼしません; 無効な値を扱うことに落ち着く可能性のあるポインタが指している値にアクセスしようとする時のみです。</p>
<!-- Note also that in Listing 19-1 and 19-3, we created `*const i32` and `*mut i32` -->
<!-- raw pointers that both pointed to the same memory location, where `num` is -->
<!-- stored. If we instead tried to create an immutable and a mutable reference to -->
<!-- `num`, the code would not have compiled because Rust’s ownership rules don’t -->
<!-- allow a mutable reference at the same time as any immutable references. With -->
<!-- raw pointers, we can create a mutable pointer and an immutable pointer to the -->
<!-- same location and change data through the mutable pointer, potentially creating -->
<!-- a data race. Be careful! -->
<p>また、リスト19-1とリスト19-3では、
<code>num</code>が格納されている同じメモリ上の場所を両方とも指す<code>*const i32</code>と<code>*mut i32</code>の生ポインタを生成したことに注目してください。
代わりに<code>num</code>への不変と可変な参照を生成しようとしたら、コードはコンパイルできなかったでしょう。
Rustの所有権規則により、不変参照と可変参照を同時に存在させられないからです。生ポインタなら、
同じ場所への可変なポインタと不変なポインタを生成でき、可変なポインタを通してデータを変更し、データ競合を引き起こす可能性があります。
気を付けてください！</p>
<!-- With all of these dangers, why would you ever use raw pointers? One major use -->
<!-- case is when interfacing with C code, as you’ll see in the next section, -->
<!-- “Calling an Unsafe Function or Method.” Another case is when building up safe -->
<!-- abstractions that the borrow checker doesn’t understand. We’ll introduce unsafe -->
<!-- functions and then look at an example of a safe abstraction that uses unsafe -->
<!-- code. -->
<p>これらの危険がありながら、一体何故生ポインタを使うのでしょうか？主なユースケースの1つは、次の節「unsafeな関数やメソッドを呼ぶ」で見るように、
Cコードとのインターフェイスです。別のユースケースは、借用精査機には理解できない安全な抽象を構成する時です。
unsafeな関数を導入し、それからunsafeコードを使用する安全な抽象の例に目を向けます。</p>
<!-- ### Calling an Unsafe Function or Method -->
<a class="header" href="print.html#unsafeな関数やメソッドを呼ぶ" id="unsafeな関数やメソッドを呼ぶ"><h3>unsafeな関数やメソッドを呼ぶ</h3></a>
<!-- The second type of operation that requires an unsafe block is calls to unsafe -->
<!-- functions. Unsafe functions and methods look exactly like regular functions and -->
<!-- methods, but they have an extra `unsafe` before the rest of the definition. The -->
<!-- `unsafe` keyword in this context indicates the function has requirements we -->
<!-- need to uphold when we call this function, because Rust can’t guarantee we’ve -->
<!-- met these requirements. By calling an unsafe function within an `unsafe` block, -->
<!-- we’re saying that we’ve read this function’s documentation and take -->
<!-- responsibility for upholding the function’s contracts. -->
<p>unsafeブロックが必要になる2番目の処理は、unsafe関数の呼び出しです。unsafeな関数やメソッドも見た目は、
普通の関数やメソッドと全く同じですが、定義の残りの前に追加の<code>unsafe</code>があります。この文脈での<code>unsafe</code>キーワードは、
この関数を呼ぶ際に保持しておく必要のある要求が関数にあることを示唆します。コンパイラには、
この要求を満たしているか保証できないからです。<code>unsafe</code>ブロックでunsafeな関数を呼び出すことで、
この関数のドキュメンテーションを読み、関数の契約を守っているという責任を取ると宣言します。</p>
<!-- Here is an unsafe function named `dangerous` that doesn’t do anything in its -->
<!-- body: -->
<p>こちらは、本体で何もしない<code>dangerous</code>というunsafeな関数です:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
#}</code></pre></pre>
<!-- We must call the `dangerous` function within a separate `unsafe` block. If we -->
<!-- try to call `dangerous` without the `unsafe` block, we’ll get an error: -->
<p>個別の<code>unsafe</code>ブロックで<code>dangerous</code>関数を呼ばなければなりません。<code>unsafe</code>ブロックなしで<code>dangerous</code>を呼ぼうとすれば、
エラーになるでしょう:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
(エラー: unsafe関数の呼び出しには、unsafeな関数かブロックが必要です)
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<!-- By inserting the `unsafe` block around our call to `dangerous`, we’re asserting -->
<!-- to Rust that we’ve read the function’s documentation, we understand how to use -->
<!-- it properly, and we’ve verified that we’re fulfilling the contract of the -->
<!-- function. -->
<p><code>dangerous</code>への呼び出しの周りに<code>unsafe</code>ブロックを挿入することで、コンパイラに関数のドキュメンテーションを読み、
適切に使用する方法を理解し、関数の契約を満たしていると確認したことをアサートしています。</p>
<!-- Bodies of unsafe functions are effectively `unsafe` blocks, so to perform other -->
<!-- unsafe operations within an unsafe function, we don’t need to add another -->
<!-- `unsafe` block. -->
<p>unsafe関数の本体は、実効的に<code>unsafe</code>ブロックになるので、unsafe関数内でunsafeな別の処理を行うには、
別の<code>unsafe</code>ブロックは必要ないのです。</p>
<!-- #### Creating a Safe Abstraction over Unsafe Code -->
<a class="header" href="print.html#unsafeコードに安全な抽象を行う" id="unsafeコードに安全な抽象を行う"><h4>unsafeコードに安全な抽象を行う</h4></a>
<!-- Just because a function contains unsafe code doesn’t mean we need to mark the -->
<!-- entire function as unsafe. In fact, wrapping unsafe code in a safe function is -->
<!-- a common abstraction. As an example, let’s study a function from the standard -->
<!-- library, `split_at_mut`, that requires some unsafe code and explore how we -->
<!-- might implement it. This safe method is defined on mutable slices: it takes one -->
<!-- slice and makes it two by splitting the slice at the index given as an -->
<!-- argument. Listing 19-4 shows how to use `split_at_mut`. -->
<p>関数がunsafeなコードを含んでいるだけで関数全体をunsafeでマークする必要があることにはなりません。
事実、安全な関数でunsafeなコードをラップすることは一般的な抽象化です。例として、
なんらかのunsafeコードが必要になる標準ライブラリの関数<code>split_at_mut</code>を学び、その実装方法を探求しましょう。
この安全なメソッドは、可変なスライスに定義されています: スライスを1つ取り、引数で与えられた添字でスライスを分割して2つにします。
リスト19-4は、<code>split_at_mut</code>の使用法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-4: Using the safe `split_at_mut` -->
<!-- function</span> -->
<p><span class="caption">リスト19-4: 安全な<code>split_at_mut</code>関数を使用する</span></p>
<!-- We can’t implement this function using only safe Rust. An attempt might look -->
<!-- something like Listing 19-5, which won’t compile. For simplicity, we’ll -->
<!-- implement `split_at_mut` as a function rather than a method and only for slices -->
<!-- of `i32` values rather than for a generic type `T`. -->
<p>この関数をsafe Rustだけを使用して実装することはできません。試みは、リスト19-5のようになる可能性がありますが、コンパイルできません。
簡単のため、<code>split_at_mut</code>をメソッドではなく関数として実装し、ジェネリックな型<code>T</code>ではなく、<code>i32</code>のスライス用に実装します。</p>
<pre><code class="language-rust ignore">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<!-- <span class="caption">Listing 19-5: An attempted implementation of -->
<!-- `split_at_mut` using only safe Rust</span> -->
<p><span class="caption">リスト19-5: safe Rustだけを使用した<code>split_at_mut</code>の未遂の実装</span></p>
<!-- This function first gets the total length of the slice. Then it asserts that -->
<!-- the index given as a parameter is within the slice by checking whether it’s -->
<!-- less than or equal to the length. The assertion means that if we pass an index -->
<!-- that is greater than the index to split the slice at, the function will panic -->
<!-- before it attempts to use that index. -->
<p>この関数はまず、スライスの全体の長さを得ます。それから引数で与えられた添え字が長さ以下であるかを確認してスライス内にあることをアサートします。
このアサートは、スライスを分割する添字よりも大きい添字を渡したら、その添字を使用しようとする前に関数がパニックすることを意味します。</p>
<!-- Then we return two mutable slices in a tuple: one from the start of the -->
<!-- original slice to the `mid` index and another from `mid` to the end of the -->
<!-- slice. -->
<p>そして、2つの可変なスライスをタプルで返します: 1つは元のスライスの最初から<code>mid</code>添字まで、
もう一方は、<code>mid</code>からスライスの終わりまでです。</p>
<!-- When we try to compile the code in Listing 19-5, we’ll get an error. -->
<p>リスト19-5のコードのコンパイルを試みると、エラーになるでしょう。</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
(エラー: 一度に2回以上、`*slice`を可変で借用できません)
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre>
<!-- Rust’s borrow checker can’t understand that we’re borrowing different parts of -->
<!-- the slice; it only knows that we’re borrowing from the same slice twice. -->
<!-- Borrowing different parts of a slice is fundamentally okay because the two -->
<!-- slices aren’t overlapping, but Rust isn’t smart enough to know this. When we -->
<!-- know code is okay, but Rust doesn’t, it’s time to reach for unsafe code. -->
<p>Rustの借用精査機には、スライスの異なる部分を借用していることが理解できないのです;
同じスライスから2回借用していることだけ知っています。2つのスライスが被らないので、
スライスの異なる部分を借用することは、根本的に大丈夫なのですが、コンパイラはこれを知れるほど賢くありません。
プログラマにはコードが大丈夫とわかるのに、コンパイラにはわからないのなら、unsafeコードに手を伸ばすタイミングです。</p>
<!-- Listing 19-6 shows how to use an `unsafe` block, a raw pointer, and some calls -->
<!-- to unsafe functions to make the implementation of `split_at_mut` work. -->
<p>リスト19-6は<code>unsafe</code>ブロック、生ポインタ、unsafe関数への呼び出しをして<code>split_at_mut</code>の実装が動くようにする方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-6: Using unsafe code in the implementation of -->
<!-- the `split_at_mut` function</span> -->
<p><span class="caption">リスト19-6: <code>split_at_mut</code>関数の実装でunsafeコードを使用する</span></p>
<!-- Recall from “The Slice Type” section in Chapter 4 that slices are a pointer to -->
<!-- some data and the length of the slice. We use the `len` method to get the -->
<!-- length of a slice and the `as_mut_ptr` method to access the raw pointer of a -->
<!-- slice. In this case, because we have a mutable slice to `i32` values, -->
<!-- `as_mut_ptr` returns a raw pointer with the type `*mut i32`, which we’ve stored -->
<!-- in the variable `ptr`. -->
<p>第4章の「スライス型」節から、スライスはなんらかのデータへのポインタとスライスの長さであることを思い出してください。
<code>len</code>メソッドを使用してスライスの長さを得て、<code>as_mut_ptr</code>メソッドを使用してスライスの生ポインタにアクセスしています。
この場合、<code>i32</code>値の可変スライスがあるので、<code>as_mut_ptr</code>は型<code>*mut i32</code>の生ポインタを返し、これを変数<code>ptr</code>に格納しました。</p>
<!-- We keep the assertion that the `mid` index is within the slice. Then we get to -->
<!-- the unsafe code: the `slice::from_raw_parts_mut` function takes a raw pointer -->
<!-- and a length, and it creates a slice. We use this function to create a slice -->
<!-- that starts from `ptr` and is `mid` items long. Then we call the `offset` -->
<!-- method on `ptr` with `mid` as an argument to get a raw pointer that starts at -->
<!-- `mid`, and we create a slice using that pointer and the remaining number of -->
<!-- items after `mid` as the length. -->
<p><code>mid</code>添字がスライス内にあるかというアサートを残しています。そして、unsafeコードに到達します:
<code>slice::from_raw_parts_mut</code>関数は、生ポインタと長さを取り、スライスを生成します。この関数を使って、
<code>ptr</code>から始まり、<code>mid</code>の長さのスライスを生成しています。それから<code>ptr</code>に<code>mid</code>を引数として<code>offset</code>メソッドを呼び出し、
<code>mid</code>で始まる生ポインタを得て、そのポインタと<code>mid</code>の後の残りの要素数を長さとして使用してスライスを生成しています。</p>
<!-- The function `slice::from_raw_parts_mut` is unsafe because it takes a raw -->
<!-- pointer and must trust that this pointer is valid. The `offset` method on raw -->
<!-- pointers is also unsafe, because it must trust that the offset location is also -->
<!-- a valid pointer. Therefore, we had to put an `unsafe` block around our calls to -->
<!-- `slice::from_raw_parts_mut` and `offset` so we could call them. By looking at -->
<!-- the code and by adding the assertion that `mid` must be less than or equal to -->
<!-- `len`, we can tell that all the raw pointers used within the `unsafe` block -->
<!-- will be valid pointers to data within the slice. This is an acceptable and -->
<!-- appropriate use of `unsafe`. -->
<p>関数<code>slice::from_raw_parts_mut</code>は、unsafeです。何故なら、生ポインタを取り、このポインタが有効であることを信用しなければならないからです。
生ポインタの<code>offset</code>メソッドもunsafeです。オフセット位置もまた有効なポインタであることを信用しなければならないからです。
故に、<code>slice::from_raw_parts_mut</code>と<code>offset</code>を呼べるように、その呼び出しの周りに<code>unsafe</code>ブロックを置かなければならなかったのです。
コードを観察して<code>mid</code>が<code>len</code>以下でなければならないとするアサートを追加することで、
<code>unsafe</code>ブロック内で使用されている生ポインタが全てスライス内のデータへの有効なポインタであることがわかります。
これは、受け入れられ、適切な<code>unsafe</code>の使用法です。</p>
<!-- Note that we don’t need to mark the resulting `split_at_mut` function as -->
<!-- `unsafe`, and we can call this function from safe Rust. We’ve created a safe -->
<!-- abstraction to the unsafe code with an implementation of the function that uses -->
<!-- `unsafe` code in a safe way, because it creates only valid pointers from the -->
<!-- data this function has access to. -->
<p>できあがった<code>split_at_mut</code>関数を<code>unsafe</code>でマークする必要はなく、この関数をsafe Rustから呼び出せることに注目してください。
<code>unsafe</code>コードを安全に使用する関数の実装でunsafeコードへの安全な抽象化を行いました。
この関数がアクセスするデータからの有効なポインタだけを生成するからです。</p>
<!-- In contrast, the use of `slice::from_raw_parts_mut` in Listing 19-7 would -->
<!-- likely crash when the slice is used. This code takes an arbitrary memory -->
<!-- location and creates a slice 10,000 items long: -->
<p>対照的に、リスト19-7の<code>slice::from_raw_parts_mut</code>の使用は、スライスが使用されるとクラッシュする可能性が高いでしょう。
このコードは任意のメモリアドレスを取り、10,000要素の長さのスライスを生成します:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-7: Creating a slice from an arbitrary memory -->
<!-- location</span> -->
<p><span class="caption">リスト19-7: 任意のメモリアドレスからスライスを生成する</span></p>
<!-- We don’t own the memory at this arbitrary location, and there is no guarantee -->
<!-- that the slice this code creates contains valid `i32` values. Attempting to use -->
<!-- `slice` as though it’s a valid slice results in undefined behavior. -->
<p>この任意の場所のメモリは所有していなく、このコードが生成するスライスに有効な<code>i32</code>値が含まれる保証もありません。
<code>slice</code>を有効なスライスであるかのように使用しようとすると、未定義動作に落ち着きます。</p>
<!-- #### Using `extern` Functions to Call External Code -->
<a class="header" href="print.html#extern関数を使用して外部のコードを呼び出す" id="extern関数を使用して外部のコードを呼び出す"><h4><code>extern</code>関数を使用して、外部のコードを呼び出す</h4></a>
<!-- Sometimes, your Rust code might need to interact with code written in another -->
<!-- language. For this, Rust has a keyword, `extern`, that facilitates the creation -->
<!-- and use of a *Foreign Function Interface (FFI)*. An FFI is a way for a -->
<!-- programming language to define functions and enable a different (foreign) -->
<!-- programming language to call those functions. -->
<p>時として、自分のRustコードが他の言語で書かれたコードと相互作用する必要が出てくる可能性があります。このために、
Rustには<code>extern</code>というキーワードがあり、これは、
<em>FFI</em>(Foreign Function Interface: 外部関数インターフェイス)の生成と使用を容易にします。
FFIは、あるプログラミング言語に関数を定義させ、異なる(外部の)プログラミング言語にそれらの関数を呼び出すことを可能にする方法です</p>
<!-- Listing 19-8 demonstrates how to set up an integration with the `abs` function -->
<!-- from the C standard library. Functions declared within `extern` blocks are -->
<!-- always unsafe to call from Rust code. The reason is that other languages don’t -->
<!-- enforce Rust’s rules and guarantees, and Rust can’t check them, so -->
<!-- responsibility falls on the programmer to ensure safety. -->
<p>リスト19-8は、Cの標準ライブラリから<code>abs</code>関数を統合するセットアップ方法をデモしています。
<code>extern</code>ブロック内で宣言された関数は、常にRustコードから呼ぶにはunsafeになります。理由は、
他の言語では、Rustの規則や保証が強制されず、コンパイラもチェックできないので、
安全性を保証する責任はプログラマに降りかかるのです。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        // -3の絶対値は、Cによると{}
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-8: Declaring and calling an `extern` function -->
<!-- defined in another language</span> -->
<p><span class="caption">リスト19-8: 他の言語で定義された<code>extern</code>関数を宣言し、呼び出す</span></p>
<!-- Within the `extern "C"` block, we list the names and signatures of external -->
<!-- functions from another language we want to call. The `"C"` part defines which -->
<!-- *application binary interface (ABI)* the external function uses: the ABI -->
<!-- defines how to call the function at the assembly level. The `"C"` ABI is the -->
<!-- most common and follows the C programming language’s ABI. -->
<p><code>extern &quot;C&quot;</code>ブロック内で他の言語から呼び出した関数の名前とシグニチャを列挙します。<code>&quot;C&quot;</code>の部分は、
外部関数がどの<em>ABI</em>(application binary interface: アプリケーション・バイナリ・インターフェイス)を使用しているか定義します:
ABIは関数の呼び出し方法をアセンブリレベルで定義します。<code>&quot;C&quot;</code>ABIは最も一般的でCプログラミング言語のABIに従っています。</p>
<!-- > #### Calling Rust Functions from Other Languages -->
<!-- > -->
<!-- > We can also use `extern` to create an interface that allows other languages -->
<!-- > to call Rust functions. Instead of an `extern` block, we add the `extern` -->
<!-- > keyword and specify the ABI to use just before the `fn` keyword. We also need -->
<!-- > to add a `#[no_mangle]` annotation to tell the Rust compiler not to mangle -->
<!-- > the name of this function. *Mangling* is when a compiler changes the name -->
<!-- > we’ve given a function to a different name that contains more information for -->
<!-- > other parts of the compilation process to consume but is less human readable. -->
<!-- > Every programming language compiler mangles names slightly differently, so -->
<!-- > for a Rust function to be nameable by other languages, we must disable the -->
<!-- > Rust compiler’s name mangling. -->
<!-- > -->
<!-- > In the following example, we make the `call_from_c` function accessible from -->
<!-- > C code, after it’s compiled to a shared library and linked from C: -->
<!-- > -->
<!-- > ```rust -->
<!-- > #[no_mangle] -->
<!-- > pub extern "C" fn call_from_c() { -->
<!-- >     println!("Just called a Rust function from C!"); -->
<!-- > } -->
<!-- > ``` -->
<!-- > -->
<!-- > This usage of `extern` does not require `unsafe`. -->
<blockquote>
<a class="header" href="print.html#a他の言語からrustの関数を呼び出す" id="a他の言語からrustの関数を呼び出す"><h4>他の言語からRustの関数を呼び出す</h4></a>
<p>また、<code>extern</code>を使用して他の言語にRustの関数を呼ばせるインターフェイスを生成することもできます。
<code>extern</code>ブロックの代わりに、<code>extern</code>キーワードを追加し、<code>fn</code>キーワードの直前に使用するABIを指定します。
さらに、<code>#[no_mangle]</code>注釈を追加してRustコンパイラに関数名をマングルしないように指示する必要もあります。
<em>マングル</em>とは、コンパイラが関数に与えた名前を他のコンパイル過程の情報をより多く含むけれども、人間に読みにくい異なる名前にすることです。
全ての言語のコンパイラは、少々異なる方法でマングルを行うので、Rustの関数が他の言語で名前付けできるように、
Rustコンパイラの名前マングルをオフにしなければならないのです。</p>
<p>以下の例では、共有ライブラリにコンパイルし、Cからリンクした後に<code>call_from_c</code>関数をCコードからアクセスできるようにしています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
#}</code></pre></pre>
<p>この<code>extern</code>の使用法では、<code>unsafe</code>は必要ありません。</p>
</blockquote>
<!-- ### Accessing or Modifying a Mutable Static Variable -->
<a class="header" href="print.html#a可変で静的な変数にアクセスしたり変更する" id="a可変で静的な変数にアクセスしたり変更する"><h3>可変で静的な変数にアクセスしたり、変更する</h3></a>
<!-- Until now, we’ve not talked about *global variables*, which Rust does support -->
<!-- but can be problematic with Rust’s ownership rules. If two threads are -->
<!-- accessing the same mutable global variable, it can cause a data race. -->
<p>今までずっと、<em>グローバル変数</em>について語りませんでした。グローバル変数をRustはサポートしていますが、
Rustの所有権規則で問題になることもあります。2つのスレッドが同じ可変なグローバル変数にアクセスしていたら、
データ競合を起こすこともあります。</p>
<!-- In Rust, global variables are called *static* variables. Listing 19-9 shows an -->
<!-- example declaration and use of a static variable with a string slice as a -->
<!-- value. -->
<p>Rustでは、グローバル変数は、<em>static</em>(静的)変数と呼ばれます。リスト19-9は、
値として文字列スライスのある静的変数の宣言例と使用を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-9: Defining and using an immutable static -->
<!-- variable</span> -->
<p><span class="caption">リスト19-9: 不変で静的な変数を定義し、使用する</span></p>
<!-- Static variables are similar to constants, which we discussed in the -->
<!-- “Differences Between Variables and Constants” section in Chapter 3. The names -->
<!-- of static variables are in `SCREAMING_SNAKE_CASE` by convention, and we *must* -->
<!-- annotate the variable’s type, which is `&'static str` in this example. Static -->
<!-- variables can only store references with the `'static` lifetime, which means -->
<!-- the Rust compiler can figure out the lifetime; we don’t need to annotate it -->
<!-- explicitly. Accessing an immutable static variable is safe. -->
<p>静的変数は、定数に似ています。定数については、第3章の「変数と定数の違い」節で議論しました。
静的変数の名前は慣習で<code>SCREAMING_SNAKE_CASE</code>(<code>直訳</code>: 叫ぶスネークケース)になり、変数の型を注釈し<em>なければなりません</em>。
この例では<code>&amp;'static str</code>です。静的変数は、<code>'static</code>ライフタイムの参照のみ格納でき、
これは、Rustコンパイラがライフタイムを推量できることを意味します; 明示的に注釈する必要はありません。
不変で静的な変数にアクセスすることは安全です。</p>
<!-- Constants and immutable static variables might seem similar, but a subtle -->
<!-- difference is that values in a static variable have a fixed address in memory. -->
<!-- Using the value will always access the same data. Constants, on the other hand, -->
<!-- are allowed to duplicate their data whenever they’re used. -->
<p>定数と不変で静的な変数は、類似して見える可能性がありますが、微妙な差異は、
静的変数の値は固定されたメモリアドレスになることです。値を使用すると、常に同じデータにアクセスします。
一方、定数は使用される度にデータを複製させることができます。</p>
<!-- Another difference between constants and static variables is that static -->
<!-- variables can be mutable. Accessing and modifying mutable static variables is -->
<!-- *unsafe*. Listing 19-10 shows how to declare, access, and modify a mutable -->
<!-- static variable named `COUNTER`. -->
<p>定数と静的変数の別の違いは、静的変数は可変にもなることです。可変で静的な変数にアクセスし変更することは、unsafeです。
リスト19-10は、<code>COUNTER</code>という可変で静的な変数を宣言し、アクセスし、変更する方法を表示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-10: Reading from or writing to a mutable -->
<!-- static variable is unsafe</span> -->
<p><span class="caption">リスト19-10: 可変で静的な変数を読んだり、書き込むのはunsafeである</span></p>
<!-- As with regular variables, we specify mutability using the `mut` keyword. Any -->
<!-- code that reads or writes from `COUNTER` must be within an `unsafe` block. This -->
<!-- code compiles and prints `COUNTER: 3` as we would expect because it’s single -->
<!-- threaded. Having multiple threads access `COUNTER` would likely result in data -->
<!-- races. -->
<p>普通の変数同様、<code>mut</code>キーワードを使用して可変性を指定します。<code>COUNTER</code>を読み書きするコードはどれも、<code>unsafe</code>ブロックになければなりません。
シングルスレッドなので、このコードは想定通り、コンパイルでき、<code>COUNTER: 3</code>と出力します。
複数のスレッドに<code>COUNTER</code>にアクセスさせると、データ競合になる可能性が高いでしょう。</p>
<!-- With mutable data that is globally accessible, it’s difficult to ensure there -->
<!-- are no data races, which is why Rust considers mutable static variables to be -->
<!-- unsafe. Where possible, it’s preferable to use the concurrency techniques and -->
<!-- thread-safe smart pointers we discussed in Chapter 16 so the compiler checks -->
<!-- that data accessed from different threads is done safely. -->
<p>グローバルにアクセス可能な可変なデータがあると、データ競合がないことを保証するのは難しくなり、そのため、
Rustは可変で静的な変数をunsafeと考えるのです。可能なら、コンパイラが異なるスレッドからアクセスされるデータが安全に行われているかを確認するように、
第16章で議論した非同期テクニックとスレッド安全なスマートポインタを使用するのが望ましいです。</p>
<!-- ### Implementing an Unsafe Trait -->
<a class="header" href="print.html#unsafeなトレイトを実装する" id="unsafeなトレイトを実装する"><h3>unsafeなトレイトを実装する</h3></a>
<!-- The final action that works only with `unsafe` is implementing an unsafe trait. -->
<!-- A trait is unsafe when at least one of its methods has some invariant that the -->
<!-- compiler can’t verify. We can declare that a trait is `unsafe` by adding the -->
<!-- `unsafe` keyword before `trait` and marking the implementation of the trait as -->
<!-- `unsafe` too, as shown in Listing 19-11. -->
<p><code>unsafe</code>でのみ動く最後の動作は、unsafeなトレイトを実装することです。少なくとも、1つのメソッドにコンパイラが確かめられない何らかの不変条件があると、
トレイトはunsafeになります。<code>trait</code>の前に<code>unsafe</code>キーワードを追加し、トレイトの実装も<code>unsafe</code>でマークすることで、
トレイトが<code>unsafe</code>であると宣言できます。リスト19-11のようにですね。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe trait Foo {
    // methods go here
    // メソッドがここに来る
}

unsafe impl Foo for i32 {
    // method implementations go here
    // メソッドの実装がここに来る
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-11: Defining and implementing an unsafe -->
<!-- trait</span> -->
<p><span class="caption">リスト19-11: unsafeなトレイトを定義して実装する</span></p>
<!-- By using `unsafe impl`, we’re promising that we’ll uphold the invariants that -->
<!-- the compiler can’t verify. -->
<p><code>unsafe impl</code>を使用することで、コンパイラが確かめられない不変条件を守ることを約束しています。</p>
<!-- As an example, recall the `Sync` and `Send` marker traits we discussed in the -->
<!-- “Extensible Concurrency with the `Sync` and `Send` Traits” section in Chapter -->
<!-- 16: the compiler implements these traits automatically if our types are -->
<!-- composed entirely of `Send` and `Sync` types. If we implement a type that -->
<!-- contains a type that is not `Send` or `Sync`, such as raw pointers, and we want -->
<!-- to mark that type as `Send` or `Sync`, we must use `unsafe`. Rust can’t verify -->
<!-- that our type upholds the guarantees that it can be safely sent across threads -->
<!-- or accessed from multiple threads; therefore, we need to do those checks -->
<!-- manually and indicate as such with `unsafe`. -->
<p>例として、第16章の「<code>Sync</code>と<code>Send</code>トレイトで拡張可能な非同期」節で議論した<code>Sync</code>と<code>Send</code>マーカートレイトを思い出してください:
型が完全に<code>Send</code>と<code>Sync</code>型だけで構成されていたら、コンパイラはこれらのトレイトを自動的に実装します。
生ポインタなどの<code>Send</code>や<code>Sync</code>でない型を含む型を実装し、その型を<code>Send</code>や<code>Sync</code>でマークしたいなら、
<code>unsafe</code>を使用しなければなりません。コンパイラは、型がスレッド間を安全に送信できたり、
複数のスレッドから安全にアクセスできるという保証を保持しているか確かめられません; 故に、そのチェックを手動で行い、
<code>unsafe</code>でそのように示唆する必要があります。</p>
<!-- ### When to Use Unsafe Code -->
<a class="header" href="print.html#aいつunsafeコードを使用するべきか" id="aいつunsafeコードを使用するべきか"><h3>いつunsafeコードを使用するべきか</h3></a>
<!-- Using `unsafe` to take one of the four actions (superpowers) just discussed -->
<!-- isn’t wrong or even frowned upon. But it is trickier to get `unsafe` code -->
<!-- correct because the compiler can’t help uphold memory safety. When you have a -->
<!-- reason to use `unsafe` code, you can do so, and having the explicit `unsafe` -->
<!-- annotation makes it easier to track down the source of problems if they occur. -->
<p><code>unsafe</code>を使って議論したばかりの4つの行動(superpower)のうちの1つを行うのは間違っていたり、認められもしないものではありません。
ですが、<code>unsafe</code>コードを正しくするのは、より巧妙なことでしょう。コンパイラがメモリ安全性を保持する手助けをできないからです。
<code>unsafe</code>コードを使用する理由があるなら、そうすることができ、明示的に<code>unsafe</code>注釈をすることで問題が起きたら、
その原因を追求するのが容易になります。</p>
<!-- ## Advanced Lifetimes -->
<a class="header" href="print.html#a高度なライフタイム" id="a高度なライフタイム"><h2>高度なライフタイム</h2></a>
<!-- In Chapter 10 in the “Validating References with Lifetimes” section, you -->
<!-- learned how to annotate references with lifetime parameters to tell Rust how -->
<!-- lifetimes of different references relate. You saw how every reference has a -->
<!-- lifetime, but most of the time, Rust will let you elide lifetimes. Now we’ll -->
<!-- look at three advanced features of lifetimes that we haven’t covered yet: -->
<p>第10章の「ライフタイムで参照を有効化する」節で、参照をライフタイム引数で注釈し、
コンパイラに異なる参照のライフタイムがどう関連しているかを指示する方法を学びました。全ての参照にはライフタイムがあるものの、
ほとんどの場合、コンパイラがライフタイムを省略させてくれることも見ました。ここでは、
まだ講義していないライフタイムの高度な機能を3つ見ていきます:</p>
<!-- * Lifetime subtyping: ensures that one lifetime outlives another lifetime -->
<!-- * Lifetime bounds: specifies a lifetime for a reference to a generic type -->
<!-- * Inference of trait object lifetimes: allows the compiler to infer trait -->
<!--   object lifetimes and when they need to be specified -->
<ul>
<li>ライフタイム・サブタイピング: あるライフタイムが他のライフタイムより長生きすることを保証する</li>
<li>ライフタイム境界: ジェネリックな型への参照のライフタイムを指定する</li>
<li>トレイトオブジェクトのライフタイムの推論: コンパイラにトレイトオブジェクトのライフタイムを推論させることと指定する必要があるタイミング</li>
</ul>
<!-- ### Ensuring One Lifetime Outlives Another with Lifetime Subtyping -->
<a class="header" href="print.html#aライフタイムサブタイピングによりあるライフタイムが他よりも長生きすることを保証する" id="aライフタイムサブタイピングによりあるライフタイムが他よりも長生きすることを保証する"><h3>ライフタイム・サブタイピングによりあるライフタイムが他よりも長生きすることを保証する</h3></a>
<!-- *Lifetime subtyping* specifies that one lifetime should outlive another -->
<!-- lifetime. To explore lifetime subtyping, imagine we want to write a parser. -->
<!-- We’ll use a structure called `Context` that holds a reference to the string -->
<!-- we’re parsing. We’ll write a parser that will parse this string and return -->
<!-- success or failure. The parser will need to borrow the `Context` to do the -->
<!-- parsing. Listing 19-12 implements this parser code, except the code doesn’t -->
<!-- have the required lifetime annotations, so it won’t compile. -->
<p><em>ライフタイム・サブタイピング</em>(lifetime subtyping; <code>訳注</code>: あえて訳すなら、ライフタイムの継承)は、
あるライフタイムが他のライフタイムよりも長生きすべきであることを指定します。
ライフタイム・サブタイピングを探求するために、パーサを書きたいところを想像してください。
パース(<code>訳注</code>: parse; 構文解析)中の文字列への参照を保持する<code>Context</code>と呼ばれる構造を使用します。この文字列をパースし、
成功か失敗を返すパーサを書きます。パーサは構文解析を行うために<code>Context</code>を借用する必要があるでしょう。
リスト19-12はコードに必要なライフタイム注釈がないことを除いてこのパーサのコードを実装しているので、コンパイルはできません。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Context(&amp;str);

struct Parser {
    context: &amp;Context,
}

impl Parser {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
</code></pre>
<!-- <span class="caption">Listing 19-12: Defining a parser without lifetime -->
<!-- annotations</span> -->
<p><span class="caption">リスト19-12: ライフタイム注釈なしでパーサを定義する</span></p>
<!-- Compiling the code results in errors because Rust expects lifetime parameters -->
<!-- on the string slice in `Context` and the reference to a `Context` in `Parser`. -->
<p>コンパイラは<code>Context</code>の文字列スライスと<code>Parser</code>の<code>Context</code>への参照にライフタイム引数を期待するので、
このコードをコンパイルすると、エラーに落ち着きます。</p>
<!-- For simplicity’s sake, the `parse` function returns `Result<(), &str>`. That -->
<!-- is, the function will do nothing on success and, on failure, will return the -->
<!-- part of the string slice that didn’t parse correctly. A real implementation -->
<!-- would provide more error information and would return a structured data type -->
<!-- when parsing succeeds. We won’t be discussing those details because they aren’t -->
<!-- relevant to the lifetimes part of this example. -->
<p>簡単のため、<code>parse</code>関数は、<code>Result&lt;(), &amp;str&gt;</code>を返します。つまり、関数は成功時には何もせず、
失敗時には、正しくパースできなかった文字列スライスの一部を返すということです。本物の実装は、
もっとエラーの情報を提供し、パースが成功したら、構造化されたデータ型を返すでしょう。そのような詳細を議論するつもりはありません。
この例のライフタイムの部分に関係ないからです。</p>
<!-- To keep this code simple, we won’t write any parsing logic. However, it’s very -->
<!-- likely that somewhere in the parsing logic we would handle invalid input by -->
<!-- returning an error that references the part of the input that is invalid; this -->
<!-- reference is what makes the code example interesting in regard to lifetimes. -->
<!-- Let’s pretend that the logic of our parser is that the input is invalid after -->
<!-- the first byte. Note that this code might panic if the first byte is not on a -->
<!-- valid character boundary; again, we’re simplifying the example to focus on the -->
<!-- lifetimes involved. -->
<p>このコードを単純に保つため、構文解析のロジックは何も書きません。ですが、構文解析ロジックのどこかで、
非合法な入力の一部を参照するエラーを返すことで非合法な入力を扱う可能性が非常に高いでしょう; この参照が、
ライフタイムに関連してこのコード例を面白くしてくれます。パーサのロジックが、最初のバイトの後で入力が不正だった振りをしましょう。
最初のバイトが有効な文字境界になければ、このコードはパニックする可能性があることに注意してください;
ここでも、例を簡略化して関連するライフタイムに集中しています。</p>
<!-- To get this code to compile, we need to fill in the lifetime parameters for the -->
<!-- string slice in `Context` and the reference to the `Context` in `Parser`. The -->
<!-- most straightforward way to do this is to use the same lifetime name -->
<!-- everywhere, as shown in Listing 19-13. Recall from the “Lifetime Annotations in -->
<!-- Struct Definitions” section in Chapter 10 that each of `struct Context<'a>`, -->
<!-- `struct Parser<'a>`, and `impl<'a>` is declaring a new lifetime parameter. -->
<!-- While their names happen to all be the same, the three lifetime parameters -->
<!-- declared in this example aren’t related. -->
<p>このコードをコンパイルできるようにするには、<code>Context</code>の文字列スライスと<code>Parser</code>の<code>Context</code>への参照のライフタイム引数を埋める必要があります。
最も率直な方法は、リスト19-13のように、全ての箇所で同じライフタイム名を使用することです。
第10章の「構造体定義のライフタイム注釈」節から、<code>struct Context&lt;'a&gt;</code>、<code>struct Parser&lt;'a&gt;</code>、
<code>impl&lt;'a&gt;</code>それぞれが新しいライフタイム引数を宣言することを思い出してください。全部の名前が偶然一致しましたが、
この例で宣言された3つのライフタイム引数は、関連していません。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Context&lt;'a&gt;(&amp;'a str);

struct Parser&lt;'a&gt; {
    context: &amp;'a Context&lt;'a&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-13: Annotating all references in `Context` and -->
<!-- `Parser` with lifetime parameters</span> -->
<p><span class="caption">リスト19-13: <code>Context</code>と<code>Parser</code>の全参照をライフタイム引数で注釈する</span></p>
<!-- This code compiles just fine. It tells Rust that a `Parser` holds a reference -->
<!-- to a `Context` with lifetime `'a` and that `Context` holds a string slice that -->
<!-- also lives as long as the reference to the `Context` in `Parser`. Rust’s -->
<!-- compiler error message stated that lifetime parameters were required for these -->
<!-- references, and we’ve now added lifetime parameters. -->
<p>このコードは、単純にうまくコンパイルできます。コンパイラに<code>Parser</code>はライフタイム<code>'a</code>の<code>Context</code>への参照を保持し、
<code>Context</code>は<code>Parser</code>の<code>Context</code>への参照と同じ期間生きる文字列スライスを保持していると指示しています。
Rustコンパイラのエラーメッセージは、これらの参照にライフタイム引数が必要であることを述べていて、
今ではライフタイム引数を追加しました。</p>
<!-- Next, in Listing 19-14, we’ll add a function that takes an instance of -->
<!-- `Context`, uses a `Parser` to parse that context, and returns what `parse` -->
<!-- returns. This code doesn’t quite work. -->
<p>次にリスト19-14では、<code>Context</code>のインスタンスを1つ取り、<code>Parser</code>を使ってその文脈をパースし、
<code>parse</code>が返すものを返す関数を追加します。このコードは完璧には動きません。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<!-- <span class="caption">Listing 19-14: An attempt to add a `parse_context` -->
<!-- function that takes a `Context` and uses a `Parser`</span> -->
<p><span class="caption">リスト19-14: <code>Context</code>を取り、<code>Parser</code>を使用する<code>parse_context</code>関数を追加する試み</span></p>
<!-- We get two verbose errors when we try to compile the code with the addition of -->
<!-- the `parse_context` function: -->
<p><code>parse_context</code>関数を追加してコードをコンパイルしようとすると、2つ冗長なエラーが出ます:</p>
<pre><code class="language-text">error[E0597]: borrowed value does not live long enough
(エラー: 借用された値は十分長生きしません)
  --&gt; src/lib.rs:14:5
   |
14 |     Parser { context: &amp;context }.parse()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough
15 | }
   | - temporary value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
(注釈: 借用された値は、13:1の関数本体で定義された1番目の匿名のライフタイムに有効でなければなりません)
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^

error[E0597]: `context` does not live long enough
  --&gt; src/lib.rs:14:24
   |
14 |     Parser { context: &amp;context }.parse()
   |                        ^^^^^^^ does not live long enough
15 | }
   | - borrowed value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^
</code></pre>
<!-- These errors state that the `Parser` instance that is created and the `context` -->
<!-- parameter live only until the end of the `parse_context` function. But they -->
<!-- both need to live for the entire lifetime of the function. -->
<p>これらのエラーは、生成された<code>Parser</code>インスタンスと<code>context</code>引数が<code>parse_context</code>関数の最後までしか生きないと述べています。
しかし、どちらも関数全体のライフタイムだけ生きる必要があります。</p>
<!-- In other words, `Parser` and `context` need to *outlive* the entire function -->
<!-- and be valid before the function starts as well as after it ends for all the -->
<!-- references in this code to always be valid. The `Parser` we’re creating and the -->
<!-- `context` parameter go out of scope at the end of the function, because -->
<!-- `parse_context` takes ownership of `context`. -->
<p>言い換えると、<code>Parser</code>と<code>context</code>は関数全体より長生きし、このコードの全参照が常に有効であるためには、
関数が始まる前や、終わった後も有効である必要があります。生成している<code>Parser</code>と<code>context</code>引数は、
関数の終わりでスコープを抜けます。<code>parse_context</code>が<code>context</code>の所有権を奪っているからです。</p>
<!-- To figure out why these errors occur, let’s look at the definitions in Listing -->
<!-- 19-13 again, specifically the references in the signature of the `parse` method: -->
<p>これらのエラーが起こる理由を推論するため、再度リスト19-13の定義、特に<code>parse</code>メソッドのシグニチャの参照を観察しましょう:</p>
<pre><code class="language-rust ignore">    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
</code></pre>
<!-- Remember the elision rules? If we annotate the lifetimes of the references -->
<!-- rather than eliding, the signature would be as follows: -->
<p>省略規則を覚えていますか？省略するのではなく、参照のライフタイムを注釈するなら、シグニチャは以下のようになるでしょう:</p>
<pre><code class="language-rust ignore">    fn parse&lt;'a&gt;(&amp;'a self) -&gt; Result&lt;(), &amp;'a str&gt; {
</code></pre>
<!-- That is, the error part of the return value of `parse` has a lifetime that is -->
<!-- tied to the lifetime of the `Parser` instance (that of `&self` in the `parse` -->
<!-- method signature). That makes sense: the returned string slice references the -->
<!-- string slice in the `Context` instance held by the `Parser`, and the definition -->
<!-- of the `Parser` struct specifies that the lifetime of the reference to -->
<!-- `Context` and the lifetime of the string slice that `Context` holds should be -->
<!-- the same. -->
<p>要するに、<code>parse</code>の戻り値のエラー部分は、<code>Parser</code>インスタンスのライフタイムと紐付いたライフタイムになるのです
(<code>parse</code>メソッドシグニチャの<code>&amp;self</code>のライフタイム)。それは、理に適っています: 返却される文字列スライスは、
<code>Parser</code>に保持された<code>Context</code>インスタンスの文字列スライスを参照していて、<code>Parser</code>構造体の定義は、
<code>Context</code>への参照のライフタイムと<code>Context</code>が保持する文字列スライスのライフタイムは同じになるべきと指定しています。</p>
<!-- The problem is that the `parse_context` function returns the value returned -->
<!-- from `parse`, so the lifetime of the return value of `parse_context` is tied to -->
<!-- the lifetime of the `Parser` as well. But the `Parser` instance created in the -->
<!-- `parse_context` function won’t live past the end of the function (it’s -->
<!-- temporary), and `context` will go out of scope at the end of the function -->
<!-- (`parse_context` takes ownership of it). -->
<p>問題は、<code>parse_context</code>関数は、<code>parse</code>から返却される値を返すので、<code>parse_context</code>の戻り値のライフタイムも、
<code>Parser</code>のライフタイムに紐付くことです。しかし、<code>parse_context</code>関数で生成された<code>Parser</code>インスタンスは、
関数の終端を超えて生きることはなく(一時的なのです)、<code>context</code>も関数の終端でスコープを抜けるのです(<code>parse_context</code>が所有権を奪っています)。</p>
<!-- Rust thinks we’re trying to return a reference to a value that goes out of -->
<!-- scope at the end of the function, because we annotated all the lifetimes with -->
<!-- the same lifetime parameter. The annotations told Rust the lifetime of the -->
<!-- string slice that `Context` holds is the same as that of the lifetime of the -->
<!-- reference to `Context` that `Parser` holds. -->
<p>コンパイラは、私たちが、関数の終端でスコープを抜ける値への参照を返そうとしていると考えます。
全ライフタイムを同じライフタイム引数で注釈したからです。注釈は、コンパイラに<code>Context</code>が保持する文字列スライスのライフタイムは、
<code>Parser</code>が保持する<code>Context</code>への参照のライフタイムと一致すると指示しました。</p>
<!-- The `parse_context` function can’t see that within the `parse` function, the -->
<!-- string slice returned will outlive `Context` and `Parser` and that the -->
<!-- reference `parse_context` returns refers to the string slice, not to `Context` -->
<!-- or `Parser`. -->
<p><code>parse_context</code>関数には、<code>parse</code>関数内で返却される文字列スライスが<code>Context</code>と<code>Parser</code>より長生きし、
<code>parse_context</code>が返す参照が<code>Context</code>や<code>Parser</code>ではなく、文字列スライスを参照することはわかりません。</p>
<!-- By knowing what the implementation of `parse` does, we know that the only -->
<!-- reason the return value of `parse` is tied to the `Parser` instance is that -->
<!-- it’s referencing the `Parser` instance’s `Context`, which is referencing the -->
<!-- string slice. So, it’s really the lifetime of the string slice that -->
<!-- `parse_context` needs to care about. We need a way to tell Rust that the string -->
<!-- slice in `Context` and the reference to the `Context` in `Parser` have -->
<!-- different lifetimes and that the return value of `parse_context` is tied to the -->
<!-- lifetime of the string slice in `Context`. -->
<p><code>parse</code>の実装が何をするか知ることで、<code>parse</code>の戻り値が<code>Parser</code>インスタンスに紐付く唯一の理由が、<code>Parser</code>インスタンスの<code>Context</code>、
引いては文字列スライスを参照していることであることを把握します。従って、<code>parse_context</code>が気にする必要があるのは、
本当は文字列スライスのライフタイムなのです。<code>Context</code>の文字列スライスと<code>Parser</code>の<code>Context</code>への参照が異なるライフタイムになり、
<code>parse_context</code>の戻り値が<code>Context</code>の文字列スライスのライフタイムに紐付くことをコンパイラに教える方法が必要です。</p>
<!-- First, we’ll try giving `Parser` and `Context` different lifetime parameters, -->
<!-- as shown in Listing 19-15. We’ll use `'s` and `'c` as lifetime parameter names -->
<!-- to clarify which lifetime goes with the string slice in `Context` and which -->
<!-- goes with the reference to `Context` in `Parser`. Note that this solution won’t -->
<!-- completely fix the problem, but it’s a start. We’ll look at why this fix isn’t -->
<!-- sufficient when we try to compile. -->
<p>まず、試しに<code>Parser</code>と<code>Context</code>に異なるライフタイム引数を与えてみましょう。リスト19-15のようにですね。
ライフタイム引数の名前として<code>'s</code>と<code>'c</code>を使用してどのライフタイムが<code>Context</code>の文字列スライスに当てはまり、
どれが<code>Parser</code>の<code>Context</code>への参照に当てはまるかを明確化します。この解決策は、完全に問題を修正しませんが、
スタート地点です。コンパイルしようとする時にこの修正で十分でない理由に目を向けます。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Context&lt;'s&gt;(&amp;'s str);

struct Parser&lt;'c, 's&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}

impl&lt;'c, 's&gt; Parser&lt;'c, 's&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;'s str&gt; {
        Err(&amp;self.context.0[1..])
    }
}

fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<!-- <span class="caption">Listing 19-15: Specifying different lifetime parameters -->
<!-- for the references to the string slice and to `Context`</span> -->
<p><span class="caption">リスト19-15: 文字列スライスと<code>Context</code>への参照に異なるライフタイム引数を指定する</span></p>
<!-- We’ve annotated the lifetimes of the references in all the same places that we -->
<!-- annotated them in Listing 19-13. But this time we used different parameters -->
<!-- depending on whether the reference goes with the string slice or with -->
<!-- `Context`. We’ve also added an annotation to the string slice part of the -->
<!-- return value of `parse` to indicate that it goes with the lifetime of the -->
<!-- string slice in `Context`. -->
<p>参照のライフタイム全部をリスト19-13で注釈したのと同じ箇所に注釈しました。ですが今回は、
参照が文字列スライスか<code>Context</code>に当てはまるかによって異なる引数を使用しました。また、
<code>parse</code>の戻り値の文字列スライス部分にも注釈を追加して、<code>Context</code>の文字列スライスのライフタイムに当てはまることを示唆しました。</p>
<!-- When we try to compile now, we get the following error: -->
<p>今コンパイルを試みると、以下のようなエラーになります:</p>
<pre><code class="language-text">error[E0491]: in type `&amp;'c Context&lt;'s&gt;`, reference has a longer lifetime than the data it references
(エラー: 型`&amp;'c Cotnext&lt;'s&gt;`において、参照のライフタイムが参照先のデータよりも長くなっています)
 --&gt; src/lib.rs:4:5
  |
4 |     context: &amp;'c Context&lt;'s&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the pointer is valid for the lifetime 'c as defined on the struct at 3:1
(注釈: ポインタは3:1の構造体で定義されたように、ライフタイム'cの間有効です)
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:1
(注釈: しかし、参照されたデータは、3:1の構造体で定義されたように、ライフタイム'sの間だけ有効です)
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
</code></pre>
<!-- Rust doesn’t know of any relationship between `'c` and `'s`. To be valid, the -->
<!-- referenced data in `Context` with lifetime `'s` needs to be constrained to -->
<!-- guarantee that it lives longer than the reference with lifetime `'c`. If `'s` -->
<!-- is not longer than `'c`, the reference to `Context` might not be valid. -->
<p>コンパイラは、<code>'c</code>と<code>'s</code>の間になんの関連性も知りません。合法であるために、<code>Context</code>でライフタイム<code>'c</code>と参照されたデータは、
制限され、ライフタイム<code>'c</code>の参照よりも長生きすることを保証する必要があります。<code>'s</code>が<code>'c</code>より長くないと、
<code>Context</code>への参照は合法ではない可能性があるのです。</p>
<!-- Now we get to the point of this section: the Rust feature *lifetime -->
<!-- subtyping* specifies that one lifetime parameter lives at least as long as -->
<!-- another one. In the angle brackets where we declare lifetime parameters, we can -->
<!-- declare a lifetime `'a` as usual and declare a lifetime `'b` that lives at -->
<!-- least as long as `'a` by declaring `'b` using the syntax `'b: 'a`. -->
<p>さて、この節の要点に到達しました: Rustの機能、<em>ライフタイム・サブタイピング</em>は、あるライフタイム引数が、
少なくとも他のライフタイムと同じだけ生きることを指定します。ライフタイム引数を宣言する山カッコ内で、
通常通りライフタイム<code>'a</code>を宣言し、<code>'b</code>を<code>'b: 'a</code>記法を使用して宣言することで、
<code>'a</code>と少なくとも同じ期間生きるライフタイム<code>'b</code>を宣言できます。</p>
<!-- In our definition of `Parser`, to say that `'s` (the lifetime of the string -->
<!-- slice) is guaranteed to live at least as long as `'c` (the lifetime of the -->
<!-- reference to `Context`), we change the lifetime declarations to look like this: -->
<p><code>Parser</code>の定義で、<code>'s</code>(文字列スライスのライフタイム)が少なくとも<code>'c</code>(<code>Context</code>への参照のライフタイム)と同じ期間だけ生きると、
保証することを宣言するには、ライフタイム宣言を以下のように変更します:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Context&lt;'a&gt;(&amp;'a str);
#
struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}
#}</code></pre></pre>
<!-- Now the reference to `Context` in the `Parser` and the reference to the string -->
<!-- slice in the `Context` have different lifetimes; we’ve ensured that the -->
<!-- lifetime of the string slice is longer than the reference to the `Context`. -->
<p>これで<code>Parser</code>の<code>Context</code>への参照と<code>Context</code>の文字列スライスへの参照のライフタイムは、違うものになりました;
文字列スライスのライフタイムが<code>Context</code>への参照よりも長いことを保証したのです。</p>
<!-- That was a very long-winded example, but as we mentioned at the start of this -->
<!-- chapter, Rust’s advanced features are very specific. You won’t often need the -->
<!-- syntax we described in this example, but in such situations, you’ll know how to -->
<!-- refer to something and give it the necessary lifetime. -->
<p>非常に長くぐにゃぐにゃした例でしたが、この章の冒頭で触れたように、Rustの高度な機能は、非常に限定的です。
この例で解説した記法は、あまり必要になりませんが、そのような場面では、何かを参照し、それに必要なライフタイムを与える方法を知っているでしょう。</p>
<!-- ### Lifetime Bounds on References to Generic Types -->
<a class="header" href="print.html#aジェネリックな型への参照に対するライフタイム境界" id="aジェネリックな型への参照に対するライフタイム境界"><h3>ジェネリックな型への参照に対するライフタイム境界</h3></a>
<!-- In the “Trait Bounds” section in Chapter 10, we discussed using trait bounds on -->
<!-- generic types. We can also add lifetime parameters as constraints on generic -->
<!-- types; these are called *lifetime bounds*. Lifetime bounds help Rust verify -->
<!-- that references in generic types won’t outlive the data they’re referencing. -->
<p>第10章の「トレイト境界」節で、ジェネリックな型にトレイト境界を使用することを議論しました。
また、ジェネリックな型への制限としてライフタイム引数を追加することもできます; これは<em>ライフタイム境界</em>と呼ばれます。
ライフタイム境界は、コンパイラが、ジェネリックな型の中の参照が参照先のデータよりも長生きしないことを確かめる手助けをします。</p>
<!-- As an example, consider a type that is a wrapper over references. Recall the -->
<!-- `RefCell<T>` type from the “`RefCell<T>` and the Interior Mutability Pattern” -->
<!-- section in Chapter 15: its `borrow` and `borrow_mut` methods return the types -->
<!-- `Ref` and `RefMut`, respectively. These types are wrappers over references that -->
<!-- keep track of the borrowing rules at runtime. The definition of the `Ref` -->
<!-- struct is shown in Listing 19-16, without lifetime bounds for now. -->
<p>例として、参照のラッパーの型を考えてください。第15章の「<code>RefCell&lt;T&gt;</code>と内部可変性パターン」節から<code>RefCell&lt;T&gt;</code>型を思い出してください:
<code>borrow</code>と<code>borrow_mut</code>メソッドがそれぞれ、<code>Ref</code>と<code>RefMut</code>を返します。これらの型は、
実行時に借用規則を追いかける参照に対するラッパーです。<code>Ref</code>構造体の定義をリスト19-16に今はライフタイム境界なしで示しました。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Ref&lt;'a, T&gt;(&amp;'a T);
</code></pre>
<!-- <span class="caption">Listing 19-16: Defining a struct to wrap a reference to a -->
<!-- generic type, without lifetime bounds</span> -->
<p><span class="caption">リスト19-16: ライフタイム境界なしでジェネリックな型への参照をラップする構造体を定義する</span></p>
<!-- Without explicitly constraining the lifetime `'a` in relation to the generic -->
<!-- parameter `T`, Rust will error because it doesn’t know how long the generic -->
<!-- type `T` will live: -->
<p>明示的にジェネリック引数<code>T</code>と関連してライフタイム<code>'a</code>を制限することがないと、ジェネリックな型<code>T</code>がどれだけ生きるのかわからないので、
コンパイラはエラーにします:</p>
<pre><code class="language-text">error[E0309]: the parameter type `T` may not live long enough
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
  |
  = help: consider adding an explicit lifetime bound `T: 'a`...
  (助言: 明示的なライフタイム境界`T: 'a`を追加することを考慮してください)
note: ...so that the reference type `&amp;'a T` does not outlive the data it points at
(注釈: そうすれば、参照型の`&amp;'a T`が指しているデータよりも長生きしません)
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
</code></pre>
<!-- Because `T` can be any type, `T` could be a reference or a type that holds one -->
<!-- or more references, each of which could have their own lifetimes. Rust can’t be -->
<!-- sure `T` will live as long as `'a`. -->
<p><code>T</code>はどんな型にもなるので、<code>T</code>が参照や1つ以上の参照を保持する型になることもあり、その個々の参照が独自のライフタイムになることもあるでしょう。
コンパイラは、<code>T</code>が<code>'a</code>と同じだけ生きることを確信できません。</p>
<!-- Fortunately, the error provides helpful advice on how to specify the lifetime -->
<!-- bound in this case: -->
<p>幸運なことに、この場合、エラーがライフタイム境界を指定する方法について役に立つアドバイスをくれています:</p>
<pre><code class="language-text">consider adding an explicit lifetime bound `T: 'a` so that the reference type
`&amp;'a T` does not outlive the data it points at
</code></pre>
<!-- Listing 19-17 shows how to apply this advice by specifying the lifetime bound -->
<!-- when we declare the generic type `T`. -->
<p>リスト19-17は、ジェネリックな型<code>T</code>を宣言する時にライフタイム境界を指定することで、
このアドバイスを適用する方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-17: Adding lifetime bounds on `T` to specify -->
<!-- that any references in `T` live at least as long as `'a`</span> -->
<p><span class="caption">リスト19-17: <code>T</code>にライフタイム境界を追加して<code>T</code>のどんな参照も少なくとも、<code>'a</code>と同じだけ生きると指定する</span></p>
<!-- This code now compiles because the `T: 'a` syntax specifies that `T` can be any -->
<!-- type, but if it contains any references, the references must live at least as -->
<!-- long as `'a`. -->
<p>このコードはもうコンパイルできます。<code>T: 'a</code>記法により、<code>T</code>はどんな型にもなり得ますが、何か参照を含んでいるのなら、
その参照は少なくとも、<code>'a</code>と同じだけ生きなければならないと指定しているからです。</p>
<!-- We could solve this problem in a different way, as shown in the definition of a -->
<!-- `StaticRef` struct in Listing 19-18, by adding the `'static` lifetime bound on -->
<!-- `T`. This means if `T` contains any references, they must have the `'static` -->
<!-- lifetime. -->
<p>この問題をリスト19-18の<code>StaticRef</code>構造体の定義で示したように、<code>T</code>に<code>'static</code>ライフタイム境界を追加し、異なる方法で解決することもできます。
これは、<code>T</code>に何か参照が含まれるなら、<code>'static</code>ライフタイムでなければならないことを意味します。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StaticRef&lt;T: 'static&gt;(&amp;'static T);
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-18: Adding a `'static` lifetime bound to `T` -->
<!-- to constrain `T` to types that have only `'static` references or no -->
<!-- references</span> -->
<p><span class="caption">リスト19-18: <code>T</code>に<code>'static</code>ライフタイム境界を追加して<code>T</code>を<code>'static</code>参照だけがあるか参照なしの型に制限する</span></p>
<!-- Because `'static` means the reference must live as long as the entire program, -->
<!-- a type that contains no references meets the criteria of all references living -->
<!-- as long as the entire program (because there are no references). For the borrow -->
<!-- checker concerned about references living long enough, there is no real -->
<!-- distinction between a type that has no references and a type that has -->
<!-- references that live forever: both are the same for determining whether or not -->
<!-- a reference has a shorter lifetime than what it refers to. -->
<p><code>'static</code>は、参照がプログラム全体と同じだけ生きなければならないことを意味するので、何も参照を含まない型は、
全ての参照がプログラム全体と同じだけ生きるという基準を満たします(参照がないからです)。借用精査機が、
参照が十分長生きしないと心配することに関しては、参照が何もない型と永久に生きる参照がある型を現実的に区別できません:
どちらも、参照が参照先のライフタイムよりも短いか決定することに関しては同じです。</p>
<!-- ### Inference of Trait Object Lifetimes -->
<a class="header" href="print.html#aトレイトオブジェクトライフタイムの推論" id="aトレイトオブジェクトライフタイムの推論"><h3>トレイトオブジェクトライフタイムの推論</h3></a>
<!-- In Chapter 17 in the “Using Trait Objects that Allow for Values of Different -->
<!-- Types” section, we discussed trait objects, consisting of a trait behind a -->
<!-- reference, that allow us to use dynamic dispatch. We haven’t yet discussed what -->
<!-- happens if the type implementing the trait in the trait object has a lifetime -->
<!-- of its own. Consider Listing 19-19 where we have a trait `Red` and a struct -->
<!-- `Ball`. The `Ball` struct holds a reference (and thus has a lifetime parameter) -->
<!-- and also implements trait `Red`. We want to use an instance of `Ball` as the -->
<!-- trait object `Box<Red>`. -->
<p>第17章の「異なる型の値を許容するトレイトオブジェクトを使用する」節で、参照の背後のトレイトから構成され、
ダイナミック・ディスパッチを使用できるトレイトオブジェクトを議論しました。まだ、トレイトオブジェクトのトレイトを実装する型が、
独自のライフタイムだった時に何が起きるか議論していません。トレイト<code>Red</code>と構造体<code>Ball</code>があるリスト19-19を考えてください。
<code>Ball</code>構造体は参照を保持し(故にライフタイム引数があり)、トレイト<code>Red</code>を実装もしています。
<code>Ball</code>のインスタンスを<code>Box&lt;Red&gt;</code>として使用したいです。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Red { }

struct Ball&lt;'a&gt; {
    diameter: &amp;'a i32,
}

impl&lt;'a&gt; Red for Ball&lt;'a&gt; { }

fn main() {
    let num = 5;

    let obj = Box::new(Ball { diameter: &amp;num }) as Box&lt;Red&gt;;
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-19: Using a type that has a lifetime parameter -->
<!-- with a trait object</span> -->
<p><span class="caption">リスト19-19: トレイトオブジェクトでライフタイム引数のある型を使用する</span></p>
<!-- This code compiles without any errors, even though we haven’t explicitly -->
<!-- annotated the lifetimes involved in `obj`. This code works because there are -->
<!-- rules for working with lifetimes and trait objects: -->
<p>明示的に<code>obj</code>に関連するライフタイムを注釈していないものの、このコードはエラーなくコンパイルできます。
ライフタイムとトレイトオブジェクトと共に動く規則があるので、このコードは動くのです:</p>
<!-- * The default lifetime of a trait object is `'static`. -->
<!-- * With `&'a Trait` or `&'a mut Trait`, the default lifetime of the trait object -->
<!--   is `'a`. -->
<!-- * With a single `T: 'a` clause, the default lifetime of the trait object is -->
<!--   `'a`. -->
<!-- * With multiple clauses like `T: 'a`, there is no default lifetime; we must be -->
<!--   explicit. -->
<ul>
<li>トレイトオブジェクトのデフォルトのライフタイムは、<code>'static</code>。</li>
<li><code>&amp;'a Trait</code>や<code>&amp;'a mut Trait</code>に関して、トレイトオブジェクトのデフォルトのライフタイムは、<code>'a</code>。</li>
<li>単独の<code>T: 'a</code>節について、トレイトオブジェクトのデフォルトのライフタイムは、<code>'a</code>。</li>
<li>複数の<code>T: 'a</code>のような節について、デフォルトのライフタイムはない; 明示しなければならない。</li>
</ul>
<!-- When we must be explicit, we can add a lifetime bound on a trait object like -->
<!-- `Box<Red>` using the syntax `Box<Red + 'static>` or `Box<Red + 'a>`, depending -->
<!-- on whether the reference lives for the entire program or not. As with the other -->
<!-- bounds, the syntax adding a lifetime bound means that any implementor of the -->
<!-- `Red` trait that has references inside the type must have the same lifetime -->
<!-- specified in the trait object bounds as those references. -->
<p>明示しなければならない時、<code>Box&lt;Red&gt;</code>のようなトレイトオブジェクトに対して、参照がプログラム全体で生きるかどうかにより、
記法<code>Box&lt;Red + 'static&gt;</code>か<code>Box&lt;Red + 'a&gt;</code>を使用してライフタイム境界を追加できます。他の境界同様、
ライフタイム境界を追記する記法は、型の内部に参照がある<code>Red</code>トレイトを実装しているものは全て、
トレイト境界に指定されるライフタイムがそれらの参照と同じにならなければなりません。</p>
<!-- Next, let’s look at some other advanced features that manage traits. -->
<p>次は、トレイトを管理する他の一部の高度な機能に目を向けましょう。</p>
<!-- ## Advanced Traits -->
<a class="header" href="print.html#a高度なトレイト" id="a高度なトレイト"><h2>高度なトレイト</h2></a>
<!-- We first covered traits in the “Traits: Defining Shared Behavior” section of -->
<!-- Chapter 10, but as with lifetimes, we didn’t discuss the more advanced details. -->
<!-- Now that you know more about Rust, we can get into the nitty-gritty. -->
<p>最初にトレイトについて講義したのは、第10章の「トレイト: 共通の振る舞いを定義する」節でしたが、
ライフタイム同様、より高度な詳細は議論しませんでした。今や、Rustに詳しくなったので、核心に迫れるでしょう。</p>
<!-- ### Specifying Placeholder Types in Trait Definitions with Associated Types -->
<a class="header" href="print.html#a関連型でトレイト定義においてプレースホルダーの型を指定する" id="a関連型でトレイト定義においてプレースホルダーの型を指定する"><h3>関連型でトレイト定義においてプレースホルダーの型を指定する</h3></a>
<!-- *Associated types* connect a type placeholder with a trait such that the trait -->
<!-- method definitions can use these placeholder types in their signatures. The -->
<!-- implementor of a trait will specify the concrete type to be used in this type’s -->
<!-- place for the particular implementation. That way, we can define a trait that -->
<!-- uses some types without needing to know exactly what those types are until the -->
<!-- trait is implemented. -->
<p><em>関連型</em>は、トレイトのメソッド定義がシグニチャでプレースホルダーの型を使用できるように、トレイトとその型のプレースホルダーを結び付けます。
トレイトを実装するものがこの特定の実装で型の位置に使用される具体的な型を指定します。そうすることで、
なんらかの型を使用するトレイトをトレイトを実装するまでその型が一体なんであるかを知る必要なく定義できます。</p>
<!-- We’ve described most of the advanced features in this chapter as being rarely -->
<!-- needed. Associated types are somewhere in the middle: they’re used more rarely -->
<!-- than features explained in the rest of the book but more commonly than many of -->
<!-- the other features discussed in this chapter. -->
<p>この章のほとんどの高度な機能は、稀にしか必要にならないと解説しました。関連型はその中間にあります:
本の残りで説明される機能よりは使用されるのが稀ですが、この章で議論される他の多くの機能よりは頻繁に使用されます。</p>
<!-- One example of a trait with an associated type is the `Iterator` trait that the -->
<!-- standard library provides. The associated type is named `Item` and stands in -->
<!-- for the type of the values the type implementing the `Iterator` trait is -->
<!-- iterating over. In “The `Iterator` Trait and the `next` Method” section of -->
<!-- Chapter 13, we mentioned that the definition of the `Iterator` trait is as -->
<!-- shown in Listing 19-20. -->
<p>関連型があるトレイトの一例は、標準ライブラリが提供する<code>Iterator</code>トレイトです。その関連型は<code>Item</code>と名付けられ、
<code>Iterator</code>トレイトを実装している型が走査している値の型の代役を務めます。第13章の「<code>Iterator</code>トレイトと<code>next</code>メソッド」節で、
<code>Iterator</code>トレイトの定義は、リスト19-20に示したようなものであることに触れました。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-20: The definition of the `Iterator` trait -->
<!-- that has an associated type `Item`</span> -->
<p><span class="caption">リスト19-20: 関連型<code>Item</code>がある<code>Iterator</code>トレイトの定義</span></p>
<!-- The type `Item` is a placeholder type, and the `next` method’s definition shows -->
<!-- that it will return values of type `Option<Self::Item>`. Implementors of the -->
<!-- `Iterator` trait will specify the concrete type for `Item`, and the `next` -->
<!-- method will return an `Option` containing a value of that concrete type. -->
<p>型<code>Item</code>はプレースホルダー型で<code>next</code>メソッドの定義は、型<code>Option&lt;Self::Item&gt;</code>の値を返すことを示しています。
<code>Iterator</code>トレイトを実装するものは、<code>Item</code>の具体的な型を指定し、<code>next</code>メソッドは、
その具体的な型の値を含む<code>Option</code>を返します。</p>
<!-- ジェネリクスはこうという話をしているのに、似ていると言っているのがどうも引っかかる -->
<!-- Associated types might seem like a similar concept to generics, in that the -->
<!-- latter allow us to define a function without specifying what types it can -->
<!-- handle. So why use associated types? -->
<p>関連型は、ジェネリクスにより扱う型を指定せずに関数を定義できるという点でジェネリクスに似た概念のように思える可能性があります。
では、何故関連型を使用するのでしょうか？</p>
<!-- Let’s examine the difference between the two concepts with an example from -->
<!-- Chapter 13 that implements the `Iterator` trait on the `Counter` struct. In -->
<!-- Listing 13-21, we specified that the `Item` type was `u32`: -->
<p>2つの概念の違いを第13章から<code>Counter</code>構造体に<code>Iterator</code>トレイトを実装する例で調査しましょう。
リスト13-21で、<code>Item</code>型は<code>u32</code>だと指定しました:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
</code></pre>
<!-- This syntax seems comparable to that of generics. So why not just define the -->
<!-- `Iterator` trait with generics, as shown in Listing 19-21? -->
<p>この記法は、ジェネリクスと比較可能に思えます。では、何故単純にリスト19-21のように、
<code>Iterator</code>トレイトをジェネリクスで定義しないのでしょうか？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-21: A hypothetical definition of the -->
<!-- `Iterator` trait using generics</span> -->
<p><span class="caption">ジェネリクスを使用した架空の<code>Iterator</code>トレイトの定義</span></p>
<!-- The difference is that when using generics, as in Listing 19-21, we must -->
<!-- annotate the types in each implementation; because we can also implement -->
<!-- `Iterator<String> for Counter` or any other type, we could have multiple -->
<!-- implementations of `Iterator` for `Counter`. In other words, when a trait has a -->
<!-- generic parameter, it can be implemented for a type multiple times, changing -->
<!-- the concrete types of the generic type parameters each time. When we use the -->
<!-- `next` method on `Counter`, we would have to provide type annotations to -->
<!-- indicate which implementation of `Iterator` we want to use. -->
<p>差異は、リスト19-21のようにジェネリクスを使用すると、各実装で型を注釈しなければならないことです;
<code>Iterator&lt;String&gt; for Counter</code>や他のどんな型にも実装することができるので、
<code>Counter</code>の<code>Iterator</code>の実装が複数できるでしょう。換言すれば、トレイトにジェネリックな引数があると、
毎回ジェネリックな型引数の具体的な型を変更してある型に対して複数回実装できるということです。
<code>Counter</code>に対して<code>next</code>メソッドを使用する際に、どの<code>Iterator</code>の実装を使用したいか型注釈をつけなければならないでしょう。</p>
<!-- With associated types, we don’t need to annotate types because we can’t -->
<!-- implement a trait on a type multiple times. In Listing 19-20 with the -->
<!-- definition that uses associated types, we can only choose what the type of -->
<!-- `Item` will be once, because there can only be one `impl Iterator for Counter`. -->
<!-- We don’t have to specify that we want an iterator of `u32` values everywhere -->
<!-- that we call `next` on `Counter`. -->
<p>関連型なら、同じ型に対してトレイトを複数回実装できないので、型を注釈する必要はありません。
関連型を使用する定義があるリスト19-20では、<code>Item</code>の型は1回しか選択できませんでした。
1つしか<code>impl Iterator for Counter</code>がないからです。<code>Counter</code>に<code>next</code>を呼び出す度に、
<code>u32</code>値のイテレータが欲しいと指定しなくてもよいわけです。</p>
<!-- ### Default Generic Type Parameters and Operator Overloading -->
<a class="header" href="print.html#aデフォルトのジェネリック型引数と演算子オーバーロード" id="aデフォルトのジェネリック型引数と演算子オーバーロード"><h3>デフォルトのジェネリック型引数と演算子オーバーロード</h3></a>
<!-- When we use generic type parameters, we can specify a default concrete type for -->
<!-- the generic type. This eliminates the need for implementors of the trait to -->
<!-- specify a concrete type if the default type works. The syntax for specifying a -->
<!-- default type for a generic type is `<PlaceholderType=ConcreteType>` when -->
<!-- declaring the generic type. -->
<p>ジェネリックな型引数を使用する際、ジェネリックな型に対して規定の具体的な型を指定できます。これにより、
規定の型が動くのなら、トレイトを実装する側が具体的な型を指定する必要を排除します。ジェネリックな型に規定の型を指定する記法は、
ジェネリックな型を宣言する際に<code>&lt;PlaceholderType=ConcreteType&gt;</code>です。</p>
<!-- A great example of a situation where this technique is useful is with operator -->
<!-- overloading. *Operator overloading* is customizing the behavior of an operator -->
<!-- (such as `+`) in particular situations. -->
<p>このテクニックが有用になる場面のいい例が、演算子オーバーロードです。<em>演算子オーバーロード</em>とは、
特定の状況で演算子(<code>+</code>など)の振る舞いをカスタマイズすることです。</p>
<!-- Rust doesn’t allow you to create your own operators or overload arbitrary -->
<!-- operators. But you can overload the operations and corresponding traits listed -->
<!-- in `std::ops` by implementing the traits associated with the operator. For -->
<!-- example, in Listing 19-22 we overload the `+` operator to add two `Point` -->
<!-- instances together. We do this by implementing the `Add` trait on a `Point` -->
<!-- struct: -->
<p>Rustでは、独自の演算子を作ったり、任意の演算子をオーバーロードすることはできません。しかし、
演算子に紐付いたトレイトを実装することで<code>std::ops</code>に列挙された処理と対応するトレイトをオーバーロードできます。
例えば、リスト19-22で<code>+</code>演算子をオーバーロードして2つの<code>Point</code>インスタンスを足し合わせています。
<code>Point</code>構造体に<code>Add</code>トレイトを実装することでこれを行なっています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-22: Implementing the `Add` trait to overload -->
<!-- the `+` operator for `Point` instances</span> -->
<p><span class="caption">リスト19-22: <code>Add</code>トレイトを実装して<code>Point</code>インスタンス用に<code>+</code>演算子をオーバーロードする</span></p>
<!-- The `add` method adds the `x` values of two `Point` instances and the `y` -->
<!-- values of two `Point` instances to create a new `Point`. The `Add` trait has an -->
<!-- associated type named `Output` that determines the type returned from the `add` -->
<!-- method. -->
<p><code>add</code>メソッドは2つの<code>Point</code>インスタンスの<code>x</code>値と2つの<code>Point</code>インスタンスの<code>y</code>値を足します。
<code>Add</code>トレイトには、<code>add</code>メソッドから返却される型を決定する<code>Output</code>という関連型があります。</p>
<!-- The default generic type in this code is within the `Add` trait. Here is its -->
<!-- definition: -->
<p>このコードの規定のジェネリック型は、<code>Add</code>トレイト内にあります。こちらがその定義です:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
#}</code></pre></pre>
<!-- This code should look generally familiar: a trait with one method and an -->
<!-- associated type. The new part is `RHS=Self`: this syntax is called *default -->
<!-- type parameters*. The `RHS` generic type parameter (short for “right hand -->
<!-- side”) defines the type of the `rhs` parameter in the `add` method. If we don’t -->
<!-- specify a concrete type for `RHS` when we implement the `Add` trait, the type -->
<!-- of `RHS` will default to `Self`, which will be the type we’re implementing -->
<!-- `Add` on. -->
<p>このコードは一般的に馴染みがあるはずです: 1つのメソッドと関連型が1つあるトレイトです。
新しい部分は、<code>RHS=Self</code>です: この記法は、<em>デフォルト型引数</em>と呼ばれます。
RHSというジェネリックな型引数(&quot;right hand side&quot;: 右辺の省略形)が、<code>add</code>メソッドの<code>rhs</code>引数の型を定義しています。
<code>Add</code>トレイトを実装する際に<code>RHS</code>の具体的な型を指定しなければ、<code>RHS</code>の型は標準で<code>Self</code>になり、
これは<code>Add</code>を実装している型になります。</p>
<!-- When we implemented `Add` for `Point`, we used the default for `RHS` because we -->
<!-- wanted to add two `Point` instances. Let’s look at an example of implementing -->
<!-- the `Add` trait where we want to customize the `RHS` type rather than using the -->
<!-- default. -->
<p><code>Point</code>に<code>Add</code>を実装する際、2つの<code>Point</code>インスタンスを足したかったので、<code>RHS</code>の規定を使用しました。
規定を使用するのではなく、<code>RHS</code>の型をカスタマイズしたくなる<code>Add</code>トレイトの実装例に目を向けましょう。</p>
<!-- We have two structs `Millimeters` and `Meters`, holding values in different -->
<!-- units. We want to add values in millimeters to values in meters and have the -->
<!-- implementation of `Add` do the conversion correctly. We can implement `Add` for -->
<!-- `Millimeters` with `Meters` as the `RHS`, as shown in Listing 19-23. -->
<p>異なる単位で値を保持する構造体、<code>Millimeters</code>と<code>Meters</code>(それぞれ<code>ミリメートル</code>と<code>メートル</code>)が2つあります。
ミリメートルの値をメートルの値に足し、<code>Add</code>の実装に変換を正しくしてほしいです。
<code>Add</code>を<code>RHS</code>に<code>Meters</code>のある<code>Millimeters</code>に実装することができます。リスト19-23のように:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-23: Implementing the `Add` trait on -->
<!-- `Millimeters` to add `Millimeters` to `Meters`</span> -->
<p><span class="caption">リスト19-23: <code>Millimeters</code>に<code>Add</code>トレイトを実装して、<code>Meters</code>に<code>Millimeters</code>を足す</span></p>
<!-- To add `Millimeters` and `Meters`, we specify `impl Add<Meters>` to set the -->
<!-- value of the `RHS` type parameter instead of using the default of `Self`. -->
<p><code>Millimeters</code>を<code>Meters</code>に足すため、<code>Self</code>という規定を使う代わりに<code>impl Add&lt;Meters&gt;</code>を指定して、
<code>RHS</code>型引数の値をセットしています。</p>
<!-- You'll use default type parameters in two main ways: -->
<p>主に2通りの方法でデフォルト型引数を使用します:</p>
<!-- * To extend a type without breaking existing code -->
<!-- * To allow customization in specific cases most users won’t need -->
<ul>
<li>既存のコードを破壊せずに型を拡張する</li>
<li>ほとんどのユーザは必要としない特定の場合でカスタマイズを可能にする</li>
</ul>
<!-- The standard library’s `Add` trait is an example of the second purpose: -->
<!-- usually, you’ll add two like types, but the `Add` trait provides the ability to -->
<!-- customize beyond that. Using a default type parameter in the `Add` trait -->
<!-- definition means you don’t have to specify the extra parameter most of the -->
<!-- time. In other words, a bit of implementation boilerplate isn’t needed, making -->
<!-- it easier to use the trait. -->
<p>標準ライブラリの<code>Add</code>トレイトは、2番目の目的の例です: 通常、2つの似た型を足しますが、
<code>Add</code>トレイトはそれ以上にカスタマイズする能力を提供します。<code>Add</code>トレイト定義でデフォルト型引数を使用することは、
ほとんどの場合、追加の引数を指定しなくてもよいことを意味します。つまり、トレイトを使いやすくして、
ちょっとだけ実装の定型コードが必要なくなるのです。</p>
<!-- The first purpose is similar to the second but in reverse: if you want to add a -->
<!-- type parameter to an existing trait, you can give it a default to allow -->
<!-- extension of the functionality of the trait without breaking the existing -->
<!-- implementation code. -->
<p>最初の目的は2番目に似ていますが、逆です: 既存のトレイトに型引数を追加したいなら、規定を与えて、
既存の実装コードを破壊せずにトレイトの機能を拡張できるのです。</p>
<!-- ### Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name -->
<a class="header" href="print.html#a明確化のためのフルパス記法-同じ名前のメソッドを呼ぶ" id="a明確化のためのフルパス記法-同じ名前のメソッドを呼ぶ"><h3>明確化のためのフルパス記法: 同じ名前のメソッドを呼ぶ</h3></a>
<!-- Nothing in Rust prevents a trait from having a method with the same name as -->
<!-- another trait’s method, nor does Rust prevent you from implementing both traits -->
<!-- on one type. It’s also possible to implement a method directly on the type with -->
<!-- the same name as methods from traits. -->
<p>Rustにおいて、別のトレイトのメソッドと同じ名前のメソッドがトレイトにあったり、両方のトレイトを1つの型に実装することを妨げるものは何もありません。
トレイトのメソッドと同じ名前のメソッドを直接型に実装することも可能です。</p>
<!-- When calling methods with the same name, you'll need to tell Rust which one you -->
<!-- want to use. Consider the code in Listing 19-24 where we’ve defined two traits, -->
<!-- `Pilot` and `Wizard`, that both have a method called `fly`. We then implement -->
<!-- both traits on a type `Human` that already has a method named `fly` implemented -->
<!-- on it. Each `fly` method does something different. -->
<p>同じ名前のメソッドを呼ぶ際、コンパイラにどれを使用したいのか教える必要があるでしょう。両方とも<code>fly</code>というメソッドがある2つのトレイト、
<code>Pilot</code>と<code>Wizard</code>(<code>訳注</code>: パイロットと魔法使い)を定義したリスト19-24のコードを考えてください。
それから両方のトレイトを既に<code>fly</code>というメソッドが実装されている型<code>Human</code>に実装します。
各<code>fly</code>メソッドは異なることをします。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        // キャプテンのお言葉
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        // 上がれ！
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        // *激しく腕を振る*
        println!(&quot;*waving arms furiously*&quot;);
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-24: Two traits are defined to have a `fly` -->
<!-- method and are implemented on the `Human` type, and a `fly` method is -->
<!-- implemented on `Human` directly</span> -->
<p><span class="caption">リスト19-24: 2つのトレイトに<code>fly</code>があるように定義され、<code>Human</code>に実装されつつ、
<code>fly</code>メソッドは<code>Human</code>に直接実装されている</span></p>
<!-- When we call `fly` on an instance of `Human`, the compiler defaults to calling -->
<!-- the method that is directly implemented on the type, as shown in Listing 19-25. -->
<p><code>Human</code>のインスタンスに対して<code>fly</code>を呼び出すと、コンパイラは型に直接実装されたメソッドを標準で呼び出します。
リスト19-25のようにですね:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Pilot {
#     fn fly(&amp;self);
# }
#
# trait Wizard {
#     fn fly(&amp;self);
# }
#
# struct Human;
#
# impl Pilot for Human {
#     fn fly(&amp;self) {
#         println!(&quot;This is your captain speaking.&quot;);
#     }
# }
#
# impl Wizard for Human {
#     fn fly(&amp;self) {
#         println!(&quot;Up!&quot;);
#     }
# }
#
# impl Human {
#     fn fly(&amp;self) {
#         println!(&quot;*waving arms furiously*&quot;);
#     }
# }
#
fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-25: Calling `fly` on an instance of -->
<!-- `Human`</span> -->
<p><span class="caption">リスト19-25: <code>Human</code>のインスタンスに対して<code>fly</code>を呼び出す</span></p>
<!-- Running this code will print `*waving arms furiously*`, showing that Rust -->
<!-- called the `fly` method implemented on `Human` directly. -->
<p>このコードを実行すると、<code>*waving arms furiously*</code>と出力され、コンパイラが<code>Human</code>に直接実装された<code>fly</code>メソッドを呼んでいることを示しています。</p>
<!-- To call the `fly` methods from either the `Pilot` trait or the `Wizard` trait, -->
<!-- we need to use more explicit syntax to specify which `fly` method we mean. -->
<!-- Listing 19-26 demonstrates this syntax. -->
<p><code>Pilot</code>トレイトか、<code>Wizard</code>トレイトの<code>fly</code>メソッドを呼ぶためには、
より明示的な記法を使用してどの<code>fly</code>メソッドを意図しているか指定する必要があります。
リスト19-26は、この記法をデモしています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Pilot {
#     fn fly(&amp;self);
# }
#
# trait Wizard {
#     fn fly(&amp;self);
# }
#
# struct Human;
#
# impl Pilot for Human {
#     fn fly(&amp;self) {
#         println!(&quot;This is your captain speaking.&quot;);
#     }
# }
#
# impl Wizard for Human {
#     fn fly(&amp;self) {
#         println!(&quot;Up!&quot;);
#     }
# }
#
# impl Human {
#     fn fly(&amp;self) {
#         println!(&quot;*waving arms furiously*&quot;);
#     }
# }
#
fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-26: Specifying which trait’s `fly` method we -->
<!-- want to call</span> -->
<p><span class="caption">リスト19-26: どのトレイトの<code>fly</code>メソッドを呼び出したいか指定する</span></p>
<!-- Specifying the trait name before the method name clarifies to Rust which -->
<!-- implementation of `fly` we want to call. We could also write -->
<!-- `Human::fly(&person)`, which is equivalent to the `person.fly()` that we used -->
<!-- in Listing 19-26, but this is a bit longer to write if we don’t need to -->
<!-- disambiguate. -->
<p>メソッド名の前にトレイト名を指定すると、コンパイラにどの<code>fly</code>の実装を呼び出したいか明確化できます。
また、<code>Human::fly(&amp;person)</code>と書くこともでき、リスト19-26で使用した<code>person.fly()</code>と等価ですが、
こちらの方が明確化する必要がないなら、ちょっと記述量が増えます。</p>
<!-- Running this code prints the following: -->
<p>このコードを実行すると、こんな出力がされます:</p>
<pre><code class="language-text">This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<!-- Because the `fly` method takes a `self` parameter, if we had two *types* that -->
<!-- both implement one *trait*, Rust could figure out which implementation of a -->
<!-- trait to use based on the type of `self`. -->
<p><code>fly</code>メソッドは<code>self</code>引数を取るので、1つの<em>トレイト</em>を両方実装する<em>型</em>が2つあれば、
コンパイラには、<code>self</code>の型に基づいてどのトレイトの実装を使うべきかわかるでしょう。</p>
<!-- However, associated functions that are part of traits don’t have a `self` -->
<!-- parameter. When two types in the same scope implement that trait, Rust can’t -->
<!-- figure out which type you mean unless you use *fully qualified syntax*. For -->
<!-- example, the `Animal` trait in Listing 19-27 has the associated function -->
<!-- `baby_name`, the implementation of `Animal` for the struct `Dog`, and the -->
<!-- associated function `baby_name` defined on `Dog` directly. -->
<p>しかしながら、トレイトの一部になる関連型には<code>self</code>引数がありません。同じスコープの2つの型がそのトレイトを実装する場合、
<em>フルパス記法</em>(fully qualified syntax)を使用しない限り、どの型を意図しているかコンパイラは推論できません。例えば、
リスト19-27の<code>Animal</code>トレイトには、関連関数<code>baby_name</code>、構造体<code>Dog</code>の<code>Animal</code>の実装、
<code>Dog</code>に直接定義された関連関数<code>baby_name</code>があります。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        // スポット(Wikipediaによると、飼い主の事故死後もその人の帰りを待つ忠犬の名前の模様)
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        // 子犬
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    // 赤ちゃん犬は{}と呼ばれる
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-27: A trait with an associated function and a -->
<!-- type with an associated function of the same name that also implements the -->
<!-- trait</span> -->
<p><span class="caption">リスト19-27: 関連関数のあるトレイトとそのトレイトも実装し、同じ名前の関連関数がある型</span></p>
<!-- This code is for an animal shelter that wants to name all puppies Spot, which -->
<!-- is implemented in the `baby_name` associated function that is defined on `Dog`. -->
<!-- The `Dog` type also implements the trait `Animal`, which describes -->
<!-- characteristics that all animals have. Baby dogs are called puppies, and that -->
<!-- is expressed in the implementation of the `Animal` trait on `Dog` in the -->
<!-- `baby_name` function associated with the `Animal` trait. -->
<p>このコードは、全ての子犬をスポットと名付けたいアニマル・シェルター(<code>訳注</code>: 身寄りのないペットを保護する保健所みたいなところ)用で、
<code>Dog</code>に定義された<code>baby_name</code>関連関数で実装されています。<code>Dog</code>型は、トレイト<code>Animal</code>も実装し、
このトレイトは全ての動物が持つ特徴を記述します。赤ちゃん犬は子犬と呼ばれ、
それが<code>Dog</code>の<code>Animal</code>トレイトの実装の<code>Animal</code>トレイトと紐付いた<code>base_name</code>関数で表現されています。</p>
<!-- In `main`, we call the `Dog::baby_name` function, which calls the associated -->
<!-- function defined on `Dog` directly. This code prints the following: -->
<p><code>main</code>で、<code>Dog::baby_name</code>関数を呼び出し、直接<code>Dog</code>に定義された関連関数を呼び出しています。
このコードは以下のような出力をします:</p>
<pre><code class="language-text">A baby dog is called a Spot
</code></pre>
<!-- This output isn’t what we wanted. We want to call the `baby_name` function that -->
<!-- is part of the `Animal` trait that we implemented on `Dog` so the code prints -->
<!-- `A baby dog is called a puppy`. The technique of specifying the trait name that -->
<!-- we used in Listing 19-26 doesn’t help here; if we change `main` to the code in -->
<!-- Listing 19-28, we’ll get a compilation error. -->
<p>この出力は、欲しかったものではありません。<code>Dog</code>に実装した<code>Animal</code>トレイトの一部の<code>baby_name</code>関数を呼び出したいので、
コードは<code>A baby dog is called a puppy</code>と出力します。リスト19-26で使用したトレイト名を指定するテクニックは、
ここでは役に立ちません; <code>main</code>をリスト19-28のようなコードに変更したら、コンパイルエラーになるでしょう。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}
</code></pre>
<!-- <span class="caption">Listing 19-28: Attempting to call the `baby_name` -->
<!-- function from the `Animal` trait, but Rust doesn’t know which implementation to -->
<!-- use</span> -->
<p><span class="caption">リスト19-28: <code>Animal</code>トレイトの<code>baby_name</code>関数を呼び出そうとするも、コンパイラにはどの実装を使うべきかわからない</span></p>
<!-- Because `Animal::baby_name` is an associated function rather than a method, and -->
<!-- thus doesn’t have a `self` parameter, Rust can’t figure out which -->
<!-- implementation of `Animal::baby_name` we want. We’ll get this compiler error: -->
<p><code>Animal::baby_name</code>はメソッドではなく関連関数であり、故に<code>self</code>引数がないので、どの<code>Animal::baby_name</code>が欲しいのか、
コンパイラには推論できません。こんなコンパイルエラーが出るでしょう:</p>
<pre><code class="language-text">error[E0283]: type annotations required: cannot resolve `_: Animal`
(エラー: 型注釈が必要です: `_: Animal`を解決できません)
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^
   |
   = note: required by `Animal::baby_name`
   (注釈: `Animal::baby_name`に必要です)
</code></pre>
<!-- To disambiguate and tell Rust that we want to use the implementation of -->
<!-- `Animal` for `Dog`, we need to use fully qualified syntax. Listing 19-29 -->
<!-- demonstrates how to use fully qualified syntax. -->
<p><code>Dog</code>に対して<code>Animal</code>実装を使用したいと明確化し、コンパイラに指示するには、フルパス記法を使う必要があります。
リスト19-29は、フルパス記法を使用する方法をデモしています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Animal {
#     fn baby_name() -&gt; String;
# }
#
# struct Dog;
#
# impl Dog {
#     fn baby_name() -&gt; String {
#         String::from(&quot;Spot&quot;)
#     }
# }
#
# impl Animal for Dog {
#     fn baby_name() -&gt; String {
#         String::from(&quot;puppy&quot;)
#     }
# }
#
fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-29: Using fully qualified syntax to specify -->
<!-- that we want to call the `baby_name` function from the `Animal` trait as -->
<!-- implemented on `Dog`</span> -->
<p><span class="caption">リスト19-29: フルパス記法を使って<code>Dog</code>に実装されているように、
<code>Animal</code>トレイトからの<code>baby_name</code>関数を呼び出したいと指定する</span></p>
<!-- We’re providing Rust with a type annotation within the angle brackets, which -->
<!-- indicates we want to call the `baby_name` method from the `Animal` trait as -->
<!-- implemented on `Dog` by saying that we want to treat the `Dog` type as an -->
<!-- `Animal` for this function call. This code will now print what we want: -->
<p>コンパイラに山カッコ内に型注釈を提供し、これは、この関数呼び出しでは<code>Dog</code>型を<code>Animal</code>として扱いたいと宣言することで、
<code>Dog</code>に実装されたように、<code>Animal</code>トレイトの<code>baby_name</code>メソッドを呼び出したいと示唆しています。
もうこのコードは、望み通りの出力をします:</p>
<pre><code class="language-text">A baby dog is called a puppy
</code></pre>
<!-- In general, fully qualified syntax is defined as follows: -->
<p>一般的に、フルパス記法は、以下のように定義されています:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<!-- For associated functions, there would not be a `receiver`: there would only be -->
<!-- the list of other arguments. You could use fully qualified syntax everywhere -->
<!-- that you call functions or methods. However, you’re allowed to omit any part of -->
<!-- this syntax that Rust can figure out from other information in the program. You -->
<!-- only need to use this more verbose syntax in cases where there are multiple -->
<!-- implementations that use the same name and Rust needs help to identify which -->
<!-- implementation you want to call. -->
<p>関連関数では、<code>receiver</code>がないでしょう: 他の引数のリストがあるだけでしょう。関数やメソッドを呼び出す箇所全部で、
フルパス記法を使用することもできるでしょうが、プログラムの他の情報からコンパイラが推論できるこの記法のどの部分も省略することが許容されています。
同じ名前を使用する実装が複数あり、どの実装を呼び出したいかコンパイラが特定するのに助けが必要な場合だけにこのより冗長な記法を使用する必要があるのです。</p>
<!-- ### Using Supertraits to Require One Trait’s Functionality Within Another Trait -->
<a class="header" href="print.html#aスーパートレイトを使用して別のトレイト内であるトレイトの機能を必要とする" id="aスーパートレイトを使用して別のトレイト内であるトレイトの機能を必要とする"><h3>スーパートレイトを使用して別のトレイト内で、あるトレイトの機能を必要とする</h3></a>
<!-- Sometimes, you might need one trait to use another trait’s functionality. In -->
<!-- this case, you need to rely on the dependent trait's also being implemented. -->
<!-- The trait you rely on is a *supertrait* of the trait you’re implementing. -->
<p>時として、あるトレイトに別のトレイトの機能を使用させる必要がある可能性があります。この場合、
依存するトレイトも実装されることを信用する必要があります。信用するトレイトは、実装しているトレイトの<em>スーパートレイト</em>です。</p>
<!-- For example, let’s say we want to make an `OutlinePrint` trait with an -->
<!-- `outline_print` method that will print a value framed in asterisks. That is, -->
<!-- given a `Point` struct that implements `Display` to result in `(x, y)`, when we -->
<!-- call `outline_print` on a `Point` instance that has `1` for `x` and `3` for -->
<!-- `y`, it should print the following: -->
<p>例えば、アスタリスクをフレームにする値を出力する<code>outline_print</code>メソッドがある<code>OutlinePrint</code>トレイトを作りたくなったとしましょう。
つまり、<code>Display</code>を実装し、<code>(x, y)</code>という結果になる<code>Point</code>構造体が与えられて、
<code>x</code>に<code>1</code>、<code>y</code>に<code>3</code>の<code>Point</code>インスタンスに対して<code>outline_print</code>を呼び出すと、以下のような出力をするはずです:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<!-- In the implementation of `outline_print`, we want to use the `Display` trait’s -->
<!-- functionality. Therefore, we need to specify that the `OutlinePrint` trait will -->
<!-- work only for types that also implement `Display` and provide the functionality -->
<!-- that `OutlinePrint` needs. We can do that in the trait definition by specifying -->
<!-- `OutlinePrint: Display`. This technique is similar to adding a trait bound to -->
<!-- the trait. Listing 19-30 shows an implementation of the `OutlinePrint` trait. -->
<p><code>outline_print</code>の実装では、<code>Display</code>トレイトの機能を使用したいです。故に、<code>Display</code>も実装する型に対してだけ<code>OutlinePrint</code>が動くと指定し、
<code>OutlinePrint</code>が必要とする機能を提供する必要があるわけです。トレイト定義で<code>OutlinePrint: Display</code>と指定することで、
そうすることができます。このテクニックは、トレイトにトレイト境界を追加することに似ています。
リスト19-30は、<code>OutlinePrint</code>トレイトの実装を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-30: Implementing the `OutlinePrint` trait that -->
<!-- requires the functionality from `Display`</span> -->
<p><span class="caption">リスト19-30: <code>Display</code>からの機能を必要とする<code>OutlinePrint</code>トレイトを実装する</span></p>
<!-- Because we’ve specified that `OutlinePrint` requires the `Display` trait, we -->
<!-- can use the `to_string` function that is automatically implemented for any type -->
<!-- that implements `Display`. If we tried to use `to_string` without adding a -->
<!-- colon and specifying `Display` trait after the trait name, we’d get an -->
<!-- error saying that no method named `to_string` was found for the type `&Self` in -->
<!-- the current scope. -->
<p><code>OutlinePrint</code>は<code>Display</code>トレイトを必要とすると指定したので、<code>Display</code>を実装するどんな型にも自動的に実装される<code>to_string</code>関数を使えます。
トレイト名の後にコロンと<code>Display</code>トレイトを追加せずに<code>to_string</code>を使おうとしたら、
現在のスコープで型<code>&amp;Self</code>に<code>to_string</code>というメソッドは存在しないというエラーが出るでしょう。</p>
<!-- Let’s see what happens when we try to implement `OutlinePrint` on a type that -->
<!-- doesn’t implement `Display`, such as the `Point` struct: -->
<p><code>Display</code>を実装しない型、<code>Point</code>構造体などに<code>OutlinePrint</code>を実装しようとしたら、何が起きるか確認しましょう:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait OutlinePrint {}
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
#}</code></pre></pre>
<!-- We get an error saying that `Display` is required but not implemented: -->
<p><code>Display</code>が必要だけれども、実装されていないというエラーが出ます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
</code></pre>
<!-- To fix this, we implement `Display` on `Point` and satisfy the constraint that -->
<!-- `OutlinePrint` requires, like so: -->
<p>これを修正するために、<code>Point</code>に<code>Display</code>を実装し、<code>OutlinePrint</code>が必要とする制限を満たします。
こんな感じで:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
#}</code></pre></pre>
<!-- Then implementing the `OutlinePrint` trait on `Point` will compile -->
<!-- successfully, and we can call `outline_print` on a `Point` instance to display -->
<!-- it within an outline of asterisks. -->
<p>そうすれば、<code>Point</code>に<code>OutlinePrint</code>トレイトを実装してもコンパイルは成功し、
<code>Point</code>インスタンスに対して<code>outline_print</code>を呼び出し、アスタリスクのふちの中に表示することができます。</p>
<!-- ### Using the Newtype Pattern to Implement External Traits on External Types -->
<a class="header" href="print.html#aニュータイプパターンを使用して外部の型に外部のトレイトを実装する" id="aニュータイプパターンを使用して外部の型に外部のトレイトを実装する"><h3>ニュータイプパターンを使用して外部の型に外部のトレイトを実装する</h3></a>
<!-- In Chapter 10 in the “Implementing a Trait on a Type” section, we mentioned the -->
<!-- orphan rule that states we’re allowed to implement a trait on a type as long as -->
<!-- either the trait or the type are local to our crate. It’s possible to get -->
<!-- around this restriction using the *newtype pattern*, which involves creating a -->
<!-- new type in a tuple struct. (We covered tuple structs in the “Using Tuple -->
<!-- Structs without Named Fields to Create Different Types” section of Chapter 5.) -->
<!-- The tuple struct will have one field and be a thin wrapper around the type we -->
<!-- want to implement a trait for. Then the wrapper type is local to our crate, and -->
<!-- we can implement the trait on the wrapper. *Newtype* is a term that originates -->
<!-- from the Haskell programming language. There is no runtime performance penalty -->
<!-- for using this pattern, and the wrapper type is elided at compile time. -->
<p>第10章の「型にトレイトを実装する」節で、トレイトか型がクレートにローカルな限り、型にトレイトを実装できると述べるオーファンルールについて触れました。
<em>ニュータイプパターン</em>を使用してこの制限を回避することができ、タプル構造体に新しい型を作成することに関連します。
(タプル構造体については、第5章の「異なる型を生成する名前付きフィールドのないタプル構造体を使用する」節で講義しました。)
タプル構造体は1つのフィールドを持ち、トレイトを実装したい型の薄いラッパーになるでしょう。そして、
ラッパーの型はクレートにローカルなので、トレイトをラッパーに実装できます。<em>ニュータイプ</em>という用語は、
Haskellプログラミング言語に端を発しています。このパターンを使用するのに実行時のパフォーマンスを犠牲にすることはなく、
ラッパー型はコンパイル時に省かれます。</p>
<!-- As an example, let’s say we want to implement `Display` on `Vec<T>`, which the -->
<!-- orphan rule prevents us from doing directly because the `Display` trait and the -->
<!-- `Vec<T>` type are defined outside our crate. We can make a `Wrapper` struct -->
<!-- that holds an instance of `Vec<T>`; then we can implement `Display` on -->
<!-- `Wrapper` and use the `Vec<T>` value, as shown in Listing 19-31. -->
<p>例として、<code>Vec&lt;T&gt;</code>に<code>Display</code>を実装したいとしましょう。これは、<code>Display</code>トレイトも<code>Vec&lt;T&gt;</code>型もクレートの外で定義されているので、
直接行うことをオーファンルールにより妨げられます。<code>Vec&lt;T&gt;</code>のインスタンスを保持する<code>Wrapper</code>構造体を作成できます;
そして、<code>Wrapper</code>に<code>Display</code>を実装し、<code>Vec&lt;T&gt;</code>値を使用できます。リスト19-31のように。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-31: Creating a `Wrapper` type around -->
<!-- `Vec<String>` to implement `Display`</span> -->
<p><span class="caption">リスト19-31: <code>Vec&lt;String&gt;</code>の周りに<code>Wrapper</code>を作成して<code>Display</code>を実装する</span></p>
<!-- The implementation of `Display` uses `self.0` to access the inner `Vec<T>`, -->
<!-- because `Wrapper` is a tuple struct and `Vec<T>` is the item at index 0 in the -->
<!-- tuple. Then we can use the functionality of the `Display` type on `Wrapper`. -->
<p><code>Display</code>の実装は、<code>self.0</code>で中身の<code>Vec&lt;T&gt;</code>にアクセスしています。<code>Wrapper</code>はタプル構造体で、
<code>Vec&lt;T&gt;</code>がタプルの番号0の要素だからです。それから、<code>Wrapper</code>に対して<code>Display</code>型の機能を使用できます。</p>
<!-- The downside of using this technique is that `Wrapper` is a new type, so it -->
<!-- doesn’t have the methods of the value it’s holding. We would have to implement -->
<!-- all the methods of `Vec<T>` directly on `Wrapper` such that the methods -->
<!-- delegate to `self.0`, which would allow us to treat `Wrapper` exactly like a -->
<!-- `Vec<T>`. If we wanted the new type to have every method the inner type has, -->
<!-- implementing the `Deref` trait (discussed in Chapter 15 in the “Treating Smart -->
<!-- Pointers like Regular References with the `Deref` Trait” section) on the -->
<!-- `Wrapper` to return the inner type would be a solution. If we don’t want the -->
<!-- `Wrapper` type to have all the methods of the inner type—for example, to -->
<!-- restrict the `Wrapper` type’s behavior—we would have to implement just the -->
<!-- methods we do want manually. -->
<p>このテクニックを使用する欠点は、<code>Wrapper</code>が新しい型なので、保持している値のメソッドがないことです。
<code>self.0</code>に委譲して、<code>Wrapper</code>を<code>Vec&lt;T&gt;</code>と全く同様に扱えるように、<code>Wrapper</code>に直接<code>Vec&lt;T&gt;</code>の全てのメソッドを実装しなければならないでしょう。
内部の型が持つ全てのメソッドを新しい型に持たせたいなら、
<code>Deref</code>トレイト(第15章の「<code>Deref</code>トレイトでスマートポインタを普通の参照のように扱う」節で議論しました)を<code>Wrapper</code>に実装して、
内部の型を返すことは解決策の1つでしょう。内部の型のメソッド全部を<code>Wrapper</code>型に持たせたくない(例えば、<code>Wrapper</code>型の機能を制限するなど)なら、
本当に欲しいメソッドだけを手動で実装しなければならないでしょう。</p>
<!-- Now you know how the newtype pattern is used in relation to traits; it’s also a -->
<!-- useful pattern even when traits are not involved. Let’s switch focus and look -->
<!-- at some advanced ways to interact with Rust’s type system. -->
<p>もう、トレイトに関してニュータイプパターンが使用される方法を知りました; トレイトが関連しなくても、
有用なパターンでもあります。焦点を変更して、Rustの型システムと相互作用する一部の高度な方法を見ましょう。</p>
<!-- ## Advanced Types -->
<a class="header" href="print.html#a高度な型" id="a高度な型"><h2>高度な型</h2></a>
<!-- The Rust type system has some features that we’ve mentioned in this book but -->
<!-- haven’t yet discussed. We’ll start by discussing newtypes in general as we -->
<!-- examine why newtypes are useful as types. Then we’ll move on to type aliases, a -->
<!-- feature similar to newtypes but with slightly different semantics. We’ll also -->
<!-- discuss the `!` type and dynamically sized types. -->
<p>Rustの型システムには、この本で触れたけれども、まだ議論していない機能があります。ニュータイプが何故型として有用なのかを調査するにつれて、
一般化してニュータイプを議論することから始めます。そして、型エイリアスに移ります。ニュータイプに類似しているけれども、
多少異なる意味を持つ機能です。また、<code>!</code>型と動的サイズ付け型も議論します。</p>
<!-- > Note: The next section assumes you’ve read the earlier section “The Newtype -->
<!-- > Pattern to Implement External Traits on External Types.” -->
<blockquote>
<p>注釈: 次の節は、前節「外部の型に外部のトレイトを実装するニュータイプパターン」を読了済みであることを前提にしています。</p>
</blockquote>
<!-- ### Using the Newtype Pattern for Type Safety and Abstraction -->
<a class="header" href="print.html#a型安全性と抽象化を求めてニュータイプパターンを使用する" id="a型安全性と抽象化を求めてニュータイプパターンを使用する"><h3>型安全性と抽象化を求めてニュータイプパターンを使用する</h3></a>
<!-- The newtype pattern is useful for tasks beyond those we’ve discussed so far, -->
<!-- including statically enforcing that values are never confused and indicating -->
<!-- the units of a value. You saw an example of using newtypes to indicate units in -->
<!-- Listing 19-23: recall that the `Millimeters` and `Meters` structs wrapped `u32` -->
<!-- values in a newtype. If we wrote a function with a parameter of type -->
<!-- `Millimeters`, we couldn’t compile a program that accidentally tried to call -->
<!-- that function with a value of type `Meters` or a plain `u32`. -->
<p>ここまでに議論した以上の作業についてもニュータイプパターンは有用で、静的に絶対に値を混同しないことを強制したり、
値の単位を示すことを含みます。ニュータイプを使用して単位を示す例をリスト19-23で見かけました:
<code>Millimeters</code>と<code>Meters</code>構造体は、<code>u32</code>値をニュータイプにラップしていたことを思い出してください。
型<code>Millimeters</code>を引数にする関数を書いたら、誤ってその関数を型<code>Meters</code>や普通の<code>u32</code>で呼び出そうとするプログラムはコンパイルできないでしょう。</p>
<!-- Another use of the newtype pattern is in abstracting away some implementation -->
<!-- details of a type: the new type can expose a public API that is different from -->
<!-- the API of the private inner type if we used the new type directly to restrict -->
<!-- the available functionality, for example. -->
<p>型の実装の詳細を抽象化する際にニュータイプパターンを使用するでしょう: 例えば、新しい型を直接使用して、
利用可能な機能を制限したら、非公開の内部の型のAPIとは異なる公開APIを新しい型は露出できます。</p>
<!-- Newtypes can also hide internal implementation. For example, we could provide a -->
<!-- `People` type to wrap a `HashMap<i32, String>` that stores a person’s ID -->
<!-- associated with their name. Code using `People` would only interact with the -->
<!-- public API we provide, such as a method to add a name string to the `People` -->
<!-- collection; that code wouldn’t need to know that we assign an `i32` ID to names -->
<!-- internally. The newtype pattern is a lightweight way to achieve encapsulation -->
<!-- to hide implementation details, which we discussed in the “Encapsulation that -->
<!-- Hides Implementation Details” section of Chapter 17. -->
<p>ニュータイプはまた、内部の実装を隠匿することもできます。例を挙げれば、<code>People</code>型を提供して、
人のIDと名前を紐付けて格納する<code>HashMap&lt;i32, String&gt;</code>をラップすることができるでしょう。
<code>People</code>を使用するコードは、名前の文字列を<code>People</code>コレクションに追加するメソッドなど、
提供している公開APIとだけ相互作用するでしょう; そのコードは、内部で<code>i32</code>IDを名前に代入していることを知る必要はないでしょう。
ニュータイプパターンは、カプセル化を実現して実装の詳細を隠匿する軽い方法であり、
第17章の「カプセル化は実装詳細を隠蔽する」節で議論しましたね。</p>
<!-- ### Creating Type Synonyms with Type Aliases -->
<a class="header" href="print.html#a型エイリアスで型同義語を生成する" id="a型エイリアスで型同義語を生成する"><h3>型エイリアスで型同義語を生成する</h3></a>
<!-- Along with the newtype pattern, Rust provides the ability to declare a *type -->
<!-- alias* to give an existing type another name. For this we use the `type` -->
<!-- keyword. For example, we can create the alias `Kilometers` to `i32` like so: -->
<p>ニュータイプパターンに付随して、Rustでは、既存の型に別の名前を与える<em>型エイリアス</em>(type alias: 型別名)を宣言する能力が提供されています。
このために、<code>type</code>キーワードを使用します。例えば、以下のように<code>i32</code>に対して<code>Kilometers</code>というエイリアスを作れます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;
#}</code></pre></pre>
<!-- Now, the alias `Kilometers` is a *synonym* for `i32`; unlike the `Millimeters` -->
<!-- and `Meters` types we created in Listing 19-23, `Kilometers` is not a separate, -->
<!-- new type. Values that have the type `Kilometers` will be treated the same as -->
<!-- values of type `i32`: -->
<p>これで、別名の<code>Kilometers</code>は<code>i32</code>と<em>同義語</em>になりました; リスト19-23で生成した<code>Millimeters</code>と<code>Meters</code>とは異なり、
<code>Kilometers</code>は個別の新しい型ではありません。型<code>Kilometers</code>の値は、型<code>i32</code>の値と同等に扱われます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);
#}</code></pre></pre>
<!-- Because `Kilometers` and `i32` are the same type, we can add values of both -->
<!-- types and we can pass `Kilometers` values to functions that take `i32` -->
<!-- parameters. However, using this method, we don’t get the type checking benefits -->
<!-- that we get from the newtype pattern discussed earlier. -->
<p><code>Kilometers</code>と<code>i32</code>が同じ型なので、両方の型を足し合わせたり、<code>Kilometers</code>の値を<code>i32</code>引数を取る関数に渡せたりします。
ですが、この方策を使用すると、先ほど議論したニュータイプパターンで得られる型チェックの利便性は得られません。</p>
<!-- The main use case for type synonyms is to reduce repetition. For example, we -->
<!-- might have a lengthy type like this: -->
<p>型同義語の主なユースケースは、繰り返しを減らすことです。例えば、こんな感じの長い型があるかもしれません:</p>
<pre><code class="language-rust ignore">Box&lt;Fn() + Send + 'static&gt;
</code></pre>
<!-- Writing this lengthy type in function signatures and as type annotations all -->
<!-- over the code can be tiresome and error prone. Imagine having a project full of -->
<!-- code like that in Listing 19-32. -->
<p>この長ったらしい型を関数シグニチャや型注釈としてコードのあちこちで記述するのは、嫌なことで間違いも起きやすいです。
リスト19-32のようなコードで溢れかえったプロジェクトがあることを想像してください。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let f: Box&lt;Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;Fn() + Send + 'static&gt; {
    // --snip--
#     Box::new(|| ())
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-32: Using a long type in many places</span> -->
<p><span class="caption">リスト19-32: 長い型を多くの場所で使用する</span></p>
<!-- A type alias makes this code more manageable by reducing the repetition. In -->
<!-- Listing 19-33, we’ve introduced an alias named `Thunk` for the verbose type and -->
<!-- can replace all uses of the type with the shorter alias `Thunk`. -->
<p>型エイリアスは、繰り返しを減らすことでこのコードをより管理しやすくしてくれます。リスト19-33で、
冗長な型に<code>Thunk</code>(<code>注釈</code>: 塊)を導入し、その型の使用全部をより短い別名の<code>Thunk</code>で置き換えることができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Thunk = Box&lt;Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
#     Box::new(|| ())
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-33: Introducing a type alias `Thunk` to reduce -->
<!-- repetition</span> -->
<p><span class="caption">リスト19-33: 型エイリアスの<code>Thunk</code>を導入して繰り返しを減らす</span></p>
<!-- This code is much easier to read and write! Choosing a meaningful name for a -->
<!-- type alias can help communicate your intent as well (*thunk* is a word for code -->
<!-- to be evaluated at a later time, so it’s an appropriate name for a closure that -->
<!-- gets stored). -->
<p>このコードの方が遥かに読み書きしやすいです！型エイリアスに意味のある名前を選択すると、
意図を伝えるのにも役に立つことがあります(<em>thunk</em>は後ほど評価されるコードのための単語なので、
格納されるクロージャには適切な名前です)。</p>
<!-- Type aliases are also commonly used with the `Result<T, E>` type for reducing -->
<!-- repetition. Consider the `std::io` module in the standard library. I/O -->
<!-- operations often return a `Result<T, E>` to handle situations when operations -->
<!-- fail to work. This library has a `std::io::Error` struct that represents all -->
<!-- possible I/O errors. Many of the functions in `std::io` will be returning -->
<!-- `Result<T, E>` where the `E` is `std::io::Error`, such as these functions in -->
<!-- the `Write` trait: -->
<p>型エイリアスは、繰り返しを減らすために<code>Result&lt;T, E&gt;</code>型ともよく使用されます。標準ライブラリの<code>std::io</code>モジュールを考えてください。
I/O処理はしばしば、<code>Result&lt;T, E&gt;</code>を返して処理がうまく動かなかった時を扱います。このライブラリには、
全ての可能性のあるI/Oエラーを表す<code>std::io::Error</code>構造体があります。<code>std::io</code>の関数の多くは、
<code>Write</code>トレイトの以下の関数のように<code>E</code>が<code>std::io::Error</code>の<code>Result&lt;T, E&gt;</code>を返すでしょう:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
#}</code></pre></pre>
<!-- The `Result<..., Error>` is repeated a lot. As such, `std::io` has this type of -->
<!-- alias declaration: -->
<p><code>Result&lt;..., Error&gt;</code>がなんども繰り返されてます。そんな状態なので、<code>std::io</code>にはこんな類のエイリアス宣言があります:</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;
</code></pre>
<!-- Because this declaration is in the `std::io` module, we can use the fully -->
<!-- qualified alias `std::io::Result<T>`-that is, a `Result<T, E>` with the `E` -->
<!-- filled in as `std::io::Error`. The `Write` trait function signatures end up -->
<!-- looking like this: -->
<p>この宣言は<code>std::io</code>モジュール内にあるので、フルパスエイリアスの<code>std::io::Result&lt;T&gt;</code>を使用できます。
つまり、<code>E</code>が<code>std::io::Error</code>で埋められた<code>Result&lt;T, E&gt;</code>です。その結果、<code>Write</code>トレイトの関数シグニチャは、
以下のような見た目になります:</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<!-- The type alias helps in two ways: it makes code easier to write *and* it gives -->
<!-- us a consistent interface across all of `std::io`. Because it’s an alias, it’s -->
<!-- just another `Result<T, E>`, which means we can use any methods that work on -->
<!-- `Result<T, E>` with it, as well as special syntax like the `?` operator. -->
<p>型エイリアスは、2通りの方法で役に立っています: コードを書きやすくすること<em>と</em><code>std::io</code>を通して首尾一貫したインターフェイスを与えてくれることです。
別名なので、ただの<code>Result&lt;T, E&gt;</code>であり、要するに<code>Result&lt;T, E&gt;</code>に対して動くメソッドはなんでも使えるし、
<code>?</code>演算子のような特殊な記法も使えます。</p>
<!-- ### The Never Type that Never Returns -->
<a class="header" href="print.html#never型は絶対に返らない" id="never型は絶対に返らない"><h3>never型は絶対に返らない</h3></a>
<!-- to stand inで「代役を務める」という意味だが、ここではあえて直訳にした -->
<!-- Rust has a special type named `!` that’s known in type theory lingo as the -->
<!-- *empty type* because it has no values. We prefer to call it the *never type* -->
<!-- because it stands in the place of the return type when a function will never -->
<!-- return. Here is an example: -->
<p>Rustには、型理論用語で値がないため、空型として知られる<code>!</code>という特別な型があります。私たちは、
関数が絶対に返らない時に戻り値の型の場所に立つので、<em>never type</em>(<code>訳注</code>: 日本語にはできないので、ネバー型と呼ぶしかないか)と呼ぶのが好きです。
こちらが例です:</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // --snip--
}
</code></pre>
<!-- This code is read as “the function `bar` returns never.” Functions that return -->
<!-- never are called *diverging functions*. We can’t create values of the type `!` -->
<!-- so `bar` can never possibly return. -->
<p>このコードは、「関数<code>bar</code>はneverを返す」と解読します。neverを返す関数は、<em>発散関数</em>(diverging function)と呼ばれます。
型<code>!</code>の値は生成できないので、<code>bar</code>が返ることは絶対にあり得ません。</p>
<!-- But what use is a type you can never create values for? Recall the code from -->
<!-- Listing 2-5; we’ve reproduced part of it here in Listing 19-34. -->
<p>ですが、値を絶対に生成できない型をどう使用するのでしょうか？リスト2-5のコードを思い出してください;
リスト19-34に一部を再現しました。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let guess = &quot;3&quot;;
# loop {
let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
# break;
# }
#}</code></pre></pre>
<!-- <span class="caption">Listing 19-34: A `match` with an arm that ends in -->
<!-- `continue`</span> -->
<p><span class="caption">リスト19-34: <code>continue</code>になるアームがある<code>match</code></span></p>
<!-- At the time, we skipped over some details in this code. In Chapter 6 in “The -->
<!-- `match` Control Flow Operator” section, we discussed that `match` arms must all -->
<!-- return the same type. So, for example, the following code doesn’t work: -->
<p>この時点では、このコードの詳細の一部を飛ばしました。第6章の「<code>match</code>フロー制御演算子」節で、
<code>match</code>アームは全て同じ型を返さなければならないと議論しました。従って、例えば以下のコードは動きません:</p>
<pre><code class="language-rust ignore">let guess = match guess.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<!-- The type of `guess` in this code would have to be an integer *and* a string, -->
<!-- and Rust requires that `guess` have only one type. So what does `continue` -->
<!-- return? How were we allowed to return a `u32` from one arm and have another arm -->
<!-- that ends with `continue` in Listing 19-34? -->
<p>このコードの<code>guess</code>は整数<em>かつ</em>文字列にならなければならないでしょうが、Rustでは、<code>guess</code>は1つの型にしかなりません。
では、<code>continue</code>は何を返すのでしょうか？どうやってリスト19-34で1つのアームからは<code>u32</code>を返し、別のアームでは、
<code>continue</code>で終わっていたのでしょうか？</p>
<!-- As you might have guessed, `continue` has a `!` value. That is, when Rust -->
<!-- computes the type of `guess`, it looks at both match arms, the former with a -->
<!-- value of `u32` and the latter with a `!` value. Because `!` can never have a -->
<!-- value, Rust decides that the type of `guess` is `u32`. -->
<p>もうお気付きかもしれませんが、<code>continue</code>は<code>!</code>値です。つまり、コンパイラが<code>guess</code>の型を計算する時、
両方のmatchアームを見て、前者は<code>u32</code>の値、後者は<code>!</code>値です。<code>!</code>は絶対に値を持ち得ないので、
コンパイラは、<code>guess</code>の型は<code>u32</code>と決定するのです。</p>
<!-- The formal way of describing this behavior is that expressions of type `!` can -->
<!-- be coerced into any other type. We’re allowed to end this `match` arm with -->
<!-- `continue` because `continue` doesn’t return a value; instead, it moves control -->
<!-- back to the top of the loop, so in the `Err` case, we never assign a value to -->
<!-- `guess`. -->
<p>この振る舞いを解説する公式の方法は、型<code>!</code>の式は、他のどんな型にも型強制され得るということです。
この<code>match</code>アームを<code>continue</code>で終えることができます。何故なら、<code>continue</code>は値を返さないからです;
その代わりに制御をループの冒頭に戻すので、<code>Err</code>の場合、<code>guess</code>には絶対に値を代入しないのです。</p>
<!-- The never type is useful with the `panic!` macro as well. Remember the `unwrap` -->
<!-- function that we call on `Option<T>` values to produce a value or panic? Here -->
<!-- is its definition: -->
<p>never型は、<code>panic!</code>マクロとも有用です。<code>Option&lt;T&gt;</code>値に対して呼び出して値かパニックを生成した<code>unwrap</code>関数を覚えていますか？
こちらがその定義です:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<!-- In this code, the same thing happens as in the `match` in Listing 19-34: Rust -->
<!-- sees that `val` has the type `T` and `panic!` has the type `!`, so the result -->
<!-- of the overall `match` expression is `T`. This code works because `panic!` -->
<!-- doesn't produce a value; it ends the program. In the `None` case, we won’t be -->
<!-- returning a value from `unwrap`, so this code is valid. -->
<p>このコードにおいて、リスト19-34の<code>match</code>と同じことが起きています: コンパイラは、<code>val</code>の型は<code>T</code>で、
<code>panic!</code>の型は<code>!</code>なので、<code>match</code>式全体の結果は<code>T</code>と確認します。<code>panic!</code>は値を生成しないので、
このコードは動きます。つまり、プログラムを終了するのです。<code>None</code>の場合、<code>unwrap</code>から値は返さないので、
このコードは合法なのです。</p>
<!-- One final expression that has the type `!` is a `loop`: -->
<p>型が<code>!</code>の最後の式の1つは、<code>loop</code>です:</p>
<pre><code class="language-rust ignore">print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
</code></pre>
<!-- Here, the loop never ends, so `!` is the value of the expression. However, this -->
<!-- wouldn’t be true if we included a `break`, because the loop would terminate -->
<!-- when it got to the `break`. -->
<p>ここで、ループは終わりませんので、<code>!</code>が式の値です。ところが、<code>break</code>を含んでいたら、これは真にはならないでしょう。
<code>break</code>に到達した際にループが終了してしまうからです。</p>
<!-- ### Dynamically Sized Types and the `Sized` Trait -->
<a class="header" href="print.html#a動的サイズ付け型とsizedトレイト" id="a動的サイズ付け型とsizedトレイト"><h3>動的サイズ付け型と<code>Sized</code>トレイト</h3></a>
<!-- Due to Rust’s need to know certain details, such as how much space to allocate -->
<!-- for a value of a particular type, there is a corner of its type system that can -->
<!-- be confusing: the concept of *dynamically sized types*. Sometimes referred to -->
<!-- as *DSTs* or *unsized types*, these types let us write code using values whose -->
<!-- size we can know only at runtime. -->
<p>コンパイラが特定の型の値1つにどれくらいのスペースのメモリを確保するのかなどの特定の詳細を知る必要があるために、
型システムには混乱することもある秘密の場所があります: 動的サイズ付け型の概念です。時として<em>DST</em>や<em>サイズなし型</em>とも称され、
これらの型により、実行時にしかサイズを知ることのできない値を使用するコードを書かせてくれます。</p>
<!-- Let’s dig into the details of a dynamically sized type called `str`, which -->
<!-- we’ve been using throughout the book. That’s right, not `&str`, but `str` on -->
<!-- its own, is a DST. We can’t know how long the string is until runtime, meaning -->
<!-- we can’t create a variable of type `str`, nor can we take an argument of type -->
<!-- `str`. Consider the following code, which does not work: -->
<p><code>str</code>と呼ばれる動的サイズ付け型の詳細を深掘りしましょう。本を通して使用してきましたね。
そうです。<code>&amp;str</code>ではなく、<code>str</code>は単独でDSTなのです。実行時までは文字列の長さを知ることができず、
これは、型<code>str</code>の変数を生成したり、型<code>str</code>を引数に取ることはできないことを意味します。
動かない以下のコードを考えてください:</p>
<pre><code class="language-rust ignore">let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<!-- Rust needs to know how much memory to allocate for any value of a particular -->
<!-- type, and all values of a type must use the same amount of memory. If Rust -->
<!-- allowed us to write this code, these two `str` values would need to take up the -->
<!-- same amount of space. But they have different lengths: `s1` needs 12 bytes of -->
<!-- storage and `s2` needs 15. This is why it’s not possible to create a variable -->
<!-- holding a dynamically sized type. -->
<p>コンパイラは、特定の型のどんな値に対しても確保するメモリ量を知る必要があり、ある型の値は全て同じ量のメモリを使用しなければなりません。
Rustでこのコードを書くことが許容されたら、これら2つの<code>str</code>値は、同じ量のスペースを消費する必要があったでしょう。
ですが、長さが異なります: <code>s1</code>は、12バイトのストレージが必要で、<code>s2</code>は15バイトです。このため、
動的サイズ付け型を保持する変数を生成することはできないのです。</p>
<!-- So what do we do? In this case, you already know the answer: we make the types -->
<!-- of `s1` and `s2` a `&str` rather than a `str`. Recall that in the “String -->
<!-- Slices” section of Chapter 4, we said the slice data structure stores the -->
<!-- starting position and the length of the slice. -->
<p>では、どうすればいいのでしょうか？この場合、もう答えはご存知です: <code>s1</code>と<code>s2</code>の型を<code>str</code>ではなく、
<code>&amp;str</code>にすればいいのです。第4章の「文字列スライス」節でスライスデータ構造は、
開始地点とスライスの長さを格納していると述べたことを思い出してください。</p>
<!-- So although a `&T` is a single value that stores the memory address of where -->
<!-- the `T` is located, a `&str` is *two* values: the address of the `str` and its -->
<!-- length. As such, we can know the size of a `&str` value at compile time: it’s -->
<!-- twice the length of a `usize`. That is, we always know the size of a `&str`, no -->
<!-- matter how long the string it refers to is. In general, this is the way in -->
<!-- which dynamically sized types are used in Rust: they have an extra bit of -->
<!-- metadata that stores the size of the dynamic information. The golden rule of -->
<!-- dynamically sized types is that we must always put values of dynamically sized -->
<!-- types behind a pointer of some kind. -->
<p>従って、<code>&amp;T</code>は、<code>T</code>がどこにあるかのメモリアドレスを格納する単独の値だけれども、<code>&amp;str</code>は<em>2つ</em>の値なのです:
<code>str</code>のアドレスとその長さです。そのため、コンパイル時に<code>&amp;str</code>のサイズを知ることができます:
<code>usize</code>の長さの2倍です。要するに、参照している文字列の長さによらず、常に<code>&amp;str</code>のサイズがわかります。
通常、このようにしてRustでは動的サイズ付け型が使用されます: 動的情報のサイズを格納する追加のちょっとしたメタデータがあるのです。
動的サイズ付け型の黄金規則は、常に動的サイズ付け型の値をなんらかの種類のポインタの背後に配置しなければならないということです。</p>
<!-- We can combine `str` with all kinds of pointers: for example, `Box<str>` or -->
<!-- `Rc<str>`. In fact, you’ve seen this before but with a different dynamically -->
<!-- sized type: traits. Every trait is a dynamically sized type we can refer to by -->
<!-- using the name of the trait. In Chapter 17 in the “Using Trait Objects that -->
<!-- Allow for Values of Different Types” section, we mentioned that to use traits -->
<!-- as trait objects, we must put them behind a pointer, such as `&Trait` or -->
<!-- `Box<Trait>` (`Rc<Trait>` would work too). -->
<p><code>str</code>を全ての種類のポインタと組み合わせられます: 例を挙げれば、<code>Box&lt;str&gt;</code>や<code>Rc&lt;str&gt;</code>などです。
実際、これまでに見かけましたが、異なる動的サイズ付け型でした: トレイトです。全てのトレイトは、
トレイト名を使用して参照できる動的サイズ付け型です。第17章の「トレイトオブジェクトで異なる型の値を許容する」節で、
トレイトをトレイトオブジェクトとして使用するには、<code>&amp;Trait</code>や<code>Box&lt;Trait&gt;</code>(Rc<Trait>も動くでしょう)など、
ポインタの背後に配置しなければならないことに触れました。</p>
<!-- To work with DSTs, Rust has a particular trait called the `Sized` trait to -->
<!-- determine whether or not a type’s size is known at compile time. This trait is -->
<!-- automatically implemented for everything whose size is known at compile time. -->
<!-- In addition, Rust implicitly adds a bound on `Sized` to every generic function. -->
<!-- That is, a generic function definition like this: -->
<p>DSTを扱うために、Rustには<code>Sized</code>トレイトと呼ばれる特定のトレイトがあり、型のサイズがコンパイル時にわかるかどうかを決定します。
このトレイトは、コンパイル時にサイズの判明する全てに自動的に実装されます。加えて、
コンパイラは暗黙的に全てのジェネリックな関数に<code>Sized</code>の境界を追加します。つまり、こんな感じのジェネリック関数定義は:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<!-- is actually treated as though we had written this: -->
<p>実際にはこう書いたかのように扱われます:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<!-- By default, generic functions will work only on types that have a known size at -->
<!-- compile time. However, you can use the following special syntax to relax this -->
<!-- restriction: -->
<p>規定では、ジェネリック関数はコンパイル時に判明するサイズがある型に対してのみ動きます。
ですが、以下の特別な記法を用いてこの制限を緩めることができます:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<!-- A trait bound on `?Sized` is the opposite of a trait bound on `Sized`: we would -->
<!-- read this as “`T` may or may not be `Sized`.” This syntax is only available for -->
<!-- `Sized`, not any other traits. -->
<p><code>?Sized</code>のトレイト境界は、<code>Sized</code>のトレイト境界の逆になります: これを「<code>T</code>は<code>Sized</code>かもしれないし、違うかもしれない」と解読するでしょう。
この記法は、<code>Sized</code>にのみ利用可能で、他のトレイトにはありません。</p>
<!-- Also note that we switched the type of the `t` parameter from `T` to `&T`. -->
<!-- Because the type might not be `Sized`, we need to use it behind some kind of -->
<!-- pointer. In this case, we’ve chosen a reference. -->
<p>また、<code>t</code>引数の型を<code>T</code>から<code>&amp;T</code>に切り替えたことにも注目してください。型は<code>Sized</code>でない可能性があるので、
なんらかのポインタの背後に使用する必要があるのです。今回は、参照を選択しました。</p>
<!-- Next, we’ll talk about functions and closures! -->
<p>次は、関数とクロージャについて語ります！</p>
<!-- ## Advanced Functions and Closures -->
<a class="header" href="print.html#a高度な関数とクロージャ" id="a高度な関数とクロージャ"><h2>高度な関数とクロージャ</h2></a>
<!-- Finally, we’ll explore some advanced features related to functions and -->
<!-- closures, which include function pointers and returning closures. -->
<p>最後に関数とクロージャに関連する高度な機能の一部を探求し、これには関数ポインタとクロージャの返却が含まれます。</p>
<!-- ### Function Pointers -->
<a class="header" href="print.html#a関数ポインタ" id="a関数ポインタ"><h3>関数ポインタ</h3></a>
<!-- We’ve talked about how to pass closures to functions; you can also pass regular -->
<!-- functions to functions! This technique is useful when you want to pass a -->
<!-- function you’ve already defined rather than defining a new closure. Doing this -->
<!-- with function pointers will allow you to use functions as arguments to other -->
<!-- functions. Functions coerce to the type `fn` (with a lowercase f), not to be -->
<!-- confused with the `Fn` closure trait. The `fn` type is called a *function -->
<!-- pointer*. The syntax for specifying that a parameter is a function pointer is -->
<!-- similar to that of closures, as shown in Listing 19-35. -->
<p>クロージャを関数に渡す方法について語りました; 普通の関数を関数に渡すこともできるのです！
新しいクロージャを定義するのではなく、既に定義した関数を渡したい時にこのテクニックは有用です。
これを関数ポインタで行うと、関数を引数として他の関数に渡して使用できます。関数は、型<code>fn</code>(小文字のfです)に型強制されます。
<code>Fn</code>クロージャトレイトと混同すべきではありません。<code>fn</code>型は、<em>関数ポインタ</em>と呼ばれます。
引数が関数ポインタであると指定する記法は、クロージャのものと似ています。リスト19-35のように。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    // 答えは{}
    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<!-- <span class="caption">Listing 19-35: Using the `fn` type to accept a function -->
<!-- pointer as an argument</span> -->
<p><span class="caption">リスト19-35: <code>fn</code>型を使用して引数として関数ポインタを受け入れる</span></p>
<!-- This code prints `The answer is: 12`. We specify that the parameter `f` in -->
<!-- `do_twice` is an `fn` that takes one parameter of type `i32` and returns an -->
<!-- `i32`. We can then call `f` in the body of `do_twice`. In `main`, we can pass -->
<!-- the function name `add_one` as the first argument to `do_twice`. -->
<p>このコードは、<code>The answer is: 12</code>と出力します。<code>do_twice</code>の引数<code>f</code>は、型<code>i32</code>の1つの引数を取り、
<code>i32</code>を返す<code>fn</code>と指定しています。それから、<code>do_twice</code>の本体で<code>f</code>を呼び出すことができます。
<code>main</code>では、関数名の<code>add_one</code>を最初の引数として<code>do_twice</code>に渡せます。</p>
<!-- Unlike closures, `fn` is a type rather than a trait, so we specify `fn` as the -->
<!-- parameter type directly rather than declaring a generic type parameter with one -->
<!-- of the `Fn` traits as a trait bound. -->
<p>クロージャと異なり、<code>fn</code>はトレイトではなく型なので、トレイト境界として<code>Fn</code>トレイトの1つでジェネリックな型引数を宣言するのではなく、
直接<code>fn</code>を引数の型として指定します。</p>
<!-- Function pointers implement all three of the closure traits (`Fn`, `FnMut`, and -->
<!-- `FnOnce`), so you can always pass a function pointer as an argument for a -->
<!-- function that expects a closure. It’s best to write functions using a generic -->
<!-- type and one of the closure traits so your functions can accept either -->
<!-- functions or closures. -->
<p>関数ポインタは、クロージャトレイト3つ全て(<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>)を実装するので、常に関数ポインタを引数として、
クロージャを期待する関数に渡すことができます。関数が関数とクロージャどちらも受け入れられるように、
ジェネリックな型とクロージャトレイトの1つを使用して関数を書くのが最善です。</p>
<!-- An example of where you would want to only accept `fn` and not closures is when -->
<!-- interfacing with external code that doesn’t have closures: C functions can -->
<!-- accept functions as arguments, but C doesn’t have closures. -->
<p>クロージャではなく<code>fn</code>だけを受け入れたくなる箇所の一例は、クロージャのない外部コードとのインターフェイスです:
C関数は引数として関数を受け入れられますが、Cにはクロージャがありません。</p>
<!-- couldだが、でしょうでは文を続けられないので、できるかもしれないと弱めている -->
<!-- As an example of where you could use either a closure defined inline or a named -->
<!-- function, let’s look at a use of `map`. To use the `map` function to turn a -->
<!-- vector of numbers into a vector of strings, we could use a closure, like this: -->
<p>インラインでクロージャが定義されるか、名前付きの関数を使用できるかもしれない箇所の例として、<code>map</code>の使用に目を向けましょう。
<code>map</code>関数を使用して数字のベクタを文字列のベクタに変換するには、このようにクロージャを使用できるでしょう:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
#}</code></pre></pre>
<!-- Or we could name a function as the argument to `map` instead of the closure, -->
<!-- like this: -->
<p>あるいは、このようにクロージャの代わりに<code>map</code>に引数として関数に名前を付けられるでしょう:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
#}</code></pre></pre>
<!-- Note that we must use the fully qualified syntax that we talked about earlier -->
<!-- in the “Advanced Traits” section because there are multiple functions available -->
<!-- named `to_string`. Here, we’re using the `to_string` function defined in the -->
<!-- `ToString` trait, which the standard library has implemented for any type that -->
<!-- implements `Display`. -->
<p>先ほど「高度なトレイト」節で語ったフルパス記法を使わなければならないことに注意してください。
というのも、<code>to_string</code>という利用可能な関数は複数あるからです。ここでは、
<code>ToString</code>トレイトで定義された<code>to_string</code>関数を使用していて、このトレイトは標準ライブラリが、
<code>Display</code>を実装するあらゆる型に実装しています。</p>
<!-- Some people prefer this style, and some people prefer to use closures. They end -->
<!-- up compiling to the same code, so use whichever style is clearer to you. -->
<p>このスタイルを好む方もいますし、クロージャを使うのを好む方もいます。どちらも結果的に同じコードにコンパイルされるので、
どちらでも、自分にとって明確な方を使用してください。</p>
<!-- ### Returning Closures -->
<a class="header" href="print.html#aクロージャを返却する" id="aクロージャを返却する"><h3>クロージャを返却する</h3></a>
<!-- Closures are represented by traits, which means you can’t return closures -->
<!-- directly. In most cases where you might want to return a trait, you can instead -->
<!-- use the concrete type that implements the trait as the return value of the -->
<!-- function. But you can’t do that with closures because they don’t have a -->
<!-- concrete type that is returnable; you’re not allowed to use the function -->
<!-- pointer `fn` as a return type, for example. -->
<p>クロージャはトレイトによって表現されます。つまり、クロージャを直接は返却できないのです。
トレイトを返却したい可能性のあるほとんどの場合、代わりにトレイトを実装する具体的な型を関数の戻り値として使用できます。
ですが、クロージャではそれはできません。返却可能な具体的な型がないからです; 例えば、
関数ポインタの<code>fn</code>を戻り値の型として使うことは許容されていません。</p>
<!-- The following code tries to return a closure directly, but it won’t compile: -->
<p>以下のコードは、クロージャを直接返そうとしていますが、コンパイルできません:</p>
<pre><code class="language-rust ignore">fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<!-- The compiler error is as follows: -->
<p>コンパイルエラーは以下の通りです:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static:
std::marker::Sized` is not satisfied
 --&gt;
  |
1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -&gt; i32 + 'static`
  does not have a constant size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for
  `std::ops::Fn(i32) -&gt; i32 + 'static`
  = note: the return type of a function must have a statically known size
</code></pre>
<!-- The error references the `Sized` trait again! Rust doesn’t know how much space -->
<!-- it will need to store the closure. We saw a solution to this problem earlier. -->
<!-- We can use a trait object: -->
<p>エラーは、再度<code>Sized</code>トレイトを参照しています！コンパイラには、クロージャを格納するのに必要なスペースがどれくらいかわからないのです。
この問題の解決策は先ほど見かけました。トレイトオブジェクトを使えます:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn returns_closure() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
#}</code></pre></pre>
<!-- This code will compile just fine. For more about trait objects, refer to the -->
<!-- “Using Trait Objects That Allow for Values of Different Types” section in -->
<!-- Chapter 17. -->
<p>このコードは、問題なくコンパイルできます。トレイトオブジェクトについて詳しくは、
第17章の「トレイトオブジェクトで異なる型の値を許容する」節を参照してください。</p>
<!-- ## Summary -->
<a class="header" href="print.html#aまとめ-16" id="aまとめ-16"><h2>まとめ</h2></a>
<!-- Whew! Now you have some features of Rust in your toolbox that you won’t use -->
<!-- often, but you’ll know they’re available in very particular circumstances. -->
<!-- We’ve introduced several complex topics so that when you encounter them in -->
<!-- error message suggestions or in other peoples’ code, you’ll be able to -->
<!-- recognize these concepts and syntax. Use this chapter as a reference to guide -->
<!-- you to solutions. -->
<p>ふう！もう道具箱に頻繁には使用しないRustの機能が何かありますが、非常に限定された状況で利用可能だと知るでしょう。
エラーメッセージや他の方のコードで遭遇した際に、これらの概念や記法を認識できるように、
複雑な話題をいくつか紹介しました。この章は、解決策へ導く参考としてご活用ください。</p>
<!-- Next, we’ll put everything we’ve discussed throughout the book into practice -->
<!-- and do one more project! -->
<p>次は、本を通して議論してきた全てを実践に配備し、もう1つプロジェクトを<ruby>熟<rp>(</rp><rt>こな</rt><rp>)</rp></ruby>します！</p>
<!-- # Final Project: Building a Multithreaded Web Server -->
<a class="header" href="print.html#a最後のプロジェクト-マルチスレッドのwebサーバを構築する" id="a最後のプロジェクト-マルチスレッドのwebサーバを構築する"><h1>最後のプロジェクト: マルチスレッドのWebサーバを構築する</h1></a>
<!-- It’s been a long journey, but we’ve reached the end of the book. In this -->
<!-- chapter, we’ll build one more project together to demonstrate some of the -->
<!-- concepts we covered in the final chapters, as well as recap some earlier -->
<!-- lessons. -->
<p>長い旅でしたが、本の末端に到達しました。この章では、共にもう一つプロジェクトを構築して最後の方の章で講義した概念の一部をデモしつつ、
前のレッスンを思い出してもらいます。</p>
<!-- For our final project, we’ll make a web server that says “hello” and looks like -->
<!-- Figure 20-1 in a web browser. -->
<p>最後のプロジェクトでは、<code>hello</code>と言うのWebサーバを作り、Webブラウザで図20-1のような見た目になります。</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<!-- <span class="caption">Figure 20-1: Our final shared project</span> -->
<p><span class="caption">図20-1: 最後の共有されたプロジェクト</span></p>
<!-- Here is the plan to build the web server: -->
<p>こちらがWebサーバを構築するプランです:</p>
<!-- 1. Learn a bit about TCP and HTTP. -->
<!-- 2. Listen for TCP connections on a socket. -->
<!-- 3. Parse a small number of HTTP requests. -->
<!-- 4. Create a proper HTTP response. -->
<!-- 5. Improve the throughput of our server with a thread pool. -->
<ol>
<li>TCPとHTTPについて少し学ぶ。</li>
<li>ソケットでTCP接続をリッスンする。</li>
<li>少量のHTTPリクエストを構文解析する。</li>
<li>適切なHTTPレスポンスを生成する。</li>
<li>スレッドプールでサーバのスループットを強化する。</li>
</ol>
<!-- But before we get started, we should mention one detail: the method we’ll use -->
<!-- won’t be the best way to build a web server with Rust. A number of -->
<!-- production-ready crates are available on *https://crates.io/* that provide more -->
<!-- complete web server and thread pool implementations than we’ll build. -->
<p>ですが、取り掛かる前に、ある詳細に触れるべきです: 使用する方法は、RustでWebサーバを構築する最善の方法ではないのです。
これから構築するよりもより完全なWebサーバとスレッドプールの実装を提供する製品利用可能な多くのクレートが、
<em>https://crates.io/</em> で利用可能なのです。</p>
<!-- However, our intention in this chapter is to help you learn, not to take the -->
<!-- easy route. Because Rust is a systems programming language, we can choose the -->
<!-- level of abstraction we want to work with and can go to a lower level than is -->
<!-- possible or practical in other languages. We’ll write the basic HTTP server and -->
<!-- thread pool manually so you can learn the general ideas and techniques behind -->
<!-- the crates you might use in the future. -->
<p>しかしながら、この章での意図は、学習の手助けであり、簡単なルートを選ぶことではありません。
Rustはシステムプログラミング言語なので、取りかかる抽象度を選ぶことができ、
他の言語で可能だったり実践的なほどよりも低レベルまで行くことができます。一般的な考えと将来使う可能性のあるクレートの背後にある技術を学べるように、
手動で基本的なHTTPサーバとスレッドプールを書きます。</p>
<!-- ## Building a Single-Threaded Web Server -->
<a class="header" href="print.html#aシングルスレッドのwebサーバを構築する" id="aシングルスレッドのwebサーバを構築する"><h2>シングルスレッドのWebサーバを構築する</h2></a>
<!-- We’ll start by getting a single-threaded web server working. Before we begin, -->
<!-- let’s look at a quick overview of the protocols involved in building web -->
<!-- servers. The details of these protocols are beyond the scope of this book, but -->
<!-- a brief overview will give you the information you need. -->
<p>シングルスレッドのWebサーバを動かすところから始めます。始める前に、Webサーバ構築に関係するプロトコルをさっと一覧しましょう。
これらのプロトコルの詳細は、この本の範疇を超えていますが、さっと眺めることで必要な情報が得られるでしょう。</p>
<!-- The two main protocols involved in web servers are the *Hypertext Transfer -->
<!-- Protocol* *(HTTP)* and the *Transmission Control Protocol* *(TCP)*. Both -->
<!-- protocols are *request-response* protocols, meaning a *client* initiates -->
<!-- requests and a *server* listens to the requests and provides a response to the -->
<!-- client. The contents of those requests and responses are defined by the -->
<!-- protocols. -->
<p>主に2つのプロトコルがWebサーバに関係し、<em>Hypertext Transfer Protocol</em> <em>(HTTP)</em>(<code>注釈</code>: ハイパーテキスト転送プロトコル)と、
<em>Transmission Control Protocol</em> <em>(TCP)</em>(<code>注釈</code>: 伝送制御プロトコル)です。
両者のプロトコルは、<em>リクエスト・レスポンス</em>プロトコルであり、つまり、<em>クライアント</em>がリクエストを初期化し、
<em>サーバ</em>はリクエストをリッスンし、クライアントにレスポンスを提供するということです。
それらのリクエストとレスポンスの中身は、プロトコルで規定されています。</p>
<!-- TCP is the lower-level protocol that describes the details of how information -->
<!-- gets from one server to another but doesn’t specify what that information is. -->
<!-- HTTP builds on top of TCP by defining the contents of the requests and -->
<!-- responses. It’s technically possible to use HTTP with other protocols, but in -->
<!-- the vast majority of cases, HTTP sends its data over TCP. We’ll work with the -->
<!-- raw bytes of TCP and HTTP requests and responses. -->
<p>TCPは、情報があるサーバから別のサーバへどう到達するかの詳細を記述するものの、その情報がなんなのかは指定しない、
より低レベルのプロトコルです。HTTPはリクエストとレスポンスの中身を定義することでTCPの元に成り立っています。
技術的にはHTTPを他のプロトコルとともに使用することができますが、過半数の場合、HTTPはTCPの上にデータを送信します。
TCPとHTTPのリクエストとレスポンスの生のバイトを処理します。</p>
<!-- ### Listening to the TCP Connection -->
<a class="header" href="print.html#tcp接続をリッスンする" id="tcp接続をリッスンする"><h3>TCP接続をリッスンする</h3></a>
<!-- Our web server needs to listen to a TCP connection, so that’s the first part -->
<!-- we’ll work on. The standard library offers a `std::net` module that lets us do -->
<!-- this. Let’s make a new project in the usual fashion: -->
<p>WebサーバはTCP接続をリッスンするので、そこが最初に取り掛かる部分になります。標準ライブラリは、
<code>std::net</code>というこれを行うモジュールを用意しています。通常通り、新しいプロジェクトを作りましょう:</p>
<pre><code class="language-text">$ cargo new hello --bin
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<!-- Now enter the code in Listing 20-1 in *src/main.rs* to start. This code will -->
<!-- listen at the address `127.0.0.1:7878` for incoming TCP streams. When it gets -->
<!-- an incoming stream, it will print `Connection established!`. -->
<p>さて、リスト20-1のコードを<em>src/main.rs</em>に入力して始めてください。このコードは、
やってくるTCPストリームを求めて<code>127.0.0.1:7878</code>というアドレスをリッスンします。
入力ストリームを得ると、<code>Connection established!</code>と出力します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        // 接続が確立しました
        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<!-- <span class="caption">Listing 20-1: Listening for incoming streams and printing -->
<!-- a message when we receive a stream</span> -->
<p><span class="caption">リスト20-1: 入力ストリームをリッスンし、ストリームを受け付けた時にメッセージを出力する</span></p>
<!-- Using `TcpListener`, we can listen for TCP connections at the address -->
<!-- `127.0.0.1:7878`. In the address, the section before the colon is an IP address -->
<!-- representing your computer (this is the same on every computer and doesn’t -->
<!-- represent the authors’ computer specifically), and `7878` is the port. We’ve -->
<!-- chosen this port for two reasons: HTTP is normally accepted on this port, and -->
<!-- 7878 is “rust” typed on a telephone. -->
<p><code>TcpListener</code>により、アドレス<code>127.0.0.1:7878</code>でTCP接続をリッスンできます。アドレス内で、
コロンの前の区域は、自分のコンピュータを表すIPアドレスで(これはどんなコンピュータでも同じで、
特に著者のコンピュータを表すわけではありません)、<code>7878</code>はポートです。このポートを選択した理由は2つあります:
HTTPは通常このポートで受け付けられることと、7878は電話で“rust”と入力されるからです。</p>
<!-- The `bind` function in this scenario works like the `new` function in that it -->
<!-- will return a new `TcpListener` instance. The reason the function is called -->
<!-- `bind` is that in networking, connecting to a port to listen to is known as -->
<!-- “binding to a port.” -->
<p>この筋書きでの<code>bind</code>関数は、新しい<code>TcpListener</code>インスタンスを返すという点で<code>new</code>関数のような働きをします。
この関数が<code>bind</code>と呼ばれている理由は、ネットワークにおいて、リッスンすべきポートに接続することは、
「ポートに束縛する」(binding to a port)こととして知られているからです。</p>
<!-- The `bind` function returns a `Result<T, E>`, which indicates that binding -->
<!-- might fail. For example, connecting to port 80 requires administrator -->
<!-- privileges (nonadministrators can listen only on ports higher than 1024), so if -->
<!-- we tried to connect to port 80 without being an administrator, binding wouldn’t -->
<!-- work. As another example, binding wouldn’t work if we ran two instances of our -->
<!-- program and so had two programs listening to the same port. Because we’re -->
<!-- writing a basic server just for learning purposes, we won’t worry about -->
<!-- handling these kinds of errors; instead, we use `unwrap` to stop the program if -->
<!-- errors happen. -->
<p><code>bind</code>関数は<code>Result&lt;T, E&gt;</code>を返し、束縛が失敗することもあることを示しています。例えば、
ポート80に接続するには管理者権限が必要なので(管理者以外はポート1024以上しかリッスンできません)管理者にならずにポート80に接続を試みたら、
束縛はうまくいかないでしょう。また、別の例として自分のプログラムを2つ同時に立ち上げて2つのプログラムが同じポートをリッスンしたら、
束縛は機能しないでしょう。学習目的のためだけに基本的なサーバを記述しているので、この種のエラーを扱う心配はしません;
その代わり、<code>unwrap</code>を使用してエラーが発生したら、プログラムを停止します。</p>
<!-- The `incoming` method on `TcpListener` returns an iterator that gives us a -->
<!-- sequence of streams (more specifically, streams of type `TcpStream`). A single -->
<!-- *stream* represents an open connection between the client and the server. A -->
<!-- *connection* is the name for the full request and response process in which a -->
<!-- client connects to the server, the server generates a response, and the server -->
<!-- closes the connection. As such, `TcpStream` will read from itself to see what -->
<!-- the client sent and then allow us to write our response to the stream. Overall, -->
<!-- this `for` loop will process each connection in turn and produce a series of -->
<!-- streams for us to handle. -->
<p><code>TcpListener</code>の<code>incoming</code>メソッドは、一連のストリームを与えるイテレータを返します(具体的には、型<code>TcpStream</code>のストリーム)。
単独の<em>ストリーム</em>がクライアント・サーバ間の開かれた接続を表します。<em>接続</em>(connection)は、
クライアントがサーバに接続し、サーバがレスポンスを生成し、サーバが接続を閉じるというリクエストとレスポンス全体の過程の名前です。
そのため、<code>TcpStream</code>は自身を読み取って、クライアントが送信したことを確認し、それからレスポンスをストリームに記述させてくれます。
総括すると、この<code>for</code>ループは各接続を順番に処理し、我々が扱えるように一連のストリームを生成します。</p>
<!-- For now, our handling of the stream consists of calling `unwrap` to terminate -->
<!-- our program if the stream has any errors; if there aren’t any errors, the -->
<!-- program prints a message. We’ll add more functionality for the success case in -->
<!-- the next listing. The reason we might receive errors from the `incoming` method -->
<!-- when a client connects to the server is that we’re not actually iterating over -->
<!-- connections. Instead, we’re iterating over *connection attempts*. The -->
<!-- connection might not be successful for a number of reasons, many of them -->
<!-- operating system specific. For example, many operating systems have a limit to -->
<!-- the number of simultaneous open connections they can support; new connection -->
<!-- attempts beyond that number will produce an error until some of the open -->
<!-- connections are closed. -->
<p>とりあえず、ストリームの扱いは、<code>unwrap</code>を呼び出してストリームにエラーがあった場合にプログラムを停止することから構成されています;
エラーがなければ、プログラムはメッセージを出力します。次のリストで成功した時にさらに多くの機能を追加します。
クライアントがサーバに接続する際に<code>incoming</code>メソッドからエラーを受け取る可能性がある理由は、
実際には接続を走査していないからです。代わりに<em>接続の試行</em>を走査しています。接続は多くの理由で失敗する可能性があり、
そのうちの多くは、OS特有です。例を挙げれば、多くのOSには、サポートできる同時に開いた接続数に上限があります;
開かれた接続の一部が閉じられるまでその数字を超えた接続の試行はエラーになります。</p>
<!-- Let’s try running this code! Invoke `cargo run` in the terminal and then load -->
<!-- *127.0.0.1:7878* in a web browser. The browser should show an error message -->
<!-- like “Connection reset,” because the server isn’t currently sending back any -->
<!-- data. But when you look at your terminal, you should see several messages that -->
<!-- were printed when the browser connected to the server! -->
<p>このコードを試しに実行してみましょう！端末で<code>cargo run</code>を呼び出し、それからWebブラウザで<em>127.0.0.1:7878</em>をロードしてください。
ブラウザは、「接続がリセットされました」などのエラーメッセージを表示するはずです。サーバが現状、何もデータを返してこないからです。
ですが、端末に目を向ければ、ブラウザがサーバに接続した際にいくつかメッセージが出力されるのを目の当たりにするはずです。</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<!-- Sometimes, you’ll see multiple messages printed for one browser request; the -->
<!-- reason might be that the browser is making a request for the page as well as a -->
<!-- request for other resources, like the *favicon.ico* icon that appears in the -->
<!-- browser tab. -->
<p>時々、1回のブラウザリクエストで複数のメッセージが出力されるのを目の当たりにするでしょう;
その理由は、ブラウザがページだけでなく、
ブラウザのタブに出現する<em>favicon.ico</em>アイコンなどの他のリソースにもリクエストを行なっているということかもしれません。</p>
<!-- It could also be that the browser is trying to connect to the server multiple -->
<!-- times because the server isn’t responding with any data. When `stream` goes out -->
<!-- of scope and is dropped at the end of the loop, the connection is closed as -->
<!-- part of the `drop` implementation. Browsers sometimes deal with closed -->
<!-- connections by retrying, because the problem might be temporary. The important -->
<!-- factor is that we’ve successfully gotten a handle to a TCP connection! -->
<p>サーバが何もデータを送り返してこないので、ブラウザがサーバに何度も接続を試みているという可能性もあります。
<code>stream</code>がスコープを抜け、ループの最後でドロップされると、接続は<code>drop</code>実装の一部として閉じられます。
ブラウザは、再試行することで閉じられた接続を扱うことがあります。問題が一時的なものかもしれないからです。
重要な要素は、TCP接続へのハンドルを得ることに成功したということです！</p>
<!-- Remember to stop the program by pressing <span class="keystroke">ctrl-c</span> -->
<!-- when you’re done running a particular version of the code. Then restart `cargo -->
<!-- run` after you’ve made each set of code changes to make sure you’re running the -->
<!-- newest code. -->
<p>特定のバージョンのコードを走らせ終わった時に<span class="keystroke">ctrl-c</span>を押して、
プログラムを止めることを忘れないでください。そして、一連のコード変更を行った後に<code>cargo run</code>を再起動し、
最新のコードを実行していることを確かめてください。</p>
<!-- ### Reading the Request -->
<a class="header" href="print.html#aリクエストを読み取る" id="aリクエストを読み取る"><h3>リクエストを読み取る</h3></a>
<!-- Let’s implement the functionality to read the request from the browser! To -->
<!-- separate the concerns of first getting a connection and then taking some action -->
<!-- with the connection, we’ll start a new function for processing connections. In -->
<!-- this new `handle_connection` function, we’ll read data from the TCP stream and -->
<!-- print it so we can see the data being sent from the browser. Change the code to -->
<!-- look like Listing 20-2. -->
<p>ブラウザからリクエストを読み取る機能を実装しましょう！まず接続を得、それから接続に対して何らかの行動を行う責任を分離するために、
接続を処理する新しい関数を開始します。この新しい<code>handle_connection</code>関数において、TCPストリームからデータを読み取り、
ブラウザからデータが送られていることを確認できるように端末に出力します。コードをリスト20-2のように変更してください。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpStream;
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<!-- <span class="caption">Listing 20-2: Reading from the `TcpStream` and printing -->
<!-- the data</span> -->
<p><span class="caption">リスト20-2: <code>TcpStream</code>から読み取り、データを出力する</span></p>
<!-- We bring `std::io::prelude` into scope to get access to certain traits that let -->
<!-- us read from and write to the stream. In the `for` loop in the `main` function, -->
<!-- instead of printing a message that says we made a connection, we now call the -->
<!-- new `handle_connection` function and pass the `stream` to it. -->
<p><code>std::io::prelude</code>をスコープに導入してストリームから読み書きさせてくれる特定のトレイトにアクセスできるようにしています。
<code>main</code>関数内の<code>for</code>ループで、接続を確立したというメッセージを出力する代わりに、今では、
新しい<code>handle_connection</code>関数を呼び出し、<code>stream</code>を渡しています。</p>
<!-- In the `handle_connection` function, we’ve made the `stream` parameter mutable. -->
<!-- The reason is that the `TcpStream` instance keeps track of what data it returns -->
<!-- to us internally. It might read more data than we asked for and save that data -->
<!-- for the next time we ask for data. It therefore needs to be `mut` because its -->
<!-- internal state might change; usually, we think of “reading” as not needing -->
<!-- mutation, but in this case we need the `mut` keyword. -->
<p><code>handle_connection</code>関数において、<code>stream</code>引数を可変にしました。理由は、
<code>TcpStream</code>インスタンスが内部で返すデータを追いかけているからです。要求した以上のデータを読み取り、
次回データを要求した時のためにそのデータを保存する可能性があります。故に、内部の状態が変化する可能性があるので、
<code>mut</code>にする必要があるのです; 普通、「読み取り」に可変化は必要ないと考えてしまいますが、この場合、<code>mut</code>キーワードが必要です。</p>
<!-- Next, we need to actually read from the stream. We do this in two steps: first, -->
<!-- we declare a `buffer` on the stack to hold the data that is read in. We’ve made -->
<!-- the buffer 512 bytes in size, which is big enough to hold the data of a basic -->
<!-- request and sufficient for our purposes in this chapter. If we wanted to handle -->
<!-- requests of an arbitrary size, buffer management would need to be more -->
<!-- complicated; we’ll keep it simple for now. We pass the buffer to `stream.read`, -->
<!-- which will read bytes from the `TcpStream` and put them in the buffer. -->
<p>次に、実際にストリームから読み取る必要があります。これを2つの手順で行います: まず、
スタックに読み取ったデータを保持する<code>buffer</code>を宣言します。バッファーのサイズは512バイトにしました。
これは、基本的なリクエストには十分な大きさでこの章の目的には必要十分です。任意のサイズのリクエストを扱いたければ、
バッファーの管理はもっと複雑にする必要があります; 今は、単純に保っておきます。このバッファーを<code>stream.read</code>に渡し、
これが<code>TcpStream</code>からバイトを読み取ってバッファーに置きます。</p>
<!-- Second, we convert the bytes in the buffer to a string and print that string. -->
<!-- The `String::from_utf8_lossy` function takes a `&[u8]` and produces a `String` -->
<!-- from it. The “lossy” part of the name indicates the behavior of this function -->
<!-- when it sees an invalid UTF-8 sequence: it will replace the invalid sequence -->
<!-- with `�`, the `U+FFFD REPLACEMENT CHARACTER`. You might see replacement -->
<!-- characters for characters in the buffer that aren’t filled by request data. -->
<p>2番目にバッファーのバイトを文字列に変換し、その文字列を出力します。<code>String::from_utf8_lossy</code>関数は、
<code>&amp;[u8]</code>を取り、<code>String</code>を生成します。名前の“lossy”の箇所は、無効なUTF-8シーケンスを目の当たりにした際のこの関数の振る舞いを示唆しています:
無効なシーケンスを<code>�</code>、<code>U+FFFD REPLACEMENT CHARACTER</code>で置き換えます。
置き換え文字をリクエストデータによって埋められたバッファーの文字の箇所に目撃する可能性があります。</p>
<!-- Let’s try this code! Start the program and make a request in a web browser -->
<!-- again. Note that we’ll still get an error page in the browser, but our -->
<!-- program’s output in the terminal will now look similar to this: -->
<p>このコードを試しましょう！プログラムを開始してWebブラウザで再度リクエストを送ってください。ブラウザではそれでも、
エラーページが得られるでしょうが、端末のプログラムの出力はこんな感じになっていることに注目してください:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<!-- Depending on your browser, you might get slightly different output. Now that -->
<!-- we’re printing the request data, we can see why we get multiple connections -->
<!-- from one browser request by looking at the path after `Request: GET`. If the -->
<!-- repeated connections are all requesting */*, we know the browser is trying to -->
<!-- fetch */* repeatedly because it’s not getting a response from our program. -->
<p>ブラウザによって、少し異なる出力になる可能性があります。今やリクエストデータを出力しているので、
<code>Request: GET</code>の後のパスを見ることで1回のブラウザリクエストから複数の接続が得られる理由が確認できます。
繰り返される接続が全て <em>/</em> を要求しているなら、ブラウザは、我々のプログラムからレスポンスが得られないので、
繰り返し <em>/</em> をフェッチしようとしていることがわかります。</p>
<!-- Let’s break down this request data to understand what the browser is asking of -->
<!-- our program. -->
<p>このリクエストデータを噛み砕いてブラウザが我々のプログラムに何を要求しているかを理解しましょう。</p>
<!-- ### A Closer Look at an HTTP Request -->
<a class="header" href="print.html#httpリクエストを詳しく見る" id="httpリクエストを詳しく見る"><h3>HTTPリクエストを詳しく見る</h3></a>
<!-- HTTP is a text-based protocol, and a request takes this format: -->
<p>HTTPはテキストベースのプロトコルで、1つの要求はこのようなフォーマットに則っています:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<!-- The first line is the *request line* that holds information about what the -->
<!-- client is requesting. The first part of the request line indicates the *method* -->
<!-- being used, such as `GET` or `POST`, which describes how the client is making -->
<!-- this request. Our client used a `GET` request. -->
<p>1行目は、クライアントが要求しているものがなんなのかについての情報を保持するリクエスト行です。
リクエスト行の最初の部分は使用されている<code>GET</code>や<code>POST</code>などの<em>メソッド</em>を示し、これは、どのようにクライアントがこの要求を行なっているかを記述します。
クライアントは<code>GET</code>リクエストを使用しました。</p>
<!-- The next part of the request line is */*, which indicates the *Uniform Resource -->
<!-- Identifier* *(URI)* the client is requesting: a URI is almost, but not quite, -->
<!-- the same as a *Uniform Resource Locator* *(URL)*. The difference between URIs -->
<!-- and URLs isn’t important for our purposes in this chapter, but the HTTP spec -->
<!-- uses the term URI, so we can just mentally substitute URL for URI here. -->
<p>リクエスト行の次の部分は <em>/</em> で、これはクライアントが要求している<em>Uniform Resource Identifier</em> <em>(URI)</em>(<code>注釈</code>: 統一資源識別子)を示します:
URIはほぼ、ですがかなりではなく、<em>Uniform Resource Locator</em> <em>(URL)</em>(<code>注釈</code>: 統一資源位置指定子)と同じです。
URIとURLの違いは、この章の目的には重要ではありませんが、HTTPの規格はURIという用語を使用しているので、
ここでは脳内でURIをURLと読み替えられます。</p>
<!-- The last part is the HTTP version the client uses, and then the request line -->
<!-- ends in a *CRLF sequence*. (CRLF stands for *carriage return* and *line feed*, -->
<!-- which are terms from the typewriter days!) The CRLF sequence can also be -->
<!-- written as `\r\n`, where `\r` is a carriage return and `\n` is a line feed. The -->
<!-- CRLF sequence separates the request line from the rest of the request data. -->
<!-- Note that when the CRLF is printed, we see a new line start rather than `\r\n`. -->
<p>最後の部分は、クライアントが使用しているHTTPのバージョンで、それからリクエスト行は<em>CRLF</em>で終了します。
(CRLFは<em>carriage return</em>と<em>line feed</em>(無理に日本語でいえば、キャリッジ(紙を固定するシリンダー)が戻ることと行を(コンピュータに)与えること)を表していて、
これはタイプライター時代からの用語です！)CRLFは<code>\r\n</code>とも表記され、<code>\r</code>がキャリッジ・リターンで<code>\n</code>がライン・フィードです。
CRLFにより、リクエスト行がリクエストデータの残りと区別されています。CRLFを出力すると、
<code>\r\n</code>ではなく、新しい行が開始されることに注意してください。</p>
<!-- Looking at the request line data we received from running our program so far, -->
<!-- we see that `GET` is the method, */* is the request URI, and `HTTP/1.1` is the -->
<!-- version. -->
<p>ここまでプログラムを実行して受け取ったリクエスト行のデータをみると、<code>GET</code>がメソッド、<em>/</em> が要求URI、
<code>HTTP/1.1</code>がバージョンであることが確認できます。</p>
<!-- After the request line, the remaining lines starting from `Host:` onward are -->
<!-- headers. `GET` requests have no body. -->
<p>リクエスト行の後に、<code>Host:</code>以下から始まる残りの行は、ヘッダーです。<code>GET</code>リクエストには、本体がありません。</p>
<!-- Try making a request from a different browser or asking for a different -->
<!-- address, such as *127.0.0.1:7878/test*, to see how the request data changes. -->
<p>試しに他のブラウザからリクエストを送ったり、<em>127.0.0.1:7878/test</em>などの異なるアドレスを要求してみて、どうリクエストデータが変わるか確認してください。</p>
<!-- Now that we know what the browser is asking for, let’s send back some data! -->
<p>さて、ブラウザが要求しているものがわかったので、何かデータを返しましょう！</p>
<!-- ### Writing a Response -->
<a class="header" href="print.html#aレスポンスを記述する" id="aレスポンスを記述する"><h3>レスポンスを記述する</h3></a>
<!-- Now we’ll implement sending data in response to a client request. Responses -->
<!-- have the following format: -->
<p>さて、クライアントのリクエストに対する返答としてデータの送信を実装します。レスポンスは、以下のようなフォーマットです:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<!-- The first line is a *status line* that contains the HTTP version used in the -->
<!-- response, a numeric status code that summarizes the result of the request, and -->
<!-- a reason phrase that provides a text description of the status code. After the -->
<!-- CRLF sequence are any headers, another CRLF sequence, and the body of the -->
<!-- response. -->
<p>1行目は、<em>ステータス行</em>で、レスポンスで使用されるHTTPバージョン、リクエストの結果を総括する数値のステータスコード、
ステータスコードをテキストで表現する理由フレーズを含みます。CRLFの後には、あらゆるヘッダー、別のCRLF、
レスポンスの本体があります。</p>
<!-- Here is an example response that uses HTTP version 1.1, has a status code of -->
<!-- 200, an OK reason phrase, no headers, and no body: -->
<p>こちらがHTTPバージョン1.1を使用し、ステータスコードが200で、OKフレーズ、ヘッダーと本体なしの例のレスポンスです:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<!-- The status code 200 is the standard success response. The text is a tiny -->
<!-- successful HTTP response. Let’s write this to the stream as our response to a -->
<!-- successful request! From the `handle_connection` function, remove the -->
<!-- `println!` that was printing the request data and replace it with the code in -->
<!-- Listing 20-3. -->
<p>ステータスコード200は、一般的な成功のレスポンスです。テキストは、<ruby>矮小<rp>(</rp><rt>わいしょう</rt><rp>)</rp></ruby>な成功のHTTPレスポンスです。
これを成功したリクエストへの返答としてストリームに書き込みましょう！<code>handle_connection</code>関数から、
リクエストデータを出力していた<code>println!</code>を除去し、リスト20-3のコードと置き換えてください。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-3: Writing a tiny successful HTTP response to -->
<!-- the stream</span> -->
<p><span class="caption">リスト20-3: ストリームに矮小な成功のHTTPレスポンスを書き込む</span></p>
<!-- The first new line defines the `response` variable that holds the success -->
<!-- message’s data. Then we call `as_bytes` on our `response` to convert the string -->
<!-- data to bytes. The `write` method on `stream` takes a `&[u8]` and sends those -->
<!-- bytes directly down the connection. -->
<p>新しい最初の行に成功したメッセージのデータを保持する<code>response</code>変数を定義しています。そして、
<code>response</code>に対して<code>as_bytes</code>を呼び出し、文字列データをバイトに変換します。<code>stream</code>の<code>write</code>メソッドは、
<code>&amp;[u8]</code>を取り、接続に直接そのバイトを送信します。</p>
<!-- Because the `write` operation could fail, we use `unwrap` on any error result -->
<!-- as before. Again, in a real application you would add error handling here. -->
<!-- Finally, `flush` will wait and prevent the program from continuing until all -->
<!-- the bytes are written to the connection; `TcpStream` contains an internal -->
<!-- buffer to minimize calls to the underlying operating system. -->
<p><code>write</code>処理は失敗することもあるので、以前のようにエラーの結果には<code>unwrap</code>を使用します。
今回も、実際のアプリでは、エラー処理をここに追加するでしょう。最後に<code>flush</code>は待機し、
バイトが全て接続に書き込まれるまでプログラムが継続するのを防ぎます; <code>TcpStream</code>は内部のバッファーを保持して、
元となるOSへの呼び出しを最小化します。</p>
<!-- With these changes, let’s run our code and make a request. We’re no longer -->
<!-- printing any data to the terminal, so we won’t see any output other than the -->
<!-- output from Cargo. When you load *127.0.0.1:7878* in a web browser, you should -->
<!-- get a blank page instead of an error. You’ve just hand-coded an HTTP request -->
<!-- and response! -->
<p>これらの変更とともに、コードを実行し、リクエストをしましょう。最早、端末にどんなデータも出力していないので、
Cargoからの出力以外には何も出力はありません。Webブラウザで<em>127.0.0.1:7878</em>をロードすると、
エラーではなく空っぽのページが得られるはずです。HTTPリクエストとレスポンスを手で実装したばかりなのです！</p>
<!-- ### Returning Real HTML -->
<a class="header" href="print.html#a本物のhtmlを返す" id="a本物のhtmlを返す"><h3>本物のHTMLを返す</h3></a>
<!-- Let’s implement the functionality for returning more than a blank page. Create -->
<!-- a new file, *hello.html*, in the root of your project directory, not in the -->
<!-- *src* directory. You can input any HTML you want; Listing 20-4 shows one -->
<!-- possibility. -->
<p>空っぽのページ以上のものを返す機能を実装しましょう。新しいファイル<em>hello.html</em>を<em>src</em>ディレクトリではなく、
プロジェクトのルートディレクトリに作成してください。お好きなようにHTMLを書いてください;
リスト20-4は、一つの可能性を示しています。</p>
<!-- <span class="filename">Filename: hello.html</span> -->
<p><span class="filename">ファイル名: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- やあ！ --&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;!-- Rustからやあ --&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!-- <span class="caption">Listing 20-4: A sample HTML file to return in a -->
<!-- response</span> -->
<p><span class="caption">リスト20-4: レスポンスで返すサンプルのHTMLファイル</span></p>
<!-- This is a minimal HTML5 document with a heading and some text. To return this -->
<!-- from the server when a request is received, we’ll modify `handle_connection` as -->
<!-- shown in Listing 20-5 to read the HTML file, add it to the response as a body, -->
<!-- and send it. -->
<p>これは、ヘッドとテキストのある最低限のHTML5ドキュメントです。リクエストを受け付けた際にこれをサーバから返すには、
リスト20-5のように<code>handle_connection</code>を変更してHTMLファイルを読み込み、本体としてレスポンスに追加して送ります。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let mut file = File::open(&quot;hello.html&quot;).unwrap();

    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-5: Sending the contents of *hello.html* as the -->
<!-- body of the response</span> -->
<p><span class="caption">リスト20-5: レスポンスの本体として<em>hello.html</em>の中身を送る</span></p>
<!-- We’ve added a line at the top to bring the standard library’s `File` into -->
<!-- scope. The code for opening a file and reading the contents should look -->
<!-- familiar; we used it in Chapter 12 when we read the contents of a file for our -->
<!-- I/O project in Listing 12-4. -->
<p>先頭に行を追加して標準ライブラリの<code>File</code>をスコープに導入しました。ファイルを開き、中身を読み込むコードは、
馴染みがあるはずです; リスト12-4でI/Oプロジェクト用にファイルの中身を読み込んだ時に第12章で使用したからです。</p>
<!-- Next, we use `format!` to add the file’s contents as the body of the success -->
<!-- response. -->
<p>次に<code>format!</code>でファイルの中身を成功したレスポンスの本体として追記しています。</p>
<!-- Run this code with `cargo run` and load *127.0.0.1:7878* in your browser; you -->
<!-- should see your HTML rendered! -->
<p>このコードを<code>cargo run</code>で走らせ、<em>127.0.0.1:7878</em>をブラウザでロードしてください;
HTMLが描画されるのが確認できるはずです！</p>
<!-- Currently, we’re ignoring the request data in `buffer` and just sending back -->
<!-- the contents of the HTML file unconditionally. That means if you try requesting -->
<!-- *127.0.0.1:7878/something-else* in your browser, you’ll still get back this -->
<!-- same HTML response. Our server is very limited and is not what most web servers -->
<!-- do. We want to customize our responses depending on the request and only send -->
<!-- back the HTML file for a well-formed request to */*. -->
<p>現時点では、<code>buffer</code>内のリクエストデータは無視し、無条件でHTMLファイルの中身を送り返しているだけです。
これはつまり、ブラウザで<em>127.0.0.1:7878/something-else</em>をリクエストしても、
この同じHTMLレスポンスが得られるということです。我々のサーバはかなり限定的で、多くのWebサーバとは異なっています。
リクエストに基づいてレスポンスをカスタマイズし、<em>/</em> への合法なリクエストに対してのみHTMLファイルを送り返したいです。</p>
<!-- ### Validating the Request and Selectively Responding -->
<a class="header" href="print.html#aリクエストにバリデーションをかけ選択的にレスポンスを返す" id="aリクエストにバリデーションをかけ選択的にレスポンスを返す"><h3>リクエストにバリデーションをかけ、選択的にレスポンスを返す</h3></a>
<!-- Right now, our web server will return the HTML in the file no matter what the -->
<!-- client requested. Let’s add functionality to check that the browser is -->
<!-- requesting */* before returning the HTML file and return an error if the -->
<!-- browser requests anything else. For this we need to modify `handle_connection`, -->
<!-- as shown in Listing 20-6. This new code checks the content of the request -->
<!-- received against what we know a request for */* looks like and adds `if` and -->
<!-- `else` blocks to treat requests differently. -->
<p>現状、このWebサーバはクライアントが何を要求しても、ファイルのHTMLを返します。HTMLファイルを返却する前にブラウザが <em>/</em> をリクエストしているか確認し、
ブラウザが他のものを要求していたらエラーを返す機能を追加しましょう。このために、
<code>handle_connection</code>をリスト20-6のように変更する必要があります。この新しいコードは、
<em>/</em> への要求がどんな見た目になるのか知っていることに対して受け取ったリクエストの中身を精査し、<code>if</code>と<code>else</code>ブロックを追加して、
要求を異なる形で扱います。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let mut file = File::open(&quot;hello.html&quot;).unwrap();

        let mut contents = String::new();
        file.read_to_string(&amp;mut contents).unwrap();

        let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // 何か他の要求
        // some other request
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-6: Matching the request and handling requests -->
<!-- to */* differently than other requests</span> -->
<p><span class="caption">リスト20-6: リクエストとマッチさせ、<em>/</em> へのリクエストを他のリクエストとは異なる形で扱う</span></p>
<!-- First, we hardcode the data corresponding to the */* request into the `get` -->
<!-- variable. Because we’re reading raw bytes into the buffer, we transform `get` -->
<!-- into a byte string by adding the `b""` byte string syntax at the start of the -->
<!-- content data. Then we check whether `buffer` starts with the bytes in `get`. If -->
<!-- it does, it means we’ve received a well-formed request to */*, which is the -->
<!-- success case we’ll handle in the `if` block that returns the contents of our -->
<!-- HTML file. -->
<p>まず、<em>/</em> リクエストに対応するデータを<code>get</code>変数にハードコードしています。生のバイトをバッファーに読み込んでいるので、
<code>b&quot;&quot;</code>バイト文字列記法を中身のデータの先頭に追記することで、<code>get</code>をバイト文字列に変換しています。
そして、<code>buffer</code>が<code>get</code>のバイトから始まっているか確認します。もしそうなら、<em>/</em> への合法なリクエストを受け取ったことを意味し、
これが、HTMLファイルの中身を返す<code>if</code>ブロックで扱う成功した場合になります。</p>
<!-- If `buffer` does *not* start with the bytes in `get`, it means we’ve received -->
<!-- some other request. We’ll add code to the `else` block in a moment to respond -->
<!-- to all other requests. -->
<p><code>buffer</code>が<code>get</code>のバイトで始まら<em>ない</em>のなら、何か他のリクエストを受け取ったことになります。
この後すぐ、<code>else</code>ブロックに他のリクエストに対応するコードを追加します。</p>
<!-- Run this code now and request *127.0.0.1:7878*; you should get the HTML in -->
<!-- *hello.html*. If you make any other request, such as -->
<!-- *127.0.0.1:7878/something-else*, you’ll get a connection error like you -->
<!-- saw when running the code in Listing 20-1 and Listing 20-2. -->
<p>さあ、このコードを走らせて<em>127.0.0.1:7878</em>を要求してください; <em>hello.html</em>のHTMLが得られるはずです。
<em>127.0.0.1:7878/something-else</em>などの他のリクエストを行うと、リスト20-1や20-2のコードを走らせた時に見かけた接続エラーになるでしょう。</p>
<!-- Now let’s add the code in Listing 20-7 to the `else` block to return a response -->
<!-- with the status code 404, which signals that the content for the request was -->
<!-- not found. We’ll also return some HTML for a page to render in the browser -->
<!-- indicating the response to the end user. -->
<p>では、<code>else</code>ブロックにリスト20-7のコードを追記してステータスコード404のレスポンスを返しましょう。
これは、リクエストの中身が見つからなかったことを通知します。エンドユーザにレスポンスを示唆するページをブラウザに描画するよう、
何かHTMLも返します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
# fn handle_connection(mut stream: TcpStream) {
# if true {
// --snip--

} else {
    let status_line = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
    let mut file = File::open(&quot;404.html&quot;).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
# }
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-7: Responding with status code 404 and an -->
<!-- error page if anything other than */* was requested</span> -->
<p><span class="caption">リスト20-7: <em>/</em> 以外の何かが要求されたら、ステータスコード404とエラーページで応答する</span></p>
<!-- Here, our response has a status line with status code 404 and the reason -->
<!-- phrase `NOT FOUND`. We’re still not returning headers, and the body of the -->
<!-- response will be the HTML in the file *404.html*. You’ll need to create a -->
<!-- *404.html* file next to *hello.html* for the error page; again feel free to use -->
<!-- any HTML you want or use the example HTML in Listing 20-8. -->
<p>ここでは、レスポンスにはステータスコード404と理由フレーズ<code>NOT FOUND</code>のステータス行があります。
それでもヘッダーは返さず、レスポンスの本体は、ファイル<em>404.html</em>のHTMLになります。エラーページのために、
<em>hello.html</em>の隣に<em>404.html</em>ファイルを作成する必要があります; 今回も、ご自由にお好きなHTMLにしたり、
リスト20-8の例のHTMLを使用したりしてください。</p>
<!-- <span class="filename">Filename: 404.html</span> -->
<p><span class="filename">ファイル名: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;!-- すいません。要求しているものが理解できません --&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!-- <span class="caption">Listing 20-8: Sample content for the page to send back -->
<!-- with any 404 response</span> -->
<p><span class="caption">リスト20-8: あらゆる404レスポンスでページが送り返す中身のサンプル</span></p>
<!-- With these changes, run your server again. Requesting *127.0.0.1:7878* -->
<!-- should return the contents of *hello.html*, and any other request, like -->
<!-- *127.0.0.1:7878/foo*, should return the error HTML from *404.html*. -->
<p>これらの変更とともに、もう一度サーバを実行してください。<em>127.0.0.1:7878</em>を要求すると、
<em>hello.html</em>の中身が返り、<em>127.0.0.1:7878/foo</em>などの他のリクエストには<em>404.html</em>からのエラーHTMLが返るはずです。</p>
<!-- ### A Touch of Refactoring -->
<a class="header" href="print.html#aリファクタリングの触り" id="aリファクタリングの触り"><h3>リファクタリングの触り</h3></a>
<!-- At the moment the `if` and `else` blocks have a lot of repetition: they’re both -->
<!-- reading files and writing the contents of the files to the stream. The only -->
<!-- differences are the status line and the filename. Let’s make the code more -->
<!-- concise by pulling out those differences into separate `if` and `else` lines -->
<!-- that will assign the values of the status line and the filename to variables; -->
<!-- we can then use those variables unconditionally in the code to read the file -->
<!-- and write the response. Listing 20-9 shows the resulting code after replacing -->
<!-- the large `if` and `else` blocks. -->
<p>現在、<code>if</code>と<code>else</code>ブロックには多くの重複があります: どちらもファイルを読み、ファイルの中身をストリームに書き込んでいます。
唯一の違いは、ステータス行とファイル名だけです。それらの差異をステータス行とファイル名の値を変数に代入する個別の<code>if</code>と<code>else</code>行に引っ張り出して、
コードをより簡潔にしましょう; そうしたら、それらの変数を無条件にコードで使用し、ファイルを読んでレスポンスを書き込めます。
リスト20-9は、大きな<code>if</code>と<code>else</code>ブロックを置き換えた後の結果のコードを示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
#
#     let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    // --snip--

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let mut file = File::open(filename).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-9: Refactoring the `if` and `else` blocks to -->
<!-- contain only the code that differs between the two cases</span> -->
<p><span class="caption">リスト20-9: 2つの場合で異なるコードだけを含むように<code>if</code>と<code>else</code>ブロックをリファクタリングする</span></p>
<!-- Now the `if` and `else` blocks only return the appropriate values for the -->
<!-- status line and filename in a tuple; we then use destructuring to assign these -->
<!-- two values to `status_line` and `filename` using a pattern in the `let` -->
<!-- statement, as discussed in Chapter 18. -->
<p>これで、<code>if</code>と<code>else</code>ブロックは、タプルにステータス行とファイル名の適切な値を返すだけになりました;
それから、分配を使用してこれら2つの値を第18章で議論したように<code>let</code>文のパターンで<code>status_line</code>と<code>filename</code>に代入しています。</p>
<!-- The previously duplicated code is now outside the `if` and `else` blocks and -->
<!-- uses the `status_line` and `filename` variables. This makes it easier to see -->
<!-- the difference between the two cases, and it means we have only one place to -->
<!-- update the code if we want to change how the file reading and response writing -->
<!-- work. The behavior of the code in Listing 20-9 will be the same as that in -->
<!-- Listing 20-8. -->
<p>前は重複していたコードは、今では<code>if</code>と<code>else</code>ブロックの外に出て、<code>status_line</code>と<code>filename</code>変数を使用しています。
これにより、2つの場合の違いがわかりやすくなり、ファイル読み取りとレスポンス記述の動作法を変更したくなった際に、
1箇所だけコードを更新すればいいようになったことを意味します。リスト20-9のコードの振る舞いは、
リスト20-8と同じです。</p>
<!-- Awesome! We now have a simple web server in approximately 40 lines of Rust code -->
<!-- that responds to one request with a page of content and responds to all other -->
<!-- requests with a 404 response. -->
<p>素晴らしい！これで、およそ40行のRustコードで、あるリクエストにはページの中身で応答し、
他のあらゆるリクエストには404レスポンスで応答する単純なWebサーバができました。</p>
<!-- Currently, our server runs in a single thread, meaning it can only serve one -->
<!-- request at a time. Let’s examine how that can be a problem by simulating some -->
<!-- slow requests. Then we'll fix it so our server can handle multiple requests at -->
<!-- once. -->
<p>現状、このサーバは、シングルスレッドで実行されます。つまり、1回に1つのリクエストしか捌けないということです。
何か遅いリクエストをシミュレーションすることでそれが問題になる可能性を調査しましょう。
それから1度にサーバが複数のリクエストを扱えるように修正します。</p>
<!-- ## Turning Our Single-Threaded Server into a Multithreaded Server -->
<a class="header" href="print.html#aシングルスレッドサーバをマルチスレッド化する" id="aシングルスレッドサーバをマルチスレッド化する"><h2>シングルスレッドサーバをマルチスレッド化する</h2></a>
<!-- Right now, the server will process each request in turn, meaning it won’t -->
<!-- process a second connection until the first is finished processing. If the -->
<!-- server received more and more requests, this serial execution would be less and -->
<!-- less optimal. If the server receives a request that takes a long time to -->
<!-- process, subsequent requests will have to wait until the long request is -->
<!-- finished, even if the new requests can be processed quickly. We’ll need to fix -->
<!-- this, but first, we’ll look at the problem in action. -->
<p>現状、サーバはリクエストを順番に処理します。つまり、最初のが処理し終わるまで、2番目の接続は処理しないということです。
サーバが受け付けるリクエストの量が増えるほど、この連続的な実行は、最適ではなくなるでしょう。
サーバが処理するのに長い時間がかかるリクエストを受け付けたら、新しいリクエストは迅速に処理できても、
続くリクエストは長いリクエストが完了するまで待たなければならなくなるでしょう。これを修正する必要がありますが、
まずは、実際に問題が起こっているところを見ます。</p>
<!-- ### Simulating a Slow Request in the Current Server Implementation -->
<a class="header" href="print.html#a現在のサーバの実装で遅いリクエストをシミュレーションする" id="a現在のサーバの実装で遅いリクエストをシミュレーションする"><h3>現在のサーバの実装で遅いリクエストをシミュレーションする</h3></a>
<!-- We’ll look at how a slow-processing request can affect other requests made to -->
<!-- our current server implementation. Listing 20-10 implements handling a request -->
<!-- to */sleep* with a simulated slow response that will cause the server to sleep -->
<!-- for 5 seconds before responding. -->
<p>処理が遅いリクエストが現在のサーバ実装に対して行われる他のリクエストにどう影響するかに目を向けます。
リスト20-10は、応答する前に5秒サーバをスリープさせる遅いレスポンスをシミュレーションした <em>/sleep</em>へのリクエストを扱う実装です。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
    // --snip--

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // --snip--
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-10: Simulating a slow request by recognizing -->
<!-- */sleep* and sleeping for 5 seconds</span> -->
<p><span class="caption">リスト20-10: <em>/sleep</em>を認識して5秒間スリープすることで遅いリクエストをシミュレーションする</span></p>
<!-- This code is a bit messy, but it’s good enough for simulation purposes. We -->
<!-- created a second request `sleep`, whose data our server recognizes. We added an -->
<!-- `else if` after the `if` block to check for the request to */sleep*. When that -->
<!-- request is received, the server will sleep for 5 seconds before rendering the -->
<!-- successful HTML page. -->
<p>このコードはちょっと汚いですが、シミュレーション目的には十分です。2番目のリクエスト<code>sleep</code>を作成し、
そのデータをサーバは認識します。<code>if</code>ブロックの後に　<code>else if</code>を追加し、<em>/sleep</em>へのリクエストを確認しています。
そのリクエストが受け付けられると、サーバは成功のHTMLページを描画する前に5秒間スリープします。</p>
<!-- You can see how primitive our server is: real libraries would handle the -->
<!-- recognition of multiple requests in a much less verbose way! -->
<p>我々のサーバがどれだけ基礎的かわかります: 本物のライブラリは、もっと冗長でない方法で複数のリクエストの認識を扱うでしょう！</p>
<!-- Start the server using `cargo run`. Then open two browser windows: one for -->
<!-- *http://localhost:7878/* and the other for *http://localhost:7878/sleep*. If -->
<!-- you enter the */* URI a few times, as before, you’ll see it respond quickly. -->
<!-- But if you enter */sleep*, and then load */*, you’ll see that */* waits until -->
<!-- `sleep` has slept for its full 5 seconds before loading. -->
<p><code>cargo run</code>でサーバを開始してください。それから2つブラウザのウインドウを開いてください: 1つは、
<em>http://localhost:7878/</em> 用、そしてもう1つは<em>http://localhost:7878/sleep</em> 用です。
以前のように <em>/</em> URIを数回入力したら、素早く応答するでしょう。しかし、<em>/sleep</em>を入力し、それから <em>/</em> をロードしたら、
<code>sleep</code>がロードする前にきっかり5秒スリープし終わるまで、<em>/</em> は待機するのを目撃するでしょう。</p>
<!-- There are multiple ways we could change how our web server works to avoid -->
<!-- having more requests back up behind a slow request; the one we’ll implement is -->
<!-- a thread pool. -->
<p>より多くのリクエストが遅いリクエストの背後に回ってしまうのを回避するようWebサーバが動く方法を変える方法は複数あります;
これから実装するのは、スレッドプールです。</p>
<!-- ### Improving Throughput with a Thread Pool -->
<a class="header" href="print.html#aスレッドプールでスループットを向上させる" id="aスレッドプールでスループットを向上させる"><h3>スレッドプールでスループットを向上させる</h3></a>
<!-- A *thread pool* is a group of spawned threads that are waiting and ready to -->
<!-- handle a task. When the program receives a new task, it assigns one of the -->
<!-- threads in the pool to the task, and that thread will process the task. The -->
<!-- remaining threads in the pool are available to handle any other tasks that come -->
<!-- in while the first thread is processing. When the first thread is done -->
<!-- processing its task, it’s returned to the pool of idle threads, ready to handle -->
<!-- a new task. A thread pool allows you to process connections concurrently, -->
<!-- increasing the throughput of your server. -->
<p><em>スレッドプール</em>は、待機し、タスクを処理する準備のできた一塊りの大量に生成されたスレッドです。
プログラムが新しいタスクを受け取ったら、プールのスレッドのどれかをタスクに<ruby>宛行<rp>(</rp><rt>あてが</rt><rp>)</rp></ruby>い、
そのスレッドがそのタスクを処理します。
プールの残りのスレッドは、最初のスレッドが処理中にやってくる他のあらゆるタスクを扱うために利用可能です。
最初のスレッドがタスクの処理を完了したら、新しいタスクを処理する準備のできたアイドル状態のスレッドプールに戻ります。
スレッドプールにより、並行で接続を処理でき、サーバのスループットを向上させます。</p>
<!-- We’ll limit the number of threads in the pool to a small number to protect us -->
<!-- from Denial of Service (DoS) attacks; if we had our program create a new thread -->
<!-- for each request as it came in, someone making 10 million requests to our -->
<!-- server could create havoc by using up all our server’s resources and grinding -->
<!-- the processing of requests to a halt. -->
<p>プール内のスレッド数は、小さい数字に制限し、DoS攻撃から保護します; リクエストが来た度に新しいスレッドをプログラムが生成したら、
1000万リクエストをサーバに行う誰かが、サーバのリソースを使い尽くし、リクエストの処理を停止に追い込むことで、
大混乱を招くことができてしまうでしょう。</p>
<!-- Rather than spawning unlimited threads, we’ll have a fixed number of threads -->
<!-- waiting in the pool. As requests come in, they’ll be sent to the pool for -->
<!-- processing. The pool will maintain a queue of incoming requests. Each of the -->
<!-- threads in the pool will pop off a request from this queue, handle the request, -->
<!-- and then ask the queue for another request. With this design, we can process -->
<!-- `N` requests concurrently, where `N` is the number of threads. If each thread -->
<!-- is responding to a long-running request, subsequent requests can still back up -->
<!-- in the queue, but we’ve increased the number of long-running requests we can -->
<!-- handle before reaching that point. -->
<p>無制限にスレッドを大量生産するのではなく、プールに固定された数のスレッドを待機させます。リクエストが来る度に、
処理するためにプールに送られます。プールは、やって来るリクエストのキューを管理します。
プールの各スレッドがこのキューからリクエストを取り出し、リクエストを処理し、そして、別のリクエストをキューに要求します。
この設計により、<code>N</code>リクエストを並行して処理でき、ここで<code>N</code>はスレッド数です。各スレッドが実行に時間のかかるリクエストに応答したら、
続くリクエストはそれでも、キュー内で待機させられてしまいますが、その地点に到達する前に扱える時間のかかるリクエスト数を増加させました。</p>
<!-- This technique is just one of many ways to improve the throughput of a web -->
<!-- server. Other options you might explore are the fork/join model and the -->
<!-- single-threaded async I/O model. If you’re interested in this topic, you can -->
<!-- read more about other solutions and try to implement them in Rust; with a -->
<!-- low-level language like Rust, all of these options are possible. -->
<p>このテクニックは、Webサーバのスループットを向上させる多くの方法の1つに過ぎません。探求する可能性のある他の選択肢は、
fork/joinモデルと、シングルスレッドの非同期I/Oモデルです。この話題にご興味があれば、他の解決策についてもっと読み、
Rustで実装を試みることができます; Rustのような低レベル言語であれば、これらの選択肢全部が可能なのです。</p>
<!-- Before we begin implementing a thread pool, let’s talk about what using the -->
<!-- pool should look like. When you’re trying to design code, writing the client -->
<!-- interface first can help guide your design. Write the API of the code so it’s -->
<!-- structured in the way you want to call it; then implement the functionality -->
<!-- within that structure rather than implementing the functionality and then -->
<!-- designing the public API. -->
<p>スレッドプールを実装し始める前に、プールを使うのはどんな感じになるはずなのかについて語りましょう。コードの設計を試みる際、
クライアントのインターフェイスをまず書くことは、設計を導く手助けになることがあります。呼び出したいように構成されるよう、
コードのAPIを記述してください; そして、機能を実装してから公開APIの設計をするのではなく、その構造内で機能を実装してください。</p>
<!-- Similar to how we used test-driven development in the project in Chapter 12, -->
<!-- we’ll use compiler-driven development here. We’ll write the code that calls the -->
<!-- functions we want, and then we’ll look at errors from the compiler to determine -->
<!-- what we should change next to get the code to work. -->
<p>第12章のプロジェクトでTDDを使用したように、ここではCompiler Driven Development(コンパイラ駆動開発)を使用します。
欲しい関数を呼び出すコードを書き、それからコンパイラの出すエラーを見てコードが動くように次に何を変更すべきかを決定します。</p>
<!-- #### Code Structure If We Could Spawn a Thread for Each Request -->
<a class="header" href="print.html#a各リクエストに対してスレッドを立ち上げられる場合のコードの構造" id="a各リクエストに対してスレッドを立ち上げられる場合のコードの構造"><h4>各リクエストに対してスレッドを立ち上げられる場合のコードの構造</h4></a>
<!-- First, let’s explore how our code might look if it did create a new thread for -->
<!-- every connection. As mentioned earlier, this isn’t our final plan due to the -->
<!-- problems with potentially spawning an unlimited number of threads, but it is a -->
<!-- starting point. Listing 20-11 shows the changes to make to `main` to spawn a -->
<!-- new thread to handle each stream within the `for` loop. -->
<p>まず、全接続に対して新しいスレッドを確かに生成した場合にコードがどんな見た目になるかを探求しましょう。
先ほど述べたように、無制限にスレッドを大量生産する可能性があるという問題のため、これは最終的な計画ではありませんが、
開始点です。リスト20-11は、新しいスレッドを立ち上げて<code>for</code>ループ内で各ストリームを扱うために<code>main</code>に行う変更を示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<!-- <span class="caption">Listing 20-11: Spawning a new thread for each -->
<!-- stream</span> -->
<p><span class="caption">リスト20-11: 各ストリームに対して新しいスレッドを立ち上げる</span></p>
<!-- As you learned in Chapter 16, `thread::spawn` will create a new thread and then -->
<!-- run the code in the closure in the new thread. If you run this code and load -->
<!-- */sleep* in your browser, then */* in two more browser tabs, you’ll indeed see -->
<!-- that the requests to */* don’t have to wait for */sleep* to finish. But as we -->
<!-- mentioned, this will eventually overwhelm the system because you'd making -->
<!-- new threads without any limit. -->
<p>第16章で学んだように、<code>thread::spawn</code>は新しいスレッドを生成し、それからクロージャ内のコードを新しいスレッドで実行します。
このコードを実行してブラウザで <em>/sleep</em>をロードし、それからもう2つのブラウザのタブで <em>/</em> をロードしたら、
確かに <em>/</em> へのリクエストは、<em>/sleep</em>が完了するのを待機しなくても済むことがわかるでしょう。
ですが、前述したように、無制限にスレッドを生成することになるので、これは最終的にシステムを参らせてしまうでしょう。</p>
<!-- #### Creating a Similar Interface for a Finite Number of Threads -->
<a class="header" href="print.html#a有限数のスレッド用に似たインターフェイスを作成する" id="a有限数のスレッド用に似たインターフェイスを作成する"><h4>有限数のスレッド用に似たインターフェイスを作成する</h4></a>
<!-- We want our thread pool to work in a similar, familiar way so switching from -->
<!-- threads to a thread pool doesn’t require large changes to the code that uses -->
<!-- our API. Listing 20-12 shows the hypothetical interface for a `ThreadPool` -->
<!-- struct we want to use instead of `thread::spawn`. -->
<p>スレッドからスレッドプールへの変更にAPIを使用するコードへの大きな変更が必要ないように、
スレッドプールには似た、馴染み深い方法で動作してほしいです。リスト20-12は、
<code>thread::spawn</code>の代わりに使用したい<code>ThreadPool</code>構造体の架空のインターフェイスを表示しています。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# struct ThreadPool;
# impl ThreadPool {
#    fn new(size: u32) -&gt; ThreadPool { ThreadPool }
#    fn execute&lt;F&gt;(&amp;self, f: F)
#        where F: FnOnce() + Send + 'static {}
# }
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<!-- <span class="caption">Listing 20-12: Our ideal `ThreadPool` interface</span> -->
<p><span class="caption">リスト20-12: <code>ThreadPool</code>の理想的なインターフェイス</span></p>
<!-- We use `ThreadPool::new` to create a new thread pool with a configurable number -->
<!-- of threads, in this case four. Then, in the `for` loop, `pool.execute` has a -->
<!-- similar interface as `thread::spawn` in that it takes a closure the pool should -->
<!-- run for each stream. We need to implement `pool.execute` so it takes the -->
<!-- closure and gives it to a thread in the pool to run. This code won’t yet -->
<!-- compile, but we’ll try so the compiler can guide us in how to fix it. -->
<p><code>ThreadPool::new</code>を使用して設定可能なスレッド数で新しいスレッドプールを作成し、今回の場合は4です。
それから<code>for</code>ループ内で、<code>pool.execute</code>は、プールが各ストリームに対して実行すべきクロージャを受け取るという点で、
<code>thread::spawn</code>と似たインターフェイスです。<code>pool.execute</code>を実装する必要があるので、
クロージャを取り、実行するためにプール内のスレッドに与えます。このコードはまだコンパイルできませんが、
コンパイラがどう修正したらいいかガイドできるように試してみます。</p>
<!-- #### Building the `ThreadPool` Struct Using Compiler Driven Development -->
<a class="header" href="print.html#aコンパイラ駆動開発でthreadpool構造体を構築する" id="aコンパイラ駆動開発でthreadpool構造体を構築する"><h4>コンパイラ駆動開発で<code>ThreadPool</code>構造体を構築する</h4></a>
<!-- Make the changes in Listing 20-12 to *src/main.rs*, and then let’s use the -->
<!-- compiler errors from `cargo check` to drive our development. Here is the first -->
<!-- error we get: -->
<p>リスト20-12の変更を<em>src/main.rs</em>に行い、それから開発を駆動するために<code>cargo check</code>からのコンパイラエラーを使用しましょう。
こちらが得られる最初のエラーです:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve. Use of undeclared type or module `ThreadPool`
(エラー: 解決に失敗しました。未定義の型またはモジュール`ThreadPool`を使用しています)
  --&gt; src\main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module
   `ThreadPool`

error: aborting due to previous error
</code></pre>
<!-- Great! This error tells us we need a `ThreadPool` type or module, so we’ll -->
<!-- build one now. Our `ThreadPool` implementation will be independent of the kind -->
<!-- of work our web server is doing. So, let’s switch the `hello` crate from a -->
<!-- binary crate to a library crate to hold our `ThreadPool` implementation. After -->
<!-- we change to a library crate, we could also use the separate thread pool -->
<!-- library for any work we want to do using a thread pool, not just for serving -->
<!-- web requests. -->
<p>よろしい!このエラーは<code>ThreadPool</code>型かモジュールが必要なことを教えてくれているので、今構築します。
<code>ThreadPool</code>の実装は、Webサーバが行う仕事の種類とは独立しています。従って、<code>hello</code>クレートをバイナリクレートからライブラリクレートに切り替え、
<code>ThreadPool</code>の実装を保持させましょう。ライブラリクレートに変更後、
個別のスレッドプールライブラリをWebリクエストを提供するためだけではなく、スレッドプールでしたいあらゆる作業にも使用できます。</p>
<!-- Create a *src/lib.rs* that contains the following, which is the simplest -->
<!-- definition of a `ThreadPool` struct that we can have for now: -->
<p>以下を含む<em>src/lib.rs</em>を生成してください。これは、現状存在できる最も単純な<code>ThreadPool</code>の定義です:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;
#}</code></pre></pre>
<!-- Then create a new directory, *src/bin*, and move the binary crate rooted in -->
<!-- *src/main.rs* into *src/bin/main.rs*. Doing so will make the library crate the -->
<!-- primary crate in the *hello* directory; we can still run the binary in -->
<!-- *src/bin/main.rs* using `cargo run`. After moving the *main.rs* file, edit it -->
<!-- to bring the library crate in and bring `ThreadPool` into scope by adding the -->
<!-- following code to the top of *src/bin/main.rs*: -->
<p>それから新しいディレクトリ、<em>src/bin</em>を作成し、<em>src/main.rs</em>に根付くバイナリクレートを<em>src/bin/main.rs</em>に移動してください。
そうすると、ライブラリクレートが<em>hello</em>ディレクトリ内でプライマリクレートになります; それでも、
<code>cargo run</code>で<em>src/bin/main.rs</em>のバイナリを実行することはできます。<em>main.rs</em>ファイルを移動後、
編集してライブラリクレートを持ち込み、以下のコードを<em>src/bin/main.rs</em>の先頭に追記して<code>ThreadPool</code>をスコープに導入してください:</p>
<!-- <span class="filename">Filename: src/bin/main.rs</span> -->
<p><span class="filename">ファイル名: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;
</code></pre>
<!-- This code still won’t work, but let’s check it again to get the next error that -->
<!-- we need to address: -->
<p>このコードはまだ動きませんが、再度それを確認して扱う必要のある次のエラーを手に入れましょう:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type
`hello::ThreadPool` in the current scope
(エラー: 現在のスコープで型`hello::ThreadPool`の関数または関連アイテムに`new`というものが見つかりません)
 --&gt; src/bin/main.rs:13:16
   |
13 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ function or associated item not found in
   `hello::ThreadPool`
</code></pre>
<!-- This error indicates that next we need to create an associated function named -->
<!-- `new` for `ThreadPool`. We also know that `new` needs to have one parameter -->
<!-- that can accept `4` as an argument and should return a `ThreadPool` instance. -->
<!-- Let’s implement the simplest `new` function that will have those -->
<!-- characteristics: -->
<p>このエラーは、次に、<code>ThreadPool</code>に対して<code>new</code>という関連関数を作成する必要があることを示唆しています。
また、<code>new</code>には<code>4</code>を引数として受け入れる引数1つがあり、<code>ThreadPool</code>インスタンスを返すべきということも知っています。
それらの特徴を持つ最も単純な<code>new</code>関数を実装しましょう:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
#}</code></pre></pre>
<!-- We chose `usize` as the type of the `size` parameter, because we know that a -->
<!-- negative number of threads doesn’t make any sense. We also know we’ll use this -->
<!-- 4 as the number of elements in a collection of threads, which is what the -->
<!-- `usize` type is for, as discussed in the “Integer Types” section of Chapter 3. -->
<p><code>size</code>引数の型として、<code>usize</code>を選択しました。何故なら、マイナスのスレッド数は、何も筋が通らないことを知っているからです。
また、この4をスレッドのコレクションの要素数として使用し、第3章の「整数型」節で議論したように、これは<code>usize</code>のあるべき姿であることも知っています。</p>
<!-- Let’s check the code again: -->
<p>コードを再度確認しましょう:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
(警告: 未使用の変数: `size`)
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:18:14
   |
18 |         pool.execute(|| {
   |              ^^^^^^^
</code></pre>
<!-- Now we get a warning and an error. Ignoring the warning for a moment, the error -->
<!-- occurs because we don’t have an `execute` method on `ThreadPool`. Recall from -->
<!-- the “Creating a Similar Interface for a Finite Number of Threads” section that -->
<!-- we decided our thread pool should have an interface similar to `thread::spawn`. -->
<!-- In addition, we’ll implement the `execute` function so it takes the closure -->
<!-- it’s given and gives it to an idle thread in the pool to run. -->
<p>今度は、警告とエラーが出ました。一時的に警告は無視して、<code>ThreadPool</code>に<code>execute</code>メソッドがないためにエラーが発生しました。
「有限数のスレッド用に似たインターフェイスを作成する」節で我々のスレッドプールは、
<code>thread::spawn</code>と似たインターフェイスにするべきと決定したことを思い出してください。
さらに、<code>execute</code>関数を実装するので、与えられたクロージャを取り、実行するようにプールの待機中のスレッドに渡します。</p>
<!-- We’ll define the `execute` method on `ThreadPool` to take a closure as a -->
<!-- parameter. Recall from the “Storing Closures Using Generic Parameters and the -->
<!-- `Fn` Traits” section in Chapter 13 that we can take closures as parameters with -->
<!-- three different traits: `Fn`, `FnMut`, and `FnOnce`. We need to decide which -->
<!-- kind of closure to use here. We know we’ll end up doing something similar to -->
<!-- the standard library `thread::spawn` implementation, so we can look at what -->
<!-- bounds the signature of `thread::spawn` has on its parameter. The documentation -->
<!-- shows us the following: -->
<p><code>ThreadPool</code>に<code>execute</code>メソッドをクロージャを引数として受け取るように定義します。
第13章の「ジェネリック引数と<code>Fn</code>トレイトを使用してクロージャを保存する」節から、
3つの異なるトレイトでクロージャを引数として取ることができることを思い出してください: <code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>です。
ここでは、どの種類のクロージャを使用するか決定する必要があります。最終的には、
標準ライブラリの<code>thread::spawn</code>実装に似たことをすることがわかっているので、
<code>thread::spawn</code>のシグニチャで引数にどんな境界があるか見ることができます。ドキュメンテーションは、以下のものを示しています:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<!-- The `F` type parameter is the one we’re concerned with here; the `T` type -->
<!-- parameter is related to the return value, and we’re not concerned with that. We -->
<!-- can see that `spawn` uses `FnOnce` as the trait bound on `F`. This is probably -->
<!-- what we want as well, because we’ll eventually pass the argument we get in -->
<!-- `execute` to `spawn`. We can be further confident that `FnOnce` is the trait we -->
<!-- want to use because the thread for running a request will only execute that -->
<!-- request’s closure one time, which matches the `Once` in `FnOnce`. -->
<p><code>F</code>型引数がここで関心のあるものです; <code>T</code>型引数は戻り値と関係があり、関心はありません。<code>spawn</code>は、
<code>F</code>のトレイト境界として<code>FnOnce</code>を使用していることが確認できます。これはおそらく、我々が欲しているものでもあるでしょう。
というのも、最終的には<code>execute</code>で得た引数を<code>spawn</code>に渡すからです。さらに<code>FnOnce</code>は使用したいトレイトであると自信を持つことができます。
リクエストを実行するスレッドは、そのリクエストのクロージャを1回だけ実行し、これは<code>FnOnce</code>の<code>Once</code>に合致するからです。</p>
<!-- The `F` type parameter also has the trait bound `Send` and the lifetime bound -->
<!-- `'static`, which are useful in our situation: we need `Send` to transfer the -->
<!-- closure from one thread to another and `'static` because we don’t know how long -->
<!-- the thread will take to execute. Let’s create an `execute` method on -->
<!-- `ThreadPool` that will take a generic parameter of type `F` with these bounds: -->
<p><code>F</code>型引数にはまた、トレイト境界の<code>Send</code>とライフタイム境界の<code>'static</code>もあり、この状況では有用です:
あるスレッドから別のスレッドにクロージャを移動するのに<code>Send</code>が必要で、スレッドの実行にどれくらいかかるかわからないので、
<code>'static</code>も必要です。<code>ThreadPool</code>にこれらの境界のジェネリックな型<code>F</code>の引数を取る<code>execute</code>メソッドを生成しましょう:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
#}</code></pre></pre>
<!-- We still use the `()` after `FnOnce` because this `FnOnce` represents a closure -->
<!-- that takes no parameters and doesn’t return a value. Just like function -->
<!-- definitions, the return type can be omitted from the signature, but even if we -->
<!-- have no parameters, we still need the parentheses. -->
<p>それでも、<code>FnOnce</code>の後に<code>()</code>を使用しています。この<code>FnOnce</code>は引数を取らず、値も返さないクロージャを表すからです。
関数定義同様に、戻り値の型はシグニチャから省略できますが、引数がなくても、カッコは必要です。</p>
<!-- Again, this is the simplest implementation of the `execute` method: it does -->
<!-- nothing, but we’re trying only to make our code compile. Let’s check it again: -->
<p>またもや、これが<code>execute</code>メソッドの最も単純な実装です: 何もしませんが、
コードがコンパイルできるようにしているだけです。再確認しましょう:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

warning: unused variable: `f`
 --&gt; src/lib.rs:8:30
  |
8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)
  |                              ^
  |
  = note: to avoid this warning, consider using `_f` instead
</code></pre>
<!-- We’re receiving only warnings now, which means it compiles! But note that if -->
<!-- you try `cargo run` and make a request in the browser, you’ll see the errors in -->
<!-- the browser that we saw at the beginning of the chapter. Our library isn’t -->
<!-- actually calling the closure passed to `execute` yet! -->
<p>これで警告を受け取るだけになり、コンパイルできるようになりました！しかし、<code>cargo run</code>を試して、
ブラウザでリクエストを行うと、章の冒頭で見かけたエラーがブラウザに現れることに注意してください。
ライブラリは、まだ実際に<code>execute</code>に渡されたクロージャを呼び出していないのです！</p>
<!-- > Note: A saying you might hear about languages with strict compilers, such as -->
<!-- > Haskell and Rust, is “if the code compiles, it works.” But this saying is not -->
<!-- > universally true. Our project compiles, but it does absolutely nothing! If we -->
<!-- > were building a real, complete project, this would be a good time to start -->
<!-- > writing unit tests to check that the code compiles *and* has the behavior we -->
<!-- > want. -->
<blockquote>
<p>注釈: HaskellやRustなどの厳密なコンパイラがある言語についての格言として「コードがコンパイルできたら、
動作する」というものを聞いたことがあるかもしれません。ですが、この格言は普遍的に当てはまるものではありません。
このプロジェクトはコンパイルできますが、全く何もしません！本物の完璧なプロジェクトを構築しようとしているのなら、
これがユニットテストを書き始めて、コードがコンパイルでき、<em>かつ</em>欲しい振る舞いを保持していることを確認するのに良い機会でしょう。</p>
</blockquote>
<!-- #### Validating the Number of Threads in `new` -->
<a class="header" href="print.html#newでスレッド数を検査する" id="newでスレッド数を検査する"><h4><code>new</code>でスレッド数を検査する</h4></a>
<!-- We’ll continue to get warnings because we aren’t doing anything with the -->
<!-- parameters to `new` and `execute`. Let’s implement the bodies of these -->
<!-- functions with the behavior we want. To start, let’s think about `new`. Earlier -->
<!-- we chose an unsigned type for the `size` parameter, because a pool with a -->
<!-- negative number of threads makes no sense. However, a pool with zero threads -->
<!-- also makes no sense, yet zero is a perfectly valid `usize`. We’ll add code to -->
<!-- check that `size` is greater than zero before we return a `ThreadPool` instance -->
<!-- and have the program panic if it receives a zero by using the `assert!` macro, -->
<!-- as shown in Listing 20-13. -->
<p><code>new</code>と<code>execute</code>の引数で何もしていないので、警告が出続けます。欲しい振る舞いでこれらの関数の本体を実装しましょう。
まずはじめに、<code>new</code>を考えましょう。先刻、<code>size</code>引数に非負整数型を選択しました。負のスレッド数のプールは、
全く道理が通らないからです。しかしながら、0スレッドのプールも全く意味がわかりませんが、0も完全に合法な<code>usize</code>です。
<code>ThreadPool</code>インスタンスを返す前に<code>size</code>が0よりも大きいことを確認するコードを追加し、リスト20-13に示したように、
<code>assert!</code>マクロを使用することで0を受け取った時にプログラムをパニックさせます。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    /// 新しいThreadPoolを生成する。
    ///
    /// sizeがプールのスレッド数です。
    ///
    /// # パニック
    ///
    /// sizeが0なら、`new`関数はパニックします。
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-13: Implementing `ThreadPool::new` to panic if -->
<!-- `size` is zero</span> -->
<p><span class="caption">リスト20-13: <code>ThreadPool::new</code>を実装して<code>size</code>が0ならパニックする</span></p>
<!-- 2行目後半、calls outを声高に叫ぶとした。叫ぶだけでは何か物足りない気がするので -->
<!-- We’ve added some documentation for our `ThreadPool` with doc comments. Note -->
<!-- that we followed good documentation practices by adding a section that calls -->
<!-- out the situations in which our function can panic, as discussed in Chapter 14. -->
<!-- Try running `cargo doc --open` and clicking the `ThreadPool` struct to see what -->
<!-- the generated docs for `new` look like! -->
<p>doc commentで<code>ThreadPool</code>にドキュメンテーションを追加しました。第14章で議論したように、
関数がパニックする場面を声高に叫ぶセクションを追加することで、いいドキュメンテーションの実践に倣っていることに注意してください。
試しに<code>cargo doc --open</code>を実行し、<code>ThreadPool</code>構造体をクリックして、<code>new</code>の生成されるドキュメンテーションがどんな感じが確かめてください！</p>
<!-- Instead of adding the `assert!` macro as we’ve done here, we could make `new` -->
<!-- return a `Result` like we did with `Config::new` in the I/O project in Listing -->
<!-- 12-9. But we’ve decided in this case that trying to create a thread pool -->
<!-- without any threads should be an unrecoverable error. If you’re feeling -->
<!-- ambitious, try to write a version of `new` with the following signature to -->
<!-- compare both versions: -->
<p>ここでしたように<code>assert!</code>マクロを追加する代わりに、リスト12-9のI/Oプロジェクトの<code>Config::new</code>でしたように、
<code>new</code>に<code>Result</code>を返させることもできるでしょう。しかし、今回の場合、スレッドなしでスレッドプールを作成しようとするのは、
回復不能なエラーであるべきと決定しました。野心を感じるのなら、以下のシグニチャの<code>new</code>も書いてみて、両者を比較してみてください:</p>
<pre><code class="language-rust ignore">pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<!-- #### Creating Space to Store the Threads -->
<a class="header" href="print.html#aスレッドを格納するスペースを生成する" id="aスレッドを格納するスペースを生成する"><h4>スレッドを格納するスペースを生成する</h4></a>
<!-- Now that we have a way to know we have a valid number of threads to store in -->
<!-- the pool, we can create those threads and store them in the `ThreadPool` struct -->
<!-- before returning it. But how do we “store” a thread? Let’s take another look at -->
<!-- the `thread::spawn` signature: -->
<p>今や、プールに格納する合法なスレッド数を知る方法ができたので、<code>ThreadPool</code>構造体を返す前にスレッドを作成して格納できます。
ですが、どのようにスレッドを「格納」するのでしょうか？もう一度、<code>thread::spawn</code>シグニチャを眺めてみましょう:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<!-- The `spawn` function returns a `JoinHandle<T>`, where `T` is the type that the -->
<!-- closure returns. Let’s try using `JoinHandle` too and see what happens. In our -->
<!-- case, the closures we’re passing to the thread pool will handle the connection -->
<!-- and not return anything, so `T` will be the unit type `()`. -->
<p><code>spawn</code>関数は、<code>JoinHandle&lt;T&gt;</code>を返し、ここで<code>T</code>は、クロージャが返す型です。試しに同じように<code>JoinHandle</code>を使ってみて、
どうなるか見てみましょう。我々の場合、スレッドプールに渡すクロージャは接続を扱い、何も返さないので、
<code>T</code>はユニット型<code>()</code>になるでしょう。</p>
<!-- The code in Listing 20-14 will compile but doesn’t create any threads yet. -->
<!-- We’ve changed the definition of `ThreadPool` to hold a vector of -->
<!-- `thread::JoinHandle<()>` instances, initialized the vector with a capacity of -->
<!-- `size`, set up a `for` loop that will run some code to create the threads, and -->
<!-- returned a `ThreadPool` instance containing them. -->
<p>リスト20-14のコードはコンパイルできますが、まだスレッドは何も生成しません。<code>ThreadPool</code>の定義を変更して、
<code>thread::JoinHandle&lt;()&gt;</code>インスタンスのベクタを保持し、<code>size</code>キャパシティのベクタを初期化し、
スレッドを生成する何らかのコードを実行する<code>for</code>ループを設定し、それらを含む<code>ThreadPool</code>インスタンスを返します。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // 実際にスレッドを生成してベクタに格納する
            // create some threads and store them in the vector
        }

        ThreadPool {
            threads
        }
    }

    // --snip--
}
</code></pre>
<!-- <span class="caption">Listing 20-14: Creating a vector for `ThreadPool` to hold -->
<!-- the threads</span> -->
<p><span class="caption">リスト20-14: <code>ThreadPool</code>にスレッドを保持するベクタを生成する</span></p>
<!-- We’ve brought `std::thread` into scope in the library crate, because we’re -->
<!-- using `thread::JoinHandle` as the type of the items in the vector in -->
<!-- `ThreadPool`. -->
<p>ライブラリクレート内で<code>std::thread</code>をスコープに導入しました。<code>ThreadPool</code>のベクタの要素の型として、
<code>thread::JoinHandle</code>を使用しているからです。</p>
<!-- Once a valid size is received, our `ThreadPool` creates a new vector that can -->
<!-- hold `size` items. We haven’t used the `with_capacity` function in this book -->
<!-- yet, which performs the same task as `Vec::new` but with an important -->
<!-- difference: it preallocates space in the vector. Because we know we need to -->
<!-- store `size` elements in the vector, doing this allocation up front is slightly -->
<!-- more efficient than using `Vec::new`, which resizes itself as elements are -->
<!-- inserted. -->
<p>一旦、合法なサイズを受け取ったら、<code>ThreadPool</code>は<code>size</code>個の要素を保持できる新しいベクタを生成します。
この本ではまだ、<code>with_capacity</code>関数を使用したことがありませんが、これは<code>Vec::new</code>と同じ作業をしつつ、
重要な違いがあります: ベクタに予めスペースを確保しておくのです。ベクタに<code>size</code>個の要素を格納する必要があることはわかっているので、
このメモリ確保を前もってしておくと、<code>Vec::new</code>よりも少しだけ効率的になります。<code>Vec::new</code>は、
要素が挿入されるにつれて、自身のサイズを変更します。</p>
<!-- When you run `cargo check` again, you’ll get a few more warnings, but it should -->
<!-- succeed. -->
<p>再び<code>cargo check</code>を実行すると、もういくつか警告が出るものの、成功するはずです。</p>
<!-- #### A `Worker` Struct Responsible for Sending Code from the `ThreadPool` to a Thread -->
<a class="header" href="print.html#threadpoolからスレッドにコードを送信する責任を負うworker構造体" id="threadpoolからスレッドにコードを送信する責任を負うworker構造体"><h4><code>ThreadPool</code>からスレッドにコードを送信する責任を負う<code>Worker</code>構造体</h4></a>
<!-- We left a comment in the `for` loop in Listing 20-14 regarding the creation of -->
<!-- threads. Here, we’ll look at how we actually create threads. The standard -->
<!-- library provides `thread::spawn` as a way to create threads, and -->
<!-- `thread::spawn` expects to get some code the thread should run as soon as the -->
<!-- thread is created. However, in our case, we want to create the threads and have -->
<!-- them *wait* for code that we’ll send later. The standard library’s -->
<!-- implementation of threads doesn’t include any way to do that; we have to -->
<!-- implement it manually. -->
<p>リスト20-14の<code>for</code>ループにスレッドの生成に関するコメントを残しました。ここでは、実際にスレッドを生成する方法に目を向けます。
標準ライブラリはスレッドを生成する手段として<code>thread::spawn</code>を提供し、<code>thread::spawn</code>は、
生成されるとすぐにスレッドが実行すべき何らかのコードを得ることを予期します。ところが、我々の場合、
スレッドを生成して、後ほど送信するコードを<em>待機</em>してほしいです。標準ライブラリのスレッドの実装は、
それをするいかなる方法も含んでいません; それを手動で実装しなければなりません。</p>
<!-- We’ll implement this behavior by introducing a new data structure between the -->
<!-- `ThreadPool` and the threads that will manage this new behavior. We’ll call -->
<!-- this data structure `Worker`, which is a common term in pooling -->
<!-- implementations. Think of people working in the kitchen at a restaurant: the -->
<!-- workers wait until orders come in from customers, and then they’re responsible -->
<!-- for taking those orders and filling them. -->
<p>この新しい振る舞いを管理するスレッドと<code>ThreadPool</code>間に新しいデータ構造を導入することでこの振る舞いを実装します。
このデータ構造を<code>Worker</code>と呼び、プール実装では一般的な用語です。レストランのキッチンで働く人々を思い浮かべてください:
労働者は、お客さんからオーダーが来るまで待機し、それからそれらのオーダーを取り、満たすことに責任を負います。</p>
<!-- Instead of storing a vector of `JoinHandle<()>` instances in the thread pool, -->
<!-- we’ll store instances of the `Worker` struct. Each `Worker` will store a single -->
<!-- `JoinHandle<()>` instance. Then we’ll implement a method on `Worker` that will -->
<!-- take a closure of code to run and send it to the already running thread for -->
<!-- execution. We’ll also give each worker an `id` so we can distinguish between -->
<!-- the different workers in the pool when logging or debugging. -->
<p>スレッドプールに<code>JoinHanlde&lt;()&gt;</code>インスタンスのベクタを格納する代わりに、<code>Worker</code>構造体のインスタンスを格納します。
各<code>Worker</code>が単独の<code>JoinHandle&lt;()&gt;</code>インスタンスを格納します。そして、<code>Worker</code>に実行するコードのクロージャを取り、
既に走っているスレッドに実行してもらうために送信します。ログを取ったり、デバッグする際にプールの異なるワーカーを区別できるように、
各ワーカに<code>id</code>も付与します。</p>
<!-- Let’s make the following changes to what happens when we create a `ThreadPool`. -->
<!-- We’ll implement the code that sends the closure to the thread after we have -->
<!-- `Worker` set up in this way: -->
<p><code>ThreadPool</code>を生成する際に発生することに以下の変更を加えましょう。このように<code>Worker</code>をセットアップした後に、
スレッドにクロージャを送信するコードを実装します:</p>
<!-- 1. Define a `Worker` struct that holds an `id` and a `JoinHandle<()>`. -->
<!-- 2. Change `ThreadPool` to hold a vector of `Worker` instances. -->
<!-- 3. Define a `Worker::new` function that takes an `id` number and returns a -->
<!--    `Worker` instance that holds the `id` and a thread spawned with an empty -->
<!--    closure. -->
<!-- 4. In `ThreadPool::new`, use the `for` loop counter to generate an `id`, create -->
<!--    a new `Worker` with that `id`, and store the worker in the vector. -->
<ol>
<li><code>id</code>と<code>JoinHandle&lt;()&gt;</code>を保持する<code>Worker</code>構造体を定義する。</li>
<li><code>ThreadPool</code>を変更し、<code>Worker</code>インスタンスのベクタを保持する。</li>
<li><code>id</code>番号を取り、<code>id</code>と空のクロージャで立ち上げられたスレッドを保持する<code>Worker</code>インスタンスを返す<code>Worker::new</code>関数を定義する。</li>
<li><code>ThreadPool::new</code>で<code>for</code>ループカウンタを使用して<code>id</code>を生成し、その<code>id</code>で新しい<code>Worker</code>を生成し、ベクタにワーカーを格納する。</li>
</ol>
<!-- If you’re up for a challenge, try implementing these changes on your own before -->
<!-- looking at the code in Listing 20-15. -->
<p>挑戦に積極的ならば、リスト20-15のコードを見る前にご自身でこれらの変更を実装してみてください。</p>
<!-- Ready? Here is Listing 20-15 with one way to make the preceding modifications. -->
<p>いいですか？こちらが先ほどの変更を行う1つの方法を行ったリスト20-15です。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers
        }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker {
            id,
            thread,
        }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-15: Modifying `ThreadPool` to hold `Worker` -->
<!-- instances instead of holding threads directly</span> -->
<p><span class="caption">リスト20-15: <code>ThreadPool</code>を変更してスレッドを直接保持するのではなく、<code>Worker</code>インスタンスを保持する</span></p>
<!-- We’ve changed the name of the field on `ThreadPool` from `threads` to `workers` -->
<!-- because it’s now holding `Worker` instances instead of `JoinHandle<()>` -->
<!-- instances. We use the counter in the `for` loop as an argument to -->
<!-- `Worker::new`, and we store each new `Worker` in the vector named `workers`. -->
<p><code>ThreadPool</code>のフィールド名を<code>threads</code>から<code>workers</code>に変更しました。<code>JoinHandle&lt;()&gt;</code>インスタンスではなく、
<code>Worker</code>インスタンスを保持するようになったからです。<code>for</code>ループのカウンタを<code>Worker::new</code>への引数として使用し、
それぞれの新しい<code>Worker</code>を<code>workers</code>というベクタに格納します。</p>
<!-- External code (like our server in *src/bin/main.rs*) doesn’t need to know the -->
<!-- implementation details regarding using a `Worker` struct within `ThreadPool`, -->
<!-- so we make the `Worker` struct and its `new` function private. The -->
<!-- `Worker::new` function uses the `id` we give it and stores a `JoinHandle<()>` -->
<!-- instance that is created by spawning a new thread using an empty closure. -->
<p>外部のコード(<em>src/bin/main.rs</em>のサーバなど)は<code>ThreadPool</code>内で<code>Worker</code>構造体を使用していることに関する実装の詳細を知る必要はないので、
<code>Worker</code>構造体とその<code>new</code>関数は非公開にしています。<code>Worker::new</code>関数は与えた<code>id</code>を使用し、
空のクロージャを使って新しいスレッドを立ち上げることで生成される<code>JoinHandle&lt;()&gt;</code>インスタンスを格納します。</p>
<!-- This code will compile and will store the number of `Worker` instances we -->
<!-- specified as an argument to `ThreadPool::new`. But we’re *still* not processing -->
<!-- the closure that we get in `execute`. Let’s look at how to do that next. -->
<p>このコードはコンパイルでき、<code>ThreadPool::new</code>への引数として指定した数の<code>Worker</code>インスタンスを格納します。
ですが<em>それでも</em>、<code>execute</code>で得るクロージャを処理してはいません。次は、それをする方法に目を向けましょう。</p>
<!-- #### Sending Requests to Threads via Channels -->
<a class="header" href="print.html#aチャンネル経由でスレッドにリクエストを送信する" id="aチャンネル経由でスレッドにリクエストを送信する"><h4>チャンネル経由でスレッドにリクエストを送信する</h4></a>
<!-- Now we’ll tackle the problem that the closures given to `thread::spawn` do -->
<!-- absolutely nothing. Currently, we get the closure we want to execute in the -->
<!-- `execute` method. But we need to give `thread::spawn` a closure to run when we -->
<!-- create each `Worker` during the creation of the `ThreadPool`. -->
<p>さて、<code>thread::spawn</code>に与えられたクロージャが確かに何もしない問題に取り組みましょう。現在、
<code>execute</code>メソッドで実行したいクロージャを得ています。ですが、<code>ThreadPool</code>の生成中、<code>Worker</code>それぞれを生成する際に、
実行するクロージャを<code>thread::spawn</code>に与える必要があります。</p>
<!-- We want the `Worker` structs that we just created to fetch code to run from a -->
<!-- queue held in the `ThreadPool` and send that code to its thread to run. -->
<p>作ったばかりの<code>Worker</code>構造体に<code>ThreadPool</code>が保持するキューから実行するコードをフェッチして、
そのコードをスレッドが実行できるように送信してほしいです。</p>
<!-- In Chapter 16, you learned about *channels*—a simple way to communicate between -->
<!-- two threads—that would be perfect for this use case. We’ll use a channel to -->
<!-- function as the queue of jobs, and `execute` will send a job from the -->
<!-- `ThreadPool` to the `Worker` instances, which will send the job to its thread. -->
<!-- Here is the plan: -->
<p>第16章でこのユースケースにぴったりであろう<em>チャンネル</em>(2スレッド間コミュニケーションをとる単純な方法)について学びました。
チャンネルをキューの仕事として機能させ、<code>execute</code>は<code>ThreadPool</code>から<code>Worker</code>インスタンスに仕事を送り、
これが仕事をスレッドに送信します。こちらが計画です:</p>
<!-- 1. The `ThreadPool` will create a channel and hold on to the sending side of -->
<!--    the channel. -->
<!-- 2. Each `Worker` will hold on to the receiving side of the channel. -->
<!-- 3. We’ll create a new `Job` struct that will hold the closures we want to send -->
<!--    down the channel. -->
<!-- 4. The `execute` method will send the job it wants to execute down the sending -->
<!--    side of the channel. -->
<!-- 5. In its thread, the `Worker` will loop over its receiving side of the channel -->
<!--    and execute the closures of any jobs it receives. -->
<ol>
<li><code>ThreadPool</code>はチャンネルを生成し、チャンネルの送信側に就く。</li>
<li><code>Worker</code>それぞれは、チャンネルの受信側に就く。</li>
<li>チャンネルに送信したいクロージャを保持する新しい<code>Job</code>構造体を生成する。</li>
<li><code>execute</code>メソッドは、実行したい仕事をチャンネルの送信側に送信する。</li>
<li>スレッド内で、<code>Worker</code>はチャンネルの受信側をループし、受け取ったあらゆる仕事のクロージャを実行する。</li>
</ol>
<!-- Let’s start by creating a channel in `ThreadPool::new` and holding the sending -->
<!-- side in the `ThreadPool` instance, as shown in Listing 20-16. The `Job` struct -->
<!-- doesn’t hold anything for now but will be the type of item we’re sending down -->
<!-- the channel. -->
<p><code>ThreadPool::new</code>内でチャンネルを生成し、<code>ThreadPool</code>インスタンスに送信側を保持することから始めましょう。リスト20-16のようにですね。
今の所、<code>Job</code>構造体は何も保持しませんが、チャンネルに送信する種類の要素になります。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}
#
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
# impl Worker {
#     fn new(id: usize) -&gt; Worker {
#         let thread = thread::spawn(|| {});
#
#         Worker {
#             id,
#             thread,
#         }
#     }
# }
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-16: Modifying `ThreadPool` to store the -->
<!-- sending end of a channel that sends `Job` instances</span> -->
<p><span class="caption">リスト20-18: <code>ThreadPool</code>を変更して<code>Job</code>インスタンスを送信するチャンネルの送信側を格納する</span></p>
<!-- In `ThreadPool::new`, we create our new channel and have the pool hold the -->
<!-- sending end. This will successfully compile, still with warnings. -->
<p><code>ThreadPool::new</code>内で新しいチャンネルを生成し、プールに送信側を保持させています。これはコンパイルに成功しますが、
まだ警告があります。</p>
<!-- Let’s try passing a receiving end of the channel into each worker as the thread -->
<!-- pool creates them. We know we want to use the receiving end in the -->
<!-- thread that the workers spawn, so we’ll reference the `receiver` parameter in -->
<!-- the closure. The code in Listing 20-17 won’t quite compile yet. -->
<p>スレッドプールがワーカーを生成する際に各ワーカーにチャンネルの受信側を試しに渡してみましょう。
受信側はワーカーが立ち上げるスレッド内で使用したいことがわかっているので、クロージャ内で<code>receiver</code>引数を参照します。
リスト20-17のコードはまだ全くコンパイルできません。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<!-- <span class="caption">Listing 20-17: Passing the receiving end of the channel -->
<!-- to the workers</span> -->
<p><span class="caption">リスト20-17: チャンネルの受信側をワーカーに渡す</span></p>
<!-- We’ve made some small and straightforward changes: we pass the receiving end of -->
<!-- the channel into `Worker::new`, and then we use it inside the closure. -->
<p>多少些細で率直な変更を行いました: チャンネルの受信側を<code>Worker::new</code>に渡し、それからクロージャの内側で使用しています。</p>
<!-- When we try to check this code, we get this error: -->
<p>このコードのチェックを試みると、このようなエラーが出ます:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here in
   previous iteration of loop
   |
   = note: move occurs because `receiver` has type
   `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
</code></pre>
<!-- The code is trying to pass `receiver` to multiple `Worker` instances. This -->
<!-- won’t work, as you’ll recall from Chapter 16: the channel implementation that -->
<!-- Rust provides is multiple *producer*, single *consumer*. This means we can’t -->
<!-- just clone the consuming end of the channel to fix this code. Even if we could, -->
<!-- that is not the technique we would want to use; instead, we want to distribute -->
<!-- the jobs across threads by sharing the single `receiver` among all the workers. -->
<p>このコードは、<code>receiver</code>を複数の<code>Worker</code>インスタンスに渡そうとしています。第16章を思い出すように、これは動作しません:
Rustが提供するチャンネル実装は、複数の<em>生成者</em>、単独の<em>消費者</em>です。要するに、
チャンネルの消費側をクローンするだけでこのコードを修正することはできません。たとえできたとしても、
使用したいテクニックではありません; 代わりに、全ワーカー間で単独の<code>receiver</code>を共有することで、
スレッド間に仕事を分配したいです。</p>
<!-- Additionally, taking a job off the channel queue involves mutating the -->
<!-- `receiver`, so the threads need a safe way to share and modify `receiver`; -->
<!-- otherwise, we might get race conditions (as covered in Chapter 16). -->
<p>さらに、チャンネルキューから仕事を取り出すことは、<code>receiver</code>を可変化することに関連するので、
スレッドには、<code>receiver</code>を共有して変更する安全な方法が必要です; さもなくば、
競合状態に陥る可能性があります(第16章で講義しました)。</p>
<!-- Recall the thread-safe smart pointers discussed in Chapter 16: to share -->
<!-- ownership across multiple threads and allow the threads to mutate the value, we -->
<!-- need to use `Arc<Mutex<T>>`. The `Arc` type will let multiple workers own the -->
<!-- receiver, and `Mutex` will ensure that only one worker gets a job from the -->
<!-- receiver at a time. Listing 20-18 shows the changes we need to make. -->
<p>第16章で議論したスレッド安全なスマートポインタを思い出してください: 複数のスレッドで所有権を共有しつつ、
スレッドに値を可変化させるためには、<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>を使用する必要があります。<code>Arc</code>型は、
複数のワーカーに受信者を所有させ、<code>Mutex</code>により、1度に受信者から1つの仕事をたった1つのワーカーが受け取ることを保証します。
リスト20-18は、行う必要のある変更を示しています。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;
// --snip--

# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# struct Job;
#
impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    // --snip--
}

# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
#         let thread = thread::spawn(|| {
#            receiver;
#         });
#
#         Worker {
#             id,
#             thread,
#         }
    }
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-18: Sharing the receiving end of the channel -->
<!-- among the workers using `Arc` and `Mutex`</span> -->
<p><span class="caption">リスト20-18: <code>Arc</code>と<code>Mutex</code>を使用してワーカー間でチャンネルの受信側を共有する</span></p>
<!-- In `ThreadPool::new`, we put the receiving end of the channel in an `Arc` and a -->
<!-- `Mutex`. For each new worker, we clone the `Arc` to bump the reference count so -->
<!-- the workers can share ownership of the receiving end. -->
<p><code>ThreadPool::new</code>で、チャンネルの受信側を<code>Arc</code>と<code>Mutex</code>に置いています。新しいワーカーそれぞれに対して、
<code>Arc</code>をクローンして参照カウントを跳ね上げているので、ワーカーは受信側の所有権を共有することができます。</p>
<!-- With these changes, the code compiles! We’re getting there! -->
<p>これらの変更でコードはコンパイルできます！もうすぐそこです！</p>
<!-- #### Implementing the `execute` Method -->
<a class="header" href="print.html#executeメソッドを実装する" id="executeメソッドを実装する"><h4><code>execute</code>メソッドを実装する</h4></a>
<!-- Let’s finally implement the `execute` method on `ThreadPool`. We’ll also change -->
<!-- `Job` from a struct to a type alias for a trait object that holds the type of -->
<!-- closure that `execute` receives. As discussed in the “Creating Type Synonyms -->
<!-- with Type Aliases” section of Chapter 19, type aliases allow us to make long -->
<!-- types shorter. Look at Listing 20-19. -->
<p>最後に<code>ThreadPool</code>に<code>execute</code>メソッドを実装しましょう。
<code>Job</code>も構造体から<code>execute</code>が受け取るクロージャの型を保持するトレイトオブジェクトの型エイリアスに変更します。
第19章の「型エイリアスで型同義語を生成する」節で議論したように、型エイリアスにより長い型を短くできます。
リスト20-19をご覧ください。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// --snip--
# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# use std::sync::mpsc;
# struct Worker {}

type Job = Box&lt;FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
#}</code></pre></pre>
<!-- <span class="caption">Listing 20-19: Creating a `Job` type alias for a `Box` -->
<!-- that holds each closure and then sending the job down the channel</span> -->
<p><span class="caption">リスト20-19: 各クロージャを保持する<code>Box</code>に対して<code>Job</code>型エイリアスを生成し、それからチャンネルに仕事を送信する</span></p>
<!-- After creating a new `Job` instance using the closure we get in `execute`, we -->
<!-- send that job down the sending end of the channel. We’re calling `unwrap` on -->
<!-- `send` for the case that sending fails. This might happen if, for example, we -->
<!-- stop all our threads from executing, meaning the receiving end has stopped -->
<!-- receiving new messages. At the moment, we can’t stop our threads from -->
<!-- executing: our threads continue executing as long as the pool exists. The -->
<!-- reason we use `unwrap` is that we know the failure case won’t happen, but the -->
<!-- compiler doesn’t know that. -->
<p><code>execute</code>で得たクロージャを使用して新しい<code>Job</code>インスタンスを生成した後、その仕事をチャンネルの送信側に送信しています。
送信が失敗した時のために<code>send</code>に対して<code>unwrap</code>を呼び出しています。これは例えば、全スレッドの実行を停止させるなど、
受信側が新しいメッセージを受け取るのをやめてしまったときなどに起こる可能性があります。現時点では、
スレッドの実行を止めることはできません: スレッドは、プールが存在する限り実行し続けます。
<code>unwrap</code>を使用している理由は、失敗する場合が起こらないとわかっているからですが、コンパイラにはわかりません。</p>
<!-- But we’re not quite done yet! In the worker, our closure being passed to -->
<!-- `thread::spawn` still only *references* the receiving end of the channel. -->
<!-- Instead, we need the closure to loop forever, asking the receiving end of the -->
<!-- channel for a job and running the job when it gets one. Let’s make the change -->
<!-- shown in Listing 20-20 to `Worker::new`. -->
<p>ですが、まだ完全にやり終えたわけではありません！ワーカー内で<code>thread::spawn</code>に渡されているクロージャは、
それでもチャンネルの受信側を<em>参照</em>しているだけです。その代わりに、クロージャには永遠にループし、
チャンネルの受信側に仕事を要求し、仕事を得たらその仕事を実行してもらう必要があります。
リスト20-20に示した変更を<code>Worker::new</code>に行いましょう。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                // ワーカー{}は仕事を得ました; 実行します
                println!(&quot;Worker {} got a job; executing.&quot;, id);

                (*job)();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<!-- <span class="caption">Listing 20-20: Receiving and executing the jobs in the -->
<!-- worker’s thread</span> -->
<p><span class="caption">リスト20-20: ワーカーのスレッドで仕事を受け取り、実行する</span></p>
<!-- Here, we first call `lock` on the `receiver` to acquire the mutex, and then we -->
<!-- call `unwrap` to panic on any errors. Acquiring a lock might fail if the mutex -->
<!-- is in a *poisoned* state, which can happen if some other thread panicked while -->
<!-- holding the lock rather than releasing the lock. In this situation, calling -->
<!-- `unwrap` to have this thread panic is the correct action to take. Feel free to -->
<!-- change this `unwrap` to an `expect` with an error message that is meaningful to -->
<!-- you. -->
<p>ここで、まず<code>receiver</code>に対して<code>lock</code>を呼び出してミューテックスを獲得し、それから<code>unwrap</code>を呼び出して、
エラーの際にはパニックします。ロックの獲得は、ミューテックスが<em>毒された</em>状態なら失敗する可能性があり、
これは、他のどれかのスレッドがロックを保持している間に、解放するのではなく、パニックした場合に起き得ます。
この場面では、<code>unwrap</code>を呼び出してこのスレッドをパニックさせるのは、取るべき正当な行動です。
この<code>unwrap</code>をあなたにとって意味のあるエラーメッセージを伴う<code>expect</code>に変更することは、ご自由に行なってください。</p>
<!-- If we get the lock on the mutex, we call `recv` to receive a `Job` from the -->
<!-- channel. A final `unwrap` moves past any errors here as well, which might occur -->
<!-- if the thread holding the sending side of the channel has shut down, similar to -->
<!-- how the `send` method returns `Err` if the receiving side shuts down. -->
<p>ミューテックスのロックを獲得できたら、<code>recv</code>を呼び出してチャンネルから<code>Job</code>を受け取ります。
最後の<code>unwrap</code>もここであらゆるエラーを超えていき、これはチャンネルの送信側を保持するスレッドが閉じた場合に発生する可能性があり、
受信側が閉じた場合に<code>send</code>メソッドが<code>Err</code>を返すのと似ています。</p>
<!-- The call to `recv` blocks, so if there is no job yet, the current thread will -->
<!-- wait until a job becomes available. The `Mutex<T>` ensures that only one -->
<!-- `Worker` thread at a time is trying to request a job. -->
<p><code>recv</code>の呼び出しはブロックするので、まだ仕事がなければ、現在のスレッドは、仕事が利用可能になるまで待機します。
<code>Mutex&lt;T&gt;</code>により、ただ1つの<code>Worker</code>スレッドのみが一度に仕事の要求を試みることを保証します。</p>
<!-- Theoretically, this code should compile. Unfortunately, the Rust compiler isn’t -->
<!-- perfect yet, and we get this error: -->
<p>理論的には、このコードはコンパイルできるはずです。残念ながら、Rustコンパイラはまだ完全ではなく、
このようなエラーが出ます:</p>
<pre><code class="language-text">error[E0161]: cannot move a value of type std::ops::FnOnce() +
std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be
statically determined
(エラー: std::ops::FnOnce() + std::marker::Sendの値をムーブできません:
std::ops::FnOnce() + std::marker::Sendのサイズを静的に決定できません)
  --&gt; src/lib.rs:63:17
   |
63 |                 (*job)();
   |                 ^^^^^^
</code></pre>
<!-- This error is fairly cryptic because the problem is fairly cryptic. To call a -->
<!-- `FnOnce` closure that is stored in a `Box<T>` (which is what our `Job` type -->
<!-- alias is), the closure needs to move itself *out* of the `Box<T>` because the -->
<!-- closure takes ownership of `self` when we call it. In general, Rust doesn’t -->
<!-- allow us to move a value out of a `Box<T>` because Rust doesn’t know how big -->
<!-- the value inside the `Box<T>` will be: recall in Chapter 15 that we used -->
<!-- `Box<T>` precisely because we had something of an unknown size that we wanted -->
<!-- to store in a `Box<T>` to get a value of a known size. -->
<p>問題が非常に謎めいているので、エラーも非常に謎めいています。<code>Box&lt;T&gt;</code>に格納された<code>FnOnce</code>クロージャを呼び出すためには(<code>Job</code>型エイリアスがそう)、
呼び出す際にクロージャが<code>self</code>の所有権を奪うので、
クロージャは自身を<code>Box&lt;T&gt;</code><em>から</em>ムーブする必要があります。一般的に、Rustは<code>Box&lt;T&gt;</code>から値をムーブすることを許可しません。
コンパイラには、<code>Box&lt;T&gt;</code>の内側の値がどれほどの大きさなのか見当がつかないからです:
第15章で<code>Box&lt;T&gt;</code>に格納して既知のサイズの値を得たい未知のサイズの何かがあるために<code>Box&lt;T&gt;</code>を正確に使用したことを思い出してください。</p>
<!-- As you saw in Listing 17-15, we can write methods that use the syntax `self: -->
<!-- Box<Self>`, which allows the method to take ownership of a `Self` value stored -->
<!-- in a `Box<T>`. That’s exactly what we want to do here, but unfortunately Rust -->
<!-- won’t let us: the part of Rust that implements behavior when a closure is -->
<!-- called isn’t implemented using `self: Box<Self>`. So Rust doesn’t yet -->
<!-- understand that it could use `self: Box<Self>` in this situation to take -->
<!-- ownership of the closure and move the closure out of the `Box<T>`. -->
<p>リスト17-15で見かけたように、記法<code>self: Box&lt;Self&gt;</code>を使用するメソッドを書くことができ、
これにより、メソッドは<code>Box&lt;T&gt;</code>に格納された<code>Self</code>値の所有権を奪うことができます。
それがまさしくここで行いたいことですが、残念ながらコンパイラはさせてくれません:
クロージャが呼び出された際に振る舞いを実装するRustの一部は、<code>self: Box&lt;Self&gt;</code>を使用して実装されていないのです。
故に、コンパイラはまだこの場面において<code>self: Box&lt;Self&gt;</code>を使用してクロージャの所有権を奪い、
クロージャを<code>Box&lt;T&gt;</code>からムーブできることを理解していないのです。</p>
<!-- Rust is still a work in progress with places where the compiler could be -->
<!-- improved, but in the future, the code in Listing 20-20 should work just fine. -->
<!-- People just like you are working to fix this and other issues! After you’ve -->
<!-- finished this book, we would love for you to join in. -->
<p>Rustは、コンパイラが改善できる箇所ではまだ、発展途上にありますが、将来的にリスト20-20のコードは、
ただ単純にうまく動くはずです。あなたのような方がこれや他の問題を修正するのに取り掛かっています！この本を完了したら、
是非ともあなたにも参加していただきたいです。</p>
<!-- But for now, let’s work around this problem using a handy trick. We can tell -->
<!-- Rust explicitly that in this case we can take ownership of the value inside the -->
<!-- `Box<T>` using `self: Box<Self>`; then, once we have ownership of the closure, -->
<!-- we can call it. This involves defining a new trait `FnBox` with the method -->
<!-- `call_box` that will use `self: Box<Self>` in its signature, defining `FnBox` -->
<!-- for any type that implements `FnOnce()`, changing our type alias to use the new -->
<!-- trait, and changing `Worker` to use the `call_box` method. These changes are -->
<!-- shown in Listing 20-21. -->
<p>ですがとりあえず、手頃なトリックを使ってこの問題を回避しましょう。この場合、<code>self: Box&lt;Self&gt;</code>で、
<code>Box&lt;T&gt;</code>の内部の値の所有権を奪うことができることをコンパイラに明示的に教えてあげます;
そして、一旦クロージャの所有権を得たら、呼び出せます。これには、
シグニチャに<code>self: Box&lt;Self&gt;</code>を使用する<code>call_box</code>というメソッドのある新しいトレイト<code>FnBox</code>を定義すること、
<code>FnOnce()</code>を実装する任意の型に対して<code>FnBox</code>を定義すること、型エイリアスを新しいトレイトを使用するように変更すること、
<code>Worker</code>を<code>call_box</code>メソッドを使用するように変更することが関連します。これらの変更は、
リスト20-21に表示されています。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<!-- <span class="caption">Listing 20-21: Adding a new trait `FnBox` to work around -->
<!-- the current limitations of `Box<FnOnce()>`</span> -->
<p><span class="caption">リスト20-21: 新しいトレイト<code>FnBox</code>を追加して<code>Box&lt;FnOnce()&gt;</code>の現在の制限を回避する</span></p>
<!-- First, we create a new trait named `FnBox`. This trait has the one method -->
<!-- `call_box`, which is similar to the `call` methods on the other `Fn*` traits -->
<!-- except that it takes `self: Box<Self>` to take ownership of `self` and move the -->
<!-- value out of the `Box<T>`. -->
<p>まず、<code>FnBox</code>という新しいトレイトを作成します。このトレイトには<code>call_box</code>という1つのメソッドがあり、
これは、<code>self: Box&lt;Self&gt;</code>を取って<code>self</code>の所有権を奪い、<code>Box&lt;T&gt;</code>から値をムーブする点を除いて、
他の<code>Fn*</code>トレイトの<code>call</code>メソッドと類似しています。</p>
<!-- Next, we implement the `FnBox` trait for any type `F` that implements the -->
<!-- `FnOnce()` trait. Effectively, this means that any `FnOnce()` closures can use -->
<!-- our `call_box` method. The implementation of `call_box` uses `(*self)()` to -->
<!-- move the closure out of the `Box<T>` and call the closure. -->
<p>次に、<code>FnOnce()</code>トレイトを実装する任意の型<code>F</code>に対して<code>FnBox</code>トレイトを実装します。実質的にこれは、
あらゆる<code>FnOnce()</code>クロージャが<code>call_box</code>メソッドを使用できることを意味します。<code>call_box</code>の実装は、
<code>(*self)()</code>を使用して<code>Box&lt;T&gt;</code>からクロージャをムーブし、クロージャを呼び出します。</p>
<!-- We now need our `Job` type alias to be a `Box` of anything that implements our -->
<!-- new trait `FnBox`. This will allow us to use `call_box` in `Worker` when we get -->
<!-- a `Job` value instead of invoking the closure directly. Implementing the -->
<!-- `FnBox` trait for any `FnOnce()` closure means we don’t have to change anything -->
<!-- about the actual values we’re sending down the channel. Now Rust is able to -->
<!-- recognize that what we want to do is fine. -->
<p>これで<code>Job</code>型エイリアスには、新しいトレイトの<code>FnBox</code>を実装する何かの<code>Box</code>である必要が出てきました。
これにより、クロージャを直接呼び出す代わりに<code>Job</code>値を得た時に<code>Worker</code>の<code>call_box</code>を使えます。
任意の<code>FnOnce()</code>クロージャに対して<code>FnBox</code>トレイトを実装することは、チャンネルに送信する実際の値は何も変えなくてもいいことを意味します。
もうコンパイラは、我々が行おうとしていることが平気なことであると認識できます。</p>
<!-- This trick is very sneaky and complicated. Don’t worry if it doesn’t make -->
<!-- perfect sense; someday, it will be completely unnecessary. -->
<p>このトリックは非常にこそこそしていて複雑です。完璧に筋が通らなくても心配しないでください;
いつの日か、完全に不要になるでしょう。</p>
<!-- With the implementation of this trick, our thread pool is in a working state! -->
<!-- Give it a `cargo run`, and make some requests: -->
<p>このトリックの実装で、スレッドプールは動く状態になります！<code>cargo run</code>を実行し、
リクエストを行なってください:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never used: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `id`
  --&gt; src/lib.rs:61:5
   |
61 |     id: usize,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `thread`
  --&gt; src/lib.rs:62:5
   |
62 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<!-- Success! We now have a thread pool that executes connections asynchronously. -->
<!-- There are never more than four threads created, so our system won’t get -->
<!-- overloaded if the server receives a lot of requests. If we make a request to -->
<!-- */sleep*, the server will be able to serve other requests by having another -->
<!-- thread run them. -->
<p>成功！もう非同期に接続を実行するスレッドプールができました。絶対に4つ以上のスレッドが生成されないので、
サーバが多くのリクエストを受け取っても、システムは過負荷にならないでしょう。<em>/sleep</em>にリクエストを行なっても、
サーバは他のスレッドに実行させることで他のリクエストを提供できるでしょう。</p>
<!-- After learning about the `while let` loop in Chapter 18, you might be wondering -->
<!-- why we didn’t write the worker thread code as shown in Listing 20-22. -->
<p>第18章で<code>while let</code>ループを学んだ後でなぜリスト20-22に示したようにワーカースレッドのコードを記述しなかったのか、
不思議に思っている可能性があります。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<!-- <span class="caption">Listing 20-22: An alternative implementation of -->
<!-- `Worker::new` using `while let`</span> -->
<p><span class="caption">リスト20-22: <code>while let</code>を使用したもう1つの<code>Worker::new</code>の実装</span></p>
<!-- This code compiles and runs but doesn’t result in the desired threading -->
<!-- behavior: a slow request will still cause other requests to wait to be -->
<!-- processed. The reason is somewhat subtle: the `Mutex` struct has no public -->
<!-- `unlock` method because the ownership of the lock is based on the lifetime of -->
<!-- the `MutexGuard<T>` within the `LockResult<MutexGuard<T>>` that the `lock` -->
<!-- method returns. At compile time, the borrow checker can then enforce the rule -->
<!-- that a resource guarded by a `Mutex` cannot be accessed unless we hold the -->
<!-- lock. But this implementation can also result in the lock being held longer -->
<!-- than intended if we don’t think carefully about the lifetime of the -->
<!-- `MutexGuard<T>`. Because the values in the `while` expression remain in scope -->
<!-- for the duration of the block, the lock remains held for the duration of the -->
<!-- call to `job.call_box()`, meaning other workers cannot receive jobs. -->
<p>このコードはコンパイルでき、動きますが、望み通りのスレッドの振る舞いにはなりません:
遅いリクエストがそれでも、他のリクエストが処理されるのを待機させてしまうのです。理由はどこか捉えがたいものです:
<code>Mutex</code>構造体には公開の<code>unlock</code>メソッドがありません。ロックの所有権が、
<code>lock</code>メソッドが返す<code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code>内の<code>MutexGuard&lt;T&gt;</code>のライフタイムに基づくからです。
コンパイル時には、ロックを保持していない限り、借用精査機はそうしたら、<code>Mutex</code>に保護されるリソースにはアクセスできないという規則を強制できます。
しかし、この実装は、<code>MutexGuard&lt;T&gt;</code>のライフタイムについて熟考しなければ、
意図したよりもロックが長い間保持される結果になり得ます。<code>while</code>式の値がブロックの間中スコープに残り続けるので、
ロックは<code>job.call_box</code>の呼び出し中保持されたままになり、他のワーカーが仕事を受け取れなくなるのです。</p>
<!-- By using `loop` instead and acquiring the lock and a job within the block -->
<!-- rather than outside it, the `MutexGuard` returned from the `lock` method is -->
<!-- dropped as soon as the `let job` statement ends. This ensures that the lock is -->
<!-- held during the call to `recv`, but it is released before the call to -->
<!-- `job.call_box()`, allowing multiple requests to be serviced concurrently. -->
<p>代わりに<code>loop</code>を使用し、ロックと仕事をブロックの外ではなく、内側で獲得することで、
<code>lock</code>メソッドが返す<code>MutexGuard</code>は<code>let job</code>文が終わると同時にドロップされます。
これにより、ロックは<code>recv</code>の呼び出しの間は保持されるけれども、<code>job.call_box</code>の呼び出しの前には解放され、
複数のリクエストを並行で提供できることを保証します。</p>
<!-- ## Graceful Shutdown and Cleanup -->
<a class="header" href="print.html#a優美なシャットダウンと片付け" id="a優美なシャットダウンと片付け"><h2>優美なシャットダウンと片付け</h2></a>
<!-- The code in Listing 20-21 is responding to requests asynchronously through the -->
<!-- use of a thread pool, as we intended. We get some warnings about the `workers`, -->
<!-- `id`, and `thread` fields that we’re not using in a direct way that reminds us -->
<!-- we’re not cleaning up anything. When we use the less elegant <span -->
<!-- class="keystroke">ctrl-c</span> method to halt the main thread, all other -->
<!-- threads are stopped immediately as well, even if they’re in the middle of -->
<!-- serving a request. -->
<p>リスト20-21のコードは、意図した通り、スレッドプールの使用を通してリクエストに非同期に応答できます。
何も片付けを行なっていないと思い出せてくれる、直接使用していない<code>workers</code>、<code>id</code>、<code>thread</code>フィールドについて警告が出ます。
優美さに欠ける<span class="keystroke">ctrl-c</span>を使用してメインスレッドを停止させる方法を使用すると、
リクエストの処理中であっても、他のスレッドも停止します。</p>
<!-- Now we’ll implement the `Drop` trait to call `join` on each of the threads in -->
<!-- the pool so they can finish the requests they’re working on before closing. -->
<!-- Then we’ll implement a way to tell the threads they should stop accepting new -->
<!-- requests and shut down. To see this code in action, we’ll modify our server to -->
<!-- accept only two requests before gracefully shutting down its thread pool. -->
<p>では、閉じる前に取り掛かっているリクエストを完了できるように、プールの各スレッドに対して<code>join</code>を呼び出す<code>Drop</code>トレイトを実装します。
そして、スレッドに新しいリクエストの受付を停止し、終了するように教える方法を実装します。
このコードが動いているのを確かめるために、サーバを変更して優美にスレッドプールを終了する前に2つしかリクエストを受け付けないようにします。</p>
<!-- ### Implementing the `Drop` Trait on `ThreadPool` -->
<a class="header" href="print.html#threadpoolにdropトレイトを実装する" id="threadpoolにdropトレイトを実装する"><h3><code>ThreadPool</code>に<code>Drop</code>トレイトを実装する</h3></a>
<!-- Let’s start with implementing `Drop` on our thread pool. When the pool is -->
<!-- dropped, our threads should all join to make sure they finish their work. -->
<!-- Listing 20-23 shows a first attempt at a `Drop` implementation; this code won’t -->
<!-- quite work yet. -->
<p>スレッドプールに<code>Drop</code>を実装するところから始めましょう。プールがドロップされると、
スレッドは全てjoinして、作業を完了するのを確かめるべきです。リスト20-23は、<code>Drop</code>実装の最初の試みを表示しています;
このコードはまだ完全には動きません。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            // ワーカー{}を終了します
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</code></pre>
<!-- <span class="caption">Listing 20-23: Joining each thread when the thread pool -->
<!-- goes out of scope</span> -->
<p><span class="caption">リスト20-23: スレッドプールがスコープを抜けた時にスレッドをjoinさせる</span></p>
<!-- First, we loop through each of the thread pool `workers`. We use `&mut` for -->
<!-- this because `self` is a mutable reference, and we also need to be able to -->
<!-- mutate `worker`. For each worker, we print a message saying that this -->
<!-- particular worker is shutting down, and then we call `join` on that worker’s -->
<!-- thread. If the call to `join` fails, we use `unwrap` to make Rust panic and go -->
<!-- into an ungraceful shutdown. -->
<p>まず、スレッドプール<code>worker</code>それぞれを走査します。<code>self</code>は可変参照であり、<code>worker</code>を可変化できる必要もあるので、
これには<code>&amp;mut</code>を使用しています。ワーカーそれぞれに対して、特定のワーカーを終了する旨のメッセージを出力し、
それから<code>join</code>をワーカースレッドに対して呼び出しています。<code>join</code>の呼び出しが失敗したら、
<code>unwrap</code>を使用してRustをパニックさせ、優美でないシャットダウンに移行します。</p>
<!-- Here is the error we get when we compile this code: -->
<p>こちらが、このコードをコンパイルする際に出るエラーです:</p>
<pre><code class="language-text">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</code></pre>
<!-- The error tells us we can’t call `join` because we only have a mutable borrow -->
<!-- of each `worker` and `join` takes ownership of its argument. To solve this -->
<!-- issue, we need to move the thread out of the `Worker` instance that owns -->
<!-- `thread` so `join` can consume the thread. We did this in Listing 17-15: if -->
<!-- `Worker` holds an `Option<thread::JoinHandle<()>` instead, we can call the -->
<!-- `take` method on the `Option` to move the value out of the `Some` variant and -->
<!-- leave a `None` variant in its place. In other words, a `Worker` that is running -->
<!-- will have a `Some` variant in `thread`, and when we want to clean up a -->
<!-- `Worker` we’ll replace `Some` with `None` so the worker doesn’t have a -->
<!-- thread to run. -->
<p>各<code>worker</code>の可変参照しかなく、<code>join</code>は引数の所有権を奪うためにこのエラーは<code>join</code>を呼び出せないと教えてくれています。
この問題を解決するには、<code>join</code>がスレッドを消費できるように、<code>thread</code>を所有する<code>Worker</code>インスタンスからスレッドをムーブする必要があります。
これをリスト17-15では行いました: <code>Worker</code>が代わりに<code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>を保持していれば、
<code>Option</code>に対して<code>take</code>メソッドを呼び出し、<code>Some</code>列挙子から値をムーブし、その場所に<code>None</code>列挙子を残すことができます。
言い換えれば、実行中の<code>Worker</code>には<code>thread</code>に<code>Some</code>列挙子があり、<code>Worker</code>を片付けたい時には、
ワーカーが実行するスレッドがないように<code>Some</code>を<code>None</code>で置き換えるのです。</p>
<!-- So we know we want to update the definition of `Worker` like this: -->
<p>従って、<code>Worker</code>の定義を以下のように更新したいことがわかります:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
#}</code></pre></pre>
<!-- Now let’s lean on the compiler to find the other places that need to change. -->
<!-- Checking this code, we get two errors: -->
<p>さて、コンパイラを頼りにして他に変更する必要がある箇所を探しましょう。このコードをチェックすると、
2つのエラーが出ます:</p>
<pre><code class="language-text">error[E0599]: no method named `join` found for type
`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:13
   |
89 |             thread,
   |             ^^^^^^
   |             |
   |             expected enum `std::option::Option`, found struct
   `std::thread::JoinHandle`
   |             help: try using a variant of the expected type: `Some(thread)`
   |
   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
              found type `std::thread::JoinHandle&lt;_&gt;`
</code></pre>
<!-- Let’s address the second error, which points to the code at the end of -->
<!-- `Worker::new`; we need to wrap the `thread` value in `Some` when we create a -->
<!-- new `Worker`. Make the following changes to fix this error: -->
<p>2番目のエラーを扱いましょう。これは、<code>Worker::new</code>の最後のコードを指しています; 新しい<code>Worker</code>を作成する際に、
<code>Some</code>に<code>thread</code>の値を包む必要があります。このエラーを修正するために以下の変更を行なってください:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<!-- The first error is in our `Drop` implementation. We mentioned earlier that we -->
<!-- intended to call `take` on the `Option` value to move `thread` out of `worker`. -->
<!-- The following changes will do so: -->
<p>最初のエラーは<code>Drop</code>実装内にあります。先ほど、<code>Option</code>値に対して<code>take</code>を呼び出し、
<code>thread</code>を<code>worker</code>からムーブする意図があることに触れました。以下の変更がそれを行います:</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<!-- As discussed in Chapter 17, the `take` method on `Option` takes the `Some` -->
<!-- variant out and leaves `None` in its place. We’re using `if let` to destructure -->
<!-- the `Some` and get the thread; then we call `join` on the thread. If a worker’s -->
<!-- thread is already `None`, we know that worker has already had its thread -->
<!-- cleaned up, so nothing happens in that case. -->
<p>第17章で議論したように、<code>Option</code>の<code>take</code>メソッドは、<code>Some</code>列挙子を取り出し、その箇所に<code>None</code>を残します。
<code>if let</code>を使用して<code>Some</code>を分配し、スレッドを得ています; そして、スレッドに対して<code>join</code>を呼び出します。
ワーカーのスレッドが既に<code>None</code>なら、ワーカーはスレッドを既に片付け済みであることがわかるので、
その場合には何も起きません。</p>
<!-- ### Signaling to the Threads to Stop Listening for Jobs -->
<a class="header" href="print.html#aスレッドに仕事をリッスンするのを止めるよう通知する" id="aスレッドに仕事をリッスンするのを止めるよう通知する"><h3>スレッドに仕事をリッスンするのを止めるよう通知する</h3></a>
<!-- With all the changes we’ve made, our code compiles without any warnings. But -->
<!-- the bad news is this code doesn’t function the way we want it to yet. The key -->
<!-- is the logic in the closures run by the threads of the `Worker` instances: at -->
<!-- the moment, we call `join`, but that won’t shut down the threads because they -->
<!-- `loop` forever looking for jobs. If we try to drop our `ThreadPool` with our -->
<!-- current implementation of `drop`, the main thread will block forever waiting -->
<!-- for the first thread to finish. -->
<p>行なった変更と共に、コードは警告なしでコンパイルできます。ですが悪い知らせは、このコードが期待したようにはまだ機能しないことです。
鍵は、<code>Worker</code>インスタンスのスレッドで実行されるクロージャのロジックです: 現時点で<code>join</code>を呼び出していますが、
仕事を求めて永遠に<code>loop</code>するので、スレッドを終了しません。現在の<code>drop</code>の実装で<code>ThreadPool</code>をドロップしようとしたら、
最初のスレッドが完了するのを永遠に待機してメインスレッドはブロックされるでしょう。</p>
<!-- To fix this problem, we’ll modify the threads so they listen for either a `Job` -->
<!-- to run or a signal that they should stop listening and exit the infinite loop. -->
<!-- Instead of `Job` instances, our channel will send one of these two enum -->
<!-- variants. -->
<p>この問題を修正するには、スレッドが、実行すべき<code>Job</code>か、リッスンをやめて無限ループを抜ける通知をリッスンするように、
変更します。<code>Job</code>インスタンスの代わりに、チャンネルはこれら2つのenum列挙子の一方を送信します。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Job;
enum Message {
    NewJob(Job),
    Terminate,
}
#}</code></pre></pre>
<!-- This `Message` enum will either be a `NewJob` variant that holds the `Job` the -->
<!-- thread should run, or it will be a `Terminate` variant that will cause the -->
<!-- thread to exit its loop and stop. -->
<p>この<code>Message</code> enumはスレッドが実行すべき<code>Job</code>を保持する<code>NewJob</code>列挙子か、スレッドをループから抜けさせ、
停止させる<code>Terminate</code>列挙子のどちらかになります。</p>
<!-- We need to adjust the channel to use values of type `Message` rather than type -->
<!-- `Job`, as shown in Listing 20-24. -->
<p>チャンネルを調整し、型<code>Job</code>ではなく、型<code>Message</code>を使用するようにする必要があります。リスト20-24のようにですね。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// --snip--

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        // ワーカー{}は停止するよう指示された
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<!-- <span class="caption">Listing 20-24: Sending and receiving `Message` values and -->
<!-- exiting the loop if a `Worker` receives `Message::Terminate`</span> -->
<p><span class="caption">リスト20-24: <code>Message</code>値を送受信し、<code>Worker</code>が<code>Message::Terminate</code>を受け取ったら、ループを抜ける</span></p>
<!-- To incorporate the `Message` enum, we need to change `Job` to `Message` in two -->
<!-- places: the definition of `ThreadPool` and the signature of `Worker::new`. The -->
<!-- `execute` method of `ThreadPool` needs to send jobs wrapped in the -->
<!-- `Message::NewJob` variant. Then, in `Worker::new` where a `Message` is received -->
<!-- from the channel, the job will be processed if the `NewJob` variant is -->
<!-- received, and the thread will break out of the loop if the `Terminate` variant -->
<!-- is received. -->
<p><code>Message</code> enumを具体化するために、2箇所で<code>Job</code>を<code>Message</code>に変更する必要があります:
<code>ThreadPool</code>の定義と<code>Worker::new</code>のシグニチャです。<code>ThreadPool</code>の<code>execute</code>メソッドは、
仕事を<code>Message::NewJob</code>に包んで送信する必要があります。それから、
<code>Message</code>がチャンネルから受け取られる<code>Worker::new</code>で、<code>NewJob</code>列挙子が受け取られたら、
仕事が処理され、<code>Terminate</code>列挙子が受け取られたら、スレッドはループを抜けます。</p>
<!-- With these changes, the code will compile and continue to function in the same -->
<!-- way as it did after Listing 20-21. But we’ll get a warning because we aren’t -->
<!-- creating any messages of the `Terminate` variety. Let’s fix this warning by -->
<!-- changing our `Drop` implementation to look like Listing 20-25. -->
<p>これらの変更と共に、コードはコンパイルでき、リスト20-21の後と同じように機能し続けます。ですが、
<code>Terminate</code>のメッセージを何も生成していないので、
警告が出るでしょう。<code>Drop</code>実装をリスト20-25のような見た目に変更してこの警告を修正しましょう。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        // 全ワーカーを閉じます
        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            // ワーカー{}を閉じます
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<!-- <span class="caption">Listing 20-25: Sending `Message::Terminate` to the -->
<!-- workers before calling `join` on each worker thread</span> -->
<p><span class="caption">リスト20-25: 各ワーカースレッドに対して<code>join</code>を呼び出す前にワーカーに<code>Message::Terminate</code>を送信する</span></p>
<!-- We’re now iterating over the workers twice: once to send one `Terminate` -->
<!-- message for each worker and once to call `join` on each worker’s thread. If we -->
<!-- tried to send a message and `join` immediately in the same loop, we couldn’t -->
<!-- guarantee that the worker in the current iteration would be the one to get the -->
<!-- message from the channel. -->
<p>今では、ワーカーを2回走査しています: 各ワーカーに<code>Terminate</code>メッセージを送信するために1回と、
各ワーカースレッドに<code>join</code>を呼び出すために1回です。メッセージ送信と<code>join</code>を同じループで即座に行おうとすると、
現在の繰り返しのワーカーがチャンネルからメッセージを受け取っているものであるか保証できなくなってしまいます。</p>
<!-- To better understand why we need two separate loops, imagine a scenario with -->
<!-- two workers. If we used a single loop to iterate through each worker, on the -->
<!-- first iteration a terminate message would be sent down the channel and `join` -->
<!-- called on the first worker’s thread. If that first worker was busy processing a -->
<!-- request at that moment, the second worker would pick up the terminate message -->
<!-- from the channel and shut down. We would be left waiting on the first worker to -->
<!-- shut down, but it never would because the second thread picked up the terminate -->
<!-- message. Deadlock! -->
<p>2つの個別のループが必要な理由をよりよく理解するために、2つのワーカーがある筋書きを想像してください。
単独のループで各ワーカーを走査すると、最初の繰り返しでチャンネルに停止メッセージが送信され、
<code>join</code>が最初のワーカースレッドで呼び出されます。その最初のワーカーが現在、リクエストの処理で忙しければ、
2番目のワーカーがチャンネルから停止メッセージを受け取り、閉じます。最初のワーカーの終了待ちをしていますが、
2番目のスレッドが停止メッセージを拾ってしまったので、終了することは絶対にありません。デッドロックです！</p>
<!-- To prevent this scenario, we first put all of our `Terminate` messages on the -->
<!-- channel in one loop; then we join on all the threads in another loop. Each -->
<!-- worker will stop receiving requests on the channel once it gets a terminate -->
<!-- message. So, we can be sure that if we send the same number of terminate -->
<!-- messages as there are workers, each worker will receive a terminate message -->
<!-- before `join` is called on its thread. -->
<p>この筋書きを回避するために、1つのループでまず、チャンネルに対して全ての<code>Terminate</code>メッセージを配置します;
そして、別のループで全スレッドのjoinを待ちます。一旦停止メッセージを受け取ったら、各ワーカーはチャンネルでリクエストの受付をやめます。
故に、存在するワーカーと同じ数だけ停止メッセージを送れば、<code>join</code>がスレッドに対して呼び出される前に、
停止メッセージを各ワーカーが受け取ると確信できるわけです。</p>
<!-- To see this code in action, let’s modify `main` to accept only two requests -->
<!-- before gracefully shutting down the server, as shown in Listing 20-26. -->
<p>このコードが動いているところを確認するために、<code>main</code>を変更してサーバを優美に閉じる前に2つしかリクエストを受け付けないようにしましょう。
リスト20-26のようにですね。</p>
<!-- <span class="filename">Filename: src/bin/main.rs</span> -->
<p><span class="filename">ファイル名: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
</code></pre>
<!-- <span class="caption">Listing 20-26: Shut down the server after serving two -->
<!-- requests by exiting the loop</span> -->
<p><span class="caption">リスト20-26: ループを抜けて2つのリクエストを処理した後にサーバを閉じる</span></p>
<!-- You wouldn’t want a real-world web server to shut down after serving only two -->
<!-- requests. This code just demonstrates that the graceful shutdown and cleanup is -->
<!-- in working order. -->
<p>現実世界のWebサーバには、たった2つしかリクエストを受け付けた後に閉じてほしくはないでしょう。
このコードは、単に優美なシャットダウンと片付けが機能する状態にあることをデモするだけです。</p>
<!-- The `take` method is defined in the `Iterator` trait and limits the iteration -->
<!-- to the first two items at most. The `ThreadPool` will go out of scope at the -->
<!-- end of `main`, and the `drop` implementation will run. -->
<p><code>take</code>メソッドは、<code>Iterator</code>トレイトで定義されていて、最大でも繰り返しを最初の2つの要素だけに制限します。
<code>ThreadPool</code>は<code>main</code>の末端でスコープを抜け、<code>drop</code>実装が実行されます。</p>
<!-- Start the server with `cargo run`, and make three requests. The third request -->
<!-- should error, and in your terminal you should see output similar to this: -->
<p><code>cargo run</code>でサーバを開始し、3つリクエストを行なってください。3番目のリクエストはエラーになるはずで、
端末にはこのような出力が目撃できるはずです:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<!-- You might see a different ordering of workers and messages printed. We can see -->
<!-- how this code works from the messages: workers 0 and 3 got the first two -->
<!-- requests, and then on the third request, the server stopped accepting -->
<!-- connections. When the `ThreadPool` goes out of scope at the end of `main`, its -->
<!-- `Drop` implementation kicks in, and the pool tells all workers to terminate. -->
<!-- The workers each print a message when they see the terminate message, and then -->
<!-- the thread pool calls `join` to shut down each worker thread. -->
<p>ワーカーとメッセージの順番は異なる可能性があります。どうやってこのコードが動くのかメッセージからわかります:
ワーカー0と3が最初の2つのリクエストを受け付け、そして3番目のリクエストではサーバは接続の受け入れをやめます。
<code>main</code>の最後で<code>ThreadPool</code>がスコープを抜ける際、<code>Drop</code>実装が割り込み、プールが全ワーカーに停止するよう指示します。
ワーカーはそれぞれ、停止メッセージを確認した時にメッセージを出力し、それからスレッドプールは各ワーカースレッドを閉じる<code>join</code>を呼び出します。</p>
<!-- Notice one interesting aspect of this particular execution: the `ThreadPool` -->
<!-- sent the terminate messages down the channel, and before any worker received -->
<!-- the messages, we tried to join worker 0. Worker 0 had not yet received the -->
<!-- terminate message, so the main thread blocked waiting for worker 0 to finish. -->
<!-- In the meantime, each of the workers received the termination messages. When -->
<!-- worker 0 finished, the main thread waited for the rest of the workers to -->
<!-- finish. At that point, they had all received the termination message and were -->
<!-- able to shut down. -->
<p>この特定の実行の1つの面白い側面に気付いてください: <code>ThreadPool</code>はチャンネルに停止メッセージを送信し、
あらゆるワーカーがそのメッセージを受け取る前に、ワーカー0のjoinを試みています。ワーカー0はまだ停止メッセージを受け取っていなかったので、
メインスレッドはワーカー0が完了するまで待機してブロックされます。その間に、各ワーカーは停止メッセージを受け取ります。
ワーカー0が完了したら、メインスレッドは残りのワーカーが完了するのを待機します。その時点で全ワーカーは停止メッセージを受け取った後で、
閉じることができたのです。</p>
<!-- Congrats! We’ve now completed our project; we have a basic web server that uses -->
<!-- a thread pool to respond asynchronously. We’re able to perform a graceful -->
<!-- shutdown of the server, which cleans up all the threads in the pool. -->
<p>おめでとうございます！プロジェクトを完成させました; スレッドプールを使用して非同期に応答する基本的なWebサーバができました。
サーバの優美なシャットダウンを行うことができ、プールの全スレッドを片付けます。</p>
<!-- Here’s the full code for reference: -->
<p>こちらが、参考になる全コードです:</p>
<!-- <span class="filename">Filename: src/bin/main.rs</span> -->
<p><span class="filename">ファイル名: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;

use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs::File;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    // 閉じます
    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

     let mut file = File::open(filename).unwrap();
     let mut contents = String::new();

     file.read_to_string(&amp;mut contents).unwrap();

     let response = format!(&quot;{}{}&quot;, status_line, contents);

     stream.write(response.as_bytes()).unwrap();
     stream.flush().unwrap();
}
</code></pre>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
#}</code></pre></pre>
<!-- We could do more here! If you want to continue enhancing this project, here are -->
<!-- some ideas: -->
<p>ここでできることはまだあるでしょう！よりこのプロジェクトを改善したいのなら、こちらがアイディアの一部です:</p>
<!-- * Add more documentation to `ThreadPool` and its public methods. -->
<!-- * Add tests of the library’s functionality. -->
<!-- * Change calls to `unwrap` to more robust error handling. -->
<!-- * Use `ThreadPool` to perform some task other than serving web requests. -->
<!-- * Find a thread pool crate on *https://crates.io/* and implement a similar web -->
<!--   server using the crate instead. Then compare its API and robustness to the -->
<!--   thread pool we implemented. -->
<ul>
<li><code>ThreadPool</code>とその公開メソッドにもっとドキュメンテーションを追加する。</li>
<li>ライブラリの機能のテストを追加する。</li>
<li><code>unwrap</code>の呼び出しをもっと頑健なエラー処理に変更する。</li>
<li><code>ThreadPool</code>を使用してWebリクエスト以外のなんらかの作業を行う。</li>
<li><em>https://crates.io</em>でスレッドプールのクレートを探してそのクレートを代わりに使用して似たWebサーバを実装する。
そして、APIと頑健性を我々が実装したものと比較する。</li>
</ul>
<!-- ## Summary -->
<a class="header" href="print.html#a総括-2" id="a総括-2"><h2>総括</h2></a>
<!-- Well done! You’ve made it to the end of the book! We want to thank you for -->
<!-- joining us on this tour of Rust. You’re now ready to implement your own Rust -->
<!-- projects and help with other peoples’ projects. Keep in mind that there is a -->
<!-- welcoming community of other Rustaceans who would love to help you with any -->
<!-- challenges you encounter on your Rust journey. -->
<p>よくやりました！本の最後に到達しました！Rustのツアーに参加していただき、感謝の辞を述べたいです。
もう、ご自身のRustプロジェクトや他の方のプロジェクトのお手伝いをする準備ができています。
あなたのRustの旅で遭遇するあらゆる挑戦の手助けを是非とも行いたい他のRustaceanの歓迎されるコミュニティがあることを肝に命じておいてください。</p>
<!-- # Appendix -->
<a class="header" href="print.html#a付録" id="a付録"><h1>付録</h1></a>
<!-- The following sections contain reference material you may find useful in your -->
<!-- Rust journey. -->
<p>以下の節は、Rustの旅で役に立つと思えるかもしれない参考文献を含んでいます。</p>
<!-- ## Appendix A: Keywords -->
<a class="header" href="print.html#a付録a-キーワード" id="a付録a-キーワード"><h2>付録A: キーワード</h2></a>
<!-- The following list contains keywords that are reserved for current or future -->
<!-- use by the Rust language. As such, they cannot be used as identifiers, such as -->
<!-- names of functions, variables, parameters, struct fields, modules, crates, -->
<!-- constants, macros, static values, attributes, types, traits, or lifetimes. -->
<p>以下のリストは、現在、あるいは将来Rust言語により使用されるために予約されているキーワードを含んでいます。
そのため、識別子として使用することはできません。識別子の例は、関数名、変数名、引数名、構造体のフィールド名、
モジュール名、クレート名、定数名、マクロ名、静的な値の名前、アトリビュート名、型名、トレイト名、ライフタイム名です。</p>
<!-- ### Keywords Currently in Use -->
<a class="header" href="print.html#a現在使用されているキーワード" id="a現在使用されているキーワード"><h3>現在使用されているキーワード</h3></a>
<!-- The following keywords currently have the functionality described. -->
<p>以下のキーワードは、解説された通りの機能が現状あります。</p>
<!-- * `as` - perform primitive casting, disambiguate the specific trait containing -->
<!--   an item, or rename items in `use` and `extern crate` statements -->
<!-- * `break` - exit a loop immediately -->
<!-- * `const` - define constant items or constant raw pointers -->
<!-- * `continue` - continue to the next loop iteration -->
<!-- * `crate` - link an external crate or a macro variable representing the crate in -->
<!--   which the macro is defined -->
<!-- * `else` - fallback for `if` and `if let` control flow constructs -->
<!-- * `enum` - define an enumeration -->
<!-- * `extern` - link an external crate, function, or variable -->
<!-- * `false` - Boolean false literal -->
<!-- * `fn` - define a function or the function pointer type -->
<!-- * `for` - loop over items from an iterator, implement a trait, or specify a -->
<!--   higher-ranked lifetime -->
<!-- * `if` - branch based on the result of a conditional expression -->
<!-- * `impl` - implement inherent or trait functionality -->
<!-- * `in` - part of `for` loop syntax -->
<!-- * `let` - bind a variable -->
<!-- * `loop` - loop unconditionally -->
<!-- * `match` - match a value to patterns -->
<!-- * `mod` - define a module -->
<!-- * `move` - make a closure take ownership of all its captures -->
<!-- * `mut` - denote mutability in references, raw pointers, or pattern bindings -->
<!-- * `pub` - denote public visibility in struct fields, `impl` blocks, or modules -->
<!-- * `ref` - bind by reference -->
<!-- * `return` - return from function -->
<!-- * `Self` - a type alias for the type implementing a trait -->
<!-- * `self` - method subject or current module -->
<!-- * `static` - global variable or lifetime lasting the entire program execution -->
<!-- * `struct` - define a structure -->
<!-- * `super` - parent module of the current module -->
<!-- * `trait` - define a trait -->
<!-- * `true` - Boolean true literal -->
<!-- * `type` - define a type alias or associated type -->
<!-- * `unsafe` - denote unsafe code, functions, traits, or implementations -->
<!-- * `use` - import symbols into scope -->
<!-- * `where` - denote clauses that constrain a type -->
<!-- * `while` - loop conditionally based on the result of an expression -->
<!-- higher-ranked lifetimeについては議論の余地ありか -->
<ul>
<li><code>as</code> - 基礎的なキャストの実行、要素を含む特定のトレイトの明確化、<code>use</code>や<code>extern crate</code>文の要素名を変更する</li>
<li><code>break</code> - 即座にループを抜ける</li>
<li><code>const</code> - 定数要素か定数の生ポインタを定義する</li>
<li><code>continue</code> - 次のループの繰り返しに継続する</li>
<li><code>crate</code> - 外部のクレートかマクロが定義されているクレートを表すマクロ変数をリンクする</li>
<li><code>else</code> - <code>if</code>と<code>if let</code>フロー制御構文の規定</li>
<li><code>enum</code> - 列挙型を定義する</li>
<li><code>extern</code> - 外部のクレート、関数、変数をリンクする</li>
<li><code>false</code> - bool型のfalseリテラル</li>
<li><code>fn</code> - 関数か関数ポインタ型を定義する</li>
<li><code>for</code> - イテレータの要素を繰り返す、トレイトの実装、高階ライフタイムの指定</li>
<li><code>if</code> - 条件式の結果によって条件分岐</li>
<li><code>impl</code> - 固有の機能やトレイトの機能を実装する</li>
<li><code>in</code> - <code>for</code>ループ記法の一部</li>
<li><code>let</code> - 変数を束縛する</li>
<li><code>loop</code> - 無条件にループする</li>
<li><code>match</code> - 値をパターンとマッチさせる</li>
<li><code>mod</code> - モジュールを定義する</li>
<li><code>move</code> - クロージャにキャプチャした変数全ての所有権を奪わせる</li>
<li><code>mut</code> - 参照、生ポインタ、パターン束縛で可変性に言及する</li>
<li><code>pub</code> - 構造体フィールド、<code>impl</code>ブロック、モジュールで公開性について言及する</li>
<li><code>ref</code> - 参照で束縛する</li>
<li><code>return</code> - 関数から帰る</li>
<li><code>Self</code> - トレイトを実装する型の型エイリアス</li>
<li><code>self</code> - メソッドの主題、または現在のモジュール</li>
<li><code>static</code> - グローバル変数、またはプログラム全体に渡るライフタイム</li>
<li><code>struct</code> - 構造体を定義する</li>
<li><code>super</code> - 現在のモジュールの親モジュール</li>
<li><code>trait</code> - トレイトを定義する</li>
<li><code>true</code> - bool型のtrueリテラル</li>
<li><code>type</code> - 型エイリアスか関連型を定義する</li>
<li><code>unsafe</code> - unsafeなコード、関数、トレイト、実装に言及する</li>
<li><code>use</code> - スコープにシンボルをインポートする</li>
<li><code>where</code> - 型を制限する節に言及する</li>
<li><code>while</code> - 式の結果に基づいて条件的にループする</li>
</ul>
<!-- ### Keywords Reserved for Future Use -->
<a class="header" href="print.html#a将来的な使用のために予約されているキーワード" id="a将来的な使用のために予約されているキーワード"><h3>将来的な使用のために予約されているキーワード</h3></a>
<!-- The following keywords do not have any functionality but are reserved by Rust -->
<!-- for potential future use. -->
<p>以下のキーワードには機能が何もないものの、将来的に使用される可能性があるので、Rustにより予約されています。</p>
<!-- * `abstract` -->
<!-- * `alignof` -->
<!-- * `become` -->
<!-- * `box` -->
<!-- * `do` -->
<!-- * `final` -->
<!-- * `macro` -->
<!-- * `offsetof` -->
<!-- * `override` -->
<!-- * `priv` -->
<!-- * `proc` -->
<!-- * `pure` -->
<!-- * `sizeof` -->
<!-- * `typeof` -->
<!-- * `unsized` -->
<!-- * `virtual` -->
<!-- * `yield` -->
<ul>
<li><code>abstract</code></li>
<li><code>alignof</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>offsetof</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>proc</code></li>
<li><code>pure</code></li>
<li><code>sizeof</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<!-- ## Appendix B: Operators and Symbols -->
<a class="header" href="print.html#a付録b-演算子とシンボル" id="a付録b-演算子とシンボル"><h2>付録B: 演算子とシンボル</h2></a>
<!-- This appendix contains a glossary of Rust’s syntax, including operators and -->
<!-- other symbols that appear by themselves or in the context of paths, generics, -->
<!-- trait bounds, macros, attributes, comments, tuples, and brackets. -->
<p>この付録は、演算子や、単独で現れたり、パス、ジェネリクス、トレイト境界、マクロ、アトリビュート、コメント、タプル、
かっこの文脈で現れる他のシンボルを含むRustの記法の用語集を含んでいます。</p>
<!-- ### Operators -->
<a class="header" href="print.html#a演算子" id="a演算子"><h3>演算子</h3></a>
<!-- Table B-1 contains the operators in Rust, an example of how the operator would -->
<!-- appear in context, a short explanation, and whether that operator is -->
<!-- overloadable. If an operator is overloadable, the relevant trait to use to -->
<!-- overload that operator is listed. -->
<p>表B-1は、Rustの演算子、演算子が文脈で現れる例、短い説明、その演算子がオーバーロード可能かどうかを含んでいます。
演算子がオーバーロード可能ならば、オーバーロードするのに使用する関係のあるトレイトも列挙されています。</p>
<!-- <span class="caption">Table B-1: Operators</span> -->
<p><span class="caption">表B-1: 演算子</span></p>
<!-- | Operator | Example | Explanation | Overloadable? | -->
<!-- |----------|---------|-------------|---------------| -->
<!-- | `!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Macro expansion | | -->
<!-- | `!` | `!expr` | Bitwise or logical complement | `Not` | -->
<!-- | `!=` | `var != expr` | Nonequality comparison | `PartialEq` | -->
<!-- | `%` | `expr % expr` | Arithmetic remainder | `Rem` | -->
<!-- | `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemAssign` | -->
<!-- | `&` | `&expr`, `&mut expr` | Borrow | | -->
<!-- | `&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Borrowed pointer type | | -->
<!-- | `&` | `expr & expr` | Bitwise AND | `BitAnd` | -->
<!-- | `&=` | `var &= expr` | Bitwise AND and assignment | `BitAndAssign` | -->
<!-- | `&&` | `expr && expr` | Logical AND | | -->
<!-- | `*` | `expr * expr` | Arithmetic multiplication | `Mul` | -->
<!-- | `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulAssign` | -->
<!-- | `*` | `*expr` | Dereference | | -->
<!-- | `*` | `*const type`, `*mut type` | Raw pointer | | -->
<!-- | `+` | `trait + trait`, `'a + trait` | Compound type constraint | | -->
<!-- | `+` | `expr + expr` | Arithmetic addition | `Add` | -->
<!-- | `+=` | `var += expr` | Arithmetic addition and assignment | `AddAssign` | -->
<!-- | `,` | `expr, expr` | Argument and element separator | | -->
<!-- | `-` | `- expr` | Arithmetic negation | `Neg` | -->
<!-- | `-` | `expr - expr` | Arithmetic subtraction | `Sub` | -->
<!-- | `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubAssign` | -->
<!-- | `->` | `fn(...) -> type`, <code>\|...\| -> type</code> | Function and closure return type | | -->
<!-- | `.` | `expr.ident` | Member access | | -->
<!-- | `..` | `..`, `expr..`, `..expr`, `expr..expr` | Right-exclusive range literal | | -->
<!-- | `..` | `..expr` | Struct literal update syntax | | -->
<!-- | `..` | `variant(x, ..)`, `struct_type { x, .. }` | “And the rest” pattern binding | | -->
<!-- | `...` | `expr...expr` | In a pattern: inclusive range pattern | | -->
<!-- | `/` | `expr / expr` | Arithmetic division | `Div` | -->
<!-- | `/=` | `var /= expr` | Arithmetic division and assignment | `DivAssign` | -->
<!-- | `:` | `pat: type`, `ident: type` | Constraints | | -->
<!-- | `:` | `ident: expr` | Struct field initializer | | -->
<!-- | `:` | `'a: loop {...}` | Loop label | | -->
<!-- | `;` | `expr;` | Statement and item terminator | | -->
<!-- | `;` | `[...; len]` | Part of fixed-size array syntax | | -->
<!-- | `<<` | `expr << expr` | Left-shift | `Shl` | -->
<!-- | `<<=` | `var <<= expr` | Left-shift and assignment | `ShlAssign` | -->
<!-- | `<` | `expr < expr` | Less than comparison | `PartialOrd` | -->
<!-- | `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` | -->
<!-- | `=` | `var = expr`, `ident = type` | Assignment/equivalence | | -->
<!-- | `==` | `expr == expr` | Equality comparison | `PartialEq` | -->
<!-- | `=>` | `pat => expr` | Part of match arm syntax | | -->
<!-- | `>` | `expr > expr` | Greater than comparison | `PartialOrd` | -->
<!-- | `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` | -->
<!-- | `>>` | `expr >> expr` | Right-shift | `Shr` | -->
<!-- | `>>=` | `var >>= expr` | Right-shift and assignment | `ShrAssign` | -->
<!-- | `@` | `ident @ pat` | Pattern binding | | -->
<!-- | `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` | -->
<!-- | `^=` | `var ^= expr` | Bitwise exclusive OR and assignment | `BitXorAssign` | -->
<!-- | <code>\|</code> | <code>pat \| pat</code> | Pattern alternatives | | -->
<!-- | <code>\|</code> | <code>expr \| expr</code> | Bitwise OR | `BitOr` | -->
<!-- | <code>\|=</code> | <code>var \|= expr</code> | Bitwise OR and assignment | `BitOrAssign` | -->
<!-- | <code>\|\|</code> | <code>expr \|\| expr</code> | Logical OR | | -->
<!-- | `?` | `expr?` | Error propagation | | -->
<table><thead><tr><th> 演算子             </th><th> 例                                               </th><th> 説明 </th><th> オーバーロードできる？ </th></tr></thead><tbody>
<tr><td> <code>!</code>               </td><td> <code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code>      </td><td> マクロ展開を意味します      </td></tr>
<tr></tr>
<tr><td> <code>!</code>               </td><td> <code>!expr</code>                                          </td><td> ビット反転、または論理反転   </td><td> <code>Not</code> </td></tr>
<tr><td> <code>!=</code>              </td><td> <code>var != expr</code>                                    </td><td> 非等価比較                 </td><td> <code>PartialEq</code> </td></tr>
<tr><td> <code>%</code>               </td><td> <code>expr % expr</code>                                    </td><td> 余り演算                   </td><td> <code>Rem</code> </td></tr>
<tr><td> <code>%=</code>              </td><td> <code>var %= expr</code>                                    </td><td> 余り演算後に代入            </td><td> <code>RemAssign</code> </td></tr>
<tr><td> <code>&amp;</code>               </td><td> <code>&amp;expr</code>, <code>&amp;mut expr</code>                             </td><td> 借用                      </td></tr>
<tr></tr>
<tr><td> <code>&amp;</code>               </td><td> <code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code> </td><td> 借用されたポインタ型        </td></tr>
<tr></tr>
<tr><td> <code>&amp;</code>               </td><td> <code>expr &amp; expr</code>                                    </td><td> ビットAND                 </td><td> <code>BitAnd</code> </td></tr>
<tr><td> <code>&amp;=</code>              </td><td> <code>var &amp;= expr</code>                                    </td><td> ビットAND後に代入          </td><td> <code>BitAndAssign</code> </td></tr>
<tr><td> <code>&amp;&amp;</code>              </td><td> <code>expr &amp;&amp; expr</code>                                   </td><td> 論理AND                   </td></tr>
<tr></tr>
<tr><td> <code>*</code>               </td><td> <code>expr * expr</code>                                    </td><td> 掛け算                    </td><td> <code>Mul</code> </td></tr>
<tr><td> <code>*</code>               </td><td> <code>*expr</code>                                          </td><td> 参照外し                  </td></tr>
<tr></tr>
<tr><td> <code>*</code>               </td><td> <code>*const type</code>, <code>*mut type</code>                       </td><td> 生ポインタ                </td></tr>
<tr></tr>
<tr><td> <code>*=</code>              </td><td> <code>var *= expr</code>                                    </td><td> 掛け算後に代入             </td><td> <code>MulAssign</code> </td></tr>
<tr><td> <code>+</code>               </td><td> <code>trait + trait</code>, <code>'a + trait</code>                    </td><td> 型制限の複合化             </td></tr>
<tr></tr>
<tr><td> <code>+</code>               </td><td> <code>expr + expr</code>                                    </td><td> 足し算                    </td><td> <code>Add</code> </td></tr>
<tr><td> <code>+=</code>              </td><td> <code>var += expr</code>                                    </td><td> 足し算後に代入             </td><td> <code>AddAssign</code> </td></tr>
<tr><td> <code>,</code>               </td><td> <code>expr, expr</code>                                     </td><td> 引数と要素の区別           </td></tr>
<tr></tr>
<tr><td> <code>-</code>               </td><td> <code>- expr</code>                                         </td><td> 算術否定                  </td><td> <code>Neg</code> </td></tr>
<tr><td> <code>-</code>               </td><td> <code>expr - expr</code>                                    </td><td> 引き算                    </td><td> <code>Sub</code> </td></tr>
<tr><td> <code>-=</code>              </td><td> <code>var -= expr</code>                                    </td><td> 引き算後に代入             </td><td> <code>SubAssign</code> </td></tr>
<tr><td> <code>-&gt;</code>              </td><td> <code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code>  </td><td> 関数とクロージャの戻り値型   </td></tr>
<tr></tr>
<tr><td> <code>.</code>               </td><td> <code>expr.ident</code>                                     </td><td> メンバーアクセス            </td></tr>
<tr></tr>
<tr><td> <code>..</code>              </td><td> <code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code>           </td><td> 未満範囲リテラル            </td></tr>
<tr></tr>
<tr><td> <code>..</code>              </td><td> <code>..expr</code>                                         </td><td> 構造体リテラル更新記法       </td></tr>
<tr></tr>
<tr><td> <code>..</code>              </td><td> <code>variant(x, ..)</code>, <code>struct_type { x, .. }</code>        </td><td> 「残り全部」パターン束縛     </td></tr>
<tr></tr>
<tr><td> <code>...</code>             </td><td> <code>expr...expr</code>                                    </td><td> パターンで: 以下範囲パターン </td></tr>
<tr></tr>
<tr><td> <code>/</code>               </td><td> <code>expr / expr</code>                                    </td><td> 割り算                    </td><td> <code>Div</code> </td></tr>
<tr><td> <code>/=</code>              </td><td> <code>var /= expr</code>                                    </td><td> 割り算後に代入             </td><td> <code>DivAssign</code> </td></tr>
<tr><td> <code>:</code>               </td><td> <code>pat: type</code>, <code>ident: type</code>                       </td><td> 型制約                    </td></tr>
<tr></tr>
<tr><td> <code>:</code>               </td><td> <code>ident: expr</code>                                    </td><td> 構造体フィールド初期化子     </td></tr>
<tr></tr>
<tr><td> <code>:</code>               </td><td> <code>'a: loop {...}</code>                                 </td><td> ループラベル               </td></tr>
<tr></tr>
<tr><td> <code>;</code>               </td><td> <code>expr;</code>                                          </td><td> 文、要素終端子             </td></tr>
<tr></tr>
<tr><td> <code>;</code>               </td><td> <code>[...; len]</code>                                     </td><td> 固定長配列記法の一部        </td></tr>
<tr></tr>
<tr><td> <code>&lt;&lt;</code>              </td><td> <code>expr &lt;&lt; expr</code>                                   </td><td> 左シフト                  </td><td> <code>Shl</code> </td></tr>
<tr><td> <code>&lt;&lt;=</code>             </td><td> <code>var &lt;&lt;= expr</code>                                   </td><td> 左シフト後に代入           </td><td> <code>ShlAssign</code> </td></tr>
<tr><td> <code>&lt;</code>               </td><td> <code>expr &lt; expr</code>                                    </td><td> 未満比較                  </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>&lt;=</code>              </td><td> <code>expr &lt;= expr</code>                                   </td><td> 以下比較                  </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>=</code>               </td><td> <code>var = expr</code>, <code>ident = type</code>                     </td><td> 代入/等価                 </td></tr>
<tr></tr>
<tr><td> <code>==</code>              </td><td> <code>expr == expr</code>                                   </td><td> 等価比較                  </td><td> <code>PartialEq</code> </td></tr>
<tr><td> <code>=&gt;</code>              </td><td> <code>pat =&gt; expr</code>                                    </td><td> matchアーム記法の一部      </td></tr>
<tr></tr>
<tr><td> <code>&gt;</code>               </td><td> <code>expr &gt; expr</code>                                    </td><td> より大きい比較             </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>&gt;=</code>              </td><td> <code>expr &gt;= expr</code>                                   </td><td> 以上比較                  </td><td> <code>PartialOrd</code> </td></tr>
<tr><td> <code>&gt;&gt;</code>              </td><td> <code>expr &gt;&gt; expr</code>                                   </td><td> 右シフト                  </td><td> <code>Shr</code> </td></tr>
<tr><td> <code>&gt;&gt;=</code>             </td><td> <code>var &gt;&gt;= expr</code>                                   </td><td> 右シフト後に代入           </td><td> <code>ShrAssign</code> </td></tr>
<tr><td> <code>@</code>               </td><td> <code>ident @ pat</code>                                    </td><td> パターン束縛              </td></tr>
<tr></tr>
<tr><td> <code>^</code>               </td><td> <code>expr ^ expr</code>                                    </td><td> ビットXOR                </td><td> <code>BitXor</code> </td></tr>
<tr><td> <code>^=</code>              </td><td> <code>var ^= expr</code>                                    </td><td> ビットXOR後に代入         </td><td> <code>BitXorAssign</code> </td></tr>
<tr><td> <code>|</code>   </td><td> <code>pat | pat</code>                          </td><td> パターンOR               </td></tr>
<tr></tr>
<tr><td> <code>|</code>   </td><td> <code>|…| expr</code>                          </td><td> クロージャ               </td></tr>
<tr></tr>
<tr><td> <code>|</code>   </td><td> <code>expr | expr</code>                        </td><td> ビットOR                 </td><td> <code>BitOr</code> </td></tr>
<tr><td> <code>|=</code>  </td><td> <code>var |= expr</code>                        </td><td> ビットOR後に代入          </td><td> <code>BitOrAssign</code></td></tr>
<tr><td> <code>||</code> </td><td> <code>expr || expr</code>                      </td><td> 論理OR                   </td></tr>
<tr></tr>
<tr><td> <code>?</code>               </td><td> <code>expr?</code>                                          </td><td> エラー委譲                </td></tr>
<tr></tr>
</tbody></table>
<!-- ### Non-operator Symbols -->
<a class="header" href="print.html#a演算子以外のシンボル" id="a演算子以外のシンボル"><h3>演算子以外のシンボル</h3></a>
<!-- The following list contains all non-letters that don’t function as operators; -->
<!-- that is, they don’t behave like a function or method call. -->
<p>以下のリストは、演算子として機能しない記号全部を含んでいます; つまり、関数やメソッド呼び出しのようには、
振る舞わないということです。</p>
<!-- Table B-2 shows symbols that appear on their own and are valid in a variety of -->
<!-- locations. -->
<p>表B-2は、単独で出現し、いろんな箇所で合法になるシンボルを示しています。</p>
<!-- <span class="caption">Table B-2: Stand-Alone Syntax</span> -->
<p><span class="caption">表B-2: スタンドアローン記法</span></p>
<!-- | Symbol | Explanation | -->
<!-- |--------|-------------| -->
<!-- | `'ident` | Named lifetime or loop label | -->
<!-- | `...u8`, `...i32`, `...f64`, `...usize`, etc. | Numeric literal of specific type | -->
<!-- | `"..."` | String literal | -->
<!-- | `r"..."`, `r#"..."#`, `r##"..."##`, etc. | Raw string literal, escape characters not processed | -->
<!-- | `b"..."` | Byte string literal; constructs a `[u8]` instead of a string | -->
<!-- | `br"..."`, `br#"..."#`, `br##"..."##`, etc. | Raw byte string literal, combination of raw and byte string literal | -->
<!-- | `'...'` | Character literal | -->
<!-- | `b'...'` | ASCII byte literal | -->
<!-- | <code>\|...\| expr</code> | Closure | -->
<!-- | `!` | Always empty bottom type for diverging functions | -->
<!-- | `_` | “Ignored” pattern binding; also used to make integer literals readable | -->
<table><thead><tr><th> シンボル                                         </th><th> 説明  </th></tr></thead><tbody>
<tr><td> <code>'ident</code>                                        </td><td> 名前付きのライフタイム、あるいはループラベル </td></tr>
<tr><td> <code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>など     </td><td> 特定の型の数値リテラル </td></tr>
<tr><td> <code>&quot;...&quot;</code>                                         </td><td> 文字列リテラル</td></tr>
<tr><td> <code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>など          </td><td> 生文字列リテラル、エスケープ文字は処理されません </td></tr>
<tr><td> <code>b&quot;...&quot;</code>                                        </td><td> バイト文字列リテラル、文字列の代わりに<code>[u8]</code>を構築します </td></tr>
<tr><td> <code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>など       </td><td> 生バイト文字列リテラル、生文字列とバイト文字列の組み合わせ </td></tr>
<tr><td> <code>'...'</code>                                         </td><td> 文字リテラル </td></tr>
<tr><td> <code>b'...'</code>                                        </td><td> ASCIIバイトリテラル </td></tr>
<tr><td> <code>|...| expr</code>                       </td><td> クロージャ </td></tr>
<tr><td> <code>!</code>                                             </td><td> 常に発散関数の空のボトム型 </td></tr>
<tr><td> <code>_</code>                                             </td><td> 「無視」パターン束縛: 整数リテラルを見やすくするのにも使われる</td></tr>
</tbody></table>
<!-- Table B-3 shows symbols that appear in the context of a path through the module -->
<!-- hierarchy to an item. -->
<p>表B-3は、要素へのモジュールヒエラルキーを通したパスの文脈で出現するシンボルを示しています。</p>
<!-- <span class="caption">Table B-3: Path-Related Syntax</span> -->
<p><span class="caption">表B-3: パス関連記法</span></p>
<!-- | Symbol | Explanation | -->
<!-- |--------|-------------| -->
<!-- | `ident::ident` | Namespace path | -->
<!-- | `::path` | Path relative to the crate root (i.e., an explicitly absolute path) | -->
<!-- | `self::path` | Path relative to the current module (i.e., an explicitly relative path). -->
<!-- | `super::path` | Path relative to the parent of the current module | -->
<!-- | `type::ident`, `<type as trait>::ident` | Associated constants, functions, and types | -->
<!-- | `<type>::...` | Associated item for a type that cannot be directly named (e.g., `<&T>::...`, `<[T]>::...`, etc.) | -->
<!-- | `trait::method(...)` | Disambiguating a method call by naming the trait that defines it | -->
<!-- | `type::method(...)` | Disambiguating a method call by naming the type for which it’s defined | -->
<!-- | `<type as trait>::method(...)` | Disambiguating a method call by naming the trait and type | -->
<table><thead><tr><th> シンボル                                 </th><th> 説明 </th></tr></thead><tbody>
<tr><td> <code>ident::ident</code>                          </td><td> 名前空間パス </td></tr>
<tr><td> <code>::path</code>                                </td><td> クレートルートに相対的なパス(すなわち、明示的な絶対パス) </td></tr>
<tr><td> <code>self::path</code>                            </td><td> 現在のモジュールに相対的なパス(すなわち、明示的な相対パス) </td></tr>
<tr><td> <code>super::path</code>                           </td><td> 現在のモジュールの親モジュールに相対的なパス </td></tr>
<tr><td> <code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code> </td><td> 関連定数、関数、型 </td></tr>
<tr><td> <code>&lt;type&gt;::...</code>                           </td><td> 直接名前付けできない型の関連要素(例, <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>など) </td></tr>
<tr><td> <code>trait::method(...)</code>                    </td><td> 定義したトレイトを名指ししてメソッド呼び出しを明確化する </td></tr>
<tr><td> <code>type::method(...)</code>                     </td><td> 定義されている型を名指ししてメソッド呼び出しを明確化する </td></tr>
<tr><td> <code>&lt;type as trait&gt;::method(...)</code>          </td><td> トレイト<em>と</em>型を名指ししてメソッド呼び出しを明確化する</td></tr>
</tbody></table>
<!-- Table B-4 shows symbols that appear in the context of using generic type -->
<!-- parameters. -->
<p>表B-4は、ジェネリックな型引数の文脈で出現するシンボルを示しています。</p>
<!-- <span class="caption">Table B-4: Generics</span> -->
<p><span class="caption">表B-4: ジェネリクス</span></p>
<!-- | Symbol | Explanation | -->
<!-- |--------|-------------| -->
<!-- | `path<...>` | Specifies parameters to generic type in a type (e.g., `Vec<u8>`) | -->
<!-- | `path::<...>`, `method::<...>` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., `"42".parse::<i32>()`) | -->
<!-- | `fn ident<...> ...` | Define generic function | -->
<!-- | `struct ident<...> ...` | Define generic structure | -->
<!-- | `enum ident<...> ...` | Define generic enumeration | -->
<!-- | `impl<...> ...` | Define generic implementation | -->
<!-- | `for<...> type` | Higher-ranked lifetime bounds | -->
<!-- | `type<ident=type>` | A generic type where one or more associated types have specific assignments (e.g., `Iterator<Item=T>`) | -->
<table><thead><tr><th> シンボル                        </th><th> 説明 </th></tr></thead><tbody>
<tr><td> <code>path&lt;...&gt;</code>                    </td><td> 型の内部のジェネリック型への引数を指定する(例、<code>Vec&lt;u8&gt;</code>) </td></tr>
<tr><td> <code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code> </td><td> 式中のジェネリックな型、関数、メソッドへの引数を指定する。しばしばターボ・フィッシュ(turbofish))と称される。(例、<code>&quot;42&quot;.parse::&lt;i32&gt;()</code>) </td></tr>
<tr><td> <code>fn ident&lt;...&gt; ...</code>            </td><td> ジェネリックな関数を定義する </td></tr>
<tr><td> <code>struct ident&lt;...&gt; ...</code>        </td><td> ジェネリックな構造体を定義する </td></tr>
<tr><td> <code>enum ident&lt;...&gt; ...</code>          </td><td> ジェネリックな列挙型を定義する </td></tr>
<tr><td> <code>impl&lt;...&gt; ...</code>                </td><td> ジェネリックな実装を定義する </td></tr>
<tr><td> <code>for&lt;...&gt; type</code>                </td><td> 高階ライフタイム境界 </td></tr>
<tr><td> <code>type&lt;ident=type&gt;</code>             </td><td> 1つ以上の関連型に代入されたジェネリックな型(例、<code>Iterator&lt;Item=T&gt;</code>) </td></tr>
</tbody></table>
<!-- Table B-5 shows symbols that appear in the context of constraining generic type -->
<!-- parameters with trait bounds. -->
<p>表B-5は、ジェネリック型引数をトレイト境界で制約する文脈で出現するシンボルを示しています。</p>
<!-- <span class="caption">Table B-5: Trait Bound Constraints</span> -->
<p><span class="caption">表B-5: トレイト境界制約</span></p>
<!-- | Symbol | Explanation | -->
<!-- |--------|-------------| -->
<!-- | `T: U` | Generic parameter `T` constrained to types that implement `U` | -->
<!-- | `T: 'a` | Generic type `T` must outlive lifetime `'a` (meaning the type cannot transitively contain any references with lifetimes shorter than `'a`) | -->
<!-- | `T : 'static` | Generic type `T` contains no borrowed references other than `'static` ones | -->
<!-- | `'b: 'a` | Generic lifetime `'b` must outlive lifetime `'a` | -->
<!-- | `T: ?Sized` | Allow generic type parameter to be a dynamically sized type | -->
<!-- | `'a + trait`, `trait + trait` | Compound type constraint | -->
<table><thead><tr><th> シンボル                       </th><th> 説明 </th></tr></thead><tbody>
<tr><td> <code>T: U</code>                        </td><td> <code>U</code>を実装する型に制約されるジェネリック引数<code>T</code> </td></tr>
<tr><td> <code>T: 'a</code>                       </td><td> ライフタイム<code>'a</code>よりも長生きしなければならないジェネリック型<code>T</code>(型がライフタイムより長生きするとは、<code>'a</code>よりも短いライフタイムの参照を何も遷移的に含めないことを意味する)</td></tr>
<tr><td> <code>T : 'static</code>                 </td><td> ジェネリック型<code>T</code>が<code>'static</code>なもの以外の借用された参照を何も含まない </td></tr>
<tr><td> <code>'b: 'a</code>                      </td><td> ジェネリックなライフタイム<code>'b</code>がライフタイム<code>'a</code>より長生きしなければならない </td></tr>
<tr><td> <code>T: ?Sized</code>                   </td><td> ジェネリック型引数が動的サイズ付け型であることを許容する </td></tr>
<tr><td> <code>'a + trait</code>, <code>trait + trait</code> </td><td> 複合型制約 </td></tr>
</tbody></table>
<!-- Table B-6 shows symbols that appear in the context of calling or defining -->
<!-- macros and specifying attributes on an item. -->
<p>表B-6は、マクロの呼び出しや定義、要素にアトリビュートを指定する文脈で出現するシンボルを示しています。</p>
<!-- <span class="caption">Table B-6: Macros and Attributes</span> -->
<p><span class="caption">表B-6: マクロとアトリビュート</span></p>
<!-- | Symbol | Explanation | -->
<!-- |--------|-------------| -->
<!-- | `#[meta]` | Outer attribute | -->
<!-- | `#![meta]` | Inner attribute | -->
<!-- | `$ident` | Macro substitution | -->
<!-- | `$ident:kind` | Macro capture | -->
<!-- | `$(…)…` | Macro repetition | -->
<table><thead><tr><th> シンボル       </th><th> 説明 </th></tr></thead><tbody>
<tr><td> <code>#[meta]</code>     </td><td> 外部アトリビュート </td></tr>
<tr><td> <code>#![meta]</code>    </td><td> 内部アトリビュート </td></tr>
<tr><td> <code>$ident</code>      </td><td> マクロ代用 </td></tr>
<tr><td> <code>$ident:kind</code> </td><td> マクロキャプチャ </td></tr>
<tr><td> <code>$(…)…</code>       </td><td> マクロの繰り返し </td></tr>
</tbody></table>
<!-- Table B-7 shows symbols that create comments. -->
<p>表B-7は、コメントを生成します。</p>
<!-- <span class="caption">Table B-7: Comments</span> -->
<p><span class="caption">表B-7: コメント</span></p>
<!-- | Symbol | Explanation | -->
<!-- |--------|-------------| -->
<!-- | `//` | Line comment | -->
<!-- | `//!` | Inner line doc comment | -->
<!-- | `///` | Outer line doc comment | -->
<!-- | `/*...*/` | Block comment | -->
<!-- | `/*!...*/` | Inner block doc comment | -->
<!-- | `/**...*/` | Outer block doc comment | -->
<table><thead><tr><th> シンボル    </th><th> 説明 </th></tr></thead><tbody>
<tr><td> <code>//</code>       </td><td> 行コメント </td></tr>
<tr><td> <code>//!</code>      </td><td> 内部行docコメント </td></tr>
<tr><td> <code>///</code>      </td><td> 外部行docコメント </td></tr>
<tr><td> <code>/*...*/</code>  </td><td> ブロックコメント </td></tr>
<tr><td> <code>/*!...*/</code> </td><td> 内部ブロックdocコメント </td></tr>
<tr><td> <code>/**...*/</code> </td><td> 外部ブロックdocコメント </td></tr>
</tbody></table>
<!-- #### Tuples -->
<a class="header" href="print.html#aタプル" id="aタプル"><h4>タプル</h4></a>
<!-- Table B-8 shows symbols that appear in the context of using tuples. -->
<p>表B-8は、タプルの文脈で出現するシンボルを示しています。</p>
<!-- <span class="caption">Table B-8: Tuples</span> -->
<p><span class="caption">表B-8: タプル</span></p>
<!-- | Symbol | Explanation | -->
<!-- |--------|-------------| -->
<!-- | `()` | Empty tuple (aka unit), both literal and type | -->
<!-- | `(expr)` | Parenthesized expression | -->
<!-- | `(expr,)` | Single-element tuple expression | -->
<!-- | `(type,)` | Single-element tuple type | -->
<!-- | `(expr, ...)` | Tuple expression | -->
<!-- | `(type, ...)` | Tuple type | -->
<!-- | `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants | -->
<!-- | `ident!(...)`, `ident!{...}`, `ident![...]` | Macro invocation | -->
<!-- | `expr.0`, `expr.1`, etc. | Tuple indexing | -->
<table><thead><tr><th> シンボル                                     </th><th> 説明 </th></tr></thead><tbody>
<tr><td> <code>()</code>                                        </td><td> 空のタプル (unitとしても知られる)、リテラル、型両方 </td></tr>
<tr><td> <code>(expr)</code>                                    </td><td> 括弧付きの式 </td></tr>
<tr><td> <code>(expr,)</code>                                   </td><td> 1要素タプル式 </td></tr>
<tr><td> <code>(type,)</code>                                   </td><td> 1要素タプル型 </td></tr>
<tr><td> <code>(expr, ...)</code>                               </td><td> タプル式 </td></tr>
<tr><td> <code>(type, ...)</code>                               </td><td> タプル型 </td></tr>
<tr><td> <code>expr(expr, ...)</code>                           </td><td> 関数呼び出し式; tuple <code>struct</code>やtuple <code>enum</code>列挙子を初期化するのにも使用される </td></tr>
<tr><td> <code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code> </td><td> マクロ呼び出し </td></tr>
<tr><td> <code>expr.0</code>, <code>expr.1</code>, など                     </td><td> タプル添え字アクセス </td></tr>
</tbody></table>
<!-- Table B-9 shows the contexts in which curly braces are used. -->
<p>表B-9は、波括弧が使用される文脈を表示しています。</p>
<!-- <span class="caption">Table B-9: Curly Brackets</span> -->
<p><span class="caption">表B-9: 波括弧</span></p>
<!-- | Context | Explanation | -->
<!-- |---------|-------------| -->
<!-- | `{...}` | Block expression | -->
<!-- | `Type {...}` | `struct` literal | -->
<table><thead><tr><th> 文脈          </th><th> 説明 </th></tr></thead><tbody>
<tr><td> <code>{...}</code>      </td><td> ブロック式 </td></tr>
<tr><td> <code>Type {...}</code> </td><td> <code>struct</code>リテラル </td></tr>
</tbody></table>
<!-- Table B-10 shows the contexts in which square brackets are used. -->
<p>表B-10は、角括弧が使用される文脈を表示しています。</p>
<!-- <span class="caption">Table B-10: Square Brackets</span> -->
<p><span class="caption">表B-10: 角括弧</span></p>
<!-- | Context | Explanation | -->
<!-- |---------|-------------| -->
<!-- | `[...]` | Array literal | -->
<!-- | `[expr; len]` | Array literal containing `len` copies of `expr` | -->
<!-- | `[type; len]` | Array type containing `len` instances of `type` | -->
<!-- | `expr[expr]` | Collection indexing. Overloadable (`Index`, `IndexMut`) | -->
<!-- | `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Collection indexing pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, or `RangeFull` as the “index” | -->
<table><thead><tr><th> 文脈                                               </th><th> 説明 </th></tr></thead><tbody>
<tr><td> <code>[...]</code>                                            </td><td> 配列リテラル </td></tr>
<tr><td> <code>[expr; len]</code>                                      </td><td> <code>len</code>個<code>expr</code>を含む配列リテラル </td></tr>
<tr><td> <code>[type; len]</code>                                      </td><td> <code>len</code>個の<code>type</code>のインスタンスを含む配列型 </td></tr>
<tr><td> <code>expr[expr]</code>                                       </td><td> コレクション添え字アクセス。オーバーロード可能 (<code>Index</code>, <code>IndexMut</code>) </td></tr>
<tr><td> <code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code> </td><td> <code>Range</code>、<code>RangeFrom</code>、<code>RangeTo</code>、<code>RangeFull</code>を「添え字」として使用してコレクション・スライシングの振りをするコレクション添え字アクセス </td></tr>
</tbody></table>
<!-- ## Appendix C: Derivable Traits -->
<a class="header" href="print.html#a付録c-継承可能なトレイト" id="a付録c-継承可能なトレイト"><h2>付録C: 継承可能なトレイト</h2></a>
<!-- In various places in the book, we’ve discussed the `derive` attribute, which -->
<!-- you can apply to a struct or enum definition. The `derive` attribute generates -->
<!-- code that will implement a trait with its own default implementation on the -->
<!-- type you’ve annotated with the `derive` syntax. -->
<p>本のいろんな箇所で<code>derive</code>アトリビュートについて議論しました。これは構造体や、enum定義に適用できます。
<code>derive</code>アトリビュートは、<code>derive</code>記法で注釈した型に対して独自の規定の実装でトレイトを実装するコードを生成します。</p>
<!-- In this appendix, we provide a reference of all the traits in the standard -->
<!-- library that you can use with `derive`. Each section covers: -->
<p>この付録では、標準ライブラリの<code>derive</code>と共に使用できる全トレイトの参照を提供します。各節は以下を講義します:</p>
<!-- * What operators and methods deriving this trait will enable -->
<!-- * What the implementation of the trait provided by `derive` does -->
<!-- * What implementing the trait signifies about the type -->
<!-- * The conditions in which you’re allowed or not allowed to implement the trait -->
<!-- * Examples of operations that require the trait -->
<ul>
<li>このトレイトを継承する演算子やメソッドで可能になること</li>
<li><code>derive</code>が提供するトレイトの実装がすること</li>
<li>トレイトを実装することが型についてどれほど重要か</li>
<li>そのトレイトを実装できたりできなかったりする条件</li>
<li>そのトレイトが必要になる処理の例</li>
</ul>
<!-- If you want different behavior than that provided by the `derive` attribute, -->
<!-- consult the standard library documentation for each trait for details on how to -->
<!-- manually implement them. -->
<p><code>derive</code>アトリビュートが提供する以外の異なる振る舞いが欲しいなら、それらを手動で実装する方法の詳細について、
各トレイトの標準ライブラリのドキュメンテーションを調べてください。</p>
<!-- The rest of the traits defined in the standard library can’t be implemented on -->
<!-- your types using `derive`. These traits don’t have sensible default behavior, -->
<!-- so it’s up to you to implement them in the way that makes sense for what you’re -->
<!-- trying to accomplish. -->
<p>標準ライブラリで定義されている残りのトレイトは、<code>derive</code>で自分の型に実装することはできません。
これらのトレイトには知覚できるほどの規定の振る舞いはないので、自分が達成しようしていることに対して、
道理が通る方法でそれらを実装するのはあなた次第です。</p>
<!-- An example of a trait that can’t be derived is `Display`, which handles -->
<!-- formatting for end users. You should always consider the appropriate way to -->
<!-- display a type to an end user. What parts of the type should an end user be -->
<!-- allowed to see? What parts would they find relevant? What format of the data -->
<!-- would be most relevant to them? The Rust compiler doesn’t have this insight, so -->
<!-- it can’t provide appropriate default behavior for you. -->
<p>継承できないトレイトの例は<code>Display</code>で、これはエンドユーザ向けにフォーマットを扱います。常に、エンドユーザ向けに型を表示する適切な方法について、
考慮すべきです。型のどの部分をエンドユーザは見ることができるべきでしょうか？どの部分を関係があると考えるでしょうか？
どんな形式のデータがエンドユーザにとって最も関係があるでしょうか？Rustコンパイラには、
この見識がないため、適切な規定動作を提供してくれないのです。</p>
<!-- The list of derivable traits provided in this appendix is not comprehensive: -->
<!-- libraries can implement `derive` for their own traits, making the list of -->
<!-- traits you can use `derive` with truly open-ended. Implementing `derive` -->
<!-- involves using a procedural macro, which is covered in Appendix D. -->
<p>この付録で提供される継承可能なトレイトのリストは、包括的ではありません: ライブラリは、自身のトレイトに<code>derive</code>を実装でき、
<code>derive</code>と共に使用できるトレイトのリストが実に限りのないものになってしまうのです。<code>derive</code>の実装には、
プロシージャルなマクロが関連します。マクロについては、付録Dで講義します。</p>
<!-- ### `Debug` for Programmer Output -->
<a class="header" href="print.html#aプログラマ用の出力のdebug" id="aプログラマ用の出力のdebug"><h3>プログラマ用の出力の<code>Debug</code></h3></a>
<!-- The `Debug` trait enables debug formatting in format strings, which you -->
<!-- indicate by adding `:?` within `{}` placeholders. -->
<p><code>Debug</code>トレイトにより、フォーマット文字列でのデバッグ成形が可能になり、
<code>{}</code>プレースホルダー内に<code>:?</code>を追記することで表します。</p>
<!-- The `Debug` trait allows you to print instances of a type for debugging -->
<!-- purposes, so you and other programmers using your type can inspect an instance -->
<!-- at a particular point in a program’s execution. -->
<p><code>Debug</code>トレイトにより、デバッグ目的で型のインスタンスを出力できるようになるので、あなたや型を使用する他のプログラマが、
プログラムの実行の特定の箇所でインスタンスを調べられます。</p>
<!-- The `Debug` trait is required, for example, in use of the `assert_eq!` macro. -->
<!-- This macro prints the values of instances given as arguments if the equality -->
<!-- assertion fails so programmers can see why the two instances weren’t equal. -->
<p><code>Debug</code>トレイトは、例えば、<code>assert_eq!</code>マクロを使用する際などに必要になります。
このマクロは、プログラマがどうして2つのインスタンスが等価でなかったのか確認できるように、
等価アサートが失敗したら、引数として与えられたインスタンスの値を出力します。</p>
<!-- ### `PartialEq` and `Eq` for Equality Comparisons -->
<a class="header" href="print.html#a等価比較のためのpartialeqとeq" id="a等価比較のためのpartialeqとeq"><h3>等価比較のための<code>PartialEq</code>と<code>Eq</code></h3></a>
<!-- The `PartialEq` trait allows you to compare instances of a type to check for -->
<!-- equality and enables use of the `==` and `!=` operators. -->
<p><code>PartialEq</code>トレイトにより、型のインスタンスを比較でき、等価性をチェックし、<code>==</code>と<code>!=</code>演算子の使用を可能にします。</p>
<!-- Deriving `PartialEq` implements the `eq` method. When `PartialEq` is derived on -->
<!-- structs, two instances are equal only if *all* fields are equal, and the -->
<!-- instances are not equal if any fields are not equal. When derived on enums, -->
<!-- each variant is equal to itself and not equal to the other variants. -->
<p><code>PartialEq</code>を継承すると、<code>eq</code>メソッドを実装します。構造体に<code>PartialEq</code>を継承すると、
<em>全</em>フィールドが等しい時のみ2つのインスタンスは等価になり、いずれかのフィールドが等価でなければ、
インスタンスは等価ではなくなります。enumに継承すると、各列挙子は、自身には等価ですが、他の列挙子には等価ではありません。</p>
<!-- The `PartialEq` trait is required, for example, with the use of the -->
<!-- `assert_eq!` macro, which needs to be able to compare two instances of a type -->
<!-- for equality. -->
<p><code>PartialEq</code>トレイトは例えば、<code>assert_eq!</code>マクロを使用する際に必要になります。
これは、等価性のために型の2つのインスタンスを比較できる必要があります。</p>
<!-- The `Eq` trait has no methods. Its purpose is to signal that for every value of -->
<!-- the annotated type, the value is equal to itself. The `Eq` trait can only be -->
<!-- applied to types that also implement `PartialEq`, although not all types that -->
<!-- implement `PartialEq` can implement `Eq`. One example of this is floating point -->
<!-- number types: the implementation of floating point numbers states that two -->
<!-- instances of the not-a-number (`NaN`) value are not equal to each other. -->
<p><code>Eq</code>トレイトにはメソッドはありません。その目的は、注釈された型の全値に対して、値が自身と等しいことを通知することです。
<code>Eq</code>トレイトは、<code>PartialEq</code>を実装する全ての型が<code>Eq</code>を実装できるわけではないものの、
<code>PartialEq</code>も実装する型に対してのみ適用できます。これの一例は、浮動小数点数型です:
浮動小数点数の実装により、非数字(<code>NaN</code>)値の2つのインスタンスはお互いに等価ではないことが宣言されます。</p>
<!-- An example of when `Eq` is required is for keys in a `HashMap<K, V>` so the -->
<!-- `HashMap<K, V>` can tell whether two keys are the same. -->
<p><code>Eq</code>が必要になる一例が、<code>HashMap&lt;K, V&gt;</code>のキーで、<code>HashMap&lt;K, V&gt;</code>が、2つのキーが同じであることがわかります。</p>
<!-- ### `PartialOrd` and `Ord` for Ordering Comparisons -->
<a class="header" href="print.html#a順序付き比較のためのpartialordとord" id="a順序付き比較のためのpartialordとord"><h3>順序付き比較のための<code>PartialOrd</code>と<code>Ord</code></h3></a>
<!-- The `PartialOrd` trait allows you to compare instances of a type for sorting -->
<!-- purposes. A type that implements `PartialOrd` can be used with the `<`, `>`, -->
<!-- `<=`, and `>=` operators. You can only apply the `PartialOrd` trait to types -->
<!-- that also implement `PartialEq`. -->
<p><code>PartialOrd</code>トレイトにより、ソートする目的で型のインスタンスを比較できます。<code>PartialOrd</code>を実装する型は、
<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>演算子を使用することができます。<code>PartialEq</code>も実装する型に対してのみ、
<code>PartialOrd</code>トレイトを適用できます。</p>
<!-- Deriving `PartialOrd` implements the `partial_cmp` method, which returns an -->
<!-- `Option<Ordering>` that will be `None` when the values given don’t produce an -->
<!-- ordering. An example of a value that doesn’t produce an ordering, even though -->
<!-- most values of that type can be compared, is the not-a-number (`NaN`) floating -->
<!-- point value. Calling `partial_cmp` with any floating point number and the `NaN` -->
<!-- floating point value will return `None`. -->
<p><code>PartialOrd</code>を継承すると、<code>partial_cmp</code>メソッドを実装し、これは、与えられた値が順序付けられない時に<code>None</code>になる<code>Option&lt;Ordering&gt;</code>を返します。
その型のほとんどの値は比較できるものの、順序付けできない値の例として、非数字(<code>NaN</code>)浮動小数点値が挙げられます。
<code>partial_cmp</code>を浮動小数点数と<code>NaN</code>浮動小数点数で呼び出すと、<code>None</code>が返るでしょう。</p>
<!-- When derived on structs, `PartialOrd` compares two instances by comparing the -->
<!-- value in each field in the order in which the fields appear in the struct -->
<!-- definition. When derived on enums, variants of the enum declared earlier in the -->
<!-- enum definition are considered less than the variants listed later. -->
<p>構造体に継承すると、フィールドが構造体定義で現れる順番で各フィールドの値を比較することで2つのインスタンスを比較します。
enumに継承すると、enum定義で先に定義された列挙子が、後に列挙された列挙子よりも小さいと考えられます。</p>
<!-- The `PartialOrd` trait is required, for example, for the `gen_range` method -->
<!-- from the `rand` crate that generates a random value in the range specified by a -->
<!-- low value and a high value. -->
<p><code>PartialOrd</code>トレイトが必要になる例には、低い値と高い値で指定される範囲の乱数を生成する<code>rand</code>クレートの<code>gen_range</code>メソッドが挙げられます。</p>
<!-- The `Ord` trait allows you to know that for any two values of the annotated -->
<!-- type, a valid ordering will exist. The `Ord` trait implements the `cmp` method, -->
<!-- which returns an `Ordering` rather than an `Option<Ordering>` because a valid -->
<!-- ordering will always be possible. You can only apply the `Ord` trait to types -->
<!-- that also implement `PartialOrd` and `Eq` (and `Eq` requires `PartialEq`). When -->
<!-- derived on structs and enums, `cmp` behaves the same way as the derived -->
<!-- implementation for `partial_cmp` does with `PartialOrd`. -->
<p><code>Ord</code>トレイトにより、注釈した型のあらゆる2つの値に対して、合法な順序付けが行えることがわかります。
<code>Ord</code>トレイトは<code>cmp</code>メソッドを実装し、これは、常に合法な順序付けが可能なので、<code>Option&lt;Ordering&gt;</code>ではなく、
<code>Ordering</code>を返します。<code>PartialOrd</code>と<code>Eq</code>(<code>Eq</code>は<code>PartialEq</code>も必要とします)も実装している型にしか、
<code>Ord</code>トレイトを適用することはできません。構造体とenumで継承したら、<code>PartialOrd</code>で、
<code>partial_cmp</code>の継承した実装と同じように<code>cmp</code>は振る舞います。</p>
<!-- An example of when `Ord` is required is when storing values in a `BTreeSet<T>`, -->
<!-- a data structure that stores data based on the sort order of the values. -->
<p><code>Ord</code>が必要になる例は、<code>BTreeSet&lt;T&gt;</code>に値を格納する時です。
これは、値のソート順に基づいてデータを格納するデータ構造です。</p>
<!-- ### `Clone` and `Copy` for Duplicating Values -->
<a class="header" href="print.html#a値を複製するcloneとcopy" id="a値を複製するcloneとcopy"><h3>値を複製する<code>Clone</code>と<code>Copy</code></h3></a>
<!-- The `Clone` trait allows you to explicitly create a deep copy of a value, and -->
<!-- the duplication process might involve running arbitrary code and copying heap -->
<!-- data. See the “Ways Variables and Data Interact: Clone” section in Chapter 4 -->
<!-- for more information on `Clone`. -->
<p><code>Clone</code>トレイトにより値のディープコピーを明示的に行うことができ、複製のプロセスは、任意のコードを実行し、
ヒープデータをコピーすることに関係がある可能性があります。<code>Clone</code>について詳しくは、
第4章の「変数とデータの相互作用法: Clone」節を参照されたし。</p>
<!-- Deriving `Clone` implements the `clone` method, which when implemented for the -->
<!-- whole type, calls `clone` on each of the parts of the type. This means all the -->
<!-- fields or values in the type must also implement `Clone` to derive `Clone`. -->
<p><code>Clone</code>を継承すると、<code>clone</code>メソッドを実装し、これは型全体に対して実装されると、
型の各部品に対して<code>clone</code>を呼び出します。要するに、<code>Clone</code>を継承するには、
型のフィールドと値全部も<code>Clone</code>を実装していなければならないということです。</p>
<!-- An example of when `Clone` is required is when calling the `to_vec` method on a -->
<!-- slice. The slice doesn’t own the type instances it contains, but the vector -->
<!-- returned from `to_vec` will need to own its instances, so `to_vec` calls -->
<!-- `clone` on each item. Thus, the type stored in the slice must implement `Clone`. -->
<p><code>Clone</code>が必要になる例は、スライスに対して<code>to_vec</code>メソッドを呼び出すことです。スライスは、
含んでいる型のインスタンスの所有権を持たないが、<code>to_vec</code>で返されるベクタはそのインスタンスを所有する必要があるので、
<code>to_vec</code>は各要素に対して<code>clone</code>を呼び出します。故に、スライスに格納される型は、<code>Clone</code>を実装しなければならないのです。</p>
<!-- The `Copy` trait allows you to duplicate a value by only copying bits stored on -->
<!-- the stack; no arbitrary code is necessary. See the “Stack-Only Data: Copy” -->
<!-- section in Chapter 4 for more information on `Copy`. -->
<p><code>Copy</code>トレイトにより、スタックに格納された部分をコピーするだけで値を複製できます; 任意のコードは必要ありません。
<code>Copy</code>について詳しくは、第4章の「スタックのみのデータ: Copy」を参照されたし。</p>
<!-- The `Copy` trait doesn’t define any methods to prevent programmers from -->
<!-- overloading those methods and violating the assumption that no arbitrary code -->
<!-- is being run. That way, all programmers can assume that copying a value will be -->
<!-- very fast. -->
<p><code>Copy</code>トレイトは、プログラマがメソッドをオーバーロードし、任意のコードが実行されないという前提を侵害することを妨げるメソッドは何も定義しません。
そのため、全プログラマは、値のコピーは非常に高速であることを前提にすることができます。</p>
<!-- You can derive `Copy` on any type whose parts all implement `Copy`. You can -->
<!-- only apply the `Copy` trait to types that also implement `Clone`, because a -->
<!-- type that implements `Copy` has a trivial implementation of `Clone` that -->
<!-- performs the same task as `Copy`. -->
<p>部品すべてが<code>Copy</code>を実装する任意の型に対して<code>Copy</code>を継承することができます。<code>Clone</code>も実装する型に対してのみ、
<code>Copy</code>トレイトを適用することができます。何故なら、<code>Copy</code>を実装する型には、
<code>Copy</code>と同じ作業を行う<code>Clone</code>の<ruby>瑣末<rp>(</rp><rt>さまつ</rt><rp>)</rp></ruby>な実装があるからです。</p>
<!-- The `Copy` trait is rarely required; types that implement `Copy` have -->
<!-- optimizations available, meaning you don’t have to call `clone`, which makes -->
<!-- the code more concise. -->
<p><code>Copy</code>トレイトは稀にしか必要になりません; <code>Copy</code>を実装する型では最適化が利用可能になります。
つまり、<code>clone</code>を呼び出す必要がなくなり、コードがより簡潔になるということです。</p>
<!-- Everything possible with `Copy` you can also accomplish with `Clone`, but the -->
<!-- code might be slower or have to use `clone` in places. -->
<p><code>Clone</code>で達成可能なこと全てが<code>Copy</code>でも可能ですが、コードがより遅い可能性や、
<code>clone</code>を使用しなければならない箇所があったりします。</p>
<!-- ### `Hash` for Mapping a Value to a Value of Fixed Size -->
<a class="header" href="print.html#a値を固定サイズの値にマップするhash" id="a値を固定サイズの値にマップするhash"><h3>値を固定サイズの値にマップする<code>Hash</code></h3></a>
<!-- The `Hash` trait allows you to take an instance of a type of arbitrary size and -->
<!-- map that instance to a value of fixed size using a hash function. Deriving -->
<!-- `Hash` implements the `hash` method. The derived implementation of the `hash` -->
<!-- method combines the result of calling `hash` on each of the parts of the type, -->
<!-- meaning all fields or values must also implement `Hash` to derive `Hash`. -->
<p><code>Hash</code>トレイトにより、任意のサイズの型のインスタンスを取り、そのインスタンスをハッシュ関数で固定サイズの値にマップできます。
<code>Hash</code>を継承すると、<code>hash</code>メソッドを実装します。<code>hash</code>の継承された実装は、
型の各部品に対して呼び出した<code>hash</code>の結果を組み合わせます。つまり、<code>Hash</code>を継承するには、
全フィールドと値も<code>Hash</code>を実装しなければならないということです。</p>
<!-- An example of when `Hash` is required is in storing keys in a `HashMap<K, V>` -->
<!-- to store data efficiently. -->
<p><code>Hash</code>が必要になる例は、<code>HashMap&lt;K, V&gt;</code>にキーを格納し、データを効率的に格納することです。</p>
<!-- ### `Default` for Default Values -->
<a class="header" href="print.html#a既定値のためのdefault" id="a既定値のためのdefault"><h3>既定値のための<code>Default</code></h3></a>
<!-- The `Default` trait allows you to create a default value for a type. Deriving -->
<!-- `Default` implements the `default` function. The derived implementation of the -->
<!-- `default` function calls the `default` function on each part of the type, -->
<!-- meaning all fields or values in the type must also implement `Default` to -->
<!-- derive `Default.` -->
<p><code>Default</code>トレイトにより、型に対して既定値を生成できます。<code>Default</code>を継承すると、<code>default</code>関数を実装します。
<code>default</code>関数の継承された実装は、型の各部品に対して<code>default</code>関数を呼び出します。つまり、
<code>Default</code>を継承するには、型の全フィールドと値も<code>Default</code>を実装しなければならないということです。</p>
<!-- The `Default::default` function is commonly used in combination with the struct -->
<!-- update syntax discussed in the “Creating Instances From Other Instances With -->
<!-- Struct Update Syntax” section in Chapter 5. You can customize a few fields of a -->
<!-- struct and then set and use a default value for the rest of the fields by using -->
<!-- `..Default::default()`. -->
<p><code>Default::default</code>関数は、
第5章の「構造体更新記法で他のインスタンスからインスタンスを生成する」節で議論した構造体更新記法と組み合わせてよく使用されます。
構造体のいくつかのフィールドをカスタマイズし、それから<code>..Default::default()</code>を使用して、
残りのフィールドに対して既定値をセットし使用することができます。</p>
<!-- The `Default` trait is required when you use the method `unwrap_or_default` on -->
<!-- `Option<T>` instances, for example. If the `Option<T>` is `None`, the method -->
<!-- `unwrap_or_default` will return the result of `Default::default` for the type -->
<!-- `T` stored in the `Option<T>`. -->
<p>例えば、<code>Default</code>トレイトは、<code>Option&lt;T&gt;</code>インスタンスに対してメソッド<code>unwrap_or_default</code>を使用する時に必要になります。
<code>Option&lt;T&gt;</code>が<code>None</code>ならば、メソッド<code>unwrap_or_default</code>は、<code>Option&lt;T&gt;</code>に格納された型<code>T</code>に対して<code>Default::default</code>の結果を返します。</p>
<!-- ## Appendix D: Macros -->
<a class="header" href="print.html#a付録d-マクロ" id="a付録d-マクロ"><h2>付録D: マクロ</h2></a>
<!-- We’ve used macros like `println!` throughout this book but haven’t fully -->
<!-- explored what a macro is and how it works. This appendix explains macros as -->
<!-- follows: -->
<p>本全体で<code>println!</code>のようなマクロを使用してきましたが、マクロがなんなのかや、
どう動いているのかということは完全には探求していません。この付録は、マクロを以下のように説明します:</p>
<!-- * What macros are and how they differ from functions -->
<!-- * How to define a declarative macro to do metaprogramming -->
<!-- * How to define a procedural macro to create custom `derive` traits -->
<ul>
<li>マクロとはなんなのかと関数とどう違うのか</li>
<li>宣言的なマクロを定義してメタプログラミングをする方法</li>
<li>プロシージャルなマクロを定義して独自の<code>derive</code>トレイトを生成する方法</li>
</ul>
<!-- We’re covering the details of macros in an appendix because they’re still -->
<!-- evolving in Rust. Macros have changed and, in the near future, will change at a -->
<!-- quicker rate than the rest of the language and standard library since Rust 1.0, -->
<!-- so this section is more likely to become out-of-date than the rest of the book. -->
<!-- Due to Rust’s stability guarantees, the code shown here will continue to work -->
<!-- with future versions, but there may be additional capabilities or easier ways -->
<!-- to write macros that weren’t available at the time of this publication. Bear -->
<!-- that in mind when you try to implement anything from this appendix. -->
<p>マクロは今でも、Rustにおいては発展中なので、付録でマクロの詳細を講義します。マクロは変わってきましたし、
近い将来、Rust1.0からの言語の他の機能や標準ライブラリに比べて速いスピードで変化するので、
この節は、本の残りの部分よりも時代遅れになる可能性が高いです。Rustの安定性保証により、
ここで示したコードは、将来のバージョンでも動き続けますが、この本の出版時点では利用可能ではないマクロを書くための追加の能力や、
より簡単な方法があるかもしれません。この付録から何かを実装しようとする場合には、そのことを肝に銘じておいてください。</p>
<!-- ### The Difference Between Macros and Functions -->
<a class="header" href="print.html#aマクロと関数の違い" id="aマクロと関数の違い"><h3>マクロと関数の違い</h3></a>
<!-- Fundamentally, macros are a way of writing code that writes other code, which -->
<!-- is known as *metaprogramming*. In Appendix C, we discussed the `derive` -->
<!-- attribute, which generates an implementation of various traits for you. We’ve -->
<!-- also used the `println!` and `vec!` macros throughout the book. All of these -->
<!-- macros *expand* to produce more code than the code you’ve written manually. -->
<p>基本的に、マクロは、他のコードを記述するコードを書く術であり、これは<em>メタプログラミング</em>として知られています。
付録Cで、<code>derive</code>アトリビュートを議論し、これは、色々なトレイトの実装を生成してくれるのでした。
また、本を通して<code>println!</code>や<code>vec!</code>マクロを使用してきました。これらのマクロは全て、<em>展開</em>され、
手で書いたよりも多くのコードを生成します。</p>
<!-- Metaprogramming is useful for reducing the amount of code you have to write and -->
<!-- maintain, which is also one of the roles of functions. However, macros have -->
<!-- some additional powers that functions don’t have. -->
<p>メタプログラミングは、書いて管理しなければならないコード量を減らすのに有用で、これは、関数の役目の一つでもあります。
ですが、マクロには関数にはない追加の力があります。</p>
<!-- A function signature must declare the number and type of parameters the -->
<!-- function has. Macros, on the other hand, can take a variable number of -->
<!-- parameters: we can call `println!("hello")` with one argument or -->
<!-- `println!("hello {}", name)` with two arguments. Also, macros are expanded -->
<!-- before the compiler interprets the meaning of the code, so a macro can, for -->
<!-- example, implement a trait on a given type. A function can’t, because it gets -->
<!-- called at runtime and a trait needs to be implemented at compile time. -->
<p>関数シグニチャは、関数の引数の数と型を宣言しなければなりません。一方、マクロは可変長の引数を取れます:
<code>println!(&quot;hello&quot;)</code>のように1引数で呼んだり、<code>println!(&quot;hello {}&quot;, name)</code>のように2引数で呼んだりできるのです。
また、マクロは、コンパイラがコードの意味を解釈する前に展開されるので、例えば、
与えられた型にトレイトを実装できます。関数ではできません。何故なら、関数は実行時に呼ばれ、
トレイトはコンパイル時に実装される必要があるからです。</p>
<!-- The downside to implementing a macro instead of a function is that macro -->
<!-- definitions are more complex than function definitions because you’re writing -->
<!-- Rust code that writes Rust code. Due to this indirection, macro definitions are -->
<!-- generally more difficult to read, understand, and maintain than function -->
<!-- definitions. -->
<p>関数ではなくマクロを実装する欠点は、Rustコードを記述するRustコードを書いているので、
関数定義よりもマクロ定義は複雑になることです。この間接性のために、マクロ定義は一般的に、
関数定義よりも、読みにくく、わかりにくく、管理しづらいです。</p>
<!-- Another difference between macros and functions is that macro definitions -->
<!-- aren’t namespaced within modules like function definitions are. To prevent -->
<!-- unexpected name clashes when using external crates, you have to explicitly -->
<!-- bring the macros into the scope of your project at the same time as you bring -->
<!-- the external crate into scope, using the `#[macro_use]` annotation. The -->
<!-- following example would bring all the macros defined in the `serde` crate into -->
<!-- the scope of the current crate: -->
<p>マクロと関数の別の違いは、マクロ定義は、関数定義のようには、モジュール内で名前空間分けされないことです。
外部クレートを使用する際に予期しない名前衝突を回避するために、<code>#[macro_use]</code>注釈を使用して、
外部クレートをスコープに導入するのと同時に、自分のプロジェクトのスコープにマクロを明示的に導入しなければなりません。
以下の例は、<code>serde</code>クレートに定義されているマクロ全部を現在のクレートのスコープに導入するでしょう:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate serde;
</code></pre>
<!-- If `extern crate` was able to bring macros into scope by default without this -->
<!-- explicit annotation, you would be prevented from using two crates that happened -->
<!-- to define macros with the same name. In practice, this conflict doesn’t occur -->
<!-- often, but the more crates you use, the more likely it is. -->
<p>この明示的注釈なしに<code>extern crate</code>が規定でスコープにマクロを導入できたら、偶然同じ名前のマクロを定義している2つのクレートを使用できなくなるでしょう。
現実的には、この衝突はあまり起きませんが、使用するクレートが増えるほど、可能性は高まります。</p>
<!-- There is one last important difference between macros and functions: you must -->
<!-- define or bring macros into scope *before* you call them in a file, whereas you -->
<!-- can define functions anywhere and call them anywhere. -->
<p>マクロと関数にはもう一つ、重要な違いがあります: ファイル内で呼び出す<em>前</em>にマクロはスコープに導入しなければなりませんが、
一方で関数はどこにでも定義でき、どこでも呼び出せます。</p>
<!-- ### Declarative Macros with `macro_rules!` for General Metaprogramming -->
<a class="header" href="print.html#a一般的なメタプログラミングのためにmacro_rulesで宣言的なマクロ" id="a一般的なメタプログラミングのためにmacro_rulesで宣言的なマクロ"><h3>一般的なメタプログラミングのために<code>macro_rules!</code>で宣言的なマクロ</h3></a>
<!-- The most widely used form of macros in Rust are *declarative macros*. These are -->
<!-- also sometimes referred to as *macros by example*, *`macro_rules!` macros*, or -->
<!-- just plain *macros*. At their core, declarative macros allow you to write -->
<!-- something similar to a Rust `match` expression. As discussed in Chapter 6, -->
<!-- `match` expressions are control structures that take an expression, compare the -->
<!-- resulting value of the expression to patterns, and then run the code associated -->
<!-- with the matching pattern. Macros also compare a value to patterns that have -->
<!-- code associated with them; in this situation, the value is the literal Rust -->
<!-- source code passed to the macro, the patterns are compared with the structure -->
<!-- of that source code, and the code associated with each pattern is the code that -->
<!-- replaces the code passed to the macro. This all happens during compilation. -->
<p>Rustにおいて、最もよく使用される形態のマクロは、<em>宣言的マクロ</em>です。これらは時として、
<em>例によるマクロ</em>、<em><code>macro_rules!</code>マクロ</em>、あるいはただ単に<em>マクロ</em>とも称されます。
核となるのは、宣言的マクロは、Rustの<code>match</code>式に似た何かを書けるということです。第6章で議論したように、
<code>match</code>式は、式を取り、式の結果の値をパターンと比較し、それからマッチしたパターンに紐付いたコードを実行する制御構造です。
マクロも自身に紐付いたコードがあるパターンと値を比較します; この場面で値とは、
マクロに渡されたリテラルのRustのソースコードそのもの、パターンは、そのソースコードの構造と比較され、
各パターンに紐付いたコードは、マクロに渡されたコードを置き換えるコードです。これは全て、コンパイル時に起きます。</p>
<!-- To define a macro, you use the `macro_rules!` construct. Let’s explore how to -->
<!-- use `macro_rules!` by looking at how the `vec!` macro is defined. Chapter 8 -->
<!-- covered how we can use the `vec!` macro to create a new vector with particular -->
<!-- values. For example, the following macro creates a new vector with three -->
<!-- integers inside: -->
<p>マクロを定義するには、<code>macro_rules!</code>構文を使用します。<code>vec!</code>マクロが定義されている方法を見て、
<code>macro_rules!</code>を使用する方法を探求しましょう。<code>vec!</code>マクロを使用して特定の値で新しいベクタを生成する方法は、
第8章で講義しました。例えば、以下のマクロは、3つの整数を中身にする新しいベクタを生成します:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;u32&gt; = vec![1, 2, 3];
#}</code></pre></pre>
<!-- We could also use the `vec!` macro to make a vector of two integers or a vector -->
<!-- of five string slices. We wouldn’t be able to use a function to do the same -->
<!-- because we wouldn’t know the number or type of values up front. -->
<p>また、<code>vec!</code>マクロを使用して2整数のベクタや、5つの文字列スライスのベクタなども生成できます。
同じことを関数を使って行うことはできません。予め、値の数や型がわかっていないからです。</p>
<!-- Let’s look at a slightly simplified definition of the `vec!` macro in Listing -->
<!-- D-1. -->
<p>リストD-1で<ruby>些<rp>(</rp><rt>いささ</rt><rp>)</rp></ruby>か簡略化された<code>vec!</code>マクロの定義を見かけましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
#}</code></pre></pre>
<!-- <span class="caption">Listing D-1: A simplified version of the `vec!` macro -->
<!-- definition</span> -->
<p><span class="caption">リストD-1: <code>vec!</code>マクロ定義の簡略化されたバージョン</span></p>
<!-- > Note: The actual definition of the `vec!` macro in the standard library -->
<!-- > includes code to preallocate the correct amount of memory up front. That code -->
<!-- > is an optimization that we don’t include here to make the example simpler. -->
<blockquote>
<p>標準ライブラリの<code>vec!</code>マクロの実際の定義は、予め正確なメモリ量を確保するコードを含みます。
そのコードは、ここでは簡略化のために含まない最適化です。</p>
</blockquote>
<!-- The `#[macro_export]` annotation indicates that this macro should be made -->
<!-- available whenever the crate in which we’re defining the macro is imported. -->
<!-- Without this annotation, even if someone depending on this crate uses the -->
<!-- `#[macro_use]` annotation, the macro wouldn’t be brought into scope. -->
<p><code>#[macro_export]</code>注釈は、マクロを定義しているクレートがインポートされる度にこのマクロが利用可能になるべきということを示しています。
この注釈がなければ、このクレートに依存する誰かが<code>#[macro_use]</code>注釈を使用していても、
このマクロはスコープに導入されないでしょう。</p>
<!-- We then start the macro definition with `macro_rules!` and the name of the -->
<!-- macro we’re defining *without* the exclamation mark. The name, in this case -->
<!-- `vec`, is followed by curly brackets denoting the body of the macro definition. -->
<p>それから、<code>macro_rules!</code>でマクロ定義と定義しているマクロの名前をビックリマーク<em>なしで</em>始めています。
名前はこの場合<code>vec</code>であり、マクロ定義の本体を意味する波括弧が続いています。</p>
<!-- The structure in the `vec!` body is similar to the structure of a `match` -->
<!-- expression. Here we have one arm with the pattern `( $( $x:expr ),* )`, -->
<!-- followed by `=>` and the block of code associated with this pattern. If the -->
<!-- pattern matches, the associated block of code will be emitted. Given that this -->
<!-- is the only pattern in this macro, there is only one valid way to match; any -->
<!-- other will be an error. More complex macros will have more than one arm. -->
<p><code>vec!</code>本体の構造は、<code>match</code>式の構造に類似しています。ここではパターン<code>( $( $x:expr ),* )</code>の1つのアーム、
<code>=&gt;</code>とこのパターンに紐付くコードのブロックが続きます。パターンが合致すれば、紐付いたコードのブロックが発されます。
これがこのマクロの唯一のパターンであることを踏まえると、合致する合法的な方法は一つしかありません;
それ以外は、全部エラーになるでしょう。より複雑なマクロには、2つ以上のアームがあるでしょう。</p>
<!-- Valid pattern syntax in macro definitions is different than the pattern syntax -->
<!-- covered in Chapter 18 because macro patterns are matched against Rust code -->
<!-- structure rather than values. Let’s walk through what the pieces of the pattern -->
<!-- in Listing D-1 mean; for the full macro pattern syntax, see [the reference]. -->
<p>マクロ定義で合法なパターン記法は、第18章で講義したパターン記法とは異なります。というのも、
マクロのパターンは値ではなく、Rustコードの構造に対してマッチされるからです。リストD-1のパターンの部品がどんな意味か見ていきましょう;
マクロパターン記法全ては<a href="../../reference/macros.html">the reference</a>をご覧ください。</p>
<!-- First, a set of parentheses encompasses the whole pattern. Next comes a dollar -->
<!-- sign (`$`) followed by a set of parentheses, which captures values that match -->
<!-- the pattern within the parentheses for use in the replacement code. Within -->
<!-- `$()` is `$x:expr`, which matches any Rust expression and gives the expression -->
<!-- the name `$x`. -->
<p>まず、1組のカッコがパターン全体を囲んでいます。次にドル記号(<code>$</code>)、そして1組のカッコが続き、
このかっこは、置き換えるコードで使用するためにかっこ内でパターンにマッチする値をキャプチャします。
<code>$()</code>の内部には、<code>$x:expr</code>があり、これは任意のRust式にマッチし、その式に<code>$x</code>という名前を与えます。</p>
<!-- The comma following `$()` indicates that a literal comma separator character -->
<!-- could optionally appear after the code that matches the code captured in `$()`. -->
<!-- The `*` following the comma specifies that the pattern matches zero or more of -->
<!-- whatever precedes the `*`. -->
<p><code>$()</code>に続くカンマは、<code>$()</code>にキャプチャされるコードにマッチするコードの後に区別するカンマ文字が現れるという選択肢もあることを示唆しています。
カンマに続く<code>*</code>は、パターンが<code>*</code>の前にあるもの0個以上にマッチすることを指定しています。</p>
<!-- When we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches three -->
<!-- times with the three expressions `1`, `2`, and `3`. -->
<p>このマクロを<code>vec![1, 2, 3];</code>と呼び出すと、<code>$x</code>パターンは、3つの式<code>1</code>、<code>2</code>、<code>3</code>で3回マッチします。</p>
<!-- Now let’s look at the pattern in the body of the code associated with this arm: -->
<!-- the `temp_vec.push()` code within the `$()*` part is generated for each part -->
<!-- that matches `$()` in the pattern, zero or more times depending on how many -->
<!-- times the pattern matches. The `$x` is replaced with each expression matched. -->
<!-- When we call this macro with `vec![1, 2, 3];`, the code generated that replaces -->
<!-- this macro call will be the following: -->
<p>さて、このアームに紐付くコードの本体のパターンに目を向けましょう: <code>$()*</code>部分内部の<code>temp_vec.push()</code>コードは、
パターンがマッチした回数に応じて0回以上パターン内で<code>$()</code>にマッチする箇所ごとに生成されます。
<code>$x</code>はマッチした式それぞれに置き換えられます。このマクロを<code>vec![1, 2, 3];</code>と呼び出すと、
このマクロ呼び出しを置き換え生成されるコードは以下のようになるでしょう:</p>
<pre><code class="language-rust ignore">let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</code></pre>
<!-- We’ve defined a macro that can take any number of arguments of any type and can -->
<!-- generate code to create a vector containing the specified elements. -->
<p>任意の型のあらゆる数の引数を取り、指定した要素を含むベクタを生成するコードを生成できるマクロを定義しました。</p>
<!-- Given that most Rust programmers will *use* macros more than *write* macros, we -->
<!-- won’t discuss `macro_rules!` any further. To learn more about how to write -->
<!-- macros, consult the online documentation or other resources, such as [“The -->
<!-- Little Book of Rust Macros”][tlborm]. -->
<p>多くのRustプログラマは、マクロを<em>書く</em>よりも<em>使う</em>方が多いことを踏まえて、これ以上<code>macro_rules!</code>を議論しません。
マクロの書き方をもっと学ぶには、オンラインドキュメンテーションか他のリソース、
<a href="https://danielkeep.github.io/tlborm/book/index.html">“The Little Book of Rust Macros</a>などを調べてください。</p>
<!-- ### Procedural Macros for Custom `derive` -->
<a class="header" href="print.html#a独自のderiveのためのプロシージャルマクロ" id="a独自のderiveのためのプロシージャルマクロ"><h3>独自の<code>derive</code>のためのプロシージャルマクロ</h3></a>
<!-- The second form of macros is called *procedural macros* because they’re more -->
<!-- like functions (which are a type of procedure). Procedural macros accept some -->
<!-- Rust code as an input, operate on that code, and produce some Rust code as an -->
<!-- output rather than matching against patterns and replacing the code with other -->
<!-- code as declarative macros do. At the time of this writing, you can only define -->
<!-- procedural macros to allow your traits to be implemented on a type by -->
<!-- specifying the trait name in a `derive` annotation. -->
<p>2番目の形態のマクロは、より関数(1種の手続きです)に似ているので、<em>プロシージャル・マクロ</em>(procedural macro; <code>訳注</code>:
手続きマクロ)と呼ばれます。プロシージャルマクロは、宣言的マクロのようにパターンにマッチさせ、
そのコードを他のコードと置き換えるのではなく、入力として何らかのRustコードを受け付け、そのコードを処理し、
出力として何らかのRustコードを生成します。これを執筆している時点では、<code>derive</code>注釈にトレイト名を指定することで、
型に自分のトレイトを実装できるプロシージャルマクロを定義できるだけです。</p>
<!-- We’ll create a crate named `hello_macro` that defines a trait named -->
<!-- `HelloMacro` with one associated function named `hello_macro`. Rather than -->
<!-- making our crate users implement the `HelloMacro` trait for each of their -->
<!-- types, we’ll provide a procedural macro so users can annotate their type with -->
<!-- `#[derive(HelloMacro)]` to get a default implementation of the `hello_macro` -->
<!-- function. The default implementation will print `Hello, Macro! My name is -->
<!-- TypeName!` where `TypeName` is the name of the type on which this trait has -->
<!-- been defined. In other words, we’ll write a crate that enables another -->
<!-- programmer to write code like Listing D-2 using our crate. -->
<p><code>hello_macro</code>という関連関数が1つある<code>HelloMacro</code>というトレイトを定義する<code>hello_macro</code>というクレートを作成します。
クレートの使用者に使用者の型に<code>HelloMacro</code>トレイトを実装することを強制するのではなく、
使用者が型を<code>#[derive(HelloMacro)]</code>で注釈して<code>hello_macro</code>関数の規定の実装を得られるように、
プロシージャルマクロを提供します。規定の実装は、<code>Hello, Macro! My name is TypeName!</code>と出力し、
ここで<code>TypeName</code>はこのトレイトが定義されている型の名前です。言い換えると、他のプログラマに我々のクレートを使用して、
リストD-2のようなコードを書けるようにするクレートを記述します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello_macro;
#[macro_use]
extern crate hello_macro_derive;

use hello_macro::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!-- <span class="caption">Listing D-2: The code a user of our crate will be able to -->
<!-- write when using our procedural macro</span> -->
<p><span class="caption">リストD-2: 我々のプロシージャルマクロを使用した時にクレートの使用者が書けるようになるコード</span></p>
<!-- This code will print `Hello, Macro! My name is Pancakes!` when we’re done. The -->
<!-- first step is to make a new library crate, like this: -->
<p>このコードは完成したら、<code>Hello, Macro! My name is Pancakes!</code>と出力します。最初の手順は、
新しいライブラリクレートを作成することです。このように:</p>
<pre><code class="language-text">$ cargo new hello_macro --lib
</code></pre>
<!-- Next, we’ll define the `HelloMacro` trait and its associated function: -->
<p>次に<code>HelloMacro</code>トレイトと関連関数を定義します。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait HelloMacro {
    fn hello_macro();
}
#}</code></pre></pre>
<!-- We have a trait and its function. At this point, our crate user could implement -->
<!-- the trait to achieve the desired functionality, like so: -->
<p>トレイトと関数があります。この時点で、クレートの使用者は、以下のように、
このトレイトを実装して所望の機能を達成できるでしょう。</p>
<pre><code class="language-rust ignore">extern crate hello_macro;

use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!-- However, they would need to write the implementation block for each type they -->
<!-- wanted to use with `hello_macro`; we want to spare them from having to do this -->
<!-- work. -->
<p>しかしながら、使用者は、<code>hello_macro</code>を使用したい型それぞれに実装ブロックを記述する必要があります;
この作業をしなくても済むようにしたいです。</p>
<!-- Additionally, we can’t yet provide a default implementation for the -->
<!-- `hello_macro` function that will print the name of the type the trait is -->
<!-- implemented on: Rust doesn’t have reflection capabilities, so it can’t look up -->
<!-- the type’s name at runtime. We need a macro to generate code at compile time. -->
<p>さらに、まだトレイトが実装されている型の名前を出力する<code>hello_macro</code>関数に規定の実装を提供することはできません:
Rustにはリフレクションの能力がないので、型の名前を実行時に検索することができないのです。
コンパイル時にコード生成するマクロが必要です。</p>
<blockquote>
<p>注釈: リフレクションとは、実行時に型名や関数の中身などを取得する機能のことです。
言語によって提供されていたりいなかったりしますが、実行時にメタデータがないと取得できないので、
RustやC++のようなアセンブリコードに翻訳され、パフォーマンスを要求される高級言語では、提供されないのが一般的と思われます。</p>
</blockquote>
<!-- The next step is to define the procedural macro. At the time of this writing, -->
<!-- procedural macros need to be in their own crate. Eventually, this restriction -->
<!-- might be lifted. The convention for structuring crates and macro crates is as -->
<!-- follows: for a crate named `foo`, a custom derive procedural macro crate is -->
<!-- called `foo_derive`. Let’s start a new crate called `hello_macro_derive` inside -->
<!-- our `hello_macro` project: -->
<p>次の手順は、プロシージャルマクロを定義することです。これを執筆している時点では、プロシージャルマクロは、
独自のクレートに存在する必要があります。最終的には、この制限は持ち上げられる可能性があります。
クレートとマクロクレートを構成する慣習は以下の通りです: <code>foo</code>というクレートに対して、
独自のderiveプロシージャルマクロクレートは<code>foo_derive</code>と呼ばれます。<code>hello_macro</code>プロジェクト内に、
<code>hello_macro_derive</code>と呼ばれる新しいクレートを開始しましょう:</p>
<pre><code class="language-text">$ cargo new hello_macro_derive --lib
</code></pre>
<!-- Our two crates are tightly related, so we create the procedural macro crate -->
<!-- within the directory of our `hello_macro` crate. If we change the trait -->
<!-- definition in `hello_macro`, we’ll have to change the implementation of the -->
<!-- procedural macro in `hello_macro_derive` as well. The two crates will need to -->
<!-- be published separately, and programmers using these crates will need to add -->
<!-- both as dependencies and bring them both into scope. We could instead have the -->
<!-- `hello_macro` crate use `hello_macro_derive` as a dependency and reexport the -->
<!-- procedural macro code. But the way we’ve structured the project makes it -->
<!-- possible for programmers to use `hello_macro` even if they don’t want the -->
<!-- `derive` functionality. -->
<p>2つのクレートは緊密に関係しているので、<code>hello_macro</code>クレートのディレクトリ内にプロシージャルマクロクレートを作成しています。
<code>hello_macro</code>のトレイト定義を変更したら、<code>hello_macro_derive</code>のプロシージャルマクロの実装も変更しなければならないでしょう。
2つのクレートは個別に発行される必要があり、これらのクレートを使用するプログラマは、
両方を依存に追加し、スコープに導入する必要があるでしょう。代わりに、<code>hello_macro</code>クレートに依存として、
<code>hello_macro_derive</code>を使用させ、プロシージャルマクロのコードを再エクスポートすることもできるでしょう。
プロジェクトの構造により、プログラマが<code>derive</code>機能を使用したくなくても、<code>hello_macro</code>を使用することが可能になります。</p>
<!-- We need to declare the `hello_macro_derive` crate as a procedural macro crate. -->
<!-- We’ll also need functionality from the `syn` and `quote` crates, as you’ll see -->
<!-- in a moment, so we need to add them as dependencies. Add the following to the -->
<!-- *Cargo.toml* file for `hello_macro_derive`: -->
<p><code>hello_macro_derive</code>クレートをプロシージャルマクロクレートとして宣言する必要があります。
また、すぐにわかるように、<code>syn</code>と<code>quote</code>クレートの機能も必要になるので、依存として追加する必要があります。
以下を<code>hello_macro_derive</code>の<em>Cargo.toml</em>ファイルに追加してください:</p>
<!-- <span class="filename">Filename: hello_macro_derive/Cargo.toml</span> -->
<p><span class="filename">ファイル名: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;0.11.11&quot;
quote = &quot;0.3.15&quot;
</code></pre>
<!-- To start defining the procedural macro, place the code in Listing D-3 into your -->
<!-- *src/lib.rs* file for the `hello_macro_derive` crate. Note that this code won’t -->
<!-- compile until we add a definition for the `impl_hello_macro` function. -->
<p>プロシージャルマクロの定義を開始するために、<code>hello_macro_derive</code>クレートの<em>src/lib.rs</em>ファイルにリストD-3のコードを配置してください。
<code>impl_hello_macro</code>関数の定義を追加するまでこのコードはコンパイルできないことに注意してください。</p>
<!-- <span class="filename">Filename: hello_macro_derive/src/lib.rs</span> -->
<p><span class="filename">ファイル名: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate proc_macro;
extern crate syn;
#[macro_use]
extern crate quote;

use proc_macro::TokenStream;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // 型定義の文字列表現を構築する
    // Construct a string representation of the type definition
    let s = input.to_string();

    // 文字列表現を構文解析する
    // Parse the string representation
    let ast = syn::parse_derive_input(&amp;s).unwrap();

    // implを構築する
    // Build the impl
    let gen = impl_hello_macro(&amp;ast);

    // 生成されたimplを返す
    // Return the generated impl
    gen.parse().unwrap()
}
</code></pre>
<!-- <span class="caption">Listing D-3: Code that most procedural macro crates will -->
<!-- need to have for processing Rust code</span> -->
<p><span class="caption">リストD-3: Rustコードを処理するためにほとんどのプロシージャルマクロクレートに必要になるコード</span></p>
<!-- Notice the way we’ve split the functions in D-3; this will be the same for -->
<!-- almost every procedural macro crate you see or create, because it makes writing -->
<!-- a procedural macro more convenient. What you choose to do in the place where -->
<!-- the `impl_hello_macro` function is called will be different depending on your -->
<!-- procedural macro’s purpose. -->
<p>D-3での関数の分け方に気付いてください; これは、目撃あるいは作成するほとんどのプロシージャルマクロクレートで同じになるでしょう。
プロシージャルマクロを書くのが便利になるからです。<code>impl_hello_macro</code>関数が呼ばれる箇所で行うことを選ぶものは、
プロシージャルマクロの目的によって異なるでしょう。</p>
<!-- We’ve introduced three new crates: `proc_macro`, [`syn`], and [`quote`]. The -->
<!-- `proc_macro` crate comes with Rust, so we didn’t need to add that to the -->
<!-- dependencies in *Cargo.toml*. The `proc_macro` crate allows us to convert Rust -->
<!-- code into a string containing that Rust code. The `syn` crate parses Rust code -->
<!-- from a string into a data structure that we can perform operations on. The -->
<!-- `quote` crate takes `syn` data structures and turns them back into Rust code. -->
<!-- These crates make it much simpler to parse any sort of Rust code we might want -->
<!-- to handle: writing a full parser for Rust code is no simple task. -->
<p>3つの新しいクレートを導入しました: <code>proc_macro</code>、<a href="https://crates.io/crates/syn"><code>syn</code></a>、<a href="https://crates.io/crates/quote"><code>quote</code></a>です。<code>proc_macro</code>クレートは、
Rustに付随してくるので、<em>Cargo.toml</em>の依存に追加する必要はありませんでした。<code>proc_macro</code>クレートにより、
RustコードをRustコードを含む文字列に変換できます。<code>syn</code>クレートは、文字列からRustコードを構文解析し、
処理を行えるデータ構造にします。<code>quote</code>クレートは、<code>syn</code>データ構造を取り、Rustコードに変換し直します。
これらのクレートにより、扱いたい可能性のあるあらゆる種類のRustコードを構文解析するのがはるかに単純になります:
Rustコードの完全なパーサを書くのは、単純な作業ではないのです。</p>
<!-- The `hello_macro_derive` function will get called when a user of our library -->
<!-- specifies `#[derive(HelloMacro)]` on a type. The reason is that we’ve annotated -->
<!-- the `hello_macro_derive` function here with `proc_macro_derive` and specified -->
<!-- the name, `HelloMacro`, which matches our trait name; that’s the convention -->
<!-- most procedural macros follow. -->
<p><code>hello_macro_derive</code>関数は、ライブラリの使用者が型に<code>#[derive(HelloMacro)]</code>を指定した時に呼び出されます。
その理由は、ここで<code>hello_macro_derive</code>関数を<code>proc_macro_derive</code>で注釈し、トレイト名に一致する<code>HelloMacro</code>を指定したからです;
これがほとんどのプロシージャルマクロが<ruby>倣<rp>(</rp><rt>なら</rt><rp>)</rp></ruby>う慣習です。</p>
<!-- This function first converts the `input` from a `TokenStream` to a `String` by -->
<!-- calling `to_string`. This `String` is a string representation of the Rust code -->
<!-- for which we are deriving `HelloMacro`. In the example in Listing D-2, `s` will -->
<!-- have the `String` value `struct Pancakes;` because that is the Rust code we -->
<!-- added the `#[derive(HelloMacro)]` annotation to. -->
<p>この関数はまず、<code>TokenStream</code>からの<code>input</code>を<code>to_string</code>を呼び出して<code>String</code>に変換します。
この<code>String</code>は、<code>HelloMacro</code>を継承しているRustコードの文字列表現になります。
リストD-2の例で、<code>s</code>は<code>struct Pancakes;</code>という<code>String</code>値になります。
それが<code>#[derive(HelloMacro)]</code>注釈を追加したRustコードだからです。</p>
<!-- > Note: At the time of this writing, you can only convert a `TokenStream` to a -->
<!-- > string. A richer API will exist in the future. -->
<blockquote>
<p>注釈: これを執筆している時点では、<code>TokenStream</code>は文字列にしか変換できません。
将来的にはよりリッチなAPIになるでしょう。</p>
</blockquote>
<!-- Now we need to parse the Rust code `String` into a data structure that we can -->
<!-- then interpret and perform operations on. This is where `syn` comes into play. -->
<!-- The `parse_derive_input` function in `syn` takes a `String` and returns a -->
<!-- `DeriveInput` struct representing the parsed Rust code. The following code -->
<!-- shows the relevant parts of the `DeriveInput` struct we get from parsing the -->
<!-- string `struct Pancakes;`: -->
<p>さて、Rustコードの<code>String</code>をそれから解釈して処理を実行できるデータ構造に構文解析する必要があります。
ここで<code>syn</code>が登場します。<code>syn</code>の<code>parse_derive_input</code>関数は、<code>String</code>を取り、
構文解析されたRustコードを表す<code>DeriveInput</code>構造体を返します。以下のコードは、
文字列<code>struct Pancakes;</code>を構文解析して得られる<code>DeriveInput</code>構造体の関係のある部分を表示しています:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident(
        &quot;Pancakes&quot;
    ),
    body: Struct(
        Unit
    )
}
</code></pre>
<!-- The fields of this struct show that the Rust code we’ve parsed is a unit struct -->
<!-- with the `ident` (identifier, meaning the name) of `Pancakes`. There are more -->
<!-- fields on this struct for describing all sorts of Rust code; check the [`syn` -->
<!-- documentation for `DeriveInput`][syn-docs] for more information. -->
<p>この構造体のフィールドは、構文解析したRustコードが<code>Pancakes</code>という<code>ident</code>(識別子、つまり名前)のユニット構造体であることを示しています。
この構造体にはRustコードのあらゆる部分を記述するフィールドがもっと多くあります;
<a href="https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html"><code>DeriveInput</code>の<code>syn</code>ドキュメンテーション</a>で詳細を確認してください。</p>
<!-- At this point, we haven’t defined the `impl_hello_macro` function, which is -->
<!-- where we’ll build the new Rust code we want to include. But before we do, note -->
<!-- that the last part of this `hello_macro_derive` function uses the `parse` -->
<!-- function from the `quote` crate to turn the output of the `impl_hello_macro` -->
<!-- function back into a `TokenStream`. The returned `TokenStream` is added to the -->
<!-- code that our crate users write, so when they compile their crate, they’ll get -->
<!-- extra functionality that we provide. -->
<p>この時点では、含みたい新しいRustコードを構築する<code>impl_hello_macro</code>関数を定義していません。
でもその前に、この<code>hello_macro_derive</code>関数の最後の部分で<code>quote</code>クレートの<code>parse</code>関数を使用して、
<code>impl_hello_macro</code>関数の出力を<code>TokenStream</code>に変換し直していることに注目してください。
返された<code>TokenStream</code>をクレートの使用者が書いたコードに追加しているので、クレートをコンパイルすると、
我々が提供している追加の機能を得られます。</p>
<!-- You might have noticed that we’re calling `unwrap` to panic if the calls to the -->
<!-- `parse_derive_input` or `parse` functions fail here. Panicking on errors is -->
<!-- necessary in procedural macro code because `proc_macro_derive` functions must -->
<!-- return `TokenStream` rather than `Result` to conform to the procedural macro -->
<!-- API. We’ve chosen to simplify this example by using `unwrap`; in production -->
<!-- code, you should provide more specific error messages about what went wrong by -->
<!-- using `panic!` or `expect`. -->
<p><code>parse_derive_input</code>か<code>parse</code>関数がここで失敗したら、<code>unwrap</code>を呼び出してパニックしていることにお気付きかもしれません。
エラー時にパニックするのは、プロシージャルマクロコードでは必要なことです。何故なら、
<code>proc_macro_derive</code>関数は、プロシージャルマクロAPIに従うように<code>Result</code>ではなく、
<code>TokenStream</code>を返さなければならないからです。<code>unwrap</code>を使用してこの例を簡略化することを選択しました;
プロダクションコードでは、<code>panic!</code>か<code>expect</code>を使用して何が間違っていたのかより具体的なエラーメッセージを提供すべきです。</p>
<!-- Now that we have the code to turn the annotated Rust code from a `TokenStream` -->
<!-- into a `String` and a `DeriveInput` instance, let’s generate the code that -->
<!-- implements the `HelloMacro` trait on the annotated type: -->
<p>今や、<code>TokenStream</code>からの注釈されたRustコードを<code>String</code>と<code>DeriveInput</code>インスタンスに変換するコードができたので、
注釈された型に<code>HelloMacro</code>トレイトを実装するコードを生成しましょう:</p>
<!-- <span class="filename">Filename: hello_macro_derive/src/lib.rs</span> -->
<p><span class="filename">ファイル名: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {
    let name = &amp;ast.ident;
    quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}&quot;, stringify!(#name));
            }
        }
    }
}
</code></pre>
<!-- We get an `Ident` struct instance containing the name (identifier) of the -->
<!-- annotated type using `ast.ident`. The code in Listing D-2 specifies that the -->
<!-- `name` will be `Ident("Pancakes")`. -->
<p><code>ast.ident</code>で注釈された型の名前(識別子)を含む<code>Ident</code>構造体インスタンスを得ています。
リストD-2のコードは、<code>name</code>が<code>Ident(&quot;Pancakes&quot;)</code>になることを指定しています。</p>
<!-- The `quote!` macro lets us write the Rust code that we want to return and -->
<!-- convert it into `quote::Tokens`. This macro also provides some very cool -->
<!-- templating mechanics; we can write `#name`, and `quote!` will replace it with -->
<!-- the value in the variable named `name`. You can even do some repetition similar -->
<!-- to the way regular macros work. Check out [the `quote` crate’s -->
<!-- docs][quote-docs] for a thorough introduction. -->
<p><code>quote!</code>マクロは、返却し<code>quote::Tokens</code>に変換したいRustコードを書かせてくれます。このマクロはまた、
非常にかっこいいテンプレート機構も提供してくれます; <code>#name</code>と書け、<code>quote!</code>は、
それを<code>name</code>という変数の値と置き換えます。普通のマクロが動作するのと似た繰り返しさえ行えます。
完全なイントロダクションは、<a href="https://docs.rs/quote"><code>quote</code>クレートのdoc</a>をご確認ください。</p>
<!-- We want our procedural macro to generate an implementation of our `HelloMacro` -->
<!-- trait for the type the user annotated, which we can get by using `#name`. The -->
<!-- trait implementation has one function, `hello_macro`, whose body contains the -->
<!-- functionality we want to provide: printing `Hello, Macro! My name is` and then -->
<!-- the name of the annotated type. -->
<p>プロシージャルマクロに使用者が注釈した型に対して<code>HelloMacro</code>トレイトの実装を生成してほしく、
これは<code>#name</code>を使用することで得られます。トレイトの実装には1つの関数<code>hello_macro</code>があり、
この本体に提供したい機能が含まれています: <code>Hello, Macro! My name is</code>そして、注釈した型の名前を出力する機能です。</p>
<!-- The `stringify!` macro used here is built into Rust. It takes a Rust -->
<!-- expression, such as `1 + 2`, and at compile time turns the expression into a -->
<!-- string literal, such as `"1 + 2"`. This is different than `format!` or -->
<!-- `println!`, which evaluate the expression and then turn the result into a -->
<!-- `String`. There is a possibility that the `#name` input might be an expression -->
<!-- to print literally, so we use `stringify!`. Using `stringify!` also saves an -->
<!-- allocation by converting `#name` to a string literal at compile time. -->
<p>ここで使用した<code>stringify!</code>マクロは、言語に埋め込まれています。<code>1 + 2</code>などのようなRustの式を取り、
コンパイル時に<code>&quot;1 + 2&quot;</code>のような文字列リテラルにその式を変換します。これは、<code>format!</code>や<code>println!</code>とは異なります。
こちらは、式を評価し、そしてその結果を<code>String</code>に変換します。<code>#name</code>入力が文字通り出力される式という可能性もあるので、
<code>stringify!</code>を使用しています。<code>stringify!</code>を使用すると、コンパイル時に<code>#name</code>を文字列リテラルに変換することで、
メモリ確保しなくても済みます。</p>
<!-- At this point, `cargo build` should complete successfully in both `hello_macro` -->
<!-- and `hello_macro_derive`. Let’s hook up these crates to the code in Listing D-2 -->
<!-- to see the procedural macro in action! Create a new binary project in your -->
<!-- *projects* directory using `cargo new --bin pancakes`. We need to add -->
<!-- `hello_macro` and `hello_macro_derive` as dependencies in the `pancakes` -->
<!-- crate’s *Cargo.toml*. If you’re publishing your versions of `hello_macro` and -->
<!-- `hello_macro_derive` to *https://crates.io/*, they would be regular -->
<!-- dependencies; if not, you can specify them as `path` dependencies as follows: -->
<p>この時点で、<code>cargo build</code>は<code>hello_macro</code>と<code>hello_macro_derive</code>の両方で成功するはずです。
これらのクレートをリストD-2のコードにフックして、プロシージャルマクロが動くところを確認しましょう！
<code>cargo new --bin pancakes</code>で<em>projects</em>ディレクトリに新しいバイナリプロジェクトを作成してください。
<code>hello_macro</code>と<code>hello_macro_derive</code>を依存として<code>pancakes</code>クレートの<em>Cargo.toml</em>に追加する必要があります。
自分のバージョンの<code>hello_macro</code>と<code>hello_macro_derive</code>を<em>https://crates.io/</em> に発行するつもりなら、
普通の依存になるでしょう; そうでなければ、以下のように<code>path</code>依存として指定できます:</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<!-- Put the code from Listing D-2 into *src/main.rs*, and run `cargo run`: it -->
<!-- should print `Hello, Macro! My name is Pancakes!` The implementation of the -->
<!-- `HelloMacro` trait from the procedural macro was included without the -->
<!-- `pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added the -->
<!-- trait implementation. -->
<p>リストD-2のコードを<em>src/main.rs</em>に配置し、<code>cargo run</code>を実行してください: <code>Hello, Macro! My name is Pancakes</code>と出力するはずです。
プロシージャルマクロの<code>HelloMacro</code>トレイトの実装は、<code>pancakes</code>クレートが実装する必要なく、包含されました;
<code>#[derive(HelloMacro)]</code>がトレイトの実装を追加したのです。</p>
<!-- ### The Future of Macros -->
<a class="header" href="print.html#aマクロの未来" id="aマクロの未来"><h3>マクロの未来</h3></a>
<!-- In the future, Rust will expand declarative and procedural macros. Rust will -->
<!-- use a better declarative macro system with the `macro` keyword and will add -->
<!-- more types of procedural macros for more powerful tasks than just `derive`. -->
<!-- These systems are still under development at the time of this publication; -->
<!-- please consult the online Rust documentation for the latest information. -->
<p>将来的にRustは、宣言的マクロとプロシージャルマクロを拡張するでしょう。<code>macro</code>キーワードでより良い宣言的マクロシステムを使用し、
<code>derive</code>だけよりもよりパワフルな作業のより多くの種類のプロシージャルマクロを追加するでしょう。
この本の出版時点ではこれらのシステムはまだ開発中です; 最新の情報は、オンラインのRustドキュメンテーションをお調べください。</p>
<!-- ## Appendix E: Translations of the Book -->
<a class="header" href="print.html#a付録e-本の翻訳" id="a付録e-本の翻訳"><h2>付録E: 本の翻訳</h2></a>
<!-- For resources in languages other than English. Most are still in progress; see -->
<!-- [the Translations label][label] to help or let us know about a new translation! -->
<p>英語以外の言語のリソースです。ほとんどは翻訳中です; <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">Translationsラベル</a>を確認して、
新しい翻訳の手助けや開始したことをお知らせください！</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/hngnaig/rust-lang-book/tree/vi-VN">Tiếng việt</a></li>
<li><a href="http://www.broadview.com.cn/article/144">简体中文</a>, <a href="https://github.com/KaiserY/trpl-zh-cn">alternate</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a></li>
<li><a href="https://github.com/AgeOfWar/rust-book-it">Italiano</a></li>
<li><a href="https://github.com/iDeBugger/rust-book-ru">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/hazama-yuinyan/book">日本語</a></li>
<li><a href="https://github.com/quadrifoglio/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">עברית</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
</ul>
<!-- # Appendix F - Newest Features -->
<a class="header" href="print.html#a付録f-最新の機能" id="a付録f-最新の機能"><h1>付録F: 最新の機能</h1></a>
<!-- This appendix documents features that have been added to stable Rust since the -->
<!-- main part of the book was completed. -->
<p>この付録は、本の主な部分が完成してから安定版Rustに追加された機能をドキュメント化しています。</p>
<!-- ## Field init shorthand -->
<a class="header" href="print.html#aフィールド初期化省略" id="aフィールド初期化省略"><h2>フィールド初期化省略</h2></a>
<!-- We can initialize a data structure (struct, enum, union) with named -->
<!-- fields, by writing `fieldname` as a shorthand for `fieldname: fieldname`. -->
<!-- This allows a compact syntax for initialization, with less duplication: -->
<p><code>fieldname</code>を<code>fieldname: fieldname</code>の省略として記述することでデータ構造(構造体、enum、ユニオン)を名前付きのフィールドで、
初期化することができます。これにより、重複を減らし、コンパクトな記法の初期化が許容されます。</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

fn main() {
    let name = String::from(&quot;Peter&quot;);
    let age = 27;

    // フル記法:
    // Using full syntax:
    let peter = Person { name: name, age: age };

    let name = String::from(&quot;Portia&quot;);
    let age = 27;

    // フィールド初期化省略:
    // Using field init shorthand:
    let portia = Person { name, age };

    println!(&quot;{:?}&quot;, portia);
}
</code></pre></pre>
<!-- ## Returning from loops -->
<a class="header" href="print.html#aループから戻る" id="aループから戻る"><h2>ループから戻る</h2></a>
<!-- One of the uses of a `loop` is to retry an operation you know can fail, such as -->
<!-- checking if a thread completed its job. However, you might need to pass the -->
<!-- result of that operation to the rest of your code. If you add it to the `break` -->
<!-- expression you use to stop the loop, it will be returned by the broken loop: -->
<p><code>loop</code>の1つの使用法は、スレッドが仕事を終えたか確認するなど、失敗する可能性のあることを知っている処理を再試行することです。
ですが、その処理の結果を残りのコードに渡す必要がある可能性があります。それをループを停止させるために使用する<code>break</code>式に追加したら、
breakしたループから返ってきます。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<!-- ## Nested groups in `use` declarations -->
<a class="header" href="print.html#use宣言のネストされたグループ" id="use宣言のネストされたグループ"><h2><code>use</code>宣言のネストされたグループ</h2></a>
<!-- If you have a complex module tree with many different submodules and you need -->
<!-- to import a few items from each one, it might be useful to group all the -->
<!-- imports in the same declaration to keep your code clean and avoid repeating the -->
<!-- base modules’ name. -->
<p>多くの異なるサブモジュールがある複雑なモジュール木があり、それぞれからいくつかの要素をインポートする必要があるなら、
同じ宣言の全インポートをグループ化し、コードを綺麗に保ち、ベースモジュールの名前を繰り返すのを回避するのが有用になる可能性があります。</p>
<!-- The `use` declaration supports nesting to help you in those cases, both with -->
<!-- simple imports and glob ones. For example this snippets imports `bar`, `Foo`, -->
<!-- all the items in `baz` and `Bar`: -->
<p><code>use</code>宣言は、単純なインポートとグロブを使用したもの両方に対して、そのような場合に手助けになるネストをサポートしています。
例を挙げれば、このコード片は、<code>bar</code>、<code>Foo</code>、<code>baz</code>の全要素、<code>Bar</code>をインポートします。</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_imports, dead_code)]
#
# mod foo {
#     pub mod bar {
#         pub type Foo = ();
#     }
#     pub mod baz {
#         pub mod quux {
#             pub type Bar = ();
#         }
#     }
# }
#
use foo::{
    bar::{self, Foo},
    baz::{*, quux::Bar},
};
#
# fn main() {}
</code></pre></pre>
<!-- ## Inclusive ranges -->
<a class="header" href="print.html#a境界を含む範囲" id="a境界を含む範囲"><h2>境界を含む範囲</h2></a>
<!-- Previously, when a range (`..` or `...`) was used as an expression, it had to be -->
<!-- `..`, which is exclusive of the upper bound, while patterns had to use `...`, -->
<!-- which is inclusive of the upper bound. Now, `..=` is accepted as syntax for -->
<!-- inclusive ranges in both expression and range context: -->
<p>以前は、範囲を式として使用する際、<code>..</code>でなければならず、これは上限を含まない一方、パターンは<code>...</code>を使用しなければならず、
これは、上限を含みます。現在では、<code>..=</code>が両方の式と範囲の文脈で上限を含む範囲の記法として受け付けられます。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for i in 0 ..= 10 {
        match i {
            0 ..= 5 =&gt; println!(&quot;{}: low&quot;, i),
            6 ..= 10 =&gt; println!(&quot;{}: high&quot;, i),
            _ =&gt; println!(&quot;{}: out of range&quot;, i),
        }
    }
}
</code></pre></pre>
<!-- The `...` syntax is still accepted in matches, but it is not accepted in -->
<!-- expressions. `..=` should be preferred. -->
<p><code>...</code>記法はそれでも、matchでは受け付けられますが、式では受け付けられません。<code>..=</code>を使用すべきです。</p>
<!-- ## 128-bit integers -->
<a class="header" href="print.html#a128ビット整数" id="a128ビット整数"><h2>128ビット整数</h2></a>
<!-- Rust 1.26.0 added 128-bit integer primitives: -->
<p>Rust1.26.0で128ビットの整数が追加されました:</p>
<!-- - `u128`: A 128-bit unsigned integer with range [0, 2^128 - 1] -->
<!-- - `i128`: A 128-bit signed integer with range [-(2^127), 2^127 - 1] -->
<ul>
<li><code>u128</code>: 範囲[0, 2^128 - 1]の128ビットの非負整数</li>
<li><code>i128</code>: 範囲[-(2^127), 2^127 - 1]の128ビットの符号付き整数</li>
</ul>
<!-- These primitives are implemented efficiently via LLVM support. They are -->
<!-- available even on platforms that don’t natively support 128-bit integers and -->
<!-- can be used like the other integer types. -->
<p>これらの基本型は、LLVMサポート経由で効率的に実装されています。ネイティブに128ビット整数をサポートしないプラットフォームですら利用可能で、
他の整数型のように使用できます。</p>
<!-- These primitives can be very useful for algorithms that need to use very large -->
<!-- integers efficiently, such as certain cryptographic algorithms. -->
<p>これらの基本型は、特定の暗号化アルゴリズムなど、非常に大きな整数を効率的に使用する必要のあるアルゴリズムで、とても有用です。</p>
<!-- # Appendix G - How Rust is Made and “Nightly Rust” -->
<a class="header" href="print.html#a付録g---rustが作られる方法とnightly-rust" id="a付録g---rustが作られる方法とnightly-rust"><h1>付録G - Rustが作られる方法と“Nightly Rust”</h1></a>
<!-- This appendix is about how Rust is made and how that affects you as a Rust -->
<!-- developer. We mentioned that the output in this book was generated by stable -->
<!-- Rust 1.21.0, but any examples that compile should continue to compile in any -->
<!-- stable version of Rust greater than that. This section is to explain how we -->
<!-- ensure this is true! -->
<p>この付録は、Rustのでき方と、それがRust開発者としてあなたにどう影響するかについてです。
この本の出力は安定版Rust 1.21.0で生成されていますが、コンパイルできるいかなる例も、
それより新しいRustのどんな安定版でもコンパイルでき続けられるはずということに触れました。
この節は、これが本当のことであると保証する方法を説明します！</p>
<!-- ### Stability Without Stagnation -->
<a class="header" href="print.html#a停滞なしの安定性" id="a停滞なしの安定性"><h3>停滞なしの安定性</h3></a>
<!-- As a language, Rust cares a *lot* about the stability of your code. We want -->
<!-- Rust to be a rock-solid foundation you can build on, and if things were -->
<!-- constantly changing, that would be impossible. At the same time, if we can’t -->
<!-- experiment with new features, we may not find out important flaws until after -->
<!-- their release, when we can no longer change things. -->
<p>言語として、Rustはコードの安定性について<em>大い</em>に注意しています。Rustには、その上に建築できる岩のように硬い基礎であってほしく、
物事が定期的に変わっていたら、それは実現できません。同時に新しい機能で実験できなければ、もはや何も変更できないリリースの時まで、
重大な<ruby>瑕疵<rp>(</rp><rt>かし</rt><rp>)</rp></ruby>を発見できなくなるかもしれません。</p>
<!-- Our solution to this problem is what we call “stability without stagnation”, -->
<!-- and our guiding principle is this: you should never have to fear upgrading to a -->
<!-- new version of stable Rust. Each upgrade should be painless, but should also -->
<!-- bring you new features, fewer bugs, and faster compile times. -->
<p>この問題に対する我々の解決策は「停滞なしの安定性」と呼ばれるもので、ガイドの原則は以下の通りです:
安定版Rustの新しいバージョンにアップグレードするのを恐れる必要は何もないはずです。各アップグレートは痛みのないもののはずですが、
新しい機能、より少ないバグ、高速なコンパイル時間も<ruby>齎<rp>(</rp><rt>もたら</rt><rp>)</rp></ruby>すべきです。</p>
<!-- ### Choo, Choo! Release Channels and Riding the Trains -->
<a class="header" href="print.html#aシュポシュポリリースチャンネルと列車に乗る" id="aシュポシュポリリースチャンネルと列車に乗る"><h3>シュポシュポ！リリースチャンネルと列車に乗る</h3></a>
<!-- Rust development operates on a *train schedule*. That is, all development is -->
<!-- done on the `master` branch of the Rust repository. Releases follow a software -->
<!-- release train model, which has been used by Cisco IOS and other software -->
<!-- projects. There are three *release channels* for Rust: -->
<p>Rust開発は、<em>電車のダイヤ</em>に合わせて処理されます。つまり、全開発はRustリポジトリの<code>master</code>ブランチで行われます。
リリースはソフトウェアのリリーストレインモデル(software release train model)に従い、これはCisco IOSや他のソフトウェアプロジェクトで活用されています。
Rustには<em>リリースチャンネル</em>が3つあります:</p>
<blockquote>
<p>注釈: software release train modelとは、あるバージョンのソフトウェアリリースの順番を列車に見立て、
列車のダイヤのように、決まった間隔でリリースに持って行く手法のことの模様。一つの列車は、Rustの場合、
ナイトリー、ベータ、安定版の順に「駅」に停車していくものと思われる。</p>
</blockquote>
<!-- * Nightly -->
<!-- * Beta -->
<!-- * Stable -->
<ul>
<li>ナイトリー</li>
<li>ベータ</li>
<li>安定版</li>
</ul>
<!-- Most Rust developers primarily use the stable channel, but those who want to -->
<!-- try out experimental new features may use nightly or beta. -->
<p>多くのRust開発者は主に安定版チャンネルを使用しますが、新しい実験的な機能を試したい方は、
ナイトリーやベータを使用するかもしれません。</p>
<!-- Here’s an example of how the development and release process works: let’s -->
<!-- assume that the Rust team is working on the release of Rust 1.5. That release -->
<!-- happened in December of 2015, but it will provide us with realistic version -->
<!-- numbers. A new feature is added to Rust: a new commit lands on the `master` -->
<!-- branch. Each night, a new nightly version of Rust is produced. Every day is a -->
<!-- release day, and these releases are created by our release infrastructure -->
<!-- automatically. So as time passes, our releases look like this, once a night: -->
<p>こちらが、開発とリリースプロセスの動き方の例です: RustチームがRust1.5のリリースに取り掛かっていると想定しましょう。
そのリリースは、2015年の11月に発生しましたが、現実的なバージョンナンバーを与えてくれるでしょう。
新しい機能がRustに追加されます: 新しいコミットが<code>master</code>ブランチに着地します。毎晩、新しいナイトリー版のRustが生成されます。
毎日がリリース日で、これらのリリースは、リリースインフラにより自動で作成されます。故に、
時間が経てばリリースは、毎晩1回、以下のような見た目になります:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<!-- Every six weeks, it’s time to prepare a new release! The `beta` branch of the -->
<!-- Rust repository branches off from the `master` branch used by nightly. Now, -->
<!-- there are two releases: -->
<p>6週間ごとに、新しいリリースを準備するタイミングになります！Rustリポジトリの<code>beta</code>ブランチが、
ナイトリーで使用される<code>master</code>ブランチから枝分かれします。さて、リリースが二つになりました:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<!-- Most Rust users do not use beta releases actively, but test against beta in -->
<!-- their CI system to help Rust discover possible regressions. In the meantime, -->
<!-- there’s still a nightly release every night: -->
<p>ほとんどのRustユーザはベータリリースを積極的には使用しませんが、自身のCIシステム内でベータに対してテストを行い、
Rustが不具合の可能性を発見するのを手伝います。その間も、やはりナイトリーリリースは毎晩あります:</p>
<blockquote>
<p>注釈: CIはContinuous Integration(継続統合といったところか)のことと思われる。開発者のコードを1日に何度も、
メインのブランチに統合することらしい。</p>
</blockquote>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<!-- Let’s say a regression is found. Good thing we had some time to test the beta -->
<!-- release before the regression snuck into a stable release! The fix is applied -->
<!-- to `master`, so that nightly is fixed, and then the fix is backported to the -->
<!-- `beta` branch, and a new release of beta is produced: -->
<p>不具合が見つかったとしましょう。よいことに、不具合が安定版のリリースにこっそり持ち込まれる前にベータリリースをテストする時間がありました！
修正が<code>master</code>に適用されるので、ナイトリーは修正され、それから修正が<code>beta</code>ブランチにバックポートされ、
ベータの新しいリリースが生成されます:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<!-- Six weeks after the first beta was created, it’s time for a stable release! The -->
<!-- `stable` branch is produced from the `beta` branch: -->
<p>最初のベータが作成されてから6週間後、安定版のリリースの時間です！<code>stable</code>ブランチが<code>beta</code>ブランチから生成されます:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<!-- Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six -->
<!-- weeks have gone by, we also need a new beta of the *next* version of Rust, 1.6. -->
<!-- So after `stable` branches off of `beta`, the next version of `beta` branches -->
<!-- off of `nightly` again: -->
<p>やりました！Rust1.5が完了しました！ですが、1つ忘れていることがあります: 6週間が経過したので、
<em>次</em>のバージョンのRust(1.6)の新しいベータも必要です。従って、<code>stable</code>が<code>beta</code>から枝分かれした後に、
次のバージョンの<code>beta</code>が<code>nightly</code>から再度枝分かれします:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<!-- This is called the “train model” because every six weeks, a release “leaves the -->
<!-- station”, but still has to take a journey through the beta channel before it -->
<!-- arrives as a stable release. -->
<p>これが「トレイン・モデル」と呼ばれます。6週間ごとにリリースが「駅を出発する」からですが、
安定版リリースとして到着する前にベータチャンネルの旅をそれでもしなければなりません。</p>
<!-- Rust releases every six weeks, like clockwork. If you know the date of one Rust -->
<!-- release, you can know the date of the next one: it’s six weeks later. A nice -->
<!-- aspect of having releases scheduled every six weeks is that the next train is -->
<!-- coming soon. If a feature happens to miss a particular release, there’s no need -->
<!-- to worry: another one is happening in a short time! This helps reduce pressure -->
<!-- to sneak possibly unpolished features in close to the release deadline. -->
<p>Rustは6週間ごとに時計仕掛けのようにリリースされます。あるRustリリースの日付を知っていれば、
次のリリースの日付もわかります: 6週間後です。6週間ごとにリリースを組むことのいい側面は、次の列車がすぐにやってくることです。
ある機能が偶然、特定のリリースを逃しても、心配する必要はありません: 別のリリースがすぐに起きます！
これにより、リリースの締め切りが近い洗練されていない可能性のある機能をこっそり持ち込むプレッシャーが減る助けになるのです。</p>
<!-- 1~2行目がよくわからない -->
<!-- Thanks to this process, you can always check out the next build of Rust and -->
<!-- verify for yourself that it’s easy to upgrade to: if a beta release doesn’t -->
<!-- work as expected, you can report it to the team and get it fixed before the -->
<!-- next stable release happens! Breakage in a beta release is relatively rare, but -->
<!-- `rustc` is still a piece of software, and bugs do exist. -->
<p>このプロセスのおかげで、Rustの次のビルドと常に一致し、アップグレードするのが容易であると自身に対して確かめることができます:
ベータリリースが予想した通りに動かなければ、チームに報告して、次の安定版のリリースが起きる前に直してもらうことができるのです！
ベータリリースでの破損はどちらかといえば稀ですが、<code>rustc</code>もソフトウェアの一種であり、バグは確実に存在します。</p>
<!-- ### Unstable Features -->
<a class="header" href="print.html#a安定しない機能" id="a安定しない機能"><h3>安定しない機能</h3></a>
<!-- There’s one more catch with this release model: unstable features. Rust uses a -->
<!-- technique called “feature flags” to determine what features are enabled in a -->
<!-- given release. If a new feature is under active development, it lands on -->
<!-- `master`, and therefore, in nightly, but behind a *feature flag*. If you, as a -->
<!-- user, wish to try out the work-in-progress feature, you can, but you must be -->
<!-- using a nightly release of Rust and annotate your source code with the -->
<!-- appropriate flag to opt in. -->
<p>このリリースモデルにはもう一つ掴み所があります: 安定しない機能です。Rustは「機能フラグ」と呼ばれるテクニックを使用して、
あるリリースで有効にする機能を決定します。新しい機能が活発に開発中なら、<code>master</code>に着地し、
故にナイトリーでは<em>機能フラグ</em>の背後に存在します。ユーザとして、絶賛作業中の機能を試したいとお望みならば、
可能ですが、ナイトリーリリースのRustを使用し、ソースコードに適切なフラグを注釈して同意しなければなりません。</p>
<!-- If you’re using a beta or stable release of Rust, you can’t use any feature -->
<!-- flags. This is the key that allows us to get practical use with new features -->
<!-- before we declare them stable forever. Those who wish to opt into the bleeding -->
<!-- edge can do so, and those who want a rock-solid experience can stick with -->
<!-- stable and know that their code won’t break. Stability without stagnation. -->
<p>ベータか安定リリースのRustを使用しているなら、機能フラグは使用できません。これが、永遠に安定であると宣言する前に、
新しい機能を実用に供することができる鍵になっています。最先端を選択するのをお望みの方はそうすることができ、
岩のように硬い経験をお望みの方は、安定版に執着し自分のコードが壊れることはないとわかります。停滞なしの安定性です。</p>
<!-- This book only contains information about stable features, as in-progress -->
<!-- features are still changing, and surely they’ll be different between when this -->
<!-- book was written and when they get enabled in stable builds. You can find -->
<!-- documentation for nightly-only features online. -->
<p>この本は安定な機能についての情報のみ含んでいます。現在進行形の機能は、変化中であり、
確実にこの本が執筆された時と安定版ビルドで有効化された時で異なるからです。ナイトリー限定の機能についてのドキュメンテーションは、
オンラインで発見できます。</p>
<!-- ### Rustup and the Role of Rust Nightly -->
<a class="header" href="print.html#rustupとrustナイトリーの役目" id="rustupとrustナイトリーの役目"><h3>RustupとRustナイトリーの役目</h3></a>
<!-- Rustup makes it easy to change between different release channels of Rust, on a -->
<!-- global or per-project basis. By default, you’ll have stable Rust installed. To -->
<!-- install nightly, for example: -->
<p>rustupは、グローバルかプロジェクトごとにRustのリリースチャンネルを変更しやすくしてくれます。
標準では、安定版のRustがインストールされます。例えば、ナイトリーをインストールするには:</p>
<pre><code class="language-text">$ rustup install nightly
</code></pre>
<!-- You can see all of the *toolchains* (releases of Rust and associated -->
<!-- components) you have installed with `rustup` as well. Here’s an example on one -->
<!-- of your authors’ Windows computer: -->
<p><code>rustup</code>でインストールした全ツールチェーン(Rustのリリースと関連するコンポーネント)も確認できます。
こちらは、著者の一人のWindowsコンピュータの例です:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<!-- As you can see, the stable toolchain is the default. Most Rust users use stable -->
<!-- most of the time. You might want to use stable most of the time, but use -->
<!-- nightly on a specific project, because you care about a cutting-edge feature. -->
<!-- To do so, you can use `rustup override` in that project’s directory to set the -->
<!-- nightly toolchain as the one `rustup` should use when you’re in that directory: -->
<p>おわかりのように、安定版のツールチェーンが標準です。ほとんどのRustユーザは、ほとんどの場合、安定版を使用します。
あなたもほとんどの場合安定版を使用したい可能性がありますが、最前線の機能が気になるので、特定のプロジェクトではナイトリーを使用したいかもしれません。
そうするためには、そのプロジェクトのディレクトリで<code>rustup override</code>を使用して、そのディレクトリにいる時に、
<code>rustup</code>が使用するべきツールチェーンとしてナイトリー版のものをセットします。</p>
<pre><code class="language-text">$ cd ~/projects/needs-nightly
$ rustup override add nightly
</code></pre>
<!-- Now, every time you call `rustc` or `cargo` inside of -->
<!-- *~/projects/needs-nightly*, `rustup` will make sure that you are using nightly -->
<!-- Rust, rather than your default of stable Rust. This comes in handy when you -->
<!-- have a lot of Rust projects! -->
<p>これで <em>~/projects/needs-nightly</em>内で<code>rustc</code>や<code>cargo</code>を呼び出す度に、<code>rustup</code>は規定の安定版のRustではなく、
ナイトリーRustを使用していることを確かめます。Rustプロジェクトが大量にある時には、重宝します。</p>
<!-- ### The RFC Process and Teams -->
<a class="header" href="print.html#rfcプロセスとチーム" id="rfcプロセスとチーム"><h3>RFCプロセスとチーム</h3></a>
<!-- So how do you learn about these new features? Rust’s development model follows -->
<!-- a *Request For Comments (RFC) process*. If you’d like an improvement in Rust, -->
<!-- you can write up a proposal, called an RFC. -->
<p>では、これらの新しい機能をどう習うのでしょうか？Rustの開発モデルは、<em>Request For Comments (RFC)プロセス</em>に従っています。
Rustに改善を行いたければ、RFCと呼ばれる提案を書き上げます。</p>
<!-- Anyone can write RFCs to improve Rust, and the proposals are reviewed and -->
<!-- discussed by the Rust team, which is comprised of many topic subteams. There’s -->
<!-- a full list of the teams [on Rust’s -->
<!-- website](https://www.rust-lang.org/en-US/team.html), which includes teams for -->
<!-- each area of the project: language design, compiler implementation, -->
<!-- infrastructure, documentation, and more. The appropriate team reads the -->
<!-- proposal and the comments, writes some comments of their own, and eventually, -->
<!-- there’s consensus to accept or reject the feature. -->
<p>誰もがRFCを書いてRustを改善でき、提案はRustチームにより査読され議論され、このチームは多くの話題のサブチームから構成されています。
<a href="https://www.rust-lang.org/en-US/team.html">RustのWebサイト</a>にはチームの完全なリストがあり、
プロジェクトの各分野のチームも含みます: 言語設計、コンパイラ実装、インフラ、ドキュメンテーションなどです。
適切なチームが提案とコメントを読み、自身のコメントを書き、最終的にその機能を受け入れるか拒否するかの同意があります。</p>
<!-- If the feature is accepted, an issue is opened on the Rust repository, and -->
<!-- someone can implement it. The person who implements it very well may not be the -->
<!-- person who proposed the feature in the first place! When the implementation is -->
<!-- ready, it lands on the `master` branch behind a feature gate, as we discussed -->
<!-- in the “Unstable Features” section. -->
<p>機能が受け入れられれば、Rustリポジトリでissueが開かれ、誰かがそれを実装します。うまく実装できる人は、
最初にその機能を提案した人ではないかもしれません！実装の準備ができたら、「安定しない機能」節で議論したいように、機能ゲートの背後の<code>master</code>に着地します。</p>
<!-- After some time, once Rust developers who use nightly releases have been able -->
<!-- to try out the new feature, team members will discuss the feature, how it’s -->
<!-- worked out on nightly, and decide if it should make it into stable Rust or not. -->
<!-- If the decision is to move forward, the feature gate is removed, and the -->
<!-- feature is now considered stable! It rides the trains into a new stable release -->
<!-- of Rust. -->
<p>時間経過後、一旦ナイトリーリリースを使用するRust開発者が新しい機能を試すことができたら、チームのメンバーがその機能と、
ナイトリーでどう機能しているかについて議論し、安定版のRustに導入すべきかどうか決定します。
決定が進行させることだったら、機能ゲートは取り除かれ、その機能はもう安定と考えられます！Rustの新しい安定版リリースまで、
列車に乗っているのです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
