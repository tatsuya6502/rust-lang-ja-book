<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ベクタ型 - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="foreword.html">まえがき</a></li><li class="affix"><a href="ch00-00-introduction.html">導入</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 事始め</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> インストール</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 数当てゲームをプログラムする</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 普遍的なプログラミング概念</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 変数と可変性</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> データ型</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 関数の動作法</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> コメント</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 制御フロー</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 所有権を理解する</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 所有権とは？</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 参照と借用</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> スライス</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 構造体を使用して関連のあるデータを構造化する</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 構造体を定義し、インスタンス化する</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 構造体を使用したプログラム例</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> メソッド記法</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumとパターンマッチング</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumを定義する</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match制御フロー演算子</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if letで簡潔な制御フロー</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> モジュール</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> modとファイルシステム</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pubで公開するか制御する</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> 異なるモジュールの名前を参照する</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 一般的なコレクション</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html" class="active"><strong aria-hidden="true">8.1.</strong> ベクタ型</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 文字列型</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ハッシュマップ</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> エラー処理</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!で回復不能なエラー</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Resultで回復可能なエラー</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!すべきかするまいか</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ジェネリックなデータ型</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> トレイト: 共通の振る舞いを定義する</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ライフタイムで参照を有効化する</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> テスト</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> テストを書く</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> テストを走らせる</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> テストの体系化</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 入出力プロジェクト: コマンドラインプログラムを構築する</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> コマンドライン引数を受け付ける</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ファイルを読み込む</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> リファクタリングしてモジュール性の向上とエラー処理</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> テスト駆動開発でライブラリの機能を開発する</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 環境変数を取り扱う</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 標準出力ではなく標準エラーにエラーメッセージを書き込む</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 関数型言語の機能: イテレータとクロージャ</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> クロージャ: 環境をキャプチャできる匿名関数</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 一連の要素をイテレータで処理する</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 入出力プロジェクトを改善する</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> パフォーマンス比較: ループVSイテレータ</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> CargoとCrates.ioについてより詳しく</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> リリースプロファイルでビルドをカスタマイズする</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.ioにクレートを公開する</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargoのワークスペース</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo installでCrates.ioからバイナリをインストールする</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 独自のコマンドでCargoで拡張する</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> スマートポインタ</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T>はヒープのデータを指し、既知のサイズである</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Derefトレイトにより、参照を通してデータにアクセスできる</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Dropトレイトにより、片付けの時にコードを実行する</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>は、参照カウント方式のスマートポインタ</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T>と内部可変性パターン</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 循環参照し、メモリをリークするのは安全である</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 恐れるな！並行性</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> スレッド</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> メッセージ受け渡し</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 状態共有</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 拡張可能な並行性: SyncとSend</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustのオブジェクト指向プログラミング機能</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> オブジェクト指向言語の特徴</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 異なる型の値を許容するトレイトオブジェクトを使用する</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> オブジェクト指向デザインパターンを実装する</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> パターンは値の構造に合致する</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> パターンが使用されるかもしれない箇所全部</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 論駁可能性: パターンが合致しないか</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> パターン記法全部</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 高度な機能</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 高度なライフタイム</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 高度なトレイト</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 高度な型</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 高度な関数とクロージャ</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最後のプロジェクト: マルチスレッドのWebサーバを構築する</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> シングルスレッドのWebサーバ</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> シングルスレッドのサーバをマルチスレッド化する</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 優美なシャットダウンとお片付け</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 付録</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - キーワード</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 演算子とシンボル</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 継承可能なトレイト</a></li><li><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - マクロ</a></li><li><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 翻訳</a></li><li><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 最新の機能</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rustが“Nightly Rust”になる方法</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- ## Storing Lists of Values with Vectors -->
<a class="header" href="ch08-01-vectors.html#aベクタで一連の値を保持する" id="aベクタで一連の値を保持する"><h2>ベクタで一連の値を保持する</h2></a>
<!-- The first collection type we’ll look at is `Vec<T>`, also known as a *vector*. -->
<!-- Vectors allow us to store more than one value in a single data structure that -->
<!-- puts all the values next to each other in memory. Vectors can only store values -->
<!-- of the same type. They are useful when you have a list of items, such as the -->
<!-- lines of text in a file or the prices of items in a shopping cart. -->
<p>最初に見るコレクションは、<code>Vec&lt;T&gt;</code>であり、<em>ベクタ</em>としても知られています。ベクタは、
メモリ上に値を隣り合わせに並べる単独のデータ構造に2つ以上の値を保持させてくれます。
ベクタには、同じ型の値しか保持できません。要素のリストがある場合に有用です。
例えば、テキストファイルの各行とか、ショッピングカートのアイテムの価格などです。</p>
<!-- ### Creating a New Vector -->
<a class="header" href="ch08-01-vectors.html#a新しいベクタを生成する" id="a新しいベクタを生成する"><h3>新しいベクタを生成する</h3></a>
<!-- To create a new, empty vector, we can call the `Vec::new` function, as shown in -->
<!-- Listing 8-1. -->
<p>新しい空のベクタを作るには、リスト8-1に示されたように、<code>Vec::new</code>関数を呼ぶことができます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-1: Creating a new, empty vector to hold values -->
<!-- of type `i32`</span> -->
<p><span class="caption">リスト8-1: 新しい空のベクタを生成して<code>i32</code>型の値を保持する</span></p>
<!-- Note that we added a type annotation here. Because we aren’t inserting any -->
<!-- values into this vector, Rust doesn’t know what kind of elements we intend to -->
<!-- store. This is an important point. Vectors are implemented using generics; -->
<!-- we’ll cover how to use generics with your own types in Chapter 10. For now, -->
<!-- know that the `Vec<T>` type provided by the standard library can hold any type, -->
<!-- and when a specific vector holds a specific type, the type is specified within -->
<!-- angle brackets. In Listing 8-1, we’ve told Rust that the `Vec<T>` in `v` will -->
<!-- hold elements of the `i32` type. -->
<p>ここでは、型注釈を付け足したことに注目してください。このベクタに対して、何も値を挿入していないので、
コンパイラには、どんなデータを保持させるつもりなのかわからないのです。これは重要な点です。ベクタは、
ジェネリクスを使用して実装されているのです; 独自の型でジェネリクスを使用する方法については、
第10章で解説します。今は、標準ライブラリにより提供されている<code>Vec&lt;T&gt;</code>型は、どんな型でも保持でき、
特定のベクタが特定の型を保持するとき、その型は山かっこ内に指定されることを知っておいてください。
リスト8-1では、コンパイラに<code>v</code>の<code>Vec&lt;T&gt;</code>は、<code>i32</code>型の要素を保持すると指示しました。</p>
<!-- In more realistic code, Rust can often infer the type of value you want to -->
<!-- store once you insert values, so you rarely need to do this type annotation. -->
<!-- It's more common to create a `Vec<T>` that has initial values, and Rust -->
<!-- provides the `vec!` macro for convenience. The macro will create a new vector -->
<!-- that holds the values we give it. Listing 8-2 creates a new `Vec<i32>` that -->
<!-- holds the values `1`, `2`, and `3`. -->
<p>より現実的なコードでは、一旦値を挿入したら、コンパイラは保持させたい値の型をしばしば推論できるので、
この型注釈をすることは滅多にありません。初期値のある<code>Vec&lt;T&gt;</code>を生成する方が一般的ですし、
Rustには、利便性のために<code>vec!</code>というマクロも用意されています。このマクロは、
与えた値を保持する新しいベクタ型を生成します。リスト8-2では、<code>1</code>、<code>2</code>、<code>3</code>という値を持つ新しい<code>Vec&lt;i32&gt;</code>を生成しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-2: Creating a new vector containing -->
<!-- values</span> -->
<p><span class="caption">リスト8-2: 値を含む新しいベクタを生成する</span></p>
<!-- Because we’ve given initial `i32` values, Rust can infer that the type of `v` -->
<!-- is `Vec<i32>`, and the type annotation isn’t necessary. Next, we’ll look at how -->
<!-- to modify a vector. -->
<p>初期値の<code>i32</code>値を与えたので、コンパイラは、<code>v</code>の型が<code>Vec&lt;i32&gt;</code>であると推論でき、型注釈は必要なくなりました。
次は、ベクタを変更する方法を見ましょう。</p>
<!-- ### Updating a Vector -->
<a class="header" href="ch08-01-vectors.html#aベクタを更新する" id="aベクタを更新する"><h3>ベクタを更新する</h3></a>
<!-- To create a vector and then add elements to it, we can use the `push` method, -->
<!-- as shown in Listing 8-3. -->
<p>ベクタを生成し、それから要素を追加するには、リスト8-3に示したように、<code>push</code>メソッドを使用できます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-3: Using the `push` method to add values to a -->
<!-- vector</span> -->
<p><span class="caption">リスト8-3: <code>push</code>メソッドを使用してベクタ型に値を追加する</span></p>
<!-- As with any variable, if we want to be able to change its value, we need to -->
<!-- make it mutable using the `mut` keyword, as discussed in Chapter 3. The numbers -->
<!-- we place inside are all of type `i32`, and Rust infers this from the data, so -->
<!-- we don’t need the `Vec<i32>` annotation. -->
<p>あらゆる変数同様、第3章で議論したように、値を変化させたかったら、<code>mut</code>キーワードで可変にする必要があります。
中に配置する数値は全て<code>i32</code>型であり、コンパイラはこのことをデータから推論するので、
<code>Vec&lt;i32&gt;</code>という注釈は必要なくなります。</p>
<!-- ### Dropping a Vector Drops Its Elements -->
<a class="header" href="ch08-01-vectors.html#aベクタをドロップすれば要素もドロップする" id="aベクタをドロップすれば要素もドロップする"><h3>ベクタをドロップすれば、要素もドロップする</h3></a>
<!-- Like any other `struct`, a vector is freed when it goes out of scope, as -->
<!-- annotated in Listing 8-4. -->
<p>他のあらゆる<code>構造体</code>同様、ベクタもスコープを抜ければ、解放されます。リスト8-4に注釈したようにですね。</p>
<!-- ```rust -->
<!-- { -->
<!--     let v = vec![1, 2, 3, 4]; -->
<!--     // do stuff with v -->
<!-- } // <- v goes out of scope and is freed here -->
<!-- ``` -->
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // vで作業をする

} // &lt;- vはここでスコープを抜け、解放される
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-4: Showing where the vector and its elements -->
<!-- are dropped</span> -->
<p><span class="caption">リスト8-4: ベクタとその要素がドロップされる箇所を示す</span></p>
<!-- When the vector gets dropped, all of its contents will also be dropped, meaning -->
<!-- those integers it holds will be cleaned up. This may seem like a -->
<!-- straightforward point but can get a bit more complicated when you start to -->
<!-- introduce references to the elements of the vector. Let’s tackle that next! -->
<p>ベクタがドロップされると、その中身もドロップされます。つまり、保持されていた整数値が、
片付けられるということです。これは一見単純な点に見えるかもしれませんが、ベクタの要素への参照を導入した途端、
もうちょっと複雑になる可能性を秘めています。次は、それに挑んでいきましょう！</p>
<!-- ### Reading Elements of Vectors -->
<a class="header" href="ch08-01-vectors.html#aベクタの要素を読む" id="aベクタの要素を読む"><h3>ベクタの要素を読む</h3></a>
<!-- Now that you know how to create, update, and destroy vectors, knowing how to -->
<!-- read their contents is a good next step. There are two ways to reference a -->
<!-- value stored in a vector. In the examples, we’ve annotated the types of the -->
<!-- values that are returned from these functions for extra clarity. -->
<p>もうベクタを生成し、更新し、破壊する方法を知ったので、コンテンツを読む方法を知るのはいいステップアップです。
ベクタに保持された値を参照する方法は2つあります。例では、さらなる明瞭性を求めて、
これらの関数から返る値の型を注釈しました。</p>
<!-- Listing 8-5 shows both methods of accessing a value in a vector, either with -->
<!-- indexing syntax or the `get` method. -->
<p>リスト8-5に示したのは、両メソッドがベクタの値に対して、添字記法と<code>get</code>メソッドによりアクセスするところです。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-5: Using indexing syntax or the `get` method to -->
<!-- access an item in a vector</span> -->
<p><span class="caption">リスト8-5: 添字記法か<code>get</code>メソッドを使用してベクタの要素にアクセスする</span></p>
<!-- Note two details here. First, we use the index value of `2` to get the third -->
<!-- element: vectors are indexed by number, starting at zero. Second, the two ways -->
<!-- to get the third element are by using `&` and `[]`, which gives us a reference, -->
<!-- or by using the `get` method with the index passed as an argument, which gives -->
<!-- us an `Option<&T>`. -->
<p>ここでは、2つのことに気付いてください。まず、3番目の要素を得るのに<code>2</code>という添え字の値を使用していることです:
ベクタは、数値により順序付けされ、添え字は0から始まります。2番目に、3番目の要素を得る2つの方法は、
<code>&amp;</code>と<code>[]</code>を使用して参照を得るものと、番号を引数として<code>get</code>メソッドに渡して、<code>Option&lt;&amp;T&gt;</code>を得るものということです。</p>
<!-- Rust has two ways to reference an element so you can choose how the program -->
<!-- behaves when you try to use an index value that the vector doesn’t have an -->
<!-- element for. As an example, let’s see what a program will do if it has a vector -->
<!-- that holds five elements and then tries to access an element at index 100, as -->
<!-- shown in Listing 8-6. -->
<p>Rustには要素を参照する方法が2通りあるので、ベクタに要素が含まれない番号の値を使用しようとした時に、
プログラムの振る舞いを選択できます。例として、ベクタに5つ要素があり、番号100の要素にアクセスを試みた場合、
プログラムがすることを確認しましょう。リスト8-6に示したようにですね。</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-6: Attempting to access the element at index -->
<!-- 100 in a vector containing five elements</span> -->
<p><span class="caption">リスト8-6: 5つの要素を含むベクタの100番目の要素にアクセスしようとする</span></p>
<!-- When we run this code, the first `[]` method will cause the program to panic -->
<!-- because it references a nonexistent element. This method is best used when you -->
<!-- want your program to crash if there's an attempt to access an element past the -->
<!-- end of the vector. -->
<p>このコードを走らせると、最初の<code>[]</code>メソッドはプログラムをパニックさせます。存在しない要素を参照しているからです。
このメソッドは、ベクタの終端を超えて要素にアクセスしようした時にプログラムをクラッシュさせたい場合に最適です。</p>
<!-- When the `get` method is passed an index that is outside the vector, it returns -->
<!-- `None` without panicking. You would use this method if accessing an element -->
<!-- beyond the range of the vector happens occasionally under normal circumstances. -->
<!-- Your code will then have logic to handle having either `Some(&element)` or -->
<!-- `None`, as discussed in Chapter 6. For example, the index could be coming from -->
<!-- a person entering a number. If they accidentally enter a number that’s too -->
<!-- large and the program gets a `None` value, you could tell the user how many -->
<!-- items are in the current vector and give them another chance to enter a valid -->
<!-- value. That would be more user-friendly than crashing the program due to a typo! -->
<p><code>get</code>メソッドがベクタ外の番号を渡されると、パニックすることなく<code>None</code>を返します。
普通の状態でも、ベクタの範囲外にアクセスする可能性がある場合に、このメソッドを使用することになるでしょう。
そうしたら、コードには<code>Some(&amp;element)</code>か<code>None</code>を扱うロジックが存在することになります。そう、
第6章で議論したように。例えば、番号は人間に数値を入力してもらうことで得ることもできます。
もし大きすぎる値を誤って入力し、プログラムが<code>None</code>値を得てしまったら、現在ベクタに幾つ要素があるかをユーザに教え、
再度正しい値を入力してもらうことができるでしょう。その方が、タイプミスでプログラムをクラッシュさせるより、
ユーザに優しくなるでしょう。</p>
<!-- When the program has a valid reference, the borrow checker enforces the -->
<!-- ownership and borrowing rules (covered in Chapter 4) to ensure this reference -->
<!-- and any other references to the contents of the vector remain valid. Recall the -->
<!-- rule that states we can’t have mutable and immutable references in the same -->
<!-- scope. That rule applies in Listing 8-7, where we hold an immutable reference to -->
<!-- the first element in a vector and try to add an element to the end, which won't -->
<!-- work. -->
<p>プログラムに有効な参照がある場合、borrow checker(借用精査機)は(第4章で解説しましたが)、
所有権と借用規則を強制し、ベクタ型の中身へのこの参照や他のいかなる参照も有効であり続けることを保証してくれます。
同一スコープ上では、可変と不変な参照を同時には存在させられないというルールを思い出してください。
このルールはリスト8-7にも適用され、リスト8-7ではベクタの最初の要素への不変参照を保持し、
終端に要素を追加しようとしていますが、動きません。</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<!-- <span class="caption">Listing 8-7: Attempting to add an element to a vector -->
<!-- while holding a reference to an item</span> -->
<p><span class="caption">リスト8-7: 要素への参照を保持しつつ、ベクタに要素を追加しようとする</span></p>
<!-- Compiling this code will result in this error: -->
<p>このコードをコンパイルすると、こんなエラーになります:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
(エラー: 不変としても借用されているので、`v`を可変で借用できません)
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
  |                  (不変借用はここで発生しています)
5 |
6 |     v.push(6);
  |     ^ mutable borrow occurs here
  |      (可変借用は、ここで発生しています)
7 | }
  | - immutable borrow ends here
  |   (不変借用はここで終了しています)
</code></pre>
<!-- The code in Listing 8-7 might look like it should work: why should a reference -->
<!-- to the first element care about what changes at the end of the vector? This -->
<!-- error is due to the way vectors work: adding a new element onto the end of the -->
<!-- vector might require allocating new memory and copying the old elements to the -->
<!-- new space if there isn’t enough room to put all the elements next to each -->
<!-- other where the vector currently is. In that case, the reference to the first -->
<!-- element would be pointing to deallocated memory. The borrowing rules prevent -->
<!-- programs from ending up in that situation. -->
<p>リスト8-7のコードは、一見動くはずのように見えるかもしれません: なぜ、最初の要素への参照が、
ベクタの終端への変更を気にかける必要があるのでしょうか？このエラーは、ベクタの動作法のせいです:
新規要素をベクタの終端に追加すると、ベクタが現在存在する位置に隣り合って要素を入れるだけの領域がなかった場合に、
メモリの新規確保をして古い要素を新しいスペースにコピーする必要があるかもしれないからです。
その場合、最初の要素を指す参照は、解放されたメモリを指すことになるでしょう。借用規則により、
そのような場面に落ち着かないよう回避されるのです。</p>
<!-- > Note: For more on the implementation details of the `Vec<T>` type, see “The -->
<!-- > Rustonomicon” at https://doc.rust-lang.org/stable/nomicon/vec.html. -->
<blockquote>
<p>注釈: <code>Vec&lt;T&gt;</code>の実装に関する詳細については、https://doc.rust-lang.org/stable/nomicon/vec.htmlの、
&quot;The Rustonomicon&quot;を参照されたし。</p>
</blockquote>
<!-- ### Iterating Over the Values in a Vector -->
<a class="header" href="ch08-01-vectors.html#aベクタの値を走査する" id="aベクタの値を走査する"><h3>ベクタの値を走査する</h3></a>
<!-- If we want to access each element in a vector in turn, we can iterate through -->
<!-- all of the elements rather than use indexes to access one at a time. Listing -->
<!-- 8-8 shows how to use a `for` loop to get immutable references to each element -->
<!-- in a vector of `i32` values and print them. -->
<p>ベクタの要素に順番にアクセスしたいなら、添え字で1回に1要素にアクセスするのではなく、全要素を走査することができます。
リスト8-8で<code>for</code>ループを使い、<code>i32</code>のベクタの各要素に対する不変な参照を得て、それらを出力する方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-8: Printing each element in a vector by -->
<!-- iterating over the elements using a `for` loop</span> -->
<p><span class="caption">リスト8-8: <code>for</code>ループで要素を走査し、ベクタの各要素を出力する</span></p>
<!-- We can also iterate over mutable references to each element in a mutable vector -->
<!-- in order to make changes to all the elements. The `for` loop in Listing 8-9 -->
<!-- will add `50` to each element. -->
<p>全要素に変更を加える目的で、可変なベクタの各要素への可変な参照を走査することもできます。
リスト8-9の<code>for</code>ループでは、各要素に<code>50</code>を足しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-9: Iterating over mutable references to -->
<!-- elements in a vector</span> -->
<p><span class="caption">リスト8-9: ベクタの要素への可変な参照を走査する</span></p>
<!-- To change the value that the mutable reference refers to, we have to use the  -->
<!-- dereference operator (`*`) to get to the value in `i` before we can use the -->
<!-- `+=` operator. -->
<p>可変参照が参照している値を変更するには、<code>+=</code>演算子を使用する前に、
参照外し演算子(<code>*</code>)を使用して<code>i</code>の値に辿り着かないといけません。</p>
<!-- ### Using an Enum to Store Multiple Types -->
<a class="header" href="ch08-01-vectors.html#enumを使って複数の型を保持する" id="enumを使って複数の型を保持する"><h3>Enumを使って複数の型を保持する</h3></a>
<!-- At the beginning of this chapter, we said that vectors can only store values -->
<!-- that are the same type. This can be inconvenient; there are definitely use -->
<!-- cases for needing to store a list of items of different types. Fortunately, the -->
<!-- variants of an enum are defined under the same enum type, so when we need to -->
<!-- store elements of a different type in a vector, we can define and use an enum! -->
<p>この章の冒頭で、ベクタは同じ型の値しか保持できないと述べました。これは不便に考えられることもあります;
異なる型の要素を保持する必要性が出てくるユースケースも確かにあるわけです。幸運なことに、
enumの列挙子は、同じenumの型の元に定義されるので、ベクタに異なる型の要素を保持する必要が出たら、
enumを定義して使用することができます！</p>
<!-- For example, say we want to get values from a row in a spreadsheet in which -->
<!-- some of the columns in the row contain integers, some floating-point numbers, -->
<!-- and some strings. We can define an enum whose variants will hold the different -->
<!-- value types, and then all the enum variants will be considered the same type: -->
<!-- that of the enum. Then we can create a vector that holds that enum and so, -->
<!-- ultimately, holds different types. We’ve demonstrated this in Listing 8-10. -->
<p>例えば、スプレッドシートの行から値を得たくなったとしましょう。ここで行の列には、整数を含むものや、
浮動小数点数を含むもの、文字列を含むものがあります。列挙子が異なる値の型を保持するenumを定義できます。
そして、このenumの列挙子は全て同じ型: enumの型と考えられるわけです。それからそのenumを保持するベクタを生成でき、
結果的に異なる型を保持できるようになるわけです。リスト8-10でこれを模擬しています。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<!-- <span class="caption">Listing 8-10: Defining an `enum` to store values of -->
<!-- different types in one vector</span> -->
<p><span class="caption">リスト8-10: <code>enum</code>を定義して、一つのベクタに異なる型の値を保持する</span></p>
<!-- Rust needs to know what types will be in the vector at compile time so it knows -->
<!-- exactly how much memory on the heap will be needed to store each element. A -->
<!-- secondary advantage is that we can be explicit about what types are allowed in -->
<!-- this vector. If Rust allowed a vector to hold any type, there would be a chance -->
<!-- that one or more of the types would cause errors with the operations performed -->
<!-- on the elements of the vector. Using an enum plus a `match` expression means -->
<!-- that Rust will ensure at compile time that every possible case is handled, as -->
<!-- discussed in Chapter 6. -->
<p>各要素を保持するのにヒープ上でズバリどれくらいのメモリが必要になるかをわかるように、
コンパイラがコンパイル時にベクタに入る型を知る必要があります。副次的な利点は、
このベクタではどんな型が許容されるのか明示できることです。もしRustでベクタがどんな型でも保持できたら、
ベクタの要素に対して行われる処理に対して一つ以上の型がエラーを引き起こす可能性があったでしょう。
enumに加えて<code>match</code>式を使うことは、第6章で議論した通り、コンパイル時にありうる場合全てに対処していることをコンパイラが、
確認できることを意味します。</p>
<!-- When you're writing a program, if you don’t know the exhaustive set of types -->
<!-- the program will get at runtime to store in a vector, the enum technique won’t -->
<!-- work. Instead, you can use a trait object, which we’ll cover in Chapter 17. -->
<p>プログラム記述時にプログラムがベクタに実行時に保持するありとあらゆる一連の型をプログラマが知らない場合、
このenumテクニックはうまく動かないでしょう。代わりにトレイトオブジェクトを使用することができ、こちらは第17章で解説します。</p>
<!-- Now that we’ve discussed some of the most common ways to use vectors, be sure -->
<!-- to review the API documentation for all the many useful methods defined on -->
<!-- `Vec<T>` by the standard library. For example, in addition to `push`, a `pop` -->
<!-- method removes and returns the last element. Let’s move on to the next -->
<!-- collection type: `String`! -->
<p>今や、ベクタを使用するべきありふれた方法について議論したので、標準ライブラリで<code>Vec&lt;T&gt;</code>に定義されている多くの有益なメソッドについては、
APIドキュメントを確認することを心得てください。例として、<code>push</code>に加えて、<code>pop</code>メソッドは最後の要素を削除して返します。
次のコレクション型に移りましょう: <code>String</code>です！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch08-00-common-collections.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch08-02-strings.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch08-00-common-collections.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch08-02-strings.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
