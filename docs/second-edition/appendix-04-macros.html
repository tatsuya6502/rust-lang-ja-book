<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>D - マクロ - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="foreword.html">まえがき</a></li><li class="affix"><a href="ch00-00-introduction.html">導入</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 事始め</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> インストール</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 数当てゲームをプログラムする</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 普遍的なプログラミング概念</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 変数と可変性</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> データ型</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 関数の動作法</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> コメント</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 制御フロー</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 所有権を理解する</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 所有権とは？</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 参照と借用</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> スライス</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 構造体を使用して関連のあるデータを構造化する</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 構造体を定義し、インスタンス化する</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 構造体を使用したプログラム例</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> メソッド記法</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumとパターンマッチング</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumを定義する</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match制御フロー演算子</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if letで簡潔な制御フロー</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> モジュール</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> modとファイルシステム</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pubで公開するか制御する</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> 異なるモジュールの名前を参照する</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 一般的なコレクション</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ベクタ型</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 文字列型</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ハッシュマップ</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> エラー処理</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!で回復不能なエラー</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Resultで回復可能なエラー</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!すべきかするまいか</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ジェネリックなデータ型</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> トレイト: 共通の振る舞いを定義する</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ライフタイムで参照を有効化する</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> テスト</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> テストを書く</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> テストを走らせる</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> テストの体系化</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 入出力プロジェクト: コマンドラインプログラムを構築する</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> コマンドライン引数を受け付ける</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ファイルを読み込む</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> リファクタリングしてモジュール性の向上とエラー処理</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> テスト駆動開発でライブラリの機能を開発する</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 環境変数を取り扱う</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 標準出力ではなく標準エラーにエラーメッセージを書き込む</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 関数型言語の機能: イテレータとクロージャ</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> クロージャ: 環境をキャプチャできる匿名関数</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 一連の要素をイテレータで処理する</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 入出力プロジェクトを改善する</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> パフォーマンス比較: ループVSイテレータ</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> CargoとCrates.ioについてより詳しく</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> リリースプロファイルでビルドをカスタマイズする</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.ioにクレートを公開する</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargoのワークスペース</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo installでCrates.ioからバイナリをインストールする</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 独自のコマンドでCargoで拡張する</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> スマートポインタ</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T>はヒープのデータを指し、既知のサイズである</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Derefトレイトにより、参照を通してデータにアクセスできる</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Dropトレイトにより、片付けの時にコードを実行する</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>は、参照カウント方式のスマートポインタ</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T>と内部可変性パターン</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 循環参照し、メモリをリークするのは安全である</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 恐れるな！並行性</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> スレッド</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> メッセージ受け渡し</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 状態共有</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 拡張可能な並行性: SyncとSend</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustのオブジェクト指向プログラミング機能</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> オブジェクト指向言語の特徴</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 異なる型の値を許容するトレイトオブジェクトを使用する</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> オブジェクト指向デザインパターンを実装する</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> パターンは値の構造に合致する</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> パターンが使用されるかもしれない箇所全部</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 論駁可能性: パターンが合致しないか</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> パターン記法全部</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 高度な機能</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 高度なライフタイム</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 高度なトレイト</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 高度な型</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 高度な関数とクロージャ</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最後のプロジェクト: マルチスレッドのWebサーバを構築する</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> シングルスレッドのWebサーバ</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> シングルスレッドのサーバをマルチスレッド化する</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 優美なシャットダウンとお片付け</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 付録</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - キーワード</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 演算子とシンボル</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 継承可能なトレイト</a></li><li><a href="appendix-04-macros.html" class="active"><strong aria-hidden="true">21.4.</strong> D - マクロ</a></li><li><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 翻訳</a></li><li><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 最新の機能</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rustが“Nightly Rust”になる方法</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- ## Appendix D: Macros -->
<a class="header" href="appendix-04-macros.html#a付録d-マクロ" id="a付録d-マクロ"><h2>付録D: マクロ</h2></a>
<!-- We’ve used macros like `println!` throughout this book but haven’t fully -->
<!-- explored what a macro is and how it works. This appendix explains macros as -->
<!-- follows: -->
<p>本全体で<code>println!</code>のようなマクロを使用してきましたが、マクロがなんなのかや、
どう動いているのかということは完全には探求していません。この付録は、マクロを以下のように説明します:</p>
<!-- * What macros are and how they differ from functions -->
<!-- * How to define a declarative macro to do metaprogramming -->
<!-- * How to define a procedural macro to create custom `derive` traits -->
<ul>
<li>マクロとはなんなのかと関数とどう違うのか</li>
<li>宣言的なマクロを定義してメタプログラミングをする方法</li>
<li>プロシージャルなマクロを定義して独自の<code>derive</code>トレイトを生成する方法</li>
</ul>
<!-- We’re covering the details of macros in an appendix because they’re still -->
<!-- evolving in Rust. Macros have changed and, in the near future, will change at a -->
<!-- quicker rate than the rest of the language and standard library since Rust 1.0, -->
<!-- so this section is more likely to become out-of-date than the rest of the book. -->
<!-- Due to Rust’s stability guarantees, the code shown here will continue to work -->
<!-- with future versions, but there may be additional capabilities or easier ways -->
<!-- to write macros that weren’t available at the time of this publication. Bear -->
<!-- that in mind when you try to implement anything from this appendix. -->
<p>マクロは今でも、Rustにおいては発展中なので、付録でマクロの詳細を講義します。マクロは変わってきましたし、
近い将来、Rust1.0からの言語の他の機能や標準ライブラリに比べて速いスピードで変化するので、
この節は、本の残りの部分よりも時代遅れになる可能性が高いです。Rustの安定性保証により、
ここで示したコードは、将来のバージョンでも動き続けますが、この本の出版時点では利用可能ではないマクロを書くための追加の能力や、
より簡単な方法があるかもしれません。この付録から何かを実装しようとする場合には、そのことを肝に銘じておいてください。</p>
<!-- ### The Difference Between Macros and Functions -->
<a class="header" href="appendix-04-macros.html#aマクロと関数の違い" id="aマクロと関数の違い"><h3>マクロと関数の違い</h3></a>
<!-- Fundamentally, macros are a way of writing code that writes other code, which -->
<!-- is known as *metaprogramming*. In Appendix C, we discussed the `derive` -->
<!-- attribute, which generates an implementation of various traits for you. We’ve -->
<!-- also used the `println!` and `vec!` macros throughout the book. All of these -->
<!-- macros *expand* to produce more code than the code you’ve written manually. -->
<p>基本的に、マクロは、他のコードを記述するコードを書く術であり、これは<em>メタプログラミング</em>として知られています。
付録Cで、<code>derive</code>アトリビュートを議論し、これは、色々なトレイトの実装を生成してくれるのでした。
また、本を通して<code>println!</code>や<code>vec!</code>マクロを使用してきました。これらのマクロは全て、<em>展開</em>され、
手で書いたよりも多くのコードを生成します。</p>
<!-- Metaprogramming is useful for reducing the amount of code you have to write and -->
<!-- maintain, which is also one of the roles of functions. However, macros have -->
<!-- some additional powers that functions don’t have. -->
<p>メタプログラミングは、書いて管理しなければならないコード量を減らすのに有用で、これは、関数の役目の一つでもあります。
ですが、マクロには関数にはない追加の力があります。</p>
<!-- A function signature must declare the number and type of parameters the -->
<!-- function has. Macros, on the other hand, can take a variable number of -->
<!-- parameters: we can call `println!("hello")` with one argument or -->
<!-- `println!("hello {}", name)` with two arguments. Also, macros are expanded -->
<!-- before the compiler interprets the meaning of the code, so a macro can, for -->
<!-- example, implement a trait on a given type. A function can’t, because it gets -->
<!-- called at runtime and a trait needs to be implemented at compile time. -->
<p>関数シグニチャは、関数の引数の数と型を宣言しなければなりません。一方、マクロは可変長の引数を取れます:
<code>println!(&quot;hello&quot;)</code>のように1引数で呼んだり、<code>println!(&quot;hello {}&quot;, name)</code>のように2引数で呼んだりできるのです。
また、マクロは、コンパイラがコードの意味を解釈する前に展開されるので、例えば、
与えられた型にトレイトを実装できます。関数ではできません。何故なら、関数は実行時に呼ばれ、
トレイトはコンパイル時に実装される必要があるからです。</p>
<!-- The downside to implementing a macro instead of a function is that macro -->
<!-- definitions are more complex than function definitions because you’re writing -->
<!-- Rust code that writes Rust code. Due to this indirection, macro definitions are -->
<!-- generally more difficult to read, understand, and maintain than function -->
<!-- definitions. -->
<p>関数ではなくマクロを実装する欠点は、Rustコードを記述するRustコードを書いているので、
関数定義よりもマクロ定義は複雑になることです。この間接性のために、マクロ定義は一般的に、
関数定義よりも、読みにくく、わかりにくく、管理しづらいです。</p>
<!-- Another difference between macros and functions is that macro definitions -->
<!-- aren’t namespaced within modules like function definitions are. To prevent -->
<!-- unexpected name clashes when using external crates, you have to explicitly -->
<!-- bring the macros into the scope of your project at the same time as you bring -->
<!-- the external crate into scope, using the `#[macro_use]` annotation. The -->
<!-- following example would bring all the macros defined in the `serde` crate into -->
<!-- the scope of the current crate: -->
<p>マクロと関数の別の違いは、マクロ定義は、関数定義のようには、モジュール内で名前空間分けされないことです。
外部クレートを使用する際に予期しない名前衝突を回避するために、<code>#[macro_use]</code>注釈を使用して、
外部クレートをスコープに導入するのと同時に、自分のプロジェクトのスコープにマクロを明示的に導入しなければなりません。
以下の例は、<code>serde</code>クレートに定義されているマクロ全部を現在のクレートのスコープに導入するでしょう:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate serde;
</code></pre>
<!-- If `extern crate` was able to bring macros into scope by default without this -->
<!-- explicit annotation, you would be prevented from using two crates that happened -->
<!-- to define macros with the same name. In practice, this conflict doesn’t occur -->
<!-- often, but the more crates you use, the more likely it is. -->
<p>この明示的注釈なしに<code>extern crate</code>が規定でスコープにマクロを導入できたら、偶然同じ名前のマクロを定義している2つのクレートを使用できなくなるでしょう。
現実的には、この衝突はあまり起きませんが、使用するクレートが増えるほど、可能性は高まります。</p>
<!-- There is one last important difference between macros and functions: you must -->
<!-- define or bring macros into scope *before* you call them in a file, whereas you -->
<!-- can define functions anywhere and call them anywhere. -->
<p>マクロと関数にはもう一つ、重要な違いがあります: ファイル内で呼び出す<em>前</em>にマクロはスコープに導入しなければなりませんが、
一方で関数はどこにでも定義でき、どこでも呼び出せます。</p>
<!-- ### Declarative Macros with `macro_rules!` for General Metaprogramming -->
<a class="header" href="appendix-04-macros.html#a一般的なメタプログラミングのためにmacro_rulesで宣言的なマクロ" id="a一般的なメタプログラミングのためにmacro_rulesで宣言的なマクロ"><h3>一般的なメタプログラミングのために<code>macro_rules!</code>で宣言的なマクロ</h3></a>
<!-- The most widely used form of macros in Rust are *declarative macros*. These are -->
<!-- also sometimes referred to as *macros by example*, *`macro_rules!` macros*, or -->
<!-- just plain *macros*. At their core, declarative macros allow you to write -->
<!-- something similar to a Rust `match` expression. As discussed in Chapter 6, -->
<!-- `match` expressions are control structures that take an expression, compare the -->
<!-- resulting value of the expression to patterns, and then run the code associated -->
<!-- with the matching pattern. Macros also compare a value to patterns that have -->
<!-- code associated with them; in this situation, the value is the literal Rust -->
<!-- source code passed to the macro, the patterns are compared with the structure -->
<!-- of that source code, and the code associated with each pattern is the code that -->
<!-- replaces the code passed to the macro. This all happens during compilation. -->
<p>Rustにおいて、最もよく使用される形態のマクロは、<em>宣言的マクロ</em>です。これらは時として、
<em>例によるマクロ</em>、<em><code>macro_rules!</code>マクロ</em>、あるいはただ単に<em>マクロ</em>とも称されます。
核となるのは、宣言的マクロは、Rustの<code>match</code>式に似た何かを書けるということです。第6章で議論したように、
<code>match</code>式は、式を取り、式の結果の値をパターンと比較し、それからマッチしたパターンに紐付いたコードを実行する制御構造です。
マクロも自身に紐付いたコードがあるパターンと値を比較します; この場面で値とは、
マクロに渡されたリテラルのRustのソースコードそのもの、パターンは、そのソースコードの構造と比較され、
各パターンに紐付いたコードは、マクロに渡されたコードを置き換えるコードです。これは全て、コンパイル時に起きます。</p>
<!-- To define a macro, you use the `macro_rules!` construct. Let’s explore how to -->
<!-- use `macro_rules!` by looking at how the `vec!` macro is defined. Chapter 8 -->
<!-- covered how we can use the `vec!` macro to create a new vector with particular -->
<!-- values. For example, the following macro creates a new vector with three -->
<!-- integers inside: -->
<p>マクロを定義するには、<code>macro_rules!</code>構文を使用します。<code>vec!</code>マクロが定義されている方法を見て、
<code>macro_rules!</code>を使用する方法を探求しましょう。<code>vec!</code>マクロを使用して特定の値で新しいベクタを生成する方法は、
第8章で講義しました。例えば、以下のマクロは、3つの整数を中身にする新しいベクタを生成します:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;u32&gt; = vec![1, 2, 3];
#}</code></pre></pre>
<!-- We could also use the `vec!` macro to make a vector of two integers or a vector -->
<!-- of five string slices. We wouldn’t be able to use a function to do the same -->
<!-- because we wouldn’t know the number or type of values up front. -->
<p>また、<code>vec!</code>マクロを使用して2整数のベクタや、5つの文字列スライスのベクタなども生成できます。
同じことを関数を使って行うことはできません。予め、値の数や型がわかっていないからです。</p>
<!-- Let’s look at a slightly simplified definition of the `vec!` macro in Listing -->
<!-- D-1. -->
<p>リストD-1で<ruby>些<rp>(</rp><rt>いささ</rt><rp>)</rp></ruby>か簡略化された<code>vec!</code>マクロの定義を見かけましょう。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
#}</code></pre></pre>
<!-- <span class="caption">Listing D-1: A simplified version of the `vec!` macro -->
<!-- definition</span> -->
<p><span class="caption">リストD-1: <code>vec!</code>マクロ定義の簡略化されたバージョン</span></p>
<!-- > Note: The actual definition of the `vec!` macro in the standard library -->
<!-- > includes code to preallocate the correct amount of memory up front. That code -->
<!-- > is an optimization that we don’t include here to make the example simpler. -->
<blockquote>
<p>標準ライブラリの<code>vec!</code>マクロの実際の定義は、予め正確なメモリ量を確保するコードを含みます。
そのコードは、ここでは簡略化のために含まない最適化です。</p>
</blockquote>
<!-- The `#[macro_export]` annotation indicates that this macro should be made -->
<!-- available whenever the crate in which we’re defining the macro is imported. -->
<!-- Without this annotation, even if someone depending on this crate uses the -->
<!-- `#[macro_use]` annotation, the macro wouldn’t be brought into scope. -->
<p><code>#[macro_export]</code>注釈は、マクロを定義しているクレートがインポートされる度にこのマクロが利用可能になるべきということを示しています。
この注釈がなければ、このクレートに依存する誰かが<code>#[macro_use]</code>注釈を使用していても、
このマクロはスコープに導入されないでしょう。</p>
<!-- We then start the macro definition with `macro_rules!` and the name of the -->
<!-- macro we’re defining *without* the exclamation mark. The name, in this case -->
<!-- `vec`, is followed by curly brackets denoting the body of the macro definition. -->
<p>それから、<code>macro_rules!</code>でマクロ定義と定義しているマクロの名前をビックリマーク<em>なしで</em>始めています。
名前はこの場合<code>vec</code>であり、マクロ定義の本体を意味する波括弧が続いています。</p>
<!-- The structure in the `vec!` body is similar to the structure of a `match` -->
<!-- expression. Here we have one arm with the pattern `( $( $x:expr ),* )`, -->
<!-- followed by `=>` and the block of code associated with this pattern. If the -->
<!-- pattern matches, the associated block of code will be emitted. Given that this -->
<!-- is the only pattern in this macro, there is only one valid way to match; any -->
<!-- other will be an error. More complex macros will have more than one arm. -->
<p><code>vec!</code>本体の構造は、<code>match</code>式の構造に類似しています。ここではパターン<code>( $( $x:expr ),* )</code>の1つのアーム、
<code>=&gt;</code>とこのパターンに紐付くコードのブロックが続きます。パターンが合致すれば、紐付いたコードのブロックが発されます。
これがこのマクロの唯一のパターンであることを踏まえると、合致する合法的な方法は一つしかありません;
それ以外は、全部エラーになるでしょう。より複雑なマクロには、2つ以上のアームがあるでしょう。</p>
<!-- Valid pattern syntax in macro definitions is different than the pattern syntax -->
<!-- covered in Chapter 18 because macro patterns are matched against Rust code -->
<!-- structure rather than values. Let’s walk through what the pieces of the pattern -->
<!-- in Listing D-1 mean; for the full macro pattern syntax, see [the reference]. -->
<p>マクロ定義で合法なパターン記法は、第18章で講義したパターン記法とは異なります。というのも、
マクロのパターンは値ではなく、Rustコードの構造に対してマッチされるからです。リストD-1のパターンの部品がどんな意味か見ていきましょう;
マクロパターン記法全ては<a href="../../reference/macros.html">the reference</a>をご覧ください。</p>
<!-- First, a set of parentheses encompasses the whole pattern. Next comes a dollar -->
<!-- sign (`$`) followed by a set of parentheses, which captures values that match -->
<!-- the pattern within the parentheses for use in the replacement code. Within -->
<!-- `$()` is `$x:expr`, which matches any Rust expression and gives the expression -->
<!-- the name `$x`. -->
<p>まず、1組のカッコがパターン全体を囲んでいます。次にドル記号(<code>$</code>)、そして1組のカッコが続き、
このかっこは、置き換えるコードで使用するためにかっこ内でパターンにマッチする値をキャプチャします。
<code>$()</code>の内部には、<code>$x:expr</code>があり、これは任意のRust式にマッチし、その式に<code>$x</code>という名前を与えます。</p>
<!-- The comma following `$()` indicates that a literal comma separator character -->
<!-- could optionally appear after the code that matches the code captured in `$()`. -->
<!-- The `*` following the comma specifies that the pattern matches zero or more of -->
<!-- whatever precedes the `*`. -->
<p><code>$()</code>に続くカンマは、<code>$()</code>にキャプチャされるコードにマッチするコードの後に区別するカンマ文字が現れるという選択肢もあることを示唆しています。
カンマに続く<code>*</code>は、パターンが<code>*</code>の前にあるもの0個以上にマッチすることを指定しています。</p>
<!-- When we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches three -->
<!-- times with the three expressions `1`, `2`, and `3`. -->
<p>このマクロを<code>vec![1, 2, 3];</code>と呼び出すと、<code>$x</code>パターンは、3つの式<code>1</code>、<code>2</code>、<code>3</code>で3回マッチします。</p>
<!-- Now let’s look at the pattern in the body of the code associated with this arm: -->
<!-- the `temp_vec.push()` code within the `$()*` part is generated for each part -->
<!-- that matches `$()` in the pattern, zero or more times depending on how many -->
<!-- times the pattern matches. The `$x` is replaced with each expression matched. -->
<!-- When we call this macro with `vec![1, 2, 3];`, the code generated that replaces -->
<!-- this macro call will be the following: -->
<p>さて、このアームに紐付くコードの本体のパターンに目を向けましょう: <code>$()*</code>部分内部の<code>temp_vec.push()</code>コードは、
パターンがマッチした回数に応じて0回以上パターン内で<code>$()</code>にマッチする箇所ごとに生成されます。
<code>$x</code>はマッチした式それぞれに置き換えられます。このマクロを<code>vec![1, 2, 3];</code>と呼び出すと、
このマクロ呼び出しを置き換え生成されるコードは以下のようになるでしょう:</p>
<pre><code class="language-rust ignore">let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</code></pre>
<!-- We’ve defined a macro that can take any number of arguments of any type and can -->
<!-- generate code to create a vector containing the specified elements. -->
<p>任意の型のあらゆる数の引数を取り、指定した要素を含むベクタを生成するコードを生成できるマクロを定義しました。</p>
<!-- Given that most Rust programmers will *use* macros more than *write* macros, we -->
<!-- won’t discuss `macro_rules!` any further. To learn more about how to write -->
<!-- macros, consult the online documentation or other resources, such as [“The -->
<!-- Little Book of Rust Macros”][tlborm]. -->
<p>多くのRustプログラマは、マクロを<em>書く</em>よりも<em>使う</em>方が多いことを踏まえて、これ以上<code>macro_rules!</code>を議論しません。
マクロの書き方をもっと学ぶには、オンラインドキュメンテーションか他のリソース、
<a href="https://danielkeep.github.io/tlborm/book/index.html">“The Little Book of Rust Macros</a>などを調べてください。</p>
<!-- ### Procedural Macros for Custom `derive` -->
<a class="header" href="appendix-04-macros.html#a独自のderiveのためのプロシージャルマクロ" id="a独自のderiveのためのプロシージャルマクロ"><h3>独自の<code>derive</code>のためのプロシージャルマクロ</h3></a>
<!-- The second form of macros is called *procedural macros* because they’re more -->
<!-- like functions (which are a type of procedure). Procedural macros accept some -->
<!-- Rust code as an input, operate on that code, and produce some Rust code as an -->
<!-- output rather than matching against patterns and replacing the code with other -->
<!-- code as declarative macros do. At the time of this writing, you can only define -->
<!-- procedural macros to allow your traits to be implemented on a type by -->
<!-- specifying the trait name in a `derive` annotation. -->
<p>2番目の形態のマクロは、より関数(1種の手続きです)に似ているので、<em>プロシージャル・マクロ</em>(procedural macro; <code>訳注</code>:
手続きマクロ)と呼ばれます。プロシージャルマクロは、宣言的マクロのようにパターンにマッチさせ、
そのコードを他のコードと置き換えるのではなく、入力として何らかのRustコードを受け付け、そのコードを処理し、
出力として何らかのRustコードを生成します。これを執筆している時点では、<code>derive</code>注釈にトレイト名を指定することで、
型に自分のトレイトを実装できるプロシージャルマクロを定義できるだけです。</p>
<!-- We’ll create a crate named `hello_macro` that defines a trait named -->
<!-- `HelloMacro` with one associated function named `hello_macro`. Rather than -->
<!-- making our crate users implement the `HelloMacro` trait for each of their -->
<!-- types, we’ll provide a procedural macro so users can annotate their type with -->
<!-- `#[derive(HelloMacro)]` to get a default implementation of the `hello_macro` -->
<!-- function. The default implementation will print `Hello, Macro! My name is -->
<!-- TypeName!` where `TypeName` is the name of the type on which this trait has -->
<!-- been defined. In other words, we’ll write a crate that enables another -->
<!-- programmer to write code like Listing D-2 using our crate. -->
<p><code>hello_macro</code>という関連関数が1つある<code>HelloMacro</code>というトレイトを定義する<code>hello_macro</code>というクレートを作成します。
クレートの使用者に使用者の型に<code>HelloMacro</code>トレイトを実装することを強制するのではなく、
使用者が型を<code>#[derive(HelloMacro)]</code>で注釈して<code>hello_macro</code>関数の規定の実装を得られるように、
プロシージャルマクロを提供します。規定の実装は、<code>Hello, Macro! My name is TypeName!</code>と出力し、
ここで<code>TypeName</code>はこのトレイトが定義されている型の名前です。言い換えると、他のプログラマに我々のクレートを使用して、
リストD-2のようなコードを書けるようにするクレートを記述します。</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello_macro;
#[macro_use]
extern crate hello_macro_derive;

use hello_macro::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!-- <span class="caption">Listing D-2: The code a user of our crate will be able to -->
<!-- write when using our procedural macro</span> -->
<p><span class="caption">リストD-2: 我々のプロシージャルマクロを使用した時にクレートの使用者が書けるようになるコード</span></p>
<!-- This code will print `Hello, Macro! My name is Pancakes!` when we’re done. The -->
<!-- first step is to make a new library crate, like this: -->
<p>このコードは完成したら、<code>Hello, Macro! My name is Pancakes!</code>と出力します。最初の手順は、
新しいライブラリクレートを作成することです。このように:</p>
<pre><code class="language-text">$ cargo new hello_macro --lib
</code></pre>
<!-- Next, we’ll define the `HelloMacro` trait and its associated function: -->
<p>次に<code>HelloMacro</code>トレイトと関連関数を定義します。</p>
<!-- <span class="filename">Filename: src/lib.rs</span> -->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait HelloMacro {
    fn hello_macro();
}
#}</code></pre></pre>
<!-- We have a trait and its function. At this point, our crate user could implement -->
<!-- the trait to achieve the desired functionality, like so: -->
<p>トレイトと関数があります。この時点で、クレートの使用者は、以下のように、
このトレイトを実装して所望の機能を達成できるでしょう。</p>
<pre><code class="language-rust ignore">extern crate hello_macro;

use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!-- However, they would need to write the implementation block for each type they -->
<!-- wanted to use with `hello_macro`; we want to spare them from having to do this -->
<!-- work. -->
<p>しかしながら、使用者は、<code>hello_macro</code>を使用したい型それぞれに実装ブロックを記述する必要があります;
この作業をしなくても済むようにしたいです。</p>
<!-- Additionally, we can’t yet provide a default implementation for the -->
<!-- `hello_macro` function that will print the name of the type the trait is -->
<!-- implemented on: Rust doesn’t have reflection capabilities, so it can’t look up -->
<!-- the type’s name at runtime. We need a macro to generate code at compile time. -->
<p>さらに、まだトレイトが実装されている型の名前を出力する<code>hello_macro</code>関数に規定の実装を提供することはできません:
Rustにはリフレクションの能力がないので、型の名前を実行時に検索することができないのです。
コンパイル時にコード生成するマクロが必要です。</p>
<blockquote>
<p>注釈: リフレクションとは、実行時に型名や関数の中身などを取得する機能のことです。
言語によって提供されていたりいなかったりしますが、実行時にメタデータがないと取得できないので、
RustやC++のようなアセンブリコードに翻訳され、パフォーマンスを要求される高級言語では、提供されないのが一般的と思われます。</p>
</blockquote>
<!-- The next step is to define the procedural macro. At the time of this writing, -->
<!-- procedural macros need to be in their own crate. Eventually, this restriction -->
<!-- might be lifted. The convention for structuring crates and macro crates is as -->
<!-- follows: for a crate named `foo`, a custom derive procedural macro crate is -->
<!-- called `foo_derive`. Let’s start a new crate called `hello_macro_derive` inside -->
<!-- our `hello_macro` project: -->
<p>次の手順は、プロシージャルマクロを定義することです。これを執筆している時点では、プロシージャルマクロは、
独自のクレートに存在する必要があります。最終的には、この制限は持ち上げられる可能性があります。
クレートとマクロクレートを構成する慣習は以下の通りです: <code>foo</code>というクレートに対して、
独自のderiveプロシージャルマクロクレートは<code>foo_derive</code>と呼ばれます。<code>hello_macro</code>プロジェクト内に、
<code>hello_macro_derive</code>と呼ばれる新しいクレートを開始しましょう:</p>
<pre><code class="language-text">$ cargo new hello_macro_derive --lib
</code></pre>
<!-- Our two crates are tightly related, so we create the procedural macro crate -->
<!-- within the directory of our `hello_macro` crate. If we change the trait -->
<!-- definition in `hello_macro`, we’ll have to change the implementation of the -->
<!-- procedural macro in `hello_macro_derive` as well. The two crates will need to -->
<!-- be published separately, and programmers using these crates will need to add -->
<!-- both as dependencies and bring them both into scope. We could instead have the -->
<!-- `hello_macro` crate use `hello_macro_derive` as a dependency and reexport the -->
<!-- procedural macro code. But the way we’ve structured the project makes it -->
<!-- possible for programmers to use `hello_macro` even if they don’t want the -->
<!-- `derive` functionality. -->
<p>2つのクレートは緊密に関係しているので、<code>hello_macro</code>クレートのディレクトリ内にプロシージャルマクロクレートを作成しています。
<code>hello_macro</code>のトレイト定義を変更したら、<code>hello_macro_derive</code>のプロシージャルマクロの実装も変更しなければならないでしょう。
2つのクレートは個別に発行される必要があり、これらのクレートを使用するプログラマは、
両方を依存に追加し、スコープに導入する必要があるでしょう。代わりに、<code>hello_macro</code>クレートに依存として、
<code>hello_macro_derive</code>を使用させ、プロシージャルマクロのコードを再エクスポートすることもできるでしょう。
プロジェクトの構造により、プログラマが<code>derive</code>機能を使用したくなくても、<code>hello_macro</code>を使用することが可能になります。</p>
<!-- We need to declare the `hello_macro_derive` crate as a procedural macro crate. -->
<!-- We’ll also need functionality from the `syn` and `quote` crates, as you’ll see -->
<!-- in a moment, so we need to add them as dependencies. Add the following to the -->
<!-- *Cargo.toml* file for `hello_macro_derive`: -->
<p><code>hello_macro_derive</code>クレートをプロシージャルマクロクレートとして宣言する必要があります。
また、すぐにわかるように、<code>syn</code>と<code>quote</code>クレートの機能も必要になるので、依存として追加する必要があります。
以下を<code>hello_macro_derive</code>の<em>Cargo.toml</em>ファイルに追加してください:</p>
<!-- <span class="filename">Filename: hello_macro_derive/Cargo.toml</span> -->
<p><span class="filename">ファイル名: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;0.11.11&quot;
quote = &quot;0.3.15&quot;
</code></pre>
<!-- To start defining the procedural macro, place the code in Listing D-3 into your -->
<!-- *src/lib.rs* file for the `hello_macro_derive` crate. Note that this code won’t -->
<!-- compile until we add a definition for the `impl_hello_macro` function. -->
<p>プロシージャルマクロの定義を開始するために、<code>hello_macro_derive</code>クレートの<em>src/lib.rs</em>ファイルにリストD-3のコードを配置してください。
<code>impl_hello_macro</code>関数の定義を追加するまでこのコードはコンパイルできないことに注意してください。</p>
<!-- <span class="filename">Filename: hello_macro_derive/src/lib.rs</span> -->
<p><span class="filename">ファイル名: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate proc_macro;
extern crate syn;
#[macro_use]
extern crate quote;

use proc_macro::TokenStream;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // 型定義の文字列表現を構築する
    // Construct a string representation of the type definition
    let s = input.to_string();

    // 文字列表現を構文解析する
    // Parse the string representation
    let ast = syn::parse_derive_input(&amp;s).unwrap();

    // implを構築する
    // Build the impl
    let gen = impl_hello_macro(&amp;ast);

    // 生成されたimplを返す
    // Return the generated impl
    gen.parse().unwrap()
}
</code></pre>
<!-- <span class="caption">Listing D-3: Code that most procedural macro crates will -->
<!-- need to have for processing Rust code</span> -->
<p><span class="caption">リストD-3: Rustコードを処理するためにほとんどのプロシージャルマクロクレートに必要になるコード</span></p>
<!-- Notice the way we’ve split the functions in D-3; this will be the same for -->
<!-- almost every procedural macro crate you see or create, because it makes writing -->
<!-- a procedural macro more convenient. What you choose to do in the place where -->
<!-- the `impl_hello_macro` function is called will be different depending on your -->
<!-- procedural macro’s purpose. -->
<p>D-3での関数の分け方に気付いてください; これは、目撃あるいは作成するほとんどのプロシージャルマクロクレートで同じになるでしょう。
プロシージャルマクロを書くのが便利になるからです。<code>impl_hello_macro</code>関数が呼ばれる箇所で行うことを選ぶものは、
プロシージャルマクロの目的によって異なるでしょう。</p>
<!-- We’ve introduced three new crates: `proc_macro`, [`syn`], and [`quote`]. The -->
<!-- `proc_macro` crate comes with Rust, so we didn’t need to add that to the -->
<!-- dependencies in *Cargo.toml*. The `proc_macro` crate allows us to convert Rust -->
<!-- code into a string containing that Rust code. The `syn` crate parses Rust code -->
<!-- from a string into a data structure that we can perform operations on. The -->
<!-- `quote` crate takes `syn` data structures and turns them back into Rust code. -->
<!-- These crates make it much simpler to parse any sort of Rust code we might want -->
<!-- to handle: writing a full parser for Rust code is no simple task. -->
<p>3つの新しいクレートを導入しました: <code>proc_macro</code>、<a href="https://crates.io/crates/syn"><code>syn</code></a>、<a href="https://crates.io/crates/quote"><code>quote</code></a>です。<code>proc_macro</code>クレートは、
Rustに付随してくるので、<em>Cargo.toml</em>の依存に追加する必要はありませんでした。<code>proc_macro</code>クレートにより、
RustコードをRustコードを含む文字列に変換できます。<code>syn</code>クレートは、文字列からRustコードを構文解析し、
処理を行えるデータ構造にします。<code>quote</code>クレートは、<code>syn</code>データ構造を取り、Rustコードに変換し直します。
これらのクレートにより、扱いたい可能性のあるあらゆる種類のRustコードを構文解析するのがはるかに単純になります:
Rustコードの完全なパーサを書くのは、単純な作業ではないのです。</p>
<!-- The `hello_macro_derive` function will get called when a user of our library -->
<!-- specifies `#[derive(HelloMacro)]` on a type. The reason is that we’ve annotated -->
<!-- the `hello_macro_derive` function here with `proc_macro_derive` and specified -->
<!-- the name, `HelloMacro`, which matches our trait name; that’s the convention -->
<!-- most procedural macros follow. -->
<p><code>hello_macro_derive</code>関数は、ライブラリの使用者が型に<code>#[derive(HelloMacro)]</code>を指定した時に呼び出されます。
その理由は、ここで<code>hello_macro_derive</code>関数を<code>proc_macro_derive</code>で注釈し、トレイト名に一致する<code>HelloMacro</code>を指定したからです;
これがほとんどのプロシージャルマクロが<ruby>倣<rp>(</rp><rt>なら</rt><rp>)</rp></ruby>う慣習です。</p>
<!-- This function first converts the `input` from a `TokenStream` to a `String` by -->
<!-- calling `to_string`. This `String` is a string representation of the Rust code -->
<!-- for which we are deriving `HelloMacro`. In the example in Listing D-2, `s` will -->
<!-- have the `String` value `struct Pancakes;` because that is the Rust code we -->
<!-- added the `#[derive(HelloMacro)]` annotation to. -->
<p>この関数はまず、<code>TokenStream</code>からの<code>input</code>を<code>to_string</code>を呼び出して<code>String</code>に変換します。
この<code>String</code>は、<code>HelloMacro</code>を継承しているRustコードの文字列表現になります。
リストD-2の例で、<code>s</code>は<code>struct Pancakes;</code>という<code>String</code>値になります。
それが<code>#[derive(HelloMacro)]</code>注釈を追加したRustコードだからです。</p>
<!-- > Note: At the time of this writing, you can only convert a `TokenStream` to a -->
<!-- > string. A richer API will exist in the future. -->
<blockquote>
<p>注釈: これを執筆している時点では、<code>TokenStream</code>は文字列にしか変換できません。
将来的にはよりリッチなAPIになるでしょう。</p>
</blockquote>
<!-- Now we need to parse the Rust code `String` into a data structure that we can -->
<!-- then interpret and perform operations on. This is where `syn` comes into play. -->
<!-- The `parse_derive_input` function in `syn` takes a `String` and returns a -->
<!-- `DeriveInput` struct representing the parsed Rust code. The following code -->
<!-- shows the relevant parts of the `DeriveInput` struct we get from parsing the -->
<!-- string `struct Pancakes;`: -->
<p>さて、Rustコードの<code>String</code>をそれから解釈して処理を実行できるデータ構造に構文解析する必要があります。
ここで<code>syn</code>が登場します。<code>syn</code>の<code>parse_derive_input</code>関数は、<code>String</code>を取り、
構文解析されたRustコードを表す<code>DeriveInput</code>構造体を返します。以下のコードは、
文字列<code>struct Pancakes;</code>を構文解析して得られる<code>DeriveInput</code>構造体の関係のある部分を表示しています:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident(
        &quot;Pancakes&quot;
    ),
    body: Struct(
        Unit
    )
}
</code></pre>
<!-- The fields of this struct show that the Rust code we’ve parsed is a unit struct -->
<!-- with the `ident` (identifier, meaning the name) of `Pancakes`. There are more -->
<!-- fields on this struct for describing all sorts of Rust code; check the [`syn` -->
<!-- documentation for `DeriveInput`][syn-docs] for more information. -->
<p>この構造体のフィールドは、構文解析したRustコードが<code>Pancakes</code>という<code>ident</code>(識別子、つまり名前)のユニット構造体であることを示しています。
この構造体にはRustコードのあらゆる部分を記述するフィールドがもっと多くあります;
<a href="https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html"><code>DeriveInput</code>の<code>syn</code>ドキュメンテーション</a>で詳細を確認してください。</p>
<!-- At this point, we haven’t defined the `impl_hello_macro` function, which is -->
<!-- where we’ll build the new Rust code we want to include. But before we do, note -->
<!-- that the last part of this `hello_macro_derive` function uses the `parse` -->
<!-- function from the `quote` crate to turn the output of the `impl_hello_macro` -->
<!-- function back into a `TokenStream`. The returned `TokenStream` is added to the -->
<!-- code that our crate users write, so when they compile their crate, they’ll get -->
<!-- extra functionality that we provide. -->
<p>この時点では、含みたい新しいRustコードを構築する<code>impl_hello_macro</code>関数を定義していません。
でもその前に、この<code>hello_macro_derive</code>関数の最後の部分で<code>quote</code>クレートの<code>parse</code>関数を使用して、
<code>impl_hello_macro</code>関数の出力を<code>TokenStream</code>に変換し直していることに注目してください。
返された<code>TokenStream</code>をクレートの使用者が書いたコードに追加しているので、クレートをコンパイルすると、
我々が提供している追加の機能を得られます。</p>
<!-- You might have noticed that we’re calling `unwrap` to panic if the calls to the -->
<!-- `parse_derive_input` or `parse` functions fail here. Panicking on errors is -->
<!-- necessary in procedural macro code because `proc_macro_derive` functions must -->
<!-- return `TokenStream` rather than `Result` to conform to the procedural macro -->
<!-- API. We’ve chosen to simplify this example by using `unwrap`; in production -->
<!-- code, you should provide more specific error messages about what went wrong by -->
<!-- using `panic!` or `expect`. -->
<p><code>parse_derive_input</code>か<code>parse</code>関数がここで失敗したら、<code>unwrap</code>を呼び出してパニックしていることにお気付きかもしれません。
エラー時にパニックするのは、プロシージャルマクロコードでは必要なことです。何故なら、
<code>proc_macro_derive</code>関数は、プロシージャルマクロAPIに従うように<code>Result</code>ではなく、
<code>TokenStream</code>を返さなければならないからです。<code>unwrap</code>を使用してこの例を簡略化することを選択しました;
プロダクションコードでは、<code>panic!</code>か<code>expect</code>を使用して何が間違っていたのかより具体的なエラーメッセージを提供すべきです。</p>
<!-- Now that we have the code to turn the annotated Rust code from a `TokenStream` -->
<!-- into a `String` and a `DeriveInput` instance, let’s generate the code that -->
<!-- implements the `HelloMacro` trait on the annotated type: -->
<p>今や、<code>TokenStream</code>からの注釈されたRustコードを<code>String</code>と<code>DeriveInput</code>インスタンスに変換するコードができたので、
注釈された型に<code>HelloMacro</code>トレイトを実装するコードを生成しましょう:</p>
<!-- <span class="filename">Filename: hello_macro_derive/src/lib.rs</span> -->
<p><span class="filename">ファイル名: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {
    let name = &amp;ast.ident;
    quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}&quot;, stringify!(#name));
            }
        }
    }
}
</code></pre>
<!-- We get an `Ident` struct instance containing the name (identifier) of the -->
<!-- annotated type using `ast.ident`. The code in Listing D-2 specifies that the -->
<!-- `name` will be `Ident("Pancakes")`. -->
<p><code>ast.ident</code>で注釈された型の名前(識別子)を含む<code>Ident</code>構造体インスタンスを得ています。
リストD-2のコードは、<code>name</code>が<code>Ident(&quot;Pancakes&quot;)</code>になることを指定しています。</p>
<!-- The `quote!` macro lets us write the Rust code that we want to return and -->
<!-- convert it into `quote::Tokens`. This macro also provides some very cool -->
<!-- templating mechanics; we can write `#name`, and `quote!` will replace it with -->
<!-- the value in the variable named `name`. You can even do some repetition similar -->
<!-- to the way regular macros work. Check out [the `quote` crate’s -->
<!-- docs][quote-docs] for a thorough introduction. -->
<p><code>quote!</code>マクロは、返却し<code>quote::Tokens</code>に変換したいRustコードを書かせてくれます。このマクロはまた、
非常にかっこいいテンプレート機構も提供してくれます; <code>#name</code>と書け、<code>quote!</code>は、
それを<code>name</code>という変数の値と置き換えます。普通のマクロが動作するのと似た繰り返しさえ行えます。
完全なイントロダクションは、<a href="https://docs.rs/quote"><code>quote</code>クレートのdoc</a>をご確認ください。</p>
<!-- We want our procedural macro to generate an implementation of our `HelloMacro` -->
<!-- trait for the type the user annotated, which we can get by using `#name`. The -->
<!-- trait implementation has one function, `hello_macro`, whose body contains the -->
<!-- functionality we want to provide: printing `Hello, Macro! My name is` and then -->
<!-- the name of the annotated type. -->
<p>プロシージャルマクロに使用者が注釈した型に対して<code>HelloMacro</code>トレイトの実装を生成してほしく、
これは<code>#name</code>を使用することで得られます。トレイトの実装には1つの関数<code>hello_macro</code>があり、
この本体に提供したい機能が含まれています: <code>Hello, Macro! My name is</code>そして、注釈した型の名前を出力する機能です。</p>
<!-- The `stringify!` macro used here is built into Rust. It takes a Rust -->
<!-- expression, such as `1 + 2`, and at compile time turns the expression into a -->
<!-- string literal, such as `"1 + 2"`. This is different than `format!` or -->
<!-- `println!`, which evaluate the expression and then turn the result into a -->
<!-- `String`. There is a possibility that the `#name` input might be an expression -->
<!-- to print literally, so we use `stringify!`. Using `stringify!` also saves an -->
<!-- allocation by converting `#name` to a string literal at compile time. -->
<p>ここで使用した<code>stringify!</code>マクロは、言語に埋め込まれています。<code>1 + 2</code>などのようなRustの式を取り、
コンパイル時に<code>&quot;1 + 2&quot;</code>のような文字列リテラルにその式を変換します。これは、<code>format!</code>や<code>println!</code>とは異なります。
こちらは、式を評価し、そしてその結果を<code>String</code>に変換します。<code>#name</code>入力が文字通り出力される式という可能性もあるので、
<code>stringify!</code>を使用しています。<code>stringify!</code>を使用すると、コンパイル時に<code>#name</code>を文字列リテラルに変換することで、
メモリ確保しなくても済みます。</p>
<!-- At this point, `cargo build` should complete successfully in both `hello_macro` -->
<!-- and `hello_macro_derive`. Let’s hook up these crates to the code in Listing D-2 -->
<!-- to see the procedural macro in action! Create a new binary project in your -->
<!-- *projects* directory using `cargo new --bin pancakes`. We need to add -->
<!-- `hello_macro` and `hello_macro_derive` as dependencies in the `pancakes` -->
<!-- crate’s *Cargo.toml*. If you’re publishing your versions of `hello_macro` and -->
<!-- `hello_macro_derive` to *https://crates.io/*, they would be regular -->
<!-- dependencies; if not, you can specify them as `path` dependencies as follows: -->
<p>この時点で、<code>cargo build</code>は<code>hello_macro</code>と<code>hello_macro_derive</code>の両方で成功するはずです。
これらのクレートをリストD-2のコードにフックして、プロシージャルマクロが動くところを確認しましょう！
<code>cargo new --bin pancakes</code>で<em>projects</em>ディレクトリに新しいバイナリプロジェクトを作成してください。
<code>hello_macro</code>と<code>hello_macro_derive</code>を依存として<code>pancakes</code>クレートの<em>Cargo.toml</em>に追加する必要があります。
自分のバージョンの<code>hello_macro</code>と<code>hello_macro_derive</code>を<em>https://crates.io/</em> に発行するつもりなら、
普通の依存になるでしょう; そうでなければ、以下のように<code>path</code>依存として指定できます:</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<!-- Put the code from Listing D-2 into *src/main.rs*, and run `cargo run`: it -->
<!-- should print `Hello, Macro! My name is Pancakes!` The implementation of the -->
<!-- `HelloMacro` trait from the procedural macro was included without the -->
<!-- `pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added the -->
<!-- trait implementation. -->
<p>リストD-2のコードを<em>src/main.rs</em>に配置し、<code>cargo run</code>を実行してください: <code>Hello, Macro! My name is Pancakes</code>と出力するはずです。
プロシージャルマクロの<code>HelloMacro</code>トレイトの実装は、<code>pancakes</code>クレートが実装する必要なく、包含されました;
<code>#[derive(HelloMacro)]</code>がトレイトの実装を追加したのです。</p>
<!-- ### The Future of Macros -->
<a class="header" href="appendix-04-macros.html#aマクロの未来" id="aマクロの未来"><h3>マクロの未来</h3></a>
<!-- In the future, Rust will expand declarative and procedural macros. Rust will -->
<!-- use a better declarative macro system with the `macro` keyword and will add -->
<!-- more types of procedural macros for more powerful tasks than just `derive`. -->
<!-- These systems are still under development at the time of this publication; -->
<!-- please consult the online Rust documentation for the latest information. -->
<p>将来的にRustは、宣言的マクロとプロシージャルマクロを拡張するでしょう。<code>macro</code>キーワードでより良い宣言的マクロシステムを使用し、
<code>derive</code>だけよりもよりパワフルな作業のより多くの種類のプロシージャルマクロを追加するでしょう。
この本の出版時点ではこれらのシステムはまだ開発中です; 最新の情報は、オンラインのRustドキュメンテーションをお調べください。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="appendix-03-derivable-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="appendix-05-translation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="appendix-03-derivable-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="appendix-05-translation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
