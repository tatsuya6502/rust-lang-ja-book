<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hello, Cargo! - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="foreword.html">まえがき</a></li><li class="affix"><a href="ch00-00-introduction.html">導入</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 事始め</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> インストール</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li><a href="ch01-03-hello-cargo.html" class="active"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 数当てゲームをプログラムする</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 普遍的なプログラミング概念</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 変数と可変性</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> データ型</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 関数の動作法</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> コメント</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 制御フロー</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 所有権を理解する</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 所有権とは？</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 参照と借用</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> スライス</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 構造体を使用して関連のあるデータを構造化する</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 構造体を定義し、インスタンス化する</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 構造体を使用したプログラム例</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> メソッド記法</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumとパターンマッチング</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumを定義する</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match制御フロー演算子</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if letで簡潔な制御フロー</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> モジュール</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> modとファイルシステム</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pubで公開するか制御する</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> 異なるモジュールの名前を参照する</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 一般的なコレクション</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ベクタ型</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 文字列型</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ハッシュマップ</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> エラー処理</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!で回復不能なエラー</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Resultで回復可能なエラー</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!すべきかするまいか</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ジェネリックなデータ型</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> トレイト: 共通の振る舞いを定義する</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ライフタイムで参照を有効化する</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> テスト</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> テストを書く</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> テストを走らせる</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> テストの体系化</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 入出力プロジェクト: コマンドラインプログラムを構築する</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> コマンドライン引数を受け付ける</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ファイルを読み込む</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> リファクタリングしてモジュール性の向上とエラー処理</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> テスト駆動開発でライブラリの機能を開発する</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 環境変数を取り扱う</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 標準出力ではなく標準エラーにエラーメッセージを書き込む</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 関数型言語の機能: イテレータとクロージャ</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> クロージャ: 環境をキャプチャできる匿名関数</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 一連の要素をイテレータで処理する</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 入出力プロジェクトを改善する</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> パフォーマンス比較: ループVSイテレータ</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> CargoとCrates.ioについてより詳しく</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> リリースプロファイルでビルドをカスタマイズする</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.ioにクレートを公開する</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargoのワークスペース</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo installでCrates.ioからバイナリをインストールする</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 独自のコマンドでCargoで拡張する</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> スマートポインタ</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T>はヒープのデータを指し、既知のサイズである</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Derefトレイトにより、参照を通してデータにアクセスできる</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Dropトレイトにより、片付けの時にコードを実行する</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>は、参照カウント方式のスマートポインタ</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T>と内部可変性パターン</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 循環参照し、メモリをリークするのは安全である</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 恐れるな！並行性</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> スレッド</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> メッセージ受け渡し</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 状態共有</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 拡張可能な並行性: SyncとSend</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustのオブジェクト指向プログラミング機能</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> オブジェクト指向言語の特徴</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 異なる型の値を許容するトレイトオブジェクトを使用する</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> オブジェクト指向デザインパターンを実装する</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> パターンは値の構造に合致する</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> パターンが使用されるかもしれない箇所全部</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 論駁可能性: パターンが合致しないか</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> パターン記法全部</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 高度な機能</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 高度なライフタイム</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 高度なトレイト</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 高度な型</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 高度な関数とクロージャ</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最後のプロジェクト: マルチスレッドのWebサーバを構築する</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> シングルスレッドのWebサーバ</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> シングルスレッドのサーバをマルチスレッド化する</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 優美なシャットダウンとお片付け</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 付録</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - キーワード</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 演算子とシンボル</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 継承可能なトレイト</a></li><li><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - マクロ</a></li><li><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 翻訳</a></li><li><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 最新の機能</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rustが“Nightly Rust”になる方法</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- ## Hello, Cargo! -->
<a class="header" href="ch01-03-hello-cargo.html#hello-cargo" id="hello-cargo"><h2>Hello, Cargo!</h2></a>
<!-- Cargo is Rust’s build system and package manager. Most Rustaceans use this tool -->
<!-- to manage their Rust projects because Cargo handles a lot of tasks for you, -->
<!-- such as building your code, downloading the libraries your code depends on, and -->
<!-- building those libraries. (We call libraries your code needs *dependencies*.) -->
<p>Cargoは、Rustのビルドシステム兼、パッケージマネージャです。ほとんどのRustaceanはこのツールを使用して、
Rustプロジェクトの管理をしています。Cargoは、コードのビルドやコードが依存しているライブラリのダウンロード、
それらのライブラリのビルド(コードが必要とするライブラリを我々は、<em>依存</em>と呼んでいます)などの多くの仕事を扱ってくれるからです。</p>
<!-- The simplest Rust programs, like the one we’ve written so far, don’t have any -->
<!-- dependencies. So if we had built the Hello, world! project with Cargo, it would -->
<!-- only use the part of Cargo that handles building your code. As you write more -->
<!-- complex Rust programs, you’ll add dependencies, and if you start a project -->
<!-- using Cargo, adding dependencies will be much easier to do. -->
<p>今までに書いたような最も単純なRustプログラムは、依存がありません。従って、Hello, world!プロジェクトをCargoを使ってビルドしても、
Cargoのコードをビルドする部分しか使用しないでしょう。より複雑なRustプログラムを書くにつれて、
依存を追加し、Cargoでプロジェクトを開始したら、依存の追加は、遥かに簡単になるのです。</p>
<!-- Because the vast majority of Rust projects use Cargo, the rest of this book -->
<!-- assumes that you’re using Cargo too. Cargo comes installed with Rust if you -->
<!-- used the official installers discussed in the “Installation” section. If you -->
<!-- installed Rust through some other means, check whether Cargo is installed by -->
<!-- entering the following into your terminal: -->
<p>Rustプロジェクトの大多数がCargoを使用しているので、これ以降この本では、あなたもCargoを使用していることを想定します。
Cargoは、「インストール」節で議論した公式のインストーラを使用していれば、勝手にインストールされます。
Rustを他の何らかの手段でインストールした場合、以下のコマンドを端末に入れてCargoがインストールされているか確かめてください:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<!-- If you see a version number, you have it! If you see an error, such as `command -->
<!-- not found`, look at the documentation for your method of installation to -->
<!-- determine how to install Cargo separately. -->
<p>バージョンナンバーが見えたら、インストールされています！<code>command not found</code>などのエラーが見えたら、
自分のインストール方法を求めてドキュメンテーションを見、Cargoを個別にインストールする方法を決定してください。</p>
<!-- ### Creating a Project with Cargo -->
<a class="header" href="ch01-03-hello-cargo.html#cargoでプロジェクトを作成する" id="cargoでプロジェクトを作成する"><h3>Cargoでプロジェクトを作成する</h3></a>
<!-- Let’s create a new project using Cargo and look at how it differs from our -->
<!-- original Hello, world! project. Navigate back to your *projects* directory (or -->
<!-- wherever you decided to store your code). Then, on any operating system, run -->
<!-- the following: -->
<p>Cargoを使用して新しいプロジェクトを作成し、元のHello, world!プロジェクトとどう違うかを見ましょう。
<em>projects</em>ディレクトリ(あるいはコードを格納すると決めた場所)に戻ってください。それから、
OSに関わらず、以下を実行してください:</p>
<pre><code class="language-text">$ cargo new hello_cargo --bin
$ cd hello_cargo
</code></pre>
<!-- The first command creates a new binary executable called *hello_cargo*. The -->
<!-- `--bin` argument passed to `cargo new` makes an executable application (often -->
<!-- just called a *binary*) as opposed to a library. We’ve named our project -->
<!-- *hello_cargo*, and Cargo creates its files in a directory of the same name. -->
<p>最初のコマンドは、<em>hello_cargo</em>という新しいバイナリの実行可能ファイルを作成します。<code>cargo new</code>に渡した<code>--bin</code>引数が、
ライブラリとは対照的に実行可能なアプリケーション(よく単に<em>バイナリ</em>と呼ばれる)を作成します。プロジェクトを<em>hello_cargo</em>と名付け、
Cargoは、そのファイルを同名のディレクトリに作成します。</p>
<!-- Go into the *hello_cargo* directory and list the files. You’ll see that Cargo -->
<!-- has generated two files and one directory for us: a *Cargo.toml* file and a -->
<!-- *src* directory with a *main.rs* file inside. It has also initialized a new Git -->
<!-- repository along with a *.gitignore* file. -->
<p><em>hello_cargo</em>ディレクトリに行き、ファイルを列挙してください。Cargoが2つのファイルと1つのディレクトリを生成してくれたことがわかるでしょう:
<em>Cargo.toml</em>ファイルと、中に<em>main.rs</em>ファイルがある<em>src</em>ディレクトリです。また、
<em>.gitignore</em>ファイルと共に、新しいGitリポジトリも初期化しています。</p>
<!-- > Note: Git is a common version control system. You can change `cargo new` to -->
<!-- > use a different version control system or no version control system by using -->
<!-- > the `--vcs` flag. Run `cargo new --help` to see the available options. -->
<blockquote>
<p>注釈: Gitは一般的なバージョンコントロールシステムです。<code>cargo new</code>を変更して、異なるバージョンコントロールシステムを使用したり、
<code>--vcs</code>フラグを使用して何もバージョンコントロールシステムを使用しないようにもできます。
<code>cargo new --help</code>を走らせて、利用可能なオプションを確認してください。</p>
</blockquote>
<!-- Open *Cargo.toml* in your text editor of choice. It should look similar to the -->
<!-- code in Listing 1-2. -->
<p>お好きなテキストエディタで<em>Cargo.toml</em>を開いてください。リスト1-2のコードのような見た目のはずです。</p>
<!-- <span class="filename">Filename: Cargo.toml</span> -->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<!-- <span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo -->
<!-- new`</span> -->
<p><span class="caption">リスト1-2: <code>cargo new</code>で生成される<em>Cargo.toml</em>の中身</span></p>
<!-- This file is in the [*TOML*][toml] (*Tom’s Obvious, Minimal -->
<!-- Language*) format, which is Cargo’s configuration format. -->
<p>このファイルは<a href="https://github.com/toml-lang/toml">TOML</a>(<em>Tom's Obvious, Minimal Language</em>; <code>直訳</code>: トムの明確な最小限の言語)フォーマットで、
Cargoの設定フォーマットです。</p>
<!-- The first line, `[package]`, is a section heading that indicates that the -->
<!-- following statements are configuring a package. As we add more information to -->
<!-- this file, we’ll add other sections. -->
<p>最初の行の<code>[package]</code>は、後の文がパッケージを設定していることを示すセクションヘッダーです。もっと情報を追加すれば、
別のセクションも追加するでしょう。</p>
<!-- The next three lines set the configuration information Cargo needs to compile -->
<!-- your program: the name, the version, and who wrote it. Cargo gets your name and -->
<!-- email information from your environment, so if that information is not correct, -->
<!-- fix the information now and then save the file. -->
<p>その後の3行が、Cargoがプログラムをコンパイルするのに必要な設定情報をセットします: 名前、バージョン、誰が書いたかです。
Cargoは名前とEメールの情報を環境から取得するので、その情報が正しくなければ、
今修正してそれから保存してください。</p>
<!-- The last line, `[dependencies]`, is the start of a section for you to list any -->
<!-- of your project’s dependencies. In Rust, packages of code are referred to as -->
<!-- *crates*. We won’t need any other crates for this project, but we will in the -->
<!-- first project in Chapter 2, so we’ll use this dependencies section then. -->
<p>最後の行の<code>[dependencies]</code>は、プロジェクトの依存を列挙するためのセクションの始まりです。
Rustでは、パッケージのコードは<em>クレート</em>として参照されます。このプロジェクトでは何も他のクレートは必要ありませんが、
第2章の最初のプロジェクトでは必要なので、その時にはこの依存セクションを使用するでしょう。</p>
<!-- Now open *src/main.rs* and take a look: -->
<p>では、<em>src/main.rs</em>を開いて覗いてみてください:</p>
<!-- <span class="filename">Filename: src/main.rs</span> -->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!-- Cargo has generated a Hello, world! program for you, just like the one we wrote -->
<!-- in Listing 1-1! So far, the differences between our previous project and the -->
<!-- project Cargo generates are that Cargo placed the code in the *src* directory, -->
<!-- and we have a *Cargo.toml* configuration file in the top directory. -->
<p>ちょうどリスト1-1で書いたように、CargoはHello, world!プログラムを生成してくれています。ここまでで、
前のプロジェクトとCargoが生成したプロジェクトの違いは、Cargoが<em>src</em>ディレクトリにコードを配置し、
最上位のディレクトリに<em>Cargo.toml</em>設定ファイルがあることです。</p>
<!-- Cargo expects your source files to live inside the *src* directory. The -->
<!-- top-level project directory is just for README files, license information, -->
<!-- configuration files, and anything else not related to your code. Using Cargo -->
<!-- helps you organize your projects. There’s a place for everything, and -->
<!-- everything is in its place. -->
<p>Cargoは、ソースファイルが<em>src</em>ディレクトリにあることを期待します。プロジェクトの最上位のディレクトリは、
READMEファイル、ライセンス情報、設定ファイル、あるいは、他のコードに関連しないもののためのものです。
Cargoを使用すると、プロジェクトを体系化する手助けをしてくれます。適材適所であり、
全てがその場所にあるのです。</p>
<!-- If you started a project that doesn’t use Cargo, as we did with the Hello, -->
<!-- world! project, you can convert it to a project that does use Cargo. Move the -->
<!-- project code into the *src* directory and create an appropriate *Cargo.toml* -->
<!-- file. -->
<p>Hello, world!プロジェクトのように、Cargoを使用しないプロジェクトを開始したら、
実際にCargoを使用するプロジェクトに変換することができます。プロジェクトのコードを<em>src</em>ディレクトリに移動し、
適切な<em>Cargo.toml</em>ファイルを作成してください。</p>
<!-- ### Building and Running a Cargo Project -->
<a class="header" href="ch01-03-hello-cargo.html#cargoプロジェクトをビルドし実行する" id="cargoプロジェクトをビルドし実行する"><h3>Cargoプロジェクトをビルドし、実行する</h3></a>
<!-- Now let’s look what's different when we build and run the Hello, world! -->
<!-- program with Cargo! From your *hello_cargo* directory, build your project by -->
<!-- entering the following command: -->
<p>さて、CargoでHello, world!プログラムをビルドし、実行する時の違いに目を向けましょう！<em>hello_cargo</em>ディレクトリから、
以下のコマンドを入力してプロジェクトをビルドしてください:</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<!-- This command creates an executable file in *target/debug/hello_cargo* (or -->
<!-- *target\debug\hello_cargo.exe* on Windows) rather than in your current -->
<!-- directory. You can run the executable with this command: -->
<p>このコマンドは、カレントディレクトリではなく、<em>target/debug/hello_cargo</em>(あるいはWindowsなら、
<em>target/debug/hello_cargo.exe</em>)の実行可能ファイルを作成します。以下のコマンドで実行可能ファイルを実行できます:</p>
<pre><code class="language-text">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
                             # あるいは、Windowsなら、.\target\debug\hello_cargo.exe
Hello, world!
</code></pre>
<!-- If all goes well, `Hello, world!` should print to the terminal. Running `cargo -->
<!-- build` for the first time also causes Cargo to create a new file at the top -->
<!-- level: *Cargo.lock*. This file keeps track of the exact versions of -->
<!-- dependencies in your project. This project doesn’t have dependencies, so the -->
<!-- file is a bit sparse. You won’t ever need to change this file manually; Cargo -->
<!-- manages its contents for you. -->
<p>全てがうまくいけば、<code>Hello, world!</code>が端末に出力されるはずです。初めて<code>cargo build</code>を実行すると、
Cargoが最上位に新しいファイルも作成します: <em>Cargo.lock</em>です。このファイルは、自分のプロジェクトの依存の正確なバージョンを追いかけます。
このプロジェクトには依存がないので、ファイルはやや空っぽです。絶対にこのファイルを手動で変更する必要はないでしょう;
Cargoが中身を管理してくれるのです。</p>
<!-- We just built a project with `cargo build` and ran it with -->
<!-- `./target/debug/hello_cargo`, but we can also use `cargo run` to compile the -->
<!-- code and then run the resulting executable all in one command: -->
<p><code>cargo build</code>でプロジェクトをビルドし、<code>./target/debug/hello_cargo</code>で実行したばかりですが、
<code>cargo run</code>を使用して、コードをコンパイルし、それから吐かれた実行可能ファイルを全部1コマンドで実行することもできます:</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!-- Notice that this time we didn’t see output indicating that Cargo was compiling -->
<!-- `hello_cargo`. Cargo figured out that the files hadn’t changed, so it just ran -->
<!-- the binary. If you had modified your source code, Cargo would have rebuilt the -->
<!-- project before running it, and you would have seen this output: -->
<p>今回は、Cargoが<code>hello_cargo</code>をコンパイルしていることを示唆する出力がないことに気付いてください。
Cargoはファイルが変更されていないことを推論したので、単純にバイナリを実行したのです。
ソースコードを変更していたら、Cargoは実行前にプロジェクトを再ビルドし、こんな出力を目の当たりにしたでしょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!-- Cargo also provides a command called `cargo check`. This command quickly checks -->
<!-- your code to make sure it compiles but doesn’t produce an executable: -->
<p>Cargoは<code>cargo check</code>というコマンドも提供しています。このコマンドは、迅速にコードを確認し、
コンパイルできることを確かめますが、実行可能ファイルは生成しません:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<!-- Why would you not want an executable? Often, `cargo check` is much faster than -->
<!-- `cargo build`, because it skips the step of producing an executable. If you’re -->
<!-- continually checking your work while writing the code, using `cargo check` will -->
<!-- speed up the process! As such, many Rustaceans run `cargo check` periodically -->
<!-- as they write their program to make sure it compiles. Then they run `cargo -->
<!-- build` when they’re ready to use the executable. -->
<p>何故、実行可能ファイルが欲しくないのでしょうか？しばしば、<code>cargo check</code>は、<code>cargo build</code>よりも遥かに速くなります。
実行可能ファイルを生成する手順を飛ばすからです。コードを書いている際に継続的に自分の作業を確認するのなら、
<code>cargo check</code>を使用すると、その過程が高速化されます！そのため、多くのRustaceanは、
プログラムを書く際にコンパイルできるか確かめるために定期的に<code>cargo check</code>を実行します。
そして、実行可能ファイルを使用できる状態になったら、<code>cargo build</code>を走らせるのです。</p>
<!-- Let’s recap what we’ve learned so far about Cargo: -->
<p>ここまでにCargoについて学んだことをおさらいしましょう:</p>
<!-- * We can build a project using `cargo build` or `cargo check`. -->
<!-- * We can build and run a project in one step using `cargo run`. -->
<!-- * Instead of saving the result of the build in the same directory as our code, -->
<!--   Cargo stores it in the *target/debug* directory. -->
<ul>
<li><code>cargo build</code>か<code>cargo check</code>でプロジェクトをビルドできる。</li>
<li>プロジェクトのビルドと実行を1ステップで<code>cargo run</code>でできる。</li>
<li>ビルドの結果をコードと同じディレクトリに保存するのではなく、Cargoは<em>target/debug</em>ディレクトリに格納する。</li>
</ul>
<!-- An additional advantage of using Cargo is that the commands are the same no -->
<!-- matter which operating system you’re working on. So, at this point, we’ll no -->
<!-- longer provide specific instructions for Linux and macOS versus Windows. -->
<p>Cargoを使用する追加の利点は、使用しているOSに関わらず、同じコマンドが使用できることです。
故にこの時点で、WindowsとLinux及びmacOSで特定の手順を提供することは最早なくなります。</p>
<!-- ### Building for Release -->
<a class="header" href="ch01-03-hello-cargo.html#aリリースビルドを行う" id="aリリースビルドを行う"><h3>リリースビルドを行う</h3></a>
<!-- When your project is finally ready for release, you can use `cargo build -->
<!-- --release` to compile it with optimizations. This command will create an -->
<!-- executable in *target/release* instead of *target/debug*. The optimizations -->
<!-- make your Rust code run faster, but turning them on lengthens the time it takes -->
<!-- for your program to compile. This is why there are two different profiles: one -->
<!-- for development, when you want to rebuild quickly and often, and another for -->
<!-- building the final program you’ll give to a user that won’t be rebuilt -->
<!-- repeatedly and that will run as fast as possible. If you’re benchmarking your -->
<!-- code’s running time, be sure to run `cargo build --release` and benchmark with -->
<!-- the executable in *target/release*. -->
<p>プロジェクトを最終的にリリースする準備ができたら、<code>cargo build --release</code>を使用して、
最適化を行なってコンパイルすることができます。このコマンドは、<em>target/debug</em>ではなく、
<em>target/release</em>に実行可能ファイルを作成します。最適化は、Rustコードの実行を速くしてくれますが、
オンにするとプログラムをコンパイルする時間が延びます。このため、2つの異なるプロファイルがあるのです:
頻繁に再ビルドをかけたい開発用と、繰り返し再ビルドすることはなく、できるだけ高速に動いてユーザにあげる最終的なプログラムをビルドする用のです。
コードの実行時間をベンチマークするなら、<code>cargo build --release</code>を確実に実行し、<em>target/release</em>の実行可能ファイルでベンチマークしてください。</p>
<!-- ### Cargo as Convention -->
<a class="header" href="ch01-03-hello-cargo.html#a習慣としてのcargo" id="a習慣としてのcargo"><h3>習慣としてのCargo</h3></a>
<!-- With simple projects, Cargo doesn’t provide a lot of value over just using -->
<!-- `rustc`, but it will prove its worth as your programs become more intricate. -->
<!-- With complex projects composed of multiple crates, it’s much easier to let -->
<!-- Cargo coordinate the build. -->
<p>単純なプロジェクトでは、Cargoは単に<code>rustc</code>を使用する以上の価値を生みませんが、プログラムが複雑になるにつれて、
その価値を証明するでしょう。複数のクレートからなる複雑なプロジェクトでは、Cargoにビルドを調整してもらうのが遥かに簡単です。</p>
<!-- Even though the `hello_cargo` project is simple, it now uses much of the real -->
<!-- tooling you’ll use in the rest of your Rust career. In fact, to work on any -->
<!-- existing projects, you can use the following commands to check out the code -->
<!-- using Git, change to that project’s directory, and build: -->
<p><code>hello_cargo</code>プロジェクトは単純ではありますが、今では、Rustのキャリアを通じて使用するであろう本物のツールを多く使用するようになりました。
事実、既存のどんなプロジェクトに取り組むにも、以下のコマンドを使用して、Gitでコードをチェックアウトし、
そのプロジェクトのディレクトリに移動し、ビルドできます:</p>
<pre><code class="language-text">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<!-- For more information about Cargo, check out [its documentation]. -->
<p>Cargoについてより詳しく知るには、<a href="https://doc.rust-lang.org/cargo/">ドキュメンテーション</a>を確認してください。</p>
<!-- ## Summary -->
<a class="header" href="ch01-03-hello-cargo.html#aまとめ" id="aまとめ"><h2>まとめ</h2></a>
<!-- You’re already off to a great start on your Rust journey! In this chapter, -->
<!-- you’ve learned how to: -->
<p>既にRustの旅の素晴らしいスタートを切っています！この章では、以下の方法を学びました:</p>
<!-- * Install the latest stable version of Rust using `rustup` -->
<!-- * Update to a newer Rust version -->
<!-- * Open locally installed documentation -->
<!-- * Write and run a Hello, world! program using `rustc` directly -->
<!-- * Create and run a new project using the conventions of Cargo -->
<ul>
<li><code>rustup</code>で最新の安定版のRustをインストールする方法</li>
<li>新しいRustのバージョンに更新する方法</li>
<li>ローカルにインストールされたドキュメンテーションを開く方法</li>
<li>直接<code>rustc</code>を使用してHello, world!プログラムを書き、実行する方法</li>
<li>Cargoの慣習を使用して新しいプロジェクトを作成し、実行する方法</li>
</ul>
<!-- This is a great time to build a more substantial program to get used to reading -->
<!-- and writing Rust code. So, in Chapter 2, we’ll build a guessing game program. -->
<!-- If you would rather start by learning how common programming concepts work in -->
<!-- Rust, see Chapter 3 and then return to Chapter 2. -->
<p>より中身のあるプログラムをビルドし、Rustコードの読み書きに慣れるいいタイミングです。故に、第2章では、
数当てゲームを構築します。むしろ一般的なプログラミングの概念がRustでどう動くのか学ぶことから始めたいのであれば、
第3章を見て、それから第2章に戻ってください。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch01-02-hello-world.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch02-00-guessing-game-tutorial.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch01-02-hello-world.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch02-00-guessing-game-tutorial.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
